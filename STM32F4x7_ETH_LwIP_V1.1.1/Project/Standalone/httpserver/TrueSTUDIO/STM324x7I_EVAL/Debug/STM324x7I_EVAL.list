
C:\Users\Jason\Documents\IoT\STM32F4x7_ETH_LwIP_V1.1.1\Project\Standalone\httpserver\TrueSTUDIO\STM324x7I_EVAL\Debug\STM324x7I_EVAL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000019c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c83c  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000ced4  0800c9dc  0800c9dc  0001c9dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  080198b0  080198b0  000298b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  080198b4  080198b4  000298b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000550  20000000  080198b8  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00030550  2**0
                  CONTENTS
  7 .bss          000084e0  20000550  20000550  00030550  2**2
                  ALLOC
  8 ._user_heap_stack 00000400  20008a30  20008a30  00030550  2**0
                  ALLOC
  9 .ARM.attributes 0000002e  00000000  00000000  00030550  2**0
                  CONTENTS, READONLY
 10 .debug_info   00025e35  00000000  00000000  0003057e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00005d9c  00000000  00000000  000563b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0001d0d8  00000000  00000000  0005c14f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00001310  00000000  00000000  00079228  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00005058  00000000  00000000  0007a538  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c022  00000000  00000000  0007f590  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000069b7  00000000  00000000  0008b5b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  00091f69  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00003f54  00000000  00000000  00091fe8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000550 	.word	0x20000550
 80001bc:	00000000 	.word	0x00000000
 80001c0:	0800c9c4 	.word	0x0800c9c4

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000554 	.word	0x20000554
 80001dc:	0800c9c4 	.word	0x0800c9c4

080001e0 <strcmp>:
 80001e0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001e4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001e8:	2a01      	cmp	r2, #1
 80001ea:	bf28      	it	cs
 80001ec:	429a      	cmpcs	r2, r3
 80001ee:	d0f7      	beq.n	80001e0 <strcmp>
 80001f0:	1ad0      	subs	r0, r2, r3
 80001f2:	4770      	bx	lr

080001f4 <strlen>:
 80001f4:	4603      	mov	r3, r0
 80001f6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001fa:	2a00      	cmp	r2, #0
 80001fc:	d1fb      	bne.n	80001f6 <strlen+0x2>
 80001fe:	1a18      	subs	r0, r3, r0
 8000200:	3801      	subs	r0, #1
 8000202:	4770      	bx	lr
	...

08000210 <memchr>:
 8000210:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000214:	2a10      	cmp	r2, #16
 8000216:	db2b      	blt.n	8000270 <memchr+0x60>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	d008      	beq.n	8000230 <memchr+0x20>
 800021e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000222:	3a01      	subs	r2, #1
 8000224:	428b      	cmp	r3, r1
 8000226:	d02d      	beq.n	8000284 <memchr+0x74>
 8000228:	f010 0f07 	tst.w	r0, #7
 800022c:	b342      	cbz	r2, 8000280 <memchr+0x70>
 800022e:	d1f6      	bne.n	800021e <memchr+0xe>
 8000230:	b4f0      	push	{r4, r5, r6, r7}
 8000232:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000236:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800023a:	f022 0407 	bic.w	r4, r2, #7
 800023e:	f07f 0700 	mvns.w	r7, #0
 8000242:	2300      	movs	r3, #0
 8000244:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000248:	3c08      	subs	r4, #8
 800024a:	ea85 0501 	eor.w	r5, r5, r1
 800024e:	ea86 0601 	eor.w	r6, r6, r1
 8000252:	fa85 f547 	uadd8	r5, r5, r7
 8000256:	faa3 f587 	sel	r5, r3, r7
 800025a:	fa86 f647 	uadd8	r6, r6, r7
 800025e:	faa5 f687 	sel	r6, r5, r7
 8000262:	b98e      	cbnz	r6, 8000288 <memchr+0x78>
 8000264:	d1ee      	bne.n	8000244 <memchr+0x34>
 8000266:	bcf0      	pop	{r4, r5, r6, r7}
 8000268:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800026c:	f002 0207 	and.w	r2, r2, #7
 8000270:	b132      	cbz	r2, 8000280 <memchr+0x70>
 8000272:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000276:	3a01      	subs	r2, #1
 8000278:	ea83 0301 	eor.w	r3, r3, r1
 800027c:	b113      	cbz	r3, 8000284 <memchr+0x74>
 800027e:	d1f8      	bne.n	8000272 <memchr+0x62>
 8000280:	2000      	movs	r0, #0
 8000282:	4770      	bx	lr
 8000284:	3801      	subs	r0, #1
 8000286:	4770      	bx	lr
 8000288:	2d00      	cmp	r5, #0
 800028a:	bf06      	itte	eq
 800028c:	4635      	moveq	r5, r6
 800028e:	3803      	subeq	r0, #3
 8000290:	3807      	subne	r0, #7
 8000292:	f015 0f01 	tst.w	r5, #1
 8000296:	d107      	bne.n	80002a8 <memchr+0x98>
 8000298:	3001      	adds	r0, #1
 800029a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800029e:	bf02      	ittt	eq
 80002a0:	3001      	addeq	r0, #1
 80002a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002a6:	3001      	addeq	r0, #1
 80002a8:	bcf0      	pop	{r4, r5, r6, r7}
 80002aa:	3801      	subs	r0, #1
 80002ac:	4770      	bx	lr
 80002ae:	bf00      	nop

080002b0 <__aeabi_drsub>:
 80002b0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002b4:	e002      	b.n	80002bc <__adddf3>
 80002b6:	bf00      	nop

080002b8 <__aeabi_dsub>:
 80002b8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002bc <__adddf3>:
 80002bc:	b530      	push	{r4, r5, lr}
 80002be:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002c2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002c6:	ea94 0f05 	teq	r4, r5
 80002ca:	bf08      	it	eq
 80002cc:	ea90 0f02 	teqeq	r0, r2
 80002d0:	bf1f      	itttt	ne
 80002d2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002d6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002da:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002de:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002e2:	f000 80e2 	beq.w	80004aa <__adddf3+0x1ee>
 80002e6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ea:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ee:	bfb8      	it	lt
 80002f0:	426d      	neglt	r5, r5
 80002f2:	dd0c      	ble.n	800030e <__adddf3+0x52>
 80002f4:	442c      	add	r4, r5
 80002f6:	ea80 0202 	eor.w	r2, r0, r2
 80002fa:	ea81 0303 	eor.w	r3, r1, r3
 80002fe:	ea82 0000 	eor.w	r0, r2, r0
 8000302:	ea83 0101 	eor.w	r1, r3, r1
 8000306:	ea80 0202 	eor.w	r2, r0, r2
 800030a:	ea81 0303 	eor.w	r3, r1, r3
 800030e:	2d36      	cmp	r5, #54	; 0x36
 8000310:	bf88      	it	hi
 8000312:	bd30      	pophi	{r4, r5, pc}
 8000314:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000318:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800031c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000320:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000324:	d002      	beq.n	800032c <__adddf3+0x70>
 8000326:	4240      	negs	r0, r0
 8000328:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800032c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000330:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000334:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000338:	d002      	beq.n	8000340 <__adddf3+0x84>
 800033a:	4252      	negs	r2, r2
 800033c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000340:	ea94 0f05 	teq	r4, r5
 8000344:	f000 80a7 	beq.w	8000496 <__adddf3+0x1da>
 8000348:	f1a4 0401 	sub.w	r4, r4, #1
 800034c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000350:	db0d      	blt.n	800036e <__adddf3+0xb2>
 8000352:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000356:	fa22 f205 	lsr.w	r2, r2, r5
 800035a:	1880      	adds	r0, r0, r2
 800035c:	f141 0100 	adc.w	r1, r1, #0
 8000360:	fa03 f20e 	lsl.w	r2, r3, lr
 8000364:	1880      	adds	r0, r0, r2
 8000366:	fa43 f305 	asr.w	r3, r3, r5
 800036a:	4159      	adcs	r1, r3
 800036c:	e00e      	b.n	800038c <__adddf3+0xd0>
 800036e:	f1a5 0520 	sub.w	r5, r5, #32
 8000372:	f10e 0e20 	add.w	lr, lr, #32
 8000376:	2a01      	cmp	r2, #1
 8000378:	fa03 fc0e 	lsl.w	ip, r3, lr
 800037c:	bf28      	it	cs
 800037e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000382:	fa43 f305 	asr.w	r3, r3, r5
 8000386:	18c0      	adds	r0, r0, r3
 8000388:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800038c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000390:	d507      	bpl.n	80003a2 <__adddf3+0xe6>
 8000392:	f04f 0e00 	mov.w	lr, #0
 8000396:	f1dc 0c00 	rsbs	ip, ip, #0
 800039a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800039e:	eb6e 0101 	sbc.w	r1, lr, r1
 80003a2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003a6:	d31b      	bcc.n	80003e0 <__adddf3+0x124>
 80003a8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003ac:	d30c      	bcc.n	80003c8 <__adddf3+0x10c>
 80003ae:	0849      	lsrs	r1, r1, #1
 80003b0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003b4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003b8:	f104 0401 	add.w	r4, r4, #1
 80003bc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003c0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003c4:	f080 809a 	bcs.w	80004fc <__adddf3+0x240>
 80003c8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003cc:	bf08      	it	eq
 80003ce:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003d2:	f150 0000 	adcs.w	r0, r0, #0
 80003d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003da:	ea41 0105 	orr.w	r1, r1, r5
 80003de:	bd30      	pop	{r4, r5, pc}
 80003e0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003e4:	4140      	adcs	r0, r0
 80003e6:	eb41 0101 	adc.w	r1, r1, r1
 80003ea:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003ee:	f1a4 0401 	sub.w	r4, r4, #1
 80003f2:	d1e9      	bne.n	80003c8 <__adddf3+0x10c>
 80003f4:	f091 0f00 	teq	r1, #0
 80003f8:	bf04      	itt	eq
 80003fa:	4601      	moveq	r1, r0
 80003fc:	2000      	moveq	r0, #0
 80003fe:	fab1 f381 	clz	r3, r1
 8000402:	bf08      	it	eq
 8000404:	3320      	addeq	r3, #32
 8000406:	f1a3 030b 	sub.w	r3, r3, #11
 800040a:	f1b3 0220 	subs.w	r2, r3, #32
 800040e:	da0c      	bge.n	800042a <__adddf3+0x16e>
 8000410:	320c      	adds	r2, #12
 8000412:	dd08      	ble.n	8000426 <__adddf3+0x16a>
 8000414:	f102 0c14 	add.w	ip, r2, #20
 8000418:	f1c2 020c 	rsb	r2, r2, #12
 800041c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000420:	fa21 f102 	lsr.w	r1, r1, r2
 8000424:	e00c      	b.n	8000440 <__adddf3+0x184>
 8000426:	f102 0214 	add.w	r2, r2, #20
 800042a:	bfd8      	it	le
 800042c:	f1c2 0c20 	rsble	ip, r2, #32
 8000430:	fa01 f102 	lsl.w	r1, r1, r2
 8000434:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000438:	bfdc      	itt	le
 800043a:	ea41 010c 	orrle.w	r1, r1, ip
 800043e:	4090      	lslle	r0, r2
 8000440:	1ae4      	subs	r4, r4, r3
 8000442:	bfa2      	ittt	ge
 8000444:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000448:	4329      	orrge	r1, r5
 800044a:	bd30      	popge	{r4, r5, pc}
 800044c:	ea6f 0404 	mvn.w	r4, r4
 8000450:	3c1f      	subs	r4, #31
 8000452:	da1c      	bge.n	800048e <__adddf3+0x1d2>
 8000454:	340c      	adds	r4, #12
 8000456:	dc0e      	bgt.n	8000476 <__adddf3+0x1ba>
 8000458:	f104 0414 	add.w	r4, r4, #20
 800045c:	f1c4 0220 	rsb	r2, r4, #32
 8000460:	fa20 f004 	lsr.w	r0, r0, r4
 8000464:	fa01 f302 	lsl.w	r3, r1, r2
 8000468:	ea40 0003 	orr.w	r0, r0, r3
 800046c:	fa21 f304 	lsr.w	r3, r1, r4
 8000470:	ea45 0103 	orr.w	r1, r5, r3
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f1c4 040c 	rsb	r4, r4, #12
 800047a:	f1c4 0220 	rsb	r2, r4, #32
 800047e:	fa20 f002 	lsr.w	r0, r0, r2
 8000482:	fa01 f304 	lsl.w	r3, r1, r4
 8000486:	ea40 0003 	orr.w	r0, r0, r3
 800048a:	4629      	mov	r1, r5
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	fa21 f004 	lsr.w	r0, r1, r4
 8000492:	4629      	mov	r1, r5
 8000494:	bd30      	pop	{r4, r5, pc}
 8000496:	f094 0f00 	teq	r4, #0
 800049a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800049e:	bf06      	itte	eq
 80004a0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004a4:	3401      	addeq	r4, #1
 80004a6:	3d01      	subne	r5, #1
 80004a8:	e74e      	b.n	8000348 <__adddf3+0x8c>
 80004aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ae:	bf18      	it	ne
 80004b0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004b4:	d029      	beq.n	800050a <__adddf3+0x24e>
 80004b6:	ea94 0f05 	teq	r4, r5
 80004ba:	bf08      	it	eq
 80004bc:	ea90 0f02 	teqeq	r0, r2
 80004c0:	d005      	beq.n	80004ce <__adddf3+0x212>
 80004c2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004c6:	bf04      	itt	eq
 80004c8:	4619      	moveq	r1, r3
 80004ca:	4610      	moveq	r0, r2
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	ea91 0f03 	teq	r1, r3
 80004d2:	bf1e      	ittt	ne
 80004d4:	2100      	movne	r1, #0
 80004d6:	2000      	movne	r0, #0
 80004d8:	bd30      	popne	{r4, r5, pc}
 80004da:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004de:	d105      	bne.n	80004ec <__adddf3+0x230>
 80004e0:	0040      	lsls	r0, r0, #1
 80004e2:	4149      	adcs	r1, r1
 80004e4:	bf28      	it	cs
 80004e6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ea:	bd30      	pop	{r4, r5, pc}
 80004ec:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004f0:	bf3c      	itt	cc
 80004f2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004f6:	bd30      	popcc	{r4, r5, pc}
 80004f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004fc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000500:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000504:	f04f 0000 	mov.w	r0, #0
 8000508:	bd30      	pop	{r4, r5, pc}
 800050a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800050e:	bf1a      	itte	ne
 8000510:	4619      	movne	r1, r3
 8000512:	4610      	movne	r0, r2
 8000514:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000518:	bf1c      	itt	ne
 800051a:	460b      	movne	r3, r1
 800051c:	4602      	movne	r2, r0
 800051e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000522:	bf06      	itte	eq
 8000524:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000528:	ea91 0f03 	teqeq	r1, r3
 800052c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000530:	bd30      	pop	{r4, r5, pc}
 8000532:	bf00      	nop

08000534 <__aeabi_ui2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000548:	f04f 0500 	mov.w	r5, #0
 800054c:	f04f 0100 	mov.w	r1, #0
 8000550:	e750      	b.n	80003f4 <__adddf3+0x138>
 8000552:	bf00      	nop

08000554 <__aeabi_i2d>:
 8000554:	f090 0f00 	teq	r0, #0
 8000558:	bf04      	itt	eq
 800055a:	2100      	moveq	r1, #0
 800055c:	4770      	bxeq	lr
 800055e:	b530      	push	{r4, r5, lr}
 8000560:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000564:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000568:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800056c:	bf48      	it	mi
 800056e:	4240      	negmi	r0, r0
 8000570:	f04f 0100 	mov.w	r1, #0
 8000574:	e73e      	b.n	80003f4 <__adddf3+0x138>
 8000576:	bf00      	nop

08000578 <__aeabi_f2d>:
 8000578:	0042      	lsls	r2, r0, #1
 800057a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800057e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000582:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000586:	bf1f      	itttt	ne
 8000588:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800058c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000590:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000594:	4770      	bxne	lr
 8000596:	f092 0f00 	teq	r2, #0
 800059a:	bf14      	ite	ne
 800059c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005a0:	4770      	bxeq	lr
 80005a2:	b530      	push	{r4, r5, lr}
 80005a4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005b0:	e720      	b.n	80003f4 <__adddf3+0x138>
 80005b2:	bf00      	nop

080005b4 <__aeabi_ul2d>:
 80005b4:	ea50 0201 	orrs.w	r2, r0, r1
 80005b8:	bf08      	it	eq
 80005ba:	4770      	bxeq	lr
 80005bc:	b530      	push	{r4, r5, lr}
 80005be:	f04f 0500 	mov.w	r5, #0
 80005c2:	e00a      	b.n	80005da <__aeabi_l2d+0x16>

080005c4 <__aeabi_l2d>:
 80005c4:	ea50 0201 	orrs.w	r2, r0, r1
 80005c8:	bf08      	it	eq
 80005ca:	4770      	bxeq	lr
 80005cc:	b530      	push	{r4, r5, lr}
 80005ce:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005d2:	d502      	bpl.n	80005da <__aeabi_l2d+0x16>
 80005d4:	4240      	negs	r0, r0
 80005d6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005da:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005de:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005e2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005e6:	f43f aedc 	beq.w	80003a2 <__adddf3+0xe6>
 80005ea:	f04f 0203 	mov.w	r2, #3
 80005ee:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005f2:	bf18      	it	ne
 80005f4:	3203      	addne	r2, #3
 80005f6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005fa:	bf18      	it	ne
 80005fc:	3203      	addne	r2, #3
 80005fe:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000602:	f1c2 0320 	rsb	r3, r2, #32
 8000606:	fa00 fc03 	lsl.w	ip, r0, r3
 800060a:	fa20 f002 	lsr.w	r0, r0, r2
 800060e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000612:	ea40 000e 	orr.w	r0, r0, lr
 8000616:	fa21 f102 	lsr.w	r1, r1, r2
 800061a:	4414      	add	r4, r2
 800061c:	e6c1      	b.n	80003a2 <__adddf3+0xe6>
 800061e:	bf00      	nop

08000620 <__aeabi_dmul>:
 8000620:	b570      	push	{r4, r5, r6, lr}
 8000622:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000626:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800062a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800062e:	bf1d      	ittte	ne
 8000630:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000634:	ea94 0f0c 	teqne	r4, ip
 8000638:	ea95 0f0c 	teqne	r5, ip
 800063c:	f000 f8de 	bleq	80007fc <__aeabi_dmul+0x1dc>
 8000640:	442c      	add	r4, r5
 8000642:	ea81 0603 	eor.w	r6, r1, r3
 8000646:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800064a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800064e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000652:	bf18      	it	ne
 8000654:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000658:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800065c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000660:	d038      	beq.n	80006d4 <__aeabi_dmul+0xb4>
 8000662:	fba0 ce02 	umull	ip, lr, r0, r2
 8000666:	f04f 0500 	mov.w	r5, #0
 800066a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800066e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000672:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000676:	f04f 0600 	mov.w	r6, #0
 800067a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800067e:	f09c 0f00 	teq	ip, #0
 8000682:	bf18      	it	ne
 8000684:	f04e 0e01 	orrne.w	lr, lr, #1
 8000688:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800068c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000690:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000694:	d204      	bcs.n	80006a0 <__aeabi_dmul+0x80>
 8000696:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800069a:	416d      	adcs	r5, r5
 800069c:	eb46 0606 	adc.w	r6, r6, r6
 80006a0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006a4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006a8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006ac:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006b0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006b4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006b8:	bf88      	it	hi
 80006ba:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006be:	d81e      	bhi.n	80006fe <__aeabi_dmul+0xde>
 80006c0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006c4:	bf08      	it	eq
 80006c6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006ca:	f150 0000 	adcs.w	r0, r0, #0
 80006ce:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006d2:	bd70      	pop	{r4, r5, r6, pc}
 80006d4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006d8:	ea46 0101 	orr.w	r1, r6, r1
 80006dc:	ea40 0002 	orr.w	r0, r0, r2
 80006e0:	ea81 0103 	eor.w	r1, r1, r3
 80006e4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006e8:	bfc2      	ittt	gt
 80006ea:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006ee:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006f2:	bd70      	popgt	{r4, r5, r6, pc}
 80006f4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006f8:	f04f 0e00 	mov.w	lr, #0
 80006fc:	3c01      	subs	r4, #1
 80006fe:	f300 80ab 	bgt.w	8000858 <__aeabi_dmul+0x238>
 8000702:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000706:	bfde      	ittt	le
 8000708:	2000      	movle	r0, #0
 800070a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800070e:	bd70      	pople	{r4, r5, r6, pc}
 8000710:	f1c4 0400 	rsb	r4, r4, #0
 8000714:	3c20      	subs	r4, #32
 8000716:	da35      	bge.n	8000784 <__aeabi_dmul+0x164>
 8000718:	340c      	adds	r4, #12
 800071a:	dc1b      	bgt.n	8000754 <__aeabi_dmul+0x134>
 800071c:	f104 0414 	add.w	r4, r4, #20
 8000720:	f1c4 0520 	rsb	r5, r4, #32
 8000724:	fa00 f305 	lsl.w	r3, r0, r5
 8000728:	fa20 f004 	lsr.w	r0, r0, r4
 800072c:	fa01 f205 	lsl.w	r2, r1, r5
 8000730:	ea40 0002 	orr.w	r0, r0, r2
 8000734:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000738:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800073c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000740:	fa21 f604 	lsr.w	r6, r1, r4
 8000744:	eb42 0106 	adc.w	r1, r2, r6
 8000748:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800074c:	bf08      	it	eq
 800074e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000752:	bd70      	pop	{r4, r5, r6, pc}
 8000754:	f1c4 040c 	rsb	r4, r4, #12
 8000758:	f1c4 0520 	rsb	r5, r4, #32
 800075c:	fa00 f304 	lsl.w	r3, r0, r4
 8000760:	fa20 f005 	lsr.w	r0, r0, r5
 8000764:	fa01 f204 	lsl.w	r2, r1, r4
 8000768:	ea40 0002 	orr.w	r0, r0, r2
 800076c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000770:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000774:	f141 0100 	adc.w	r1, r1, #0
 8000778:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800077c:	bf08      	it	eq
 800077e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000782:	bd70      	pop	{r4, r5, r6, pc}
 8000784:	f1c4 0520 	rsb	r5, r4, #32
 8000788:	fa00 f205 	lsl.w	r2, r0, r5
 800078c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000790:	fa20 f304 	lsr.w	r3, r0, r4
 8000794:	fa01 f205 	lsl.w	r2, r1, r5
 8000798:	ea43 0302 	orr.w	r3, r3, r2
 800079c:	fa21 f004 	lsr.w	r0, r1, r4
 80007a0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007a4:	fa21 f204 	lsr.w	r2, r1, r4
 80007a8:	ea20 0002 	bic.w	r0, r0, r2
 80007ac:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007b0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007b4:	bf08      	it	eq
 80007b6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ba:	bd70      	pop	{r4, r5, r6, pc}
 80007bc:	f094 0f00 	teq	r4, #0
 80007c0:	d10f      	bne.n	80007e2 <__aeabi_dmul+0x1c2>
 80007c2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007c6:	0040      	lsls	r0, r0, #1
 80007c8:	eb41 0101 	adc.w	r1, r1, r1
 80007cc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007d0:	bf08      	it	eq
 80007d2:	3c01      	subeq	r4, #1
 80007d4:	d0f7      	beq.n	80007c6 <__aeabi_dmul+0x1a6>
 80007d6:	ea41 0106 	orr.w	r1, r1, r6
 80007da:	f095 0f00 	teq	r5, #0
 80007de:	bf18      	it	ne
 80007e0:	4770      	bxne	lr
 80007e2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007e6:	0052      	lsls	r2, r2, #1
 80007e8:	eb43 0303 	adc.w	r3, r3, r3
 80007ec:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007f0:	bf08      	it	eq
 80007f2:	3d01      	subeq	r5, #1
 80007f4:	d0f7      	beq.n	80007e6 <__aeabi_dmul+0x1c6>
 80007f6:	ea43 0306 	orr.w	r3, r3, r6
 80007fa:	4770      	bx	lr
 80007fc:	ea94 0f0c 	teq	r4, ip
 8000800:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000804:	bf18      	it	ne
 8000806:	ea95 0f0c 	teqne	r5, ip
 800080a:	d00c      	beq.n	8000826 <__aeabi_dmul+0x206>
 800080c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000810:	bf18      	it	ne
 8000812:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000816:	d1d1      	bne.n	80007bc <__aeabi_dmul+0x19c>
 8000818:	ea81 0103 	eor.w	r1, r1, r3
 800081c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000820:	f04f 0000 	mov.w	r0, #0
 8000824:	bd70      	pop	{r4, r5, r6, pc}
 8000826:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800082a:	bf06      	itte	eq
 800082c:	4610      	moveq	r0, r2
 800082e:	4619      	moveq	r1, r3
 8000830:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000834:	d019      	beq.n	800086a <__aeabi_dmul+0x24a>
 8000836:	ea94 0f0c 	teq	r4, ip
 800083a:	d102      	bne.n	8000842 <__aeabi_dmul+0x222>
 800083c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000840:	d113      	bne.n	800086a <__aeabi_dmul+0x24a>
 8000842:	ea95 0f0c 	teq	r5, ip
 8000846:	d105      	bne.n	8000854 <__aeabi_dmul+0x234>
 8000848:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800084c:	bf1c      	itt	ne
 800084e:	4610      	movne	r0, r2
 8000850:	4619      	movne	r1, r3
 8000852:	d10a      	bne.n	800086a <__aeabi_dmul+0x24a>
 8000854:	ea81 0103 	eor.w	r1, r1, r3
 8000858:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800085c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000860:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000864:	f04f 0000 	mov.w	r0, #0
 8000868:	bd70      	pop	{r4, r5, r6, pc}
 800086a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800086e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000872:	bd70      	pop	{r4, r5, r6, pc}

08000874 <__aeabi_ddiv>:
 8000874:	b570      	push	{r4, r5, r6, lr}
 8000876:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800087a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800087e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000882:	bf1d      	ittte	ne
 8000884:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000888:	ea94 0f0c 	teqne	r4, ip
 800088c:	ea95 0f0c 	teqne	r5, ip
 8000890:	f000 f8a7 	bleq	80009e2 <__aeabi_ddiv+0x16e>
 8000894:	eba4 0405 	sub.w	r4, r4, r5
 8000898:	ea81 0e03 	eor.w	lr, r1, r3
 800089c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008a0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008a4:	f000 8088 	beq.w	80009b8 <__aeabi_ddiv+0x144>
 80008a8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008ac:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008b0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008b4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008b8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008bc:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008c0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008c4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008c8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008cc:	429d      	cmp	r5, r3
 80008ce:	bf08      	it	eq
 80008d0:	4296      	cmpeq	r6, r2
 80008d2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008d6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008da:	d202      	bcs.n	80008e2 <__aeabi_ddiv+0x6e>
 80008dc:	085b      	lsrs	r3, r3, #1
 80008de:	ea4f 0232 	mov.w	r2, r2, rrx
 80008e2:	1ab6      	subs	r6, r6, r2
 80008e4:	eb65 0503 	sbc.w	r5, r5, r3
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008f2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008fe:	bf22      	ittt	cs
 8000900:	1ab6      	subcs	r6, r6, r2
 8000902:	4675      	movcs	r5, lr
 8000904:	ea40 000c 	orrcs.w	r0, r0, ip
 8000908:	085b      	lsrs	r3, r3, #1
 800090a:	ea4f 0232 	mov.w	r2, r2, rrx
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000946:	bf22      	ittt	cs
 8000948:	1ab6      	subcs	r6, r6, r2
 800094a:	4675      	movcs	r5, lr
 800094c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000950:	ea55 0e06 	orrs.w	lr, r5, r6
 8000954:	d018      	beq.n	8000988 <__aeabi_ddiv+0x114>
 8000956:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800095a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800095e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000962:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000966:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800096a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800096e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000972:	d1c0      	bne.n	80008f6 <__aeabi_ddiv+0x82>
 8000974:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000978:	d10b      	bne.n	8000992 <__aeabi_ddiv+0x11e>
 800097a:	ea41 0100 	orr.w	r1, r1, r0
 800097e:	f04f 0000 	mov.w	r0, #0
 8000982:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000986:	e7b6      	b.n	80008f6 <__aeabi_ddiv+0x82>
 8000988:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800098c:	bf04      	itt	eq
 800098e:	4301      	orreq	r1, r0
 8000990:	2000      	moveq	r0, #0
 8000992:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000996:	bf88      	it	hi
 8000998:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800099c:	f63f aeaf 	bhi.w	80006fe <__aeabi_dmul+0xde>
 80009a0:	ebb5 0c03 	subs.w	ip, r5, r3
 80009a4:	bf04      	itt	eq
 80009a6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009aa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009ae:	f150 0000 	adcs.w	r0, r0, #0
 80009b2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009b6:	bd70      	pop	{r4, r5, r6, pc}
 80009b8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009bc:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009c0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009c4:	bfc2      	ittt	gt
 80009c6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009ca:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009ce:	bd70      	popgt	{r4, r5, r6, pc}
 80009d0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009d4:	f04f 0e00 	mov.w	lr, #0
 80009d8:	3c01      	subs	r4, #1
 80009da:	e690      	b.n	80006fe <__aeabi_dmul+0xde>
 80009dc:	ea45 0e06 	orr.w	lr, r5, r6
 80009e0:	e68d      	b.n	80006fe <__aeabi_dmul+0xde>
 80009e2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009e6:	ea94 0f0c 	teq	r4, ip
 80009ea:	bf08      	it	eq
 80009ec:	ea95 0f0c 	teqeq	r5, ip
 80009f0:	f43f af3b 	beq.w	800086a <__aeabi_dmul+0x24a>
 80009f4:	ea94 0f0c 	teq	r4, ip
 80009f8:	d10a      	bne.n	8000a10 <__aeabi_ddiv+0x19c>
 80009fa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009fe:	f47f af34 	bne.w	800086a <__aeabi_dmul+0x24a>
 8000a02:	ea95 0f0c 	teq	r5, ip
 8000a06:	f47f af25 	bne.w	8000854 <__aeabi_dmul+0x234>
 8000a0a:	4610      	mov	r0, r2
 8000a0c:	4619      	mov	r1, r3
 8000a0e:	e72c      	b.n	800086a <__aeabi_dmul+0x24a>
 8000a10:	ea95 0f0c 	teq	r5, ip
 8000a14:	d106      	bne.n	8000a24 <__aeabi_ddiv+0x1b0>
 8000a16:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a1a:	f43f aefd 	beq.w	8000818 <__aeabi_dmul+0x1f8>
 8000a1e:	4610      	mov	r0, r2
 8000a20:	4619      	mov	r1, r3
 8000a22:	e722      	b.n	800086a <__aeabi_dmul+0x24a>
 8000a24:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a28:	bf18      	it	ne
 8000a2a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a2e:	f47f aec5 	bne.w	80007bc <__aeabi_dmul+0x19c>
 8000a32:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a36:	f47f af0d 	bne.w	8000854 <__aeabi_dmul+0x234>
 8000a3a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a3e:	f47f aeeb 	bne.w	8000818 <__aeabi_dmul+0x1f8>
 8000a42:	e712      	b.n	800086a <__aeabi_dmul+0x24a>

08000a44 <__aeabi_d2uiz>:
 8000a44:	004a      	lsls	r2, r1, #1
 8000a46:	d211      	bcs.n	8000a6c <__aeabi_d2uiz+0x28>
 8000a48:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a4c:	d211      	bcs.n	8000a72 <__aeabi_d2uiz+0x2e>
 8000a4e:	d50d      	bpl.n	8000a6c <__aeabi_d2uiz+0x28>
 8000a50:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a54:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a58:	d40e      	bmi.n	8000a78 <__aeabi_d2uiz+0x34>
 8000a5a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a5e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a62:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a66:	fa23 f002 	lsr.w	r0, r3, r2
 8000a6a:	4770      	bx	lr
 8000a6c:	f04f 0000 	mov.w	r0, #0
 8000a70:	4770      	bx	lr
 8000a72:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a76:	d102      	bne.n	8000a7e <__aeabi_d2uiz+0x3a>
 8000a78:	f04f 30ff 	mov.w	r0, #4294967295
 8000a7c:	4770      	bx	lr
 8000a7e:	f04f 0000 	mov.w	r0, #0
 8000a82:	4770      	bx	lr

08000a84 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000a84:	493d      	ldr	r1, [pc, #244]	; (8000b7c <SystemInit+0xf8>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000a86:	4b3e      	ldr	r3, [pc, #248]	; (8000b80 <SystemInit+0xfc>)
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000a88:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000a8c:	483d      	ldr	r0, [pc, #244]	; (8000b84 <SystemInit+0x100>)
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000a8e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000a92:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000a96:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000a98:	2100      	movs	r1, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000a9a:	f042 0201 	orr.w	r2, r2, #1
 8000a9e:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000aa0:	6099      	str	r1, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000aa2:	681a      	ldr	r2, [r3, #0]
 8000aa4:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000aa8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000aac:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000aae:	6058      	str	r0, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000ab0:	681a      	ldr	r2, [r3, #0]
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000ab2:	b082      	sub	sp, #8

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000ab4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000ab8:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000aba:	60d9      	str	r1, [r3, #12]
static void SetSysClock(void)
{
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000abc:	9100      	str	r1, [sp, #0]
 8000abe:	9101      	str	r1, [sp, #4]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000ac0:	681a      	ldr	r2, [r3, #0]
 8000ac2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000ac6:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000ac8:	461a      	mov	r2, r3
 8000aca:	e003      	b.n	8000ad4 <SystemInit+0x50>
    StartUpCounter++;
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000acc:	9b00      	ldr	r3, [sp, #0]
 8000ace:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8000ad2:	d009      	beq.n	8000ae8 <SystemInit+0x64>
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000ad4:	6813      	ldr	r3, [r2, #0]
 8000ad6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000ada:	9301      	str	r3, [sp, #4]
    StartUpCounter++;
 8000adc:	9b00      	ldr	r3, [sp, #0]
 8000ade:	3301      	adds	r3, #1
 8000ae0:	9300      	str	r3, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000ae2:	9b01      	ldr	r3, [sp, #4]
 8000ae4:	2b00      	cmp	r3, #0
 8000ae6:	d0f1      	beq.n	8000acc <SystemInit+0x48>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000ae8:	4b25      	ldr	r3, [pc, #148]	; (8000b80 <SystemInit+0xfc>)
 8000aea:	681b      	ldr	r3, [r3, #0]
 8000aec:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 8000af0:	bf18      	it	ne
 8000af2:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8000af4:	9301      	str	r3, [sp, #4]
  }

  if (HSEStatus == (uint32_t)0x01)
 8000af6:	9b01      	ldr	r3, [sp, #4]
 8000af8:	2b01      	cmp	r3, #1
 8000afa:	d005      	beq.n	8000b08 <SystemInit+0x84>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000afc:	4b1f      	ldr	r3, [pc, #124]	; (8000b7c <SystemInit+0xf8>)
 8000afe:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000b02:	609a      	str	r2, [r3, #8]
#endif
}
 8000b04:	b002      	add	sp, #8
 8000b06:	4770      	bx	lr
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8000b08:	4b1d      	ldr	r3, [pc, #116]	; (8000b80 <SystemInit+0xfc>)
    PWR->CR |= PWR_CR_VOS;
 8000b0a:	491f      	ldr	r1, [pc, #124]	; (8000b88 <SystemInit+0x104>)
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8000b0c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000b0e:	481f      	ldr	r0, [pc, #124]	; (8000b8c <SystemInit+0x108>)
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8000b10:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000b14:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_VOS;
 8000b16:	680a      	ldr	r2, [r1, #0]
 8000b18:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8000b1c:	600a      	str	r2, [r1, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8000b1e:	689a      	ldr	r2, [r3, #8]
 8000b20:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8000b22:	689a      	ldr	r2, [r3, #8]
 8000b24:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000b28:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8000b2a:	689a      	ldr	r2, [r3, #8]
 8000b2c:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8000b30:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000b32:	6058      	str	r0, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 8000b34:	681a      	ldr	r2, [r3, #0]
 8000b36:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000b3a:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000b3c:	681a      	ldr	r2, [r3, #0]
 8000b3e:	0192      	lsls	r2, r2, #6
 8000b40:	d5fc      	bpl.n	8000b3c <SystemInit+0xb8>
    {
    }
   
    if ((DBGMCU->IDCODE >> 16) == 0x1001)
 8000b42:	4b13      	ldr	r3, [pc, #76]	; (8000b90 <SystemInit+0x10c>)
 8000b44:	681a      	ldr	r2, [r3, #0]
 8000b46:	f241 0301 	movw	r3, #4097	; 0x1001
 8000b4a:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
    {
      /* STM32F40x/41x Revision Z devices: prefetch is supported  */
      /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
      FLASH->ACR = FLASH_ACR_PRFTEN |FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8000b4e:	4b11      	ldr	r3, [pc, #68]	; (8000b94 <SystemInit+0x110>)
 8000b50:	bf0c      	ite	eq
 8000b52:	f240 7205 	movweq	r2, #1797	; 0x705
    }
    else
    {
      /* STM32F40x/41x Revision A devices: prefetch is not supported  */
      /* Configure Flash Instruction cache, Data cache and wait state */
      FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8000b56:	f240 6205 	movwne	r2, #1541	; 0x605
 8000b5a:	601a      	str	r2, [r3, #0]
    }

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000b5c:	4a08      	ldr	r2, [pc, #32]	; (8000b80 <SystemInit+0xfc>)
 8000b5e:	6893      	ldr	r3, [r2, #8]
 8000b60:	f023 0303 	bic.w	r3, r3, #3
 8000b64:	6093      	str	r3, [r2, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 8000b66:	6893      	ldr	r3, [r2, #8]
 8000b68:	f043 0302 	orr.w	r3, r3, #2
 8000b6c:	6093      	str	r3, [r2, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8000b6e:	6893      	ldr	r3, [r2, #8]
 8000b70:	f003 030c 	and.w	r3, r3, #12
 8000b74:	2b08      	cmp	r3, #8
 8000b76:	d1fa      	bne.n	8000b6e <SystemInit+0xea>
 8000b78:	e7c0      	b.n	8000afc <SystemInit+0x78>
 8000b7a:	bf00      	nop
 8000b7c:	e000ed00 	.word	0xe000ed00
 8000b80:	40023800 	.word	0x40023800
 8000b84:	24003010 	.word	0x24003010
 8000b88:	40007000 	.word	0x40007000
 8000b8c:	07405419 	.word	0x07405419
 8000b90:	e0042000 	.word	0xe0042000
 8000b94:	40023c00 	.word	0x40023c00

08000b98 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8000b98:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
 8000b9c:	6847      	ldr	r7, [r0, #4]
  hlen = IPH_HL(iphdr) * 4;
 8000b9e:	783c      	ldrb	r4, [r7, #0]
 8000ba0:	f004 040f 	and.w	r4, r4, #15
 8000ba4:	00a4      	lsls	r4, r4, #2
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 8000ba6:	4265      	negs	r5, r4
 8000ba8:	b22d      	sxth	r5, r5
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8000baa:	b084      	sub	sp, #16
 8000bac:	4688      	mov	r8, r1
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 8000bae:	4629      	mov	r1, r5
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8000bb0:	4606      	mov	r6, r0
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 8000bb2:	f003 fabb 	bl	800412c <pbuf_header>
 8000bb6:	2800      	cmp	r0, #0
 8000bb8:	d165      	bne.n	8000c86 <icmp_input+0xee>
 8000bba:	8933      	ldrh	r3, [r6, #8]
 8000bbc:	2b03      	cmp	r3, #3
 8000bbe:	d962      	bls.n	8000c86 <icmp_input+0xee>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 8000bc0:	6873      	ldr	r3, [r6, #4]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
 8000bc2:	781b      	ldrb	r3, [r3, #0]
 8000bc4:	2b08      	cmp	r3, #8
 8000bc6:	d15e      	bne.n	8000c86 <icmp_input+0xee>
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 8000bc8:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 8000c98 <icmp_input+0x100>
 8000bcc:	f8da 9000 	ldr.w	r9, [sl]
        accepted = 0;
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 8000bd0:	4641      	mov	r1, r8
 8000bd2:	4648      	mov	r0, r9
 8000bd4:	f000 fb26 	bl	8001224 <ip4_addr_isbroadcast>
 8000bd8:	2800      	cmp	r0, #0
 8000bda:	d154      	bne.n	8000c86 <icmp_input+0xee>
        accepted = 0;
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
 8000bdc:	f009 09f0 	and.w	r9, r9, #240	; 0xf0
 8000be0:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
 8000be4:	d04f      	beq.n	8000c86 <icmp_input+0xee>
        return;
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8000be6:	8933      	ldrh	r3, [r6, #8]
 8000be8:	2b07      	cmp	r3, #7
 8000bea:	d94c      	bls.n	8000c86 <icmp_input+0xee>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
 8000bec:	4630      	mov	r0, r6
 8000bee:	f000 f929 	bl	8000e44 <inet_chksum_pbuf>
 8000bf2:	2800      	cmp	r0, #0
 8000bf4:	d147      	bne.n	8000c86 <icmp_input+0xee>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8000bf6:	2122      	movs	r1, #34	; 0x22
 8000bf8:	4630      	mov	r0, r6
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
 8000bfa:	b224      	sxth	r4, r4
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8000bfc:	f003 fa96 	bl	800412c <pbuf_header>
 8000c00:	b1e0      	cbz	r0, 8000c3c <icmp_input+0xa4>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
 8000c02:	4621      	mov	r1, r4
 8000c04:	4630      	mov	r0, r6
 8000c06:	f003 fa91 	bl	800412c <pbuf_header>
 8000c0a:	2800      	cmp	r0, #0
 8000c0c:	d13b      	bne.n	8000c86 <icmp_input+0xee>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 8000c0e:	4602      	mov	r2, r0
 8000c10:	8931      	ldrh	r1, [r6, #8]
 8000c12:	2002      	movs	r0, #2
 8000c14:	f003 f968 	bl	8003ee8 <pbuf_alloc>
      if (r == NULL) {
 8000c18:	4681      	mov	r9, r0
 8000c1a:	b3a0      	cbz	r0, 8000c86 <icmp_input+0xee>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
 8000c1c:	4631      	mov	r1, r6
 8000c1e:	f003 fb33 	bl	8004288 <pbuf_copy>
 8000c22:	bb80      	cbnz	r0, 8000c86 <icmp_input+0xee>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 8000c24:	4629      	mov	r1, r5
 8000c26:	4648      	mov	r0, r9
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
 8000c28:	f8d9 7004 	ldr.w	r7, [r9, #4]
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 8000c2c:	f003 fa7e 	bl	800412c <pbuf_header>
 8000c30:	bb48      	cbnz	r0, 8000c86 <icmp_input+0xee>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
 8000c32:	4630      	mov	r0, r6
 8000c34:	f003 fab0 	bl	8004198 <pbuf_free>
 8000c38:	464e      	mov	r6, r9
 8000c3a:	e005      	b.n	8000c48 <icmp_input+0xb0>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8000c3c:	f06f 0121 	mvn.w	r1, #33	; 0x21
 8000c40:	4630      	mov	r0, r6
 8000c42:	f003 fa73 	bl	800412c <pbuf_header>
 8000c46:	b9f0      	cbnz	r0, 8000c86 <icmp_input+0xee>
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 8000c48:	4b12      	ldr	r3, [pc, #72]	; (8000c94 <icmp_input+0xfc>)
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
 8000c4a:	6870      	ldr	r0, [r6, #4]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 8000c4c:	f8da 2000 	ldr.w	r2, [sl]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 8000c50:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 8000c52:	60fa      	str	r2, [r7, #12]
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */
    
    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 8000c54:	25ff      	movs	r5, #255	; 0xff
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 8000c56:	2200      	movs	r2, #0
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 8000c58:	613b      	str	r3, [r7, #16]
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 8000c5a:	4621      	mov	r1, r4
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 8000c5c:	7002      	strb	r2, [r0, #0]
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
    }
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
 8000c5e:	7082      	strb	r2, [r0, #2]
 8000c60:	70c2      	strb	r2, [r0, #3]
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 8000c62:	4630      	mov	r0, r6
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */
    
    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    IPH_CHKSUM_SET(iphdr, 0);
 8000c64:	72ba      	strb	r2, [r7, #10]
 8000c66:	72fa      	strb	r2, [r7, #11]
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */
    
    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 8000c68:	723d      	strb	r5, [r7, #8]
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 8000c6a:	f003 fa5f 	bl	800412c <pbuf_header>
 8000c6e:	b950      	cbnz	r0, 8000c86 <icmp_input+0xee>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 8000c70:	2101      	movs	r1, #1
 8000c72:	9000      	str	r0, [sp, #0]
 8000c74:	4602      	mov	r2, r0
 8000c76:	9101      	str	r1, [sp, #4]
 8000c78:	f8cd 8008 	str.w	r8, [sp, #8]
 8000c7c:	462b      	mov	r3, r5
 8000c7e:	4906      	ldr	r1, [pc, #24]	; (8000c98 <icmp_input+0x100>)
 8000c80:	4630      	mov	r0, r6
 8000c82:	f000 fa3f 	bl	8001104 <ip_output_if>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 8000c86:	4630      	mov	r0, r6
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 8000c88:	b004      	add	sp, #16
 8000c8a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 8000c8e:	f003 ba83 	b.w	8004198 <pbuf_free>
 8000c92:	bf00      	nop
 8000c94:	20002ee4 	.word	0x20002ee4
 8000c98:	20002eec 	.word	0x20002eec

08000c9c <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 8000c9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8000ca0:	2200      	movs	r2, #0
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 8000ca2:	b084      	sub	sp, #16
 8000ca4:	4605      	mov	r5, r0
 8000ca6:	460f      	mov	r7, r1
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8000ca8:	2001      	movs	r0, #1
 8000caa:	2124      	movs	r1, #36	; 0x24
 8000cac:	f003 f91c 	bl	8003ee8 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 8000cb0:	2800      	cmp	r0, #0
 8000cb2:	d03b      	beq.n	8000d2c <icmp_dest_unreach+0x90>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8000cb4:	6844      	ldr	r4, [r0, #4]
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 8000cb6:	f8d5 8004 	ldr.w	r8, [r5, #4]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
 8000cba:	7067      	strb	r7, [r4, #1]
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
 8000cbc:	2303      	movs	r3, #3
 8000cbe:	7023      	strb	r3, [r4, #0]
  icmphdr->code = code;
  icmphdr->id = 0;
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8000cc0:	686b      	ldr	r3, [r5, #4]
 8000cc2:	f8d0 e004 	ldr.w	lr, [r0, #4]
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
 8000cc6:	2500      	movs	r5, #0
 8000cc8:	7125      	strb	r5, [r4, #4]
 8000cca:	7165      	strb	r5, [r4, #5]
  icmphdr->seqno = 0;
 8000ccc:	71a5      	strb	r5, [r4, #6]
 8000cce:	71e5      	strb	r5, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8000cd0:	6859      	ldr	r1, [r3, #4]
 8000cd2:	689f      	ldr	r7, [r3, #8]
 8000cd4:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8000cd8:	4606      	mov	r6, r0
 8000cda:	6818      	ldr	r0, [r3, #0]
 8000cdc:	f8ce 0008 	str.w	r0, [lr, #8]
 8000ce0:	f8ce 100c 	str.w	r1, [lr, #12]
 8000ce4:	f8ce 7010 	str.w	r7, [lr, #16]
 8000ce8:	f8ce c014 	str.w	ip, [lr, #20]
 8000cec:	6918      	ldr	r0, [r3, #16]
 8000cee:	6959      	ldr	r1, [r3, #20]
 8000cf0:	699f      	ldr	r7, [r3, #24]
 8000cf2:	f8ce 7020 	str.w	r7, [lr, #32]
 8000cf6:	f8ce 0018 	str.w	r0, [lr, #24]
 8000cfa:	f8ce 101c 	str.w	r1, [lr, #28]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8000cfe:	8971      	ldrh	r1, [r6, #10]
  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 8000d00:	70a5      	strb	r5, [r4, #2]
 8000d02:	70e5      	strb	r5, [r4, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8000d04:	4620      	mov	r0, r4
 8000d06:	f000 f861 	bl	8000dcc <inet_chksum>
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 8000d0a:	aa04      	add	r2, sp, #16
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8000d0c:	8060      	strh	r0, [r4, #2]
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 8000d0e:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8000d12:	f842 3d04 	str.w	r3, [r2, #-4]!
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 8000d16:	2301      	movs	r3, #1
 8000d18:	9301      	str	r3, [sp, #4]
 8000d1a:	9500      	str	r5, [sp, #0]
 8000d1c:	4629      	mov	r1, r5
 8000d1e:	23ff      	movs	r3, #255	; 0xff
 8000d20:	4630      	mov	r0, r6
 8000d22:	f000 fa51 	bl	80011c8 <ip_output>
  pbuf_free(q);
 8000d26:	4630      	mov	r0, r6
 8000d28:	f003 fa36 	bl	8004198 <pbuf_free>
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  icmp_send_response(p, ICMP_DUR, t);
}
 8000d2c:	b004      	add	sp, #16
 8000d2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000d32:	bf00      	nop

08000d34 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 8000d34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8000d38:	2200      	movs	r2, #0
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 8000d3a:	b084      	sub	sp, #16
 8000d3c:	4605      	mov	r5, r0
 8000d3e:	460f      	mov	r7, r1
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8000d40:	2001      	movs	r0, #1
 8000d42:	2124      	movs	r1, #36	; 0x24
 8000d44:	f003 f8d0 	bl	8003ee8 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 8000d48:	2800      	cmp	r0, #0
 8000d4a:	d03b      	beq.n	8000dc4 <icmp_time_exceeded+0x90>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8000d4c:	6844      	ldr	r4, [r0, #4]
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 8000d4e:	f8d5 8004 	ldr.w	r8, [r5, #4]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
 8000d52:	7067      	strb	r7, [r4, #1]
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
 8000d54:	230b      	movs	r3, #11
 8000d56:	7023      	strb	r3, [r4, #0]
  icmphdr->code = code;
  icmphdr->id = 0;
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8000d58:	686b      	ldr	r3, [r5, #4]
 8000d5a:	f8d0 e004 	ldr.w	lr, [r0, #4]
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
 8000d5e:	2500      	movs	r5, #0
 8000d60:	7125      	strb	r5, [r4, #4]
 8000d62:	7165      	strb	r5, [r4, #5]
  icmphdr->seqno = 0;
 8000d64:	71a5      	strb	r5, [r4, #6]
 8000d66:	71e5      	strb	r5, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8000d68:	6859      	ldr	r1, [r3, #4]
 8000d6a:	689f      	ldr	r7, [r3, #8]
 8000d6c:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8000d70:	4606      	mov	r6, r0
 8000d72:	6818      	ldr	r0, [r3, #0]
 8000d74:	f8ce 0008 	str.w	r0, [lr, #8]
 8000d78:	f8ce 100c 	str.w	r1, [lr, #12]
 8000d7c:	f8ce 7010 	str.w	r7, [lr, #16]
 8000d80:	f8ce c014 	str.w	ip, [lr, #20]
 8000d84:	6918      	ldr	r0, [r3, #16]
 8000d86:	6959      	ldr	r1, [r3, #20]
 8000d88:	699f      	ldr	r7, [r3, #24]
 8000d8a:	f8ce 7020 	str.w	r7, [lr, #32]
 8000d8e:	f8ce 0018 	str.w	r0, [lr, #24]
 8000d92:	f8ce 101c 	str.w	r1, [lr, #28]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8000d96:	8971      	ldrh	r1, [r6, #10]
  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 8000d98:	70a5      	strb	r5, [r4, #2]
 8000d9a:	70e5      	strb	r5, [r4, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8000d9c:	4620      	mov	r0, r4
 8000d9e:	f000 f815 	bl	8000dcc <inet_chksum>
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 8000da2:	aa04      	add	r2, sp, #16
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8000da4:	8060      	strh	r0, [r4, #2]
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 8000da6:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8000daa:	f842 3d04 	str.w	r3, [r2, #-4]!
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 8000dae:	2301      	movs	r3, #1
 8000db0:	9301      	str	r3, [sp, #4]
 8000db2:	9500      	str	r5, [sp, #0]
 8000db4:	4629      	mov	r1, r5
 8000db6:	23ff      	movs	r3, #255	; 0xff
 8000db8:	4630      	mov	r0, r6
 8000dba:	f000 fa05 	bl	80011c8 <ip_output>
  pbuf_free(q);
 8000dbe:	4630      	mov	r0, r6
 8000dc0:	f003 f9ea 	bl	8004198 <pbuf_free>
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  icmp_send_response(p, ICMP_TE, t);
}
 8000dc4:	b004      	add	sp, #16
 8000dc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000dca:	bf00      	nop

08000dcc <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 8000dcc:	b470      	push	{r4, r5, r6}
 8000dce:	b083      	sub	sp, #12

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 8000dd0:	2300      	movs	r3, #0
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8000dd2:	f010 0601 	ands.w	r6, r0, #1

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 8000dd6:	f8ad 3006 	strh.w	r3, [sp, #6]
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8000dda:	d005      	beq.n	8000de8 <inet_chksum+0x1c>
 8000ddc:	b329      	cbz	r1, 8000e2a <inet_chksum+0x5e>
    ((u8_t *)&t)[1] = *pb++;
 8000dde:	7803      	ldrb	r3, [r0, #0]
 8000de0:	f88d 3007 	strb.w	r3, [sp, #7]
    len--;
 8000de4:	3901      	subs	r1, #1
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    ((u8_t *)&t)[1] = *pb++;
 8000de6:	3001      	adds	r0, #1
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 8000de8:	2901      	cmp	r1, #1
 8000dea:	dd28      	ble.n	8000e3e <inet_chksum+0x72>
 8000dec:	460b      	mov	r3, r1
 8000dee:	4604      	mov	r4, r0
 8000df0:	2200      	movs	r2, #0
    sum += *ps++;
 8000df2:	f834 5b02 	ldrh.w	r5, [r4], #2
    len -= 2;
 8000df6:	3b02      	subs	r3, #2
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 8000df8:	2b01      	cmp	r3, #1
    sum += *ps++;
 8000dfa:	442a      	add	r2, r5
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 8000dfc:	dcf9      	bgt.n	8000df2 <inet_chksum+0x26>
 8000dfe:	3902      	subs	r1, #2
 8000e00:	084b      	lsrs	r3, r1, #1
 8000e02:	1c5c      	adds	r4, r3, #1
 8000e04:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
 8000e08:	eb00 0044 	add.w	r0, r0, r4, lsl #1
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 8000e0c:	2901      	cmp	r1, #1
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 8000e0e:	bf04      	itt	eq
 8000e10:	7803      	ldrbeq	r3, [r0, #0]
 8000e12:	f88d 3006 	strbeq.w	r3, [sp, #6]
 8000e16:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000e1a:	441a      	add	r2, r3
 8000e1c:	b291      	uxth	r1, r2
 8000e1e:	eb01 4212 	add.w	r2, r1, r2, lsr #16
 8000e22:	b293      	uxth	r3, r2
 8000e24:	eb03 4112 	add.w	r1, r3, r2, lsr #16
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
  sum = FOLD_U32T(sum);

  /* Swap if alignment was odd */
  if (odd) {
 8000e28:	b126      	cbz	r6, 8000e34 <inet_chksum+0x68>
    sum = SWAP_BYTES_IN_WORD(sum);
 8000e2a:	020a      	lsls	r2, r1, #8
 8000e2c:	b292      	uxth	r2, r2
 8000e2e:	f3c1 2107 	ubfx	r1, r1, #8, #8
 8000e32:	4311      	orrs	r1, r2
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  return ~LWIP_CHKSUM(dataptr, len);
 8000e34:	43c8      	mvns	r0, r1
}
 8000e36:	b280      	uxth	r0, r0
 8000e38:	b003      	add	sp, #12
 8000e3a:	bc70      	pop	{r4, r5, r6}
 8000e3c:	4770      	bx	lr
static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
  u32_t sum = 0;
 8000e3e:	2200      	movs	r2, #0
 8000e40:	e7e4      	b.n	8000e0c <inet_chksum+0x40>
 8000e42:	bf00      	nop

08000e44 <inet_chksum_pbuf>:
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 8000e44:	2800      	cmp	r0, #0
 8000e46:	d071      	beq.n	8000f2c <inet_chksum_pbuf+0xe8>
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 8000e48:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 8000e4c:	2600      	movs	r6, #0
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 8000e4e:	b083      	sub	sp, #12
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 8000e50:	46b6      	mov	lr, r6

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 8000e52:	4637      	mov	r7, r6
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
 8000e54:	f8d0 9004 	ldr.w	r9, [r0, #4]
 8000e58:	8945      	ldrh	r5, [r0, #10]

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 8000e5a:	f8ad 7006 	strh.w	r7, [sp, #6]
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8000e5e:	f019 0c01 	ands.w	ip, r9, #1
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
 8000e62:	46a8      	mov	r8, r5
  u16_t *ps, t = 0;
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8000e64:	d009      	beq.n	8000e7a <inet_chksum_pbuf+0x36>
 8000e66:	2d00      	cmp	r5, #0
 8000e68:	d056      	beq.n	8000f18 <inet_chksum_pbuf+0xd4>
    ((u8_t *)&t)[1] = *pb++;
 8000e6a:	f899 3000 	ldrb.w	r3, [r9]
 8000e6e:	f88d 3007 	strb.w	r3, [sp, #7]
 8000e72:	f109 0901 	add.w	r9, r9, #1
    len--;
 8000e76:	f105 38ff 	add.w	r8, r5, #4294967295
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 8000e7a:	f1b8 0f01 	cmp.w	r8, #1
 8000e7e:	dd4d      	ble.n	8000f1c <inet_chksum_pbuf+0xd8>
 8000e80:	4643      	mov	r3, r8
 8000e82:	4649      	mov	r1, r9
 8000e84:	2200      	movs	r2, #0
    sum += *ps++;
 8000e86:	f831 4b02 	ldrh.w	r4, [r1], #2
    len -= 2;
 8000e8a:	3b02      	subs	r3, #2
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 8000e8c:	2b01      	cmp	r3, #1
    sum += *ps++;
 8000e8e:	4422      	add	r2, r4
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 8000e90:	dcf9      	bgt.n	8000e86 <inet_chksum_pbuf+0x42>
 8000e92:	f1a8 0802 	sub.w	r8, r8, #2
 8000e96:	ea4f 0358 	mov.w	r3, r8, lsr #1
 8000e9a:	1c59      	adds	r1, r3, #1
 8000e9c:	eba8 0843 	sub.w	r8, r8, r3, lsl #1
 8000ea0:	eb09 0941 	add.w	r9, r9, r1, lsl #1
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 8000ea4:	f1b8 0f01 	cmp.w	r8, #1
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 8000ea8:	bf04      	itt	eq
 8000eaa:	f899 3000 	ldrbeq.w	r3, [r9]
 8000eae:	f88d 3006 	strbeq.w	r3, [sp, #6]
 8000eb2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000eb6:	441a      	add	r2, r3
 8000eb8:	b293      	uxth	r3, r2
 8000eba:	eb03 4212 	add.w	r2, r3, r2, lsr #16
 8000ebe:	b293      	uxth	r3, r2
 8000ec0:	eb03 4312 	add.w	r3, r3, r2, lsr #16
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
  sum = FOLD_U32T(sum);

  /* Swap if alignment was odd */
  if (odd) {
 8000ec4:	f1bc 0f00 	cmp.w	ip, #0
 8000ec8:	d005      	beq.n	8000ed6 <inet_chksum_pbuf+0x92>
 8000eca:	461a      	mov	r2, r3
    sum = SWAP_BYTES_IN_WORD(sum);
 8000ecc:	0213      	lsls	r3, r2, #8
 8000ece:	b299      	uxth	r1, r3
 8000ed0:	f3c2 2307 	ubfx	r3, r2, #8, #8
 8000ed4:	430b      	orrs	r3, r1
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
 8000ed6:	fa1e f283 	uxtah	r2, lr, r3
    acc = FOLD_U32T(acc);
 8000eda:	fa1f fe82 	uxth.w	lr, r2
    if (q->len % 2 != 0) {
 8000ede:	07eb      	lsls	r3, r5, #31

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
 8000ee0:	eb0e 4e12 	add.w	lr, lr, r2, lsr #16
    if (q->len % 2 != 0) {
 8000ee4:	d509      	bpl.n	8000efa <inet_chksum_pbuf+0xb6>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
 8000ee6:	ea4f 230e 	mov.w	r3, lr, lsl #8
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 8000eea:	f1c6 0601 	rsb	r6, r6, #1
      acc = SWAP_BYTES_IN_WORD(acc);
 8000eee:	b29b      	uxth	r3, r3
 8000ef0:	f3ce 2207 	ubfx	r2, lr, #8, #8
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 8000ef4:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 8000ef6:	ea43 0e02 	orr.w	lr, r3, r2
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 8000efa:	6800      	ldr	r0, [r0, #0]
 8000efc:	2800      	cmp	r0, #0
 8000efe:	d1a9      	bne.n	8000e54 <inet_chksum_pbuf+0x10>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 8000f00:	b176      	cbz	r6, 8000f20 <inet_chksum_pbuf+0xdc>
    acc = SWAP_BYTES_IN_WORD(acc);
 8000f02:	ea4f 200e 	mov.w	r0, lr, lsl #8
 8000f06:	f3ce 2207 	ubfx	r2, lr, #8, #8
 8000f0a:	b280      	uxth	r0, r0
 8000f0c:	4310      	orrs	r0, r2
 8000f0e:	43c0      	mvns	r0, r0
 8000f10:	b280      	uxth	r0, r0
  }
  return (u16_t)~(acc & 0xffffUL);
}
 8000f12:	b003      	add	sp, #12
 8000f14:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  u16_t *ps, t = 0;
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8000f18:	462a      	mov	r2, r5
 8000f1a:	e7d7      	b.n	8000ecc <inet_chksum_pbuf+0x88>
static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
  u32_t sum = 0;
 8000f1c:	2200      	movs	r2, #0
 8000f1e:	e7c1      	b.n	8000ea4 <inet_chksum_pbuf+0x60>
 8000f20:	ea6f 020e 	mvn.w	r2, lr
 8000f24:	b290      	uxth	r0, r2

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  return (u16_t)~(acc & 0xffffUL);
}
 8000f26:	b003      	add	sp, #12
 8000f28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 8000f2c:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8000f30:	4770      	bx	lr
 8000f32:	bf00      	nop

08000f34 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *dest)
{
 8000f34:	b410      	push	{r4}
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 8000f36:	4b0e      	ldr	r3, [pc, #56]	; (8000f70 <ip_route+0x3c>)
 8000f38:	681b      	ldr	r3, [r3, #0]
 8000f3a:	b16b      	cbz	r3, 8000f58 <ip_route+0x24>
    /* network mask matches? */
    if (netif_is_up(netif)) {
 8000f3c:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
 8000f40:	07d2      	lsls	r2, r2, #31
 8000f42:	d5f9      	bpl.n	8000f38 <ip_route+0x4>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 8000f44:	6804      	ldr	r4, [r0, #0]
 8000f46:	685a      	ldr	r2, [r3, #4]
 8000f48:	6899      	ldr	r1, [r3, #8]
 8000f4a:	4062      	eors	r2, r4
 8000f4c:	420a      	tst	r2, r1
 8000f4e:	d1f3      	bne.n	8000f38 <ip_route+0x4>
 8000f50:	4618      	mov	r0, r3
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 8000f52:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000f56:	4770      	bx	lr
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 8000f58:	4b06      	ldr	r3, [pc, #24]	; (8000f74 <ip_route+0x40>)
 8000f5a:	6818      	ldr	r0, [r3, #0]
 8000f5c:	b128      	cbz	r0, 8000f6a <ip_route+0x36>
 8000f5e:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
 8000f62:	f013 0f01 	tst.w	r3, #1
 8000f66:	bf08      	it	eq
 8000f68:	2000      	moveq	r0, #0
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 8000f6a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000f6e:	4770      	bx	lr
 8000f70:	2000573c 	.word	0x2000573c
 8000f74:	20005740 	.word	0x20005740

08000f78 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 8000f78:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8000f7c:	f8d0 b004 	ldr.w	fp, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 8000f80:	f89b 8000 	ldrb.w	r8, [fp]
 8000f84:	ea4f 1318 	mov.w	r3, r8, lsr #4
 8000f88:	2b04      	cmp	r3, #4
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 8000f8a:	4607      	mov	r7, r0
  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
 8000f8c:	d005      	beq.n	8000f9a <ip_input+0x22>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 8000f8e:	4638      	mov	r0, r7
 8000f90:	f003 f902 	bl	8004198 <pbuf_free>
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
  ip_addr_set_any(&current_iphdr_dest);

  return ERR_OK;
}
 8000f94:	2000      	movs	r0, #0
 8000f96:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 8000f9a:	f8bb 0002 	ldrh.w	r0, [fp, #2]
 8000f9e:	460e      	mov	r6, r1
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
 8000fa0:	f008 080f 	and.w	r8, r8, #15
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 8000fa4:	f000 fc66 	bl	8001874 <lwip_ntohs>

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 8000fa8:	897b      	ldrh	r3, [r7, #10]
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
 8000faa:	ea4f 0888 	mov.w	r8, r8, lsl #2
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 8000fae:	4543      	cmp	r3, r8
 8000fb0:	d3ed      	bcc.n	8000f8e <ip_input+0x16>
 8000fb2:	893b      	ldrh	r3, [r7, #8]
 8000fb4:	4283      	cmp	r3, r0
 8000fb6:	d3ea      	bcc.n	8000f8e <ip_input+0x16>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 8000fb8:	4601      	mov	r1, r0

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 8000fba:	f8df 9140 	ldr.w	r9, [pc, #320]	; 80010fc <ip_input+0x184>
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
        first = 0;
        netif = netif_list;
 8000fbe:	f8df a140 	ldr.w	sl, [pc, #320]	; 8001100 <ip_input+0x188>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 8000fc2:	4638      	mov	r0, r7
 8000fc4:	f003 f868 	bl	8004098 <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 8000fc8:	f8db 3010 	ldr.w	r3, [fp, #16]
 8000fcc:	f8c9 3000 	str.w	r3, [r9]
  ip_addr_copy(current_iphdr_src, iphdr->src);
 8000fd0:	4a47      	ldr	r2, [pc, #284]	; (80010f0 <ip_input+0x178>)
 8000fd2:	f8db 300c 	ldr.w	r3, [fp, #12]
 8000fd6:	6013      	str	r3, [r2, #0]
 8000fd8:	4634      	mov	r4, r6
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
 8000fda:	2501      	movs	r5, #1
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 8000fdc:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
 8000fe0:	07db      	lsls	r3, r3, #31
 8000fe2:	d509      	bpl.n	8000ff8 <ip_input+0x80>
 8000fe4:	6863      	ldr	r3, [r4, #4]
 8000fe6:	b13b      	cbz	r3, 8000ff8 <ip_input+0x80>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 8000fe8:	f8d9 0000 	ldr.w	r0, [r9]
 8000fec:	4283      	cmp	r3, r0
 8000fee:	d022      	beq.n	8001036 <ip_input+0xbe>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 8000ff0:	4621      	mov	r1, r4
 8000ff2:	f000 f917 	bl	8001224 <ip4_addr_isbroadcast>
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 8000ff6:	b9f0      	cbnz	r0, 8001036 <ip_input+0xbe>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
 8000ff8:	2d00      	cmp	r5, #0
 8000ffa:	d05e      	beq.n	80010ba <ip_input+0x142>
        first = 0;
        netif = netif_list;
 8000ffc:	f8da 4000 	ldr.w	r4, [sl]
      } else {
        netif = netif->next;
      }
      if (netif == inp) {
 8001000:	42b4      	cmp	r4, r6
        netif = netif->next;
 8001002:	bf08      	it	eq
 8001004:	6824      	ldreq	r4, [r4, #0]
 8001006:	2500      	movs	r5, #0
      }
    } while(netif != NULL);
 8001008:	2c00      	cmp	r4, #0
 800100a:	d1e7      	bne.n	8000fdc <ip_input+0x64>
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 800100c:	f89b 3009 	ldrb.w	r3, [fp, #9]
 8001010:	2b11      	cmp	r3, #17
 8001012:	d063      	beq.n	80010dc <ip_input+0x164>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 8001014:	4b36      	ldr	r3, [pc, #216]	; (80010f0 <ip_input+0x178>)
 8001016:	6818      	ldr	r0, [r3, #0]
 8001018:	2800      	cmp	r0, #0
 800101a:	d0b8      	beq.n	8000f8e <ip_input+0x16>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 800101c:	4631      	mov	r1, r6
 800101e:	f000 f901 	bl	8001224 <ip4_addr_isbroadcast>
 8001022:	2800      	cmp	r0, #0
 8001024:	d1b3      	bne.n	8000f8e <ip_input+0x16>
 8001026:	4b32      	ldr	r3, [pc, #200]	; (80010f0 <ip_input+0x178>)
 8001028:	681b      	ldr	r3, [r3, #0]
 800102a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800102e:	2be0      	cmp	r3, #224	; 0xe0
 8001030:	d0ad      	beq.n	8000f8e <ip_input+0x16>
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 8001032:	b924      	cbnz	r4, 800103e <ip_input+0xc6>
 8001034:	e7ab      	b.n	8000f8e <ip_input+0x16>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 8001036:	4b2e      	ldr	r3, [pc, #184]	; (80010f0 <ip_input+0x178>)
 8001038:	6818      	ldr	r0, [r3, #0]
 800103a:	2800      	cmp	r0, #0
 800103c:	d1ee      	bne.n	800101c <ip_input+0xa4>
    }
    pbuf_free(p);
    return ERR_OK;
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 800103e:	f8bb 3006 	ldrh.w	r3, [fp, #6]
 8001042:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8001046:	b13b      	cbz	r3, 8001058 <ip_input+0xe0>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 8001048:	4638      	mov	r0, r7
 800104a:	f000 f9a3 	bl	8001394 <ip_reass>
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 800104e:	4607      	mov	r7, r0
 8001050:	2800      	cmp	r0, #0
 8001052:	d09f      	beq.n	8000f94 <ip_input+0x1c>
      return ERR_OK;
    }
    iphdr = (struct ip_hdr *)p->payload;
 8001054:	f8d0 b004 	ldr.w	fp, [r0, #4]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 8001058:	4d26      	ldr	r5, [pc, #152]	; (80010f4 <ip_input+0x17c>)
  current_header = iphdr;
 800105a:	4c27      	ldr	r4, [pc, #156]	; (80010f8 <ip_input+0x180>)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 800105c:	602e      	str	r6, [r5, #0]
  current_header = iphdr;

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 800105e:	4631      	mov	r1, r6
 8001060:	4638      	mov	r0, r7
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
  current_header = iphdr;
 8001062:	f8c4 b000 	str.w	fp, [r4]

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 8001066:	f003 f9a7 	bl	80043b8 <raw_input>
 800106a:	b9e0      	cbnz	r0, 80010a6 <ip_input+0x12e>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
 800106c:	f89b 3009 	ldrb.w	r3, [fp, #9]
 8001070:	2b06      	cmp	r3, #6
 8001072:	d024      	beq.n	80010be <ip_input+0x146>
 8001074:	2b11      	cmp	r3, #17
 8001076:	d027      	beq.n	80010c8 <ip_input+0x150>
 8001078:	2b01      	cmp	r3, #1
 800107a:	d02a      	beq.n	80010d2 <ip_input+0x15a>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 800107c:	4631      	mov	r1, r6
 800107e:	f8d9 0000 	ldr.w	r0, [r9]
 8001082:	4e1e      	ldr	r6, [pc, #120]	; (80010fc <ip_input+0x184>)
 8001084:	f000 f8ce 	bl	8001224 <ip4_addr_isbroadcast>
 8001088:	b950      	cbnz	r0, 80010a0 <ip_input+0x128>
 800108a:	6833      	ldr	r3, [r6, #0]
 800108c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001090:	2be0      	cmp	r3, #224	; 0xe0
 8001092:	d005      	beq.n	80010a0 <ip_input+0x128>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
 8001094:	f8c7 b004 	str.w	fp, [r7, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 8001098:	2102      	movs	r1, #2
 800109a:	4638      	mov	r0, r7
 800109c:	f7ff fdfe 	bl	8000c9c <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 80010a0:	4638      	mov	r0, r7
 80010a2:	f003 f879 	bl	8004198 <pbuf_free>
    }
  }

  current_netif = NULL;
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
 80010a6:	4a12      	ldr	r2, [pc, #72]	; (80010f0 <ip_input+0x178>)
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 80010a8:	2300      	movs	r3, #0
 80010aa:	602b      	str	r3, [r5, #0]
  current_header = NULL;
 80010ac:	6023      	str	r3, [r4, #0]
  ip_addr_set_any(&current_iphdr_src);
 80010ae:	6013      	str	r3, [r2, #0]
  ip_addr_set_any(&current_iphdr_dest);
 80010b0:	f8c9 3000 	str.w	r3, [r9]

  return ERR_OK;
}
 80010b4:	2000      	movs	r0, #0
 80010b6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      if (first) {
        first = 0;
        netif = netif_list;
      } else {
        netif = netif->next;
 80010ba:	6824      	ldr	r4, [r4, #0]
 80010bc:	e7a0      	b.n	8001000 <ip_input+0x88>
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 80010be:	4631      	mov	r1, r6
 80010c0:	4638      	mov	r0, r7
 80010c2:	f004 fcb3 	bl	8005a2c <tcp_input>
      break;
 80010c6:	e7ee      	b.n	80010a6 <ip_input+0x12e>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 80010c8:	4631      	mov	r1, r6
 80010ca:	4638      	mov	r0, r7
 80010cc:	f005 ffb2 	bl	8007034 <udp_input>
      break;
 80010d0:	e7e9      	b.n	80010a6 <ip_input+0x12e>
      break;
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 80010d2:	4631      	mov	r1, r6
 80010d4:	4638      	mov	r0, r7
 80010d6:	f7ff fd5f 	bl	8000b98 <icmp_input>
      break;
 80010da:	e7e4      	b.n	80010a6 <ip_input+0x12e>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 80010dc:	44d8      	add	r8, fp
 80010de:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 80010e2:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
 80010e6:	d195      	bne.n	8001014 <ip_input+0x9c>
 80010e8:	4634      	mov	r4, r6
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 80010ea:	2c00      	cmp	r4, #0
 80010ec:	d1a7      	bne.n	800103e <ip_input+0xc6>
 80010ee:	e74e      	b.n	8000f8e <ip_input+0x16>
 80010f0:	20002ee4 	.word	0x20002ee4
 80010f4:	20002ee8 	.word	0x20002ee8
 80010f8:	20002ef0 	.word	0x20002ef0
 80010fc:	20002eec 	.word	0x20002eec
 8001100:	2000573c 	.word	0x2000573c

08001104 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 8001104:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001108:	b085      	sub	sp, #20
 800110a:	4606      	mov	r6, r0
 800110c:	9301      	str	r3, [sp, #4]
 800110e:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 8001112:	9300      	str	r3, [sp, #0]
 8001114:	f89d b03c 	ldrb.w	fp, [sp, #60]	; 0x3c
 8001118:	9f10      	ldr	r7, [sp, #64]	; 0x40
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 800111a:	2a00      	cmp	r2, #0
 800111c:	d040      	beq.n	80011a0 <ip_output_if+0x9c>
 800111e:	4689      	mov	r9, r1
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 8001120:	2114      	movs	r1, #20
 8001122:	4615      	mov	r5, r2
 8001124:	f003 f802 	bl	800412c <pbuf_header>
 8001128:	4680      	mov	r8, r0
 800112a:	2800      	cmp	r0, #0
 800112c:	d146      	bne.n	80011bc <ip_output_if+0xb8>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 800112e:	6874      	ldr	r4, [r6, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8001130:	9b01      	ldr	r3, [sp, #4]
 8001132:	7223      	strb	r3, [r4, #8]
    IPH_PROTO_SET(iphdr, proto);
 8001134:	f884 b009 	strb.w	fp, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8001138:	2145      	movs	r1, #69	; 0x45
    IPH_TOS_SET(iphdr, tos);
 800113a:	f89d 2000 	ldrb.w	r2, [sp]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 800113e:	682b      	ldr	r3, [r5, #0]
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
 8001140:	7062      	strb	r2, [r4, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8001142:	7021      	strb	r1, [r4, #0]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 8001144:	6123      	str	r3, [r4, #16]
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 8001146:	8930      	ldrh	r0, [r6, #8]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
 8001148:	f8df a078 	ldr.w	sl, [pc, #120]	; 80011c4 <ip_output_if+0xc0>
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800114c:	f000 fb8e 	bl	800186c <lwip_htons>
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8001150:	f884 8006 	strb.w	r8, [r4, #6]
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 8001154:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8001156:	f884 8007 	strb.w	r8, [r4, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 800115a:	f8ba 0000 	ldrh.w	r0, [sl]
 800115e:	f000 fb85 	bl	800186c <lwip_htons>
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 8001162:	f8ba 3000 	ldrh.w	r3, [sl]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
 8001166:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 8001168:	3301      	adds	r3, #1
 800116a:	f8aa 3000 	strh.w	r3, [sl]

    if (ip_addr_isany(src)) {
 800116e:	f1b9 0f00 	cmp.w	r9, #0
 8001172:	d013      	beq.n	800119c <ip_output_if+0x98>
 8001174:	f8d9 3000 	ldr.w	r3, [r9]
 8001178:	b183      	cbz	r3, 800119c <ip_output_if+0x98>
 800117a:	60e3      	str	r3, [r4, #12]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    chk_sum = (chk_sum >> 16) + chk_sum;
    chk_sum = ~chk_sum;
    iphdr->_chksum = chk_sum; /* network order */
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 800117c:	2300      	movs	r3, #0
 800117e:	72a3      	strb	r3, [r4, #10]
 8001180:	72e3      	strb	r3, [r4, #11]
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 8001182:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8001184:	b113      	cbz	r3, 800118c <ip_output_if+0x88>
 8001186:	8932      	ldrh	r2, [r6, #8]
 8001188:	429a      	cmp	r2, r3
 800118a:	d80f      	bhi.n	80011ac <ip_output_if+0xa8>
    return ip_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 800118c:	462a      	mov	r2, r5
 800118e:	4631      	mov	r1, r6
 8001190:	697b      	ldr	r3, [r7, #20]
 8001192:	4638      	mov	r0, r7
 8001194:	4798      	blx	r3
}
 8001196:	b005      	add	sp, #20
 8001198:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;

    if (ip_addr_isany(src)) {
      ip_addr_copy(iphdr->src, netif->ip_addr);
 800119c:	687b      	ldr	r3, [r7, #4]
 800119e:	e7ec      	b.n	800117a <ip_output_if+0x76>
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
 80011a0:	6843      	ldr	r3, [r0, #4]
 80011a2:	ad04      	add	r5, sp, #16
 80011a4:	691b      	ldr	r3, [r3, #16]
 80011a6:	f845 3d04 	str.w	r3, [r5, #-4]!
 80011aa:	e7ea      	b.n	8001182 <ip_output_if+0x7e>
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    return ip_frag(p, netif, dest);
 80011ac:	462a      	mov	r2, r5
 80011ae:	4639      	mov	r1, r7
 80011b0:	4630      	mov	r0, r6
 80011b2:	f000 fa87 	bl	80016c4 <ip_frag>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
}
 80011b6:	b005      	add	sp, #20
 80011b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
 80011bc:	f06f 0001 	mvn.w	r0, #1
 80011c0:	e7e9      	b.n	8001196 <ip_output_if+0x92>
 80011c2:	bf00      	nop
 80011c4:	2000056c 	.word	0x2000056c

080011c8 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 80011c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80011ca:	4c14      	ldr	r4, [pc, #80]	; (800121c <ip_output+0x54>)
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 80011cc:	b085      	sub	sp, #20
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80011ce:	6824      	ldr	r4, [r4, #0]
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 80011d0:	f89d 6028 	ldrb.w	r6, [sp, #40]	; 0x28
 80011d4:	f89d 702c 	ldrb.w	r7, [sp, #44]	; 0x2c
 80011d8:	469e      	mov	lr, r3
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80011da:	b164      	cbz	r4, 80011f6 <ip_output+0x2e>
    /* network mask matches? */
    if (netif_is_up(netif)) {
 80011dc:	f894 5031 	ldrb.w	r5, [r4, #49]	; 0x31
 80011e0:	07ed      	lsls	r5, r5, #31
 80011e2:	d505      	bpl.n	80011f0 <ip_output+0x28>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 80011e4:	6813      	ldr	r3, [r2, #0]
 80011e6:	6865      	ldr	r5, [r4, #4]
 80011e8:	405d      	eors	r5, r3
 80011ea:	68a3      	ldr	r3, [r4, #8]
 80011ec:	421d      	tst	r5, r3
 80011ee:	d009      	beq.n	8001204 <ip_output+0x3c>
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80011f0:	6824      	ldr	r4, [r4, #0]
 80011f2:	2c00      	cmp	r4, #0
 80011f4:	d1f2      	bne.n	80011dc <ip_output+0x14>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 80011f6:	4c0a      	ldr	r4, [pc, #40]	; (8001220 <ip_output+0x58>)
 80011f8:	6824      	ldr	r4, [r4, #0]
 80011fa:	b15c      	cbz	r4, 8001214 <ip_output+0x4c>
 80011fc:	f894 5031 	ldrb.w	r5, [r4, #49]	; 0x31
 8001200:	07eb      	lsls	r3, r5, #31
 8001202:	d507      	bpl.n	8001214 <ip_output+0x4c>
 8001204:	4673      	mov	r3, lr
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 8001206:	9402      	str	r4, [sp, #8]
 8001208:	e88d 00c0 	stmia.w	sp, {r6, r7}
 800120c:	f7ff ff7a 	bl	8001104 <ip_output_if>
}
 8001210:	b005      	add	sp, #20
 8001212:	bdf0      	pop	{r4, r5, r6, r7, pc}

  if ((netif = ip_route(dest)) == NULL) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
 8001214:	f06f 0003 	mvn.w	r0, #3
 8001218:	e7fa      	b.n	8001210 <ip_output+0x48>
 800121a:	bf00      	nop
 800121c:	2000573c 	.word	0x2000573c
 8001220:	20005740 	.word	0x20005740

08001224 <ip4_addr_isbroadcast>:
{
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 8001224:	1e43      	subs	r3, r0, #1
 8001226:	3303      	adds	r3, #3
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
 8001228:	4602      	mov	r2, r0
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 800122a:	d816      	bhi.n	800125a <ip4_addr_isbroadcast+0x36>
 800122c:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
 8001230:	f003 0302 	and.w	r3, r3, #2
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 8001234:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8001238:	b173      	cbz	r3, 8001258 <ip4_addr_isbroadcast+0x34>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
 800123a:	684b      	ldr	r3, [r1, #4]
 800123c:	429a      	cmp	r2, r3
 800123e:	d00a      	beq.n	8001256 <ip4_addr_isbroadcast+0x32>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
 8001240:	6889      	ldr	r1, [r1, #8]
 8001242:	4053      	eors	r3, r2
 8001244:	420b      	tst	r3, r1
 8001246:	d106      	bne.n	8001256 <ip4_addr_isbroadcast+0x32>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 8001248:	43c9      	mvns	r1, r1
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
      (addr == IPADDR_ANY)) {
    return 1;
 800124a:	ea31 0302 	bics.w	r3, r1, r2
 800124e:	bf0c      	ite	eq
 8001250:	2001      	moveq	r0, #1
 8001252:	2000      	movne	r0, #0
 8001254:	4770      	bx	lr
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 8001256:	2000      	movs	r0, #0
  }
}
 8001258:	4770      	bx	lr
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
      (addr == IPADDR_ANY)) {
    return 1;
 800125a:	2001      	movs	r0, #1
 800125c:	4770      	bx	lr
 800125e:	bf00      	nop

08001260 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 8001260:	b510      	push	{r4, lr}
 8001262:	4604      	mov	r4, r0
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 8001264:	6940      	ldr	r0, [r0, #20]
 8001266:	b108      	cbz	r0, 800126c <ipfrag_free_pbuf_custom+0xc>
    pbuf_free(pcr->original);
 8001268:	f002 ff96 	bl	8004198 <pbuf_free>
/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
 800126c:	4621      	mov	r1, r4
 800126e:	2006      	movs	r0, #6
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
    pbuf_free(pcr->original);
  }
  ip_frag_free_pbuf_custom_ref(pcr);
}
 8001270:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
 8001274:	f002 bce4 	b.w	8003c40 <memp_free>

08001278 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 8001278:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800127c:	b083      	sub	sp, #12
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 800127e:	2300      	movs	r3, #0
 8001280:	f8df b108 	ldr.w	fp, [pc, #264]	; 800138c <ip_reass_remove_oldest_datagram+0x114>
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 8001284:	9101      	str	r1, [sp, #4]
 8001286:	4681      	mov	r9, r0
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 8001288:	9300      	str	r3, [sp, #0]
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
 800128a:	f8db 3000 	ldr.w	r3, [fp]
    while (r != NULL) {
 800128e:	2b00      	cmp	r3, #0
 8001290:	d056      	beq.n	8001340 <ip_reass_remove_oldest_datagram+0xc8>
 8001292:	2700      	movs	r7, #0
 8001294:	46b8      	mov	r8, r7
 8001296:	463d      	mov	r5, r7
 8001298:	f8d9 000c 	ldr.w	r0, [r9, #12]
 800129c:	e00a      	b.n	80012b4 <ip_reass_remove_oldest_datagram+0x3c>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 800129e:	3701      	adds	r7, #1
        if (oldest == NULL) {
 80012a0:	b1c5      	cbz	r5, 80012d4 <ip_reass_remove_oldest_datagram+0x5c>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
 80012a2:	7fd9      	ldrb	r1, [r3, #31]
 80012a4:	7fea      	ldrb	r2, [r5, #31]
 80012a6:	4291      	cmp	r1, r2
 80012a8:	bf98      	it	ls
 80012aa:	461d      	movls	r5, r3
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
 80012ac:	681c      	ldr	r4, [r3, #0]
 80012ae:	b1ac      	cbz	r4, 80012dc <ip_reass_remove_oldest_datagram+0x64>
 80012b0:	4698      	mov	r8, r3
 80012b2:	4623      	mov	r3, r4
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 80012b4:	695a      	ldr	r2, [r3, #20]
 80012b6:	4282      	cmp	r2, r0
 80012b8:	d1f1      	bne.n	800129e <ip_reass_remove_oldest_datagram+0x26>
 80012ba:	f8d9 2010 	ldr.w	r2, [r9, #16]
 80012be:	6999      	ldr	r1, [r3, #24]
 80012c0:	4291      	cmp	r1, r2
 80012c2:	d1ec      	bne.n	800129e <ip_reass_remove_oldest_datagram+0x26>
 80012c4:	8999      	ldrh	r1, [r3, #12]
 80012c6:	f8b9 2004 	ldrh.w	r2, [r9, #4]
 80012ca:	4291      	cmp	r1, r2
 80012cc:	d0ee      	beq.n	80012ac <ip_reass_remove_oldest_datagram+0x34>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 80012ce:	3701      	adds	r7, #1
        if (oldest == NULL) {
 80012d0:	2d00      	cmp	r5, #0
 80012d2:	d1e6      	bne.n	80012a2 <ip_reass_remove_oldest_datagram+0x2a>
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
 80012d4:	681c      	ldr	r4, [r3, #0]
 80012d6:	461d      	mov	r5, r3
 80012d8:	2c00      	cmp	r4, #0
 80012da:	d1e9      	bne.n	80012b0 <ip_reass_remove_oldest_datagram+0x38>
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
 80012dc:	b355      	cbz	r5, 8001334 <ip_reass_remove_oldest_datagram+0xbc>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 80012de:	686e      	ldr	r6, [r5, #4]
 80012e0:	6873      	ldr	r3, [r6, #4]
  if (iprh->start == 0) {
 80012e2:	889a      	ldrh	r2, [r3, #4]
 80012e4:	2a00      	cmp	r2, #0
 80012e6:	d02f      	beq.n	8001348 <ip_reass_remove_oldest_datagram+0xd0>
  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 80012e8:	6873      	ldr	r3, [r6, #4]
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
 80012ea:	4630      	mov	r0, r6
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 80012ec:	f8d3 a000 	ldr.w	sl, [r3]
    clen = pbuf_clen(pcur);
 80012f0:	f002 ff80 	bl	80041f4 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 80012f4:	4404      	add	r4, r0
    pbuf_free(pcur);
 80012f6:	4630      	mov	r0, r6
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 80012f8:	4656      	mov	r6, sl
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 80012fa:	b2a4      	uxth	r4, r4
    pbuf_free(pcur);
 80012fc:	f002 ff4c 	bl	8004198 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 8001300:	2e00      	cmp	r6, #0
 8001302:	d1f1      	bne.n	80012e8 <ip_reass_remove_oldest_datagram+0x70>
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 8001304:	f8db 3000 	ldr.w	r3, [fp]
 8001308:	429d      	cmp	r5, r3
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 800130a:	bf08      	it	eq
 800130c:	4a1f      	ldreq	r2, [pc, #124]	; (800138c <ip_reass_remove_oldest_datagram+0x114>)
 800130e:	682b      	ldr	r3, [r5, #0]
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 8001310:	bf18      	it	ne
 8001312:	f8c8 3000 	strne.w	r3, [r8]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 8001316:	4629      	mov	r1, r5
 8001318:	f04f 0005 	mov.w	r0, #5
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 800131c:	bf08      	it	eq
 800131e:	6013      	streq	r3, [r2, #0]
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 8001320:	f002 fc8e 	bl	8003c40 <memp_free>
      }
      r = r->next;
    }
    if (oldest != NULL) {
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
      pbufs_freed += pbufs_freed_current;
 8001324:	9a00      	ldr	r2, [sp, #0]
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 8001326:	4b1a      	ldr	r3, [pc, #104]	; (8001390 <ip_reass_remove_oldest_datagram+0x118>)
      }
      r = r->next;
    }
    if (oldest != NULL) {
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
      pbufs_freed += pbufs_freed_current;
 8001328:	4422      	add	r2, r4
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 800132a:	881b      	ldrh	r3, [r3, #0]
      }
      r = r->next;
    }
    if (oldest != NULL) {
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
      pbufs_freed += pbufs_freed_current;
 800132c:	9200      	str	r2, [sp, #0]
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 800132e:	4a18      	ldr	r2, [pc, #96]	; (8001390 <ip_reass_remove_oldest_datagram+0x118>)
 8001330:	1b1b      	subs	r3, r3, r4
 8001332:	8013      	strh	r3, [r2, #0]
    }
    if (oldest != NULL) {
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
      pbufs_freed += pbufs_freed_current;
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 8001334:	9b00      	ldr	r3, [sp, #0]
 8001336:	9a01      	ldr	r2, [sp, #4]
 8001338:	4293      	cmp	r3, r2
 800133a:	da01      	bge.n	8001340 <ip_reass_remove_oldest_datagram+0xc8>
 800133c:	2f01      	cmp	r7, #1
 800133e:	dca4      	bgt.n	800128a <ip_reass_remove_oldest_datagram+0x12>
  return pbufs_freed;
}
 8001340:	9800      	ldr	r0, [sp, #0]
 8001342:	b003      	add	sp, #12
 8001344:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
 8001348:	681a      	ldr	r2, [r3, #0]
 800134a:	606a      	str	r2, [r5, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 800134c:	462a      	mov	r2, r5
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 800134e:	2101      	movs	r1, #1
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 8001350:	f852 0f08 	ldr.w	r0, [r2, #8]!
 8001354:	6894      	ldr	r4, [r2, #8]
 8001356:	f8d2 e004 	ldr.w	lr, [r2, #4]
 800135a:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 800135e:	f8c3 c00c 	str.w	ip, [r3, #12]
 8001362:	609c      	str	r4, [r3, #8]
 8001364:	6018      	str	r0, [r3, #0]
 8001366:	f8c3 e004 	str.w	lr, [r3, #4]
 800136a:	6910      	ldr	r0, [r2, #16]
 800136c:	6118      	str	r0, [r3, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 800136e:	4630      	mov	r0, r6
 8001370:	f7ff fce0 	bl	8000d34 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 8001374:	4630      	mov	r0, r6
 8001376:	f002 ff3d 	bl	80041f4 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 800137a:	b284      	uxth	r4, r0
    pbuf_free(p);
 800137c:	4630      	mov	r0, r6
 800137e:	f002 ff0b 	bl	8004198 <pbuf_free>
 8001382:	686e      	ldr	r6, [r5, #4]
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 8001384:	2e00      	cmp	r6, #0
 8001386:	d1af      	bne.n	80012e8 <ip_reass_remove_oldest_datagram+0x70>
 8001388:	e7bc      	b.n	8001304 <ip_reass_remove_oldest_datagram+0x8c>
 800138a:	bf00      	nop
 800138c:	20000570 	.word	0x20000570
 8001390:	20000574 	.word	0x20000574

08001394 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 8001394:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
 8001398:	6846      	ldr	r6, [r0, #4]
 800139a:	7833      	ldrb	r3, [r6, #0]

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 800139c:	f003 030f 	and.w	r3, r3, #15
 80013a0:	2b05      	cmp	r3, #5
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 80013a2:	b085      	sub	sp, #20
 80013a4:	4607      	mov	r7, r0
  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 80013a6:	f040 8151 	bne.w	800164c <ip_reass+0x2b8>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 80013aa:	88f0      	ldrh	r0, [r6, #6]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 80013ac:	f8df 8310 	ldr.w	r8, [pc, #784]	; 80016c0 <ip_reass+0x32c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 80013b0:	f000 fa60 	bl	8001874 <lwip_ntohs>
 80013b4:	9001      	str	r0, [sp, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 80013b6:	8870      	ldrh	r0, [r6, #2]
 80013b8:	f000 fa5c 	bl	8001874 <lwip_ntohs>
 80013bc:	7833      	ldrb	r3, [r6, #0]
 80013be:	9302      	str	r3, [sp, #8]
 80013c0:	4683      	mov	fp, r0

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 80013c2:	4638      	mov	r0, r7
 80013c4:	f002 ff16 	bl	80041f4 <pbuf_clen>
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 80013c8:	f8b8 3000 	ldrh.w	r3, [r8]
 80013cc:	4403      	add	r3, r0
 80013ce:	2b0a      	cmp	r3, #10

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 80013d0:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 80013d2:	f300 8130 	bgt.w	8001636 <ip_reass+0x2a2>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 80013d6:	f8df a2e4 	ldr.w	sl, [pc, #740]	; 80016bc <ip_reass+0x328>
 80013da:	f8da 4000 	ldr.w	r4, [sl]
 80013de:	2c00      	cmp	r4, #0
 80013e0:	f000 80e2 	beq.w	80015a8 <ip_reass+0x214>
 80013e4:	68f2      	ldr	r2, [r6, #12]
 80013e6:	2500      	movs	r5, #0
 80013e8:	e005      	b.n	80013f6 <ip_reass+0x62>
 80013ea:	6823      	ldr	r3, [r4, #0]
 80013ec:	4625      	mov	r5, r4
 80013ee:	2b00      	cmp	r3, #0
 80013f0:	f000 80da 	beq.w	80015a8 <ip_reass+0x214>
 80013f4:	461c      	mov	r4, r3
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 80013f6:	6963      	ldr	r3, [r4, #20]
 80013f8:	4293      	cmp	r3, r2
 80013fa:	d1f6      	bne.n	80013ea <ip_reass+0x56>
 80013fc:	6933      	ldr	r3, [r6, #16]
 80013fe:	69a1      	ldr	r1, [r4, #24]
 8001400:	4299      	cmp	r1, r3
 8001402:	d1f2      	bne.n	80013ea <ip_reass+0x56>
 8001404:	89a1      	ldrh	r1, [r4, #12]
 8001406:	88b3      	ldrh	r3, [r6, #4]
 8001408:	4299      	cmp	r1, r3
 800140a:	d1ee      	bne.n	80013ea <ip_reass+0x56>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 800140c:	88f0      	ldrh	r0, [r6, #6]
 800140e:	f000 fa31 	bl	8001874 <lwip_ntohs>
 8001412:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8001416:	2800      	cmp	r0, #0
 8001418:	f000 811f 	beq.w	800165a <ip_reass+0x2c6>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 800141c:	f8b8 3000 	ldrh.w	r3, [r8]
 8001420:	4499      	add	r9, r3
 8001422:	f8a8 9000 	strh.w	r9, [r8]

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 8001426:	88f3      	ldrh	r3, [r6, #6]
 8001428:	0699      	lsls	r1, r3, #26
 800142a:	f140 80e0 	bpl.w	80015ee <ip_reass+0x25a>
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 800142e:	687e      	ldr	r6, [r7, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8001430:	8870      	ldrh	r0, [r6, #2]
 8001432:	f000 fa1f 	bl	8001874 <lwip_ntohs>
 8001436:	f896 9000 	ldrb.w	r9, [r6]
 800143a:	f009 090f 	and.w	r9, r9, #15
 800143e:	eba0 0989 	sub.w	r9, r0, r9, lsl #2
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8001442:	88f0      	ldrh	r0, [r6, #6]
 8001444:	f000 fa16 	bl	8001874 <lwip_ntohs>
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 8001448:	f8d7 c004 	ldr.w	ip, [r7, #4]
  iprh->next_pbuf = NULL;
 800144c:	2300      	movs	r3, #0
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800144e:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8001452:	00c0      	lsls	r0, r0, #3
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8001454:	fa1f f989 	uxth.w	r9, r9
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
 8001458:	f88c 3000 	strb.w	r3, [ip]
 800145c:	f88c 3001 	strb.w	r3, [ip, #1]
 8001460:	f88c 3002 	strb.w	r3, [ip, #2]
 8001464:	f88c 3003 	strb.w	r3, [ip, #3]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 8001468:	6863      	ldr	r3, [r4, #4]
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
 800146a:	f8ac 0004 	strh.w	r0, [ip, #4]
  iprh->end = offset + len;
 800146e:	4481      	add	r9, r0
 8001470:	fa1f f989 	uxth.w	r9, r9
 8001474:	f8ac 9006 	strh.w	r9, [ip, #6]

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 8001478:	2b00      	cmp	r3, #0
 800147a:	f000 8119 	beq.w	80016b0 <ip_reass+0x31c>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 800147e:	f8d3 b004 	ldr.w	fp, [r3, #4]
    if (iprh->start < iprh_tmp->start) {
 8001482:	f8bb 2004 	ldrh.w	r2, [fp, #4]
 8001486:	4290      	cmp	r0, r2
 8001488:	f0c0 80ff 	bcc.w	800168a <ip_reass+0x2f6>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
 800148c:	f000 80c4 	beq.w	8001618 <ip_reass+0x284>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 8001490:	f8bb 6006 	ldrh.w	r6, [fp, #6]
 8001494:	42b0      	cmp	r0, r6
 8001496:	f0c0 80bf 	bcc.w	8001618 <ip_reass+0x284>
 800149a:	f04f 0e01 	mov.w	lr, #1
 800149e:	e010      	b.n	80014c2 <ip_reass+0x12e>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 80014a0:	6853      	ldr	r3, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 80014a2:	8899      	ldrh	r1, [r3, #4]
 80014a4:	4288      	cmp	r0, r1
 80014a6:	f0c0 80b1 	bcc.w	800160c <ip_reass+0x278>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
 80014aa:	f000 80b5 	beq.w	8001618 <ip_reass+0x284>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 80014ae:	88da      	ldrh	r2, [r3, #6]
 80014b0:	4290      	cmp	r0, r2
 80014b2:	f0c0 80b1 	bcc.w	8001618 <ip_reass+0x284>
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 80014b6:	42b1      	cmp	r1, r6
 80014b8:	bf18      	it	ne
 80014ba:	f04f 0e00 	movne.w	lr, #0
 80014be:	469b      	mov	fp, r3
 80014c0:	4616      	mov	r6, r2
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 80014c2:	f8db 2000 	ldr.w	r2, [fp]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 80014c6:	2a00      	cmp	r2, #0
 80014c8:	d1ea      	bne.n	80014a0 <ip_reass+0x10c>
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
      if (iprh_prev->end != iprh->start) {
 80014ca:	42b0      	cmp	r0, r6
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 80014cc:	f8cb 7000 	str.w	r7, [fp]
      if (iprh_prev->end != iprh->start) {
 80014d0:	f040 80ad 	bne.w	800162e <ip_reass+0x29a>
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 80014d4:	7fa3      	ldrb	r3, [r4, #30]
 80014d6:	07db      	lsls	r3, r3, #31
 80014d8:	f140 80a9 	bpl.w	800162e <ip_reass+0x29a>
    /* and had no wholes so far */
    if (valid) {
 80014dc:	f1be 0f00 	cmp.w	lr, #0
 80014e0:	f000 80a5 	beq.w	800162e <ip_reass+0x29a>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 80014e4:	6863      	ldr	r3, [r4, #4]
 80014e6:	685f      	ldr	r7, [r3, #4]
 80014e8:	88bb      	ldrh	r3, [r7, #4]
 80014ea:	2b00      	cmp	r3, #0
 80014ec:	f040 809f 	bne.w	800162e <ip_reass+0x29a>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
 80014f0:	f8dc 3000 	ldr.w	r3, [ip]
        while (q != NULL) {
 80014f4:	b173      	cbz	r3, 8001514 <ip_reass+0x180>
          iprh = (struct ip_reass_helper*)q->payload;
 80014f6:	685b      	ldr	r3, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 80014f8:	889a      	ldrh	r2, [r3, #4]
 80014fa:	454a      	cmp	r2, r9
 80014fc:	d007      	beq.n	800150e <ip_reass+0x17a>
 80014fe:	e096      	b.n	800162e <ip_reass+0x29a>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
 8001500:	6852      	ldr	r2, [r2, #4]
          if (iprh_prev->end != iprh->start) {
 8001502:	88d9      	ldrh	r1, [r3, #6]
 8001504:	8893      	ldrh	r3, [r2, #4]
 8001506:	4299      	cmp	r1, r3
 8001508:	f040 8091 	bne.w	800162e <ip_reass+0x29a>
 800150c:	4613      	mov	r3, r2
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
 800150e:	681a      	ldr	r2, [r3, #0]
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 8001510:	2a00      	cmp	r2, #0
 8001512:	d1f5      	bne.n	8001500 <ip_reass+0x16c>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 8001514:	8ba2      	ldrh	r2, [r4, #28]

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 8001516:	683e      	ldr	r6, [r7, #0]

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8001518:	4623      	mov	r3, r4
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 800151a:	3214      	adds	r2, #20
 800151c:	83a2      	strh	r2, [r4, #28]
    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800151e:	f853 2f08 	ldr.w	r2, [r3, #8]!
 8001522:	6858      	ldr	r0, [r3, #4]
 8001524:	6899      	ldr	r1, [r3, #8]
 8001526:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 800152a:	f8c7 e00c 	str.w	lr, [r7, #12]
 800152e:	60b9      	str	r1, [r7, #8]
 8001530:	6078      	str	r0, [r7, #4]
 8001532:	603a      	str	r2, [r7, #0]
 8001534:	691a      	ldr	r2, [r3, #16]
 8001536:	613a      	str	r2, [r7, #16]
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 8001538:	8ba0      	ldrh	r0, [r4, #28]
 800153a:	f000 f997 	bl	800186c <lwip_htons>
    IPH_OFFSET_SET(fraghdr, 0);
 800153e:	2300      	movs	r3, #0
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 8001540:	8078      	strh	r0, [r7, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 8001542:	71bb      	strb	r3, [r7, #6]
 8001544:	71fb      	strb	r3, [r7, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 8001546:	72bb      	strb	r3, [r7, #10]
 8001548:	72fb      	strb	r3, [r7, #11]
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 800154a:	2114      	movs	r1, #20
 800154c:	4638      	mov	r0, r7
 800154e:	f7ff fc3d 	bl	8000dcc <inet_chksum>

    p = ipr->p;
 8001552:	f8d4 9004 	ldr.w	r9, [r4, #4]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    IPH_OFFSET_SET(fraghdr, 0);
    IPH_CHKSUM_SET(fraghdr, 0);
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 8001556:	8178      	strh	r0, [r7, #10]

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 8001558:	b166      	cbz	r6, 8001574 <ip_reass+0x1e0>
      iprh = (struct ip_reass_helper*)r->payload;
 800155a:	6877      	ldr	r7, [r6, #4]

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 800155c:	f06f 0113 	mvn.w	r1, #19
 8001560:	4630      	mov	r0, r6
 8001562:	f002 fde3 	bl	800412c <pbuf_header>
      pbuf_cat(p, r);
 8001566:	4631      	mov	r1, r6
 8001568:	4648      	mov	r0, r9
 800156a:	f002 fe53 	bl	8004214 <pbuf_cat>
      r = iprh->next_pbuf;
 800156e:	683e      	ldr	r6, [r7, #0]
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 8001570:	2e00      	cmp	r6, #0
 8001572:	d1f2      	bne.n	800155a <ip_reass+0x1c6>
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 8001574:	f8da 3000 	ldr.w	r3, [sl]
 8001578:	4a50      	ldr	r2, [pc, #320]	; (80016bc <ip_reass+0x328>)
 800157a:	429c      	cmp	r4, r3
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 800157c:	6823      	ldr	r3, [r4, #0]
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 800157e:	bf18      	it	ne
 8001580:	602b      	strne	r3, [r5, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 8001582:	4621      	mov	r1, r4
 8001584:	f04f 0005 	mov.w	r0, #5
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 8001588:	bf08      	it	eq
 800158a:	6013      	streq	r3, [r2, #0]
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800158c:	f002 fb58 	bl	8003c40 <memp_free>
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 8001590:	4648      	mov	r0, r9
 8001592:	f002 fe2f 	bl	80041f4 <pbuf_clen>
 8001596:	f8b8 3000 	ldrh.w	r3, [r8]
 800159a:	1a1b      	subs	r3, r3, r0

    /* Return the pbuf chain */
    return p;
 800159c:	4648      	mov	r0, r9
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 800159e:	f8a8 3000 	strh.w	r3, [r8]
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
 80015a2:	b005      	add	sp, #20
 80015a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 80015a8:	2005      	movs	r0, #5
 80015aa:	f002 fb37 	bl	8003c1c <memp_malloc>
  if (ipr == NULL) {
 80015ae:	4603      	mov	r3, r0
 80015b0:	2800      	cmp	r0, #0
 80015b2:	d070      	beq.n	8001696 <ip_reass+0x302>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 80015b4:	2220      	movs	r2, #32
 80015b6:	2100      	movs	r1, #0
 80015b8:	4618      	mov	r0, r3
 80015ba:	9303      	str	r3, [sp, #12]
 80015bc:	f009 ffb6 	bl	800b52c <memset>
  ipr->timer = IP_REASS_MAXAGE;
 80015c0:	9b03      	ldr	r3, [sp, #12]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 80015c2:	f8da 2000 	ldr.w	r2, [sl]
 80015c6:	601a      	str	r2, [r3, #0]
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;
 80015c8:	2103      	movs	r1, #3
 80015ca:	77d9      	strb	r1, [r3, #31]
  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  reassdatagrams = ipr;
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 80015cc:	6831      	ldr	r1, [r6, #0]
 80015ce:	68b5      	ldr	r5, [r6, #8]
 80015d0:	f8d6 e004 	ldr.w	lr, [r6, #4]
 80015d4:	68f0      	ldr	r0, [r6, #12]
 80015d6:	6158      	str	r0, [r3, #20]
 80015d8:	611d      	str	r5, [r3, #16]
 80015da:	6099      	str	r1, [r3, #8]
 80015dc:	f8c3 e00c 	str.w	lr, [r3, #12]
 80015e0:	6931      	ldr	r1, [r6, #16]
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  reassdatagrams = ipr;
 80015e2:	f8ca 3000 	str.w	r3, [sl]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 80015e6:	4625      	mov	r5, r4
 80015e8:	6199      	str	r1, [r3, #24]
 80015ea:	461c      	mov	r4, r3
 80015ec:	e716      	b.n	800141c <ip_reass+0x88>
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
 80015ee:	9b02      	ldr	r3, [sp, #8]
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 80015f0:	7fa2      	ldrb	r2, [r4, #30]
    ipr->datagram_len = offset + len;
 80015f2:	f003 030f 	and.w	r3, r3, #15
 80015f6:	ebab 0b83 	sub.w	fp, fp, r3, lsl #2
 80015fa:	9b01      	ldr	r3, [sp, #4]
 80015fc:	eb0b 0bc3 	add.w	fp, fp, r3, lsl #3
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8001600:	f042 0301 	orr.w	r3, r2, #1
    ipr->datagram_len = offset + len;
 8001604:	f8a4 b01c 	strh.w	fp, [r4, #28]
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8001608:	77a3      	strb	r3, [r4, #30]
 800160a:	e710      	b.n	800142e <ip_reass+0x9a>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
      if (iprh_prev != NULL) {
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 800160c:	42b0      	cmp	r0, r6
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 800160e:	f8cc 2000 	str.w	r2, [ip]
      if (iprh_prev != NULL) {
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 8001612:	d301      	bcc.n	8001618 <ip_reass+0x284>
 8001614:	4589      	cmp	r9, r1
 8001616:	d935      	bls.n	8001684 <ip_reass+0x2f0>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 8001618:	4638      	mov	r0, r7
 800161a:	f002 fdeb 	bl	80041f4 <pbuf_clen>
 800161e:	f8b8 3000 	ldrh.w	r3, [r8]
 8001622:	1a1b      	subs	r3, r3, r0
  pbuf_free(new_p);
 8001624:	4638      	mov	r0, r7
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 8001626:	f8a8 3000 	strh.w	r3, [r8]
  pbuf_free(new_p);
 800162a:	f002 fdb5 	bl	8004198 <pbuf_free>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 800162e:	2000      	movs	r0, #0
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
 8001630:	b005      	add	sp, #20
 8001632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8001636:	4601      	mov	r1, r0
 8001638:	4630      	mov	r0, r6
 800163a:	f7ff fe1d 	bl	8001278 <ip_reass_remove_oldest_datagram>
 800163e:	b128      	cbz	r0, 800164c <ip_reass+0x2b8>
 8001640:	f8b8 3000 	ldrh.w	r3, [r8]
 8001644:	444b      	add	r3, r9
 8001646:	2b0a      	cmp	r3, #10
 8001648:	f77f aec5 	ble.w	80013d6 <ip_reass+0x42>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
 800164c:	4638      	mov	r0, r7
 800164e:	f002 fda3 	bl	8004198 <pbuf_free>
  return NULL;
 8001652:	2000      	movs	r0, #0
}
 8001654:	b005      	add	sp, #20
 8001656:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 800165a:	89e0      	ldrh	r0, [r4, #14]
 800165c:	f000 f90a 	bl	8001874 <lwip_ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 8001660:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8001664:	2800      	cmp	r0, #0
 8001666:	f43f aed9 	beq.w	800141c <ip_reass+0x88>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 800166a:	6832      	ldr	r2, [r6, #0]
 800166c:	f8d6 e004 	ldr.w	lr, [r6, #4]
 8001670:	68b0      	ldr	r0, [r6, #8]
 8001672:	68f1      	ldr	r1, [r6, #12]
 8001674:	6161      	str	r1, [r4, #20]
 8001676:	60a2      	str	r2, [r4, #8]
 8001678:	f8c4 e00c 	str.w	lr, [r4, #12]
 800167c:	6120      	str	r0, [r4, #16]
 800167e:	6932      	ldr	r2, [r6, #16]
 8001680:	61a2      	str	r2, [r4, #24]
 8001682:	e6cb      	b.n	800141c <ip_reass+0x88>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 8001684:	f8cb 7000 	str.w	r7, [fp]
 8001688:	e724      	b.n	80014d4 <ip_reass+0x140>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 800168a:	f8cc 3000 	str.w	r3, [ip]
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
 800168e:	f04f 0e01 	mov.w	lr, #1
 8001692:	6067      	str	r7, [r4, #4]
 8001694:	e71e      	b.n	80014d4 <ip_reass+0x140>
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
  if (ipr == NULL) {
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8001696:	4649      	mov	r1, r9
 8001698:	4630      	mov	r0, r6
 800169a:	f7ff fded 	bl	8001278 <ip_reass_remove_oldest_datagram>
 800169e:	4581      	cmp	r9, r0
 80016a0:	dcd4      	bgt.n	800164c <ip_reass+0x2b8>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 80016a2:	2005      	movs	r0, #5
 80016a4:	f002 faba 	bl	8003c1c <memp_malloc>
    }
    if (ipr == NULL)
 80016a8:	4603      	mov	r3, r0
 80016aa:	2800      	cmp	r0, #0
 80016ac:	d182      	bne.n	80015b4 <ip_reass+0x220>
 80016ae:	e7cd      	b.n	800164c <ip_reass+0x2b8>
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 80016b0:	7fa3      	ldrb	r3, [r4, #30]
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 80016b2:	6067      	str	r7, [r4, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 80016b4:	07da      	lsls	r2, r3, #31
 80016b6:	f53f af15 	bmi.w	80014e4 <ip_reass+0x150>
 80016ba:	e7b8      	b.n	800162e <ip_reass+0x29a>
 80016bc:	20000570 	.word	0x20000570
 80016c0:	20000574 	.word	0x20000574

080016c4 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 80016c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80016c8:	b08f      	sub	sp, #60	; 0x3c

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
 80016ca:	f8d0 a004 	ldr.w	sl, [r0, #4]
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 80016ce:	910b      	str	r1, [sp, #44]	; 0x2c
 80016d0:	4605      	mov	r5, r0
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 80016d2:	f8ba 0006 	ldrh.w	r0, [sl, #6]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 80016d6:	8d0c      	ldrh	r4, [r1, #40]	; 0x28
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 80016d8:	920c      	str	r2, [sp, #48]	; 0x30
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 80016da:	f000 f8cb 	bl	8001874 <lwip_ntohs>
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
 80016de:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
 80016e2:	b29b      	uxth	r3, r3

  left = p->tot_len - IP_HLEN;
 80016e4:	f8b5 9008 	ldrh.w	r9, [r5, #8]
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
 80016e8:	9309      	str	r3, [sp, #36]	; 0x24
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
 80016ea:	f3c0 030c 	ubfx	r3, r0, #0, #13
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
 80016ee:	f1a9 0914 	sub.w	r9, r9, #20
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
 80016f2:	9304      	str	r3, [sp, #16]
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
 80016f4:	f1b4 0314 	subs.w	r3, r4, #20
  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
 80016f8:	fa1f f289 	uxth.w	r2, r9

  nfb = (mtu - IP_HLEN) / 8;
 80016fc:	bf48      	it	mi
 80016fe:	f1a4 030d 	submi.w	r3, r4, #13
 8001702:	f3c3 03cf 	ubfx	r3, r3, #3, #16
  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
 8001706:	9203      	str	r2, [sp, #12]

  nfb = (mtu - IP_HLEN) / 8;
 8001708:	9308      	str	r3, [sp, #32]

  while (left) {
 800170a:	9b03      	ldr	r3, [sp, #12]
 800170c:	2b00      	cmp	r3, #0
 800170e:	f000 80a8 	beq.w	8001862 <ip_frag+0x19e>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 8001712:	9b08      	ldr	r3, [sp, #32]
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
      pcr->original = p;
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 8001714:	f8df b150 	ldr.w	fp, [pc, #336]	; 8001868 <ip_frag+0x1a4>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 8001718:	00db      	lsls	r3, r3, #3
 800171a:	f1a4 0213 	sub.w	r2, r4, #19
 800171e:	b29b      	uxth	r3, r3
 8001720:	920a      	str	r2, [sp, #40]	; 0x28
 8001722:	930d      	str	r3, [sp, #52]	; 0x34
 8001724:	2400      	movs	r4, #0
 8001726:	2614      	movs	r6, #20
 8001728:	4611      	mov	r1, r2

  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 800172a:	9b04      	ldr	r3, [sp, #16]
 800172c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800172e:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8001732:	4313      	orrs	r3, r2
    if (!last) {
 8001734:	9a03      	ldr	r2, [sp, #12]

  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 8001736:	9306      	str	r3, [sp, #24]
    if (!last) {
 8001738:	428a      	cmp	r2, r1
      tmp = tmp | IP_MF;
 800173a:	bfaa      	itet	ge
 800173c:	f443 5300 	orrge.w	r3, r3, #8192	; 0x2000
 8001740:	4613      	movlt	r3, r2
 8001742:	9306      	strge	r3, [sp, #24]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 8001744:	f04f 0200 	mov.w	r2, #0
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 8001748:	bfa8      	it	ge
 800174a:	9b0d      	ldrge	r3, [sp, #52]	; 0x34
 800174c:	9305      	str	r3, [sp, #20]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 800174e:	2114      	movs	r1, #20
 8001750:	2002      	movs	r0, #2
 8001752:	f002 fbc9 	bl	8003ee8 <pbuf_alloc>
    if (rambuf == NULL) {
 8001756:	4680      	mov	r8, r0
 8001758:	2800      	cmp	r0, #0
 800175a:	d07f      	beq.n	800185c <ip_frag+0x198>
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 800175c:	6843      	ldr	r3, [r0, #4]
 800175e:	f8da 2000 	ldr.w	r2, [sl]
 8001762:	f8da 1008 	ldr.w	r1, [sl, #8]
 8001766:	f8da 0004 	ldr.w	r0, [sl, #4]
 800176a:	f8da 700c 	ldr.w	r7, [sl, #12]
 800176e:	60df      	str	r7, [r3, #12]
 8001770:	601a      	str	r2, [r3, #0]
 8001772:	6058      	str	r0, [r3, #4]
 8001774:	6099      	str	r1, [r3, #8]
 8001776:	f8da 2010 	ldr.w	r2, [sl, #16]
 800177a:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 800177c:	686a      	ldr	r2, [r5, #4]
    p->len -= poff;
 800177e:	896b      	ldrh	r3, [r5, #10]
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    iphdr = (struct ip_hdr *)rambuf->payload;
 8001780:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8001784:	9107      	str	r1, [sp, #28]

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;
 8001786:	1b9b      	subs	r3, r3, r6
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    iphdr = (struct ip_hdr *)rambuf->payload;

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 8001788:	4416      	add	r6, r2
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
 800178a:	9a05      	ldr	r2, [sp, #20]
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    iphdr = (struct ip_hdr *)rambuf->payload;

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 800178c:	606e      	str	r6, [r5, #4]
    p->len -= poff;
 800178e:	b29b      	uxth	r3, r3
 8001790:	816b      	strh	r3, [r5, #10]

    left_to_copy = cop;
    while (left_to_copy) {
 8001792:	b352      	cbz	r2, 80017ea <ip_frag+0x126>
 8001794:	4616      	mov	r6, r2
 8001796:	461c      	mov	r4, r3
 8001798:	e001      	b.n	800179e <ip_frag+0xda>
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
        p = p->next;
 800179a:	682d      	ldr	r5, [r5, #0]
 800179c:	896c      	ldrh	r4, [r5, #10]
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
      struct pbuf_custom_ref *pcr;
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
 800179e:	42b4      	cmp	r4, r6
 80017a0:	bf28      	it	cs
 80017a2:	4634      	movcs	r4, r6
 80017a4:	b2a4      	uxth	r4, r4
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
 80017a6:	2c00      	cmp	r4, #0
 80017a8:	d0f7      	beq.n	800179a <ip_frag+0xd6>
#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref*
ip_frag_alloc_pbuf_custom_ref(void)
{
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 80017aa:	2006      	movs	r0, #6
 80017ac:	f002 fa36 	bl	8003c1c <memp_malloc>
      if (pcr == NULL) {
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 80017b0:	2202      	movs	r2, #2
      if (!newpbuflen) {
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
      if (pcr == NULL) {
 80017b2:	4607      	mov	r7, r0
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 80017b4:	4603      	mov	r3, r0
 80017b6:	4621      	mov	r1, r4
      if (!newpbuflen) {
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
      if (pcr == NULL) {
 80017b8:	2800      	cmp	r0, #0
 80017ba:	d047      	beq.n	800184c <ip_frag+0x188>
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 80017bc:	9401      	str	r4, [sp, #4]
 80017be:	6868      	ldr	r0, [r5, #4]
 80017c0:	9000      	str	r0, [sp, #0]
 80017c2:	2003      	movs	r0, #3
 80017c4:	f002 fc3e 	bl	8004044 <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 80017c8:	4681      	mov	r9, r0
 80017ca:	2800      	cmp	r0, #0
 80017cc:	d03a      	beq.n	8001844 <ip_frag+0x180>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
 80017ce:	4628      	mov	r0, r5

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
      left_to_copy -= newpbuflen;
 80017d0:	1b36      	subs	r6, r6, r4
      if (newpbuf == NULL) {
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
 80017d2:	f002 fd19 	bl	8004208 <pbuf_ref>

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
      left_to_copy -= newpbuflen;
 80017d6:	b2b6      	uxth	r6, r6
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
      pcr->original = p;
 80017d8:	617d      	str	r5, [r7, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 80017da:	f8c7 b010 	str.w	fp, [r7, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 80017de:	4649      	mov	r1, r9
 80017e0:	4640      	mov	r0, r8
 80017e2:	f002 fd17 	bl	8004214 <pbuf_cat>
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
 80017e6:	2e00      	cmp	r6, #0
 80017e8:	d1d7      	bne.n	800179a <ip_frag+0xd6>
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 80017ea:	9806      	ldr	r0, [sp, #24]
 80017ec:	f000 f83e 	bl	800186c <lwip_htons>
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 80017f0:	9f05      	ldr	r7, [sp, #20]
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 80017f2:	9e07      	ldr	r6, [sp, #28]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 80017f4:	463b      	mov	r3, r7
 80017f6:	3314      	adds	r3, #20
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 80017f8:	80f0      	strh	r0, [r6, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 80017fa:	b298      	uxth	r0, r3
 80017fc:	f000 f836 	bl	800186c <lwip_htons>
    IPH_CHKSUM_SET(iphdr, 0);
 8001800:	2300      	movs	r3, #0
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 8001802:	8070      	strh	r0, [r6, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 8001804:	72b3      	strb	r3, [r6, #10]
 8001806:	72f3      	strb	r3, [r6, #11]
 8001808:	4630      	mov	r0, r6
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800180a:	2114      	movs	r1, #20
 800180c:	f7ff fade 	bl	8000dcc <inet_chksum>
 8001810:	46b1      	mov	r9, r6
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 8001812:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8001814:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8001816:	6973      	ldr	r3, [r6, #20]

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 8001818:	f8a9 000a 	strh.w	r0, [r9, #10]
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 800181c:	4641      	mov	r1, r8
 800181e:	4630      	mov	r0, r6
 8001820:	4798      	blx	r3
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
 8001822:	4640      	mov	r0, r8
 8001824:	f002 fcb8 	bl	8004198 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 8001828:	9a03      	ldr	r2, [sp, #12]
    ofo += nfb;
 800182a:	9908      	ldr	r1, [sp, #32]
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 800182c:	1bd3      	subs	r3, r2, r7
 800182e:	b29b      	uxth	r3, r3
 8001830:	461a      	mov	r2, r3
 8001832:	9303      	str	r3, [sp, #12]
    ofo += nfb;
 8001834:	9b04      	ldr	r3, [sp, #16]
 8001836:	440b      	add	r3, r1
 8001838:	b29b      	uxth	r3, r3
 800183a:	9304      	str	r3, [sp, #16]

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
 800183c:	b18a      	cbz	r2, 8001862 <ip_frag+0x19e>
 800183e:	4626      	mov	r6, r4
 8001840:	990a      	ldr	r1, [sp, #40]	; 0x28
 8001842:	e772      	b.n	800172a <ip_frag+0x66>
/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
 8001844:	4639      	mov	r1, r7
 8001846:	2006      	movs	r0, #6
 8001848:	f002 f9fa 	bl	8003c40 <memp_free>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
      if (newpbuf == NULL) {
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
 800184c:	4640      	mov	r0, r8
 800184e:	f002 fca3 	bl	8004198 <pbuf_free>
        return ERR_MEM;
 8001852:	f04f 30ff 	mov.w	r0, #4294967295
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
 8001856:	b00f      	add	sp, #60	; 0x3c
 8001858:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    if (rambuf == NULL) {
      return ERR_MEM;
 800185c:	f04f 30ff 	mov.w	r0, #4294967295
 8001860:	e7f9      	b.n	8001856 <ip_frag+0x192>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
 8001862:	2000      	movs	r0, #0
 8001864:	e7f7      	b.n	8001856 <ip_frag+0x192>
 8001866:	bf00      	nop
 8001868:	08001261 	.word	0x08001261

0800186c <lwip_htons>:
 800186c:	ba40      	rev16	r0, r0
 800186e:	b280      	uxth	r0, r0
 8001870:	4770      	bx	lr
 8001872:	bf00      	nop

08001874 <lwip_ntohs>:
 * @return n in host byte order
 */
u16_t
lwip_ntohs(u16_t n)
{
  return lwip_htons(n);
 8001874:	ba40      	rev16	r0, r0
}
 8001876:	b280      	uxth	r0, r0
 8001878:	4770      	bx	lr
 800187a:	bf00      	nop

0800187c <lwip_htonl>:
 800187c:	ba00      	rev	r0, r0
 800187e:	4770      	bx	lr

08001880 <lwip_ntohl>:
 */
u32_t
lwip_ntohl(u32_t n)
{
  return lwip_htonl(n);
}
 8001880:	ba00      	rev	r0, r0
 8001882:	4770      	bx	lr

08001884 <dhcp_bind>:
dhcp_bind(struct netif *netif)
{
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
 8001884:	2800      	cmp	r0, #0
 8001886:	d064      	beq.n	8001952 <dhcp_bind+0xce>
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
 8001888:	b530      	push	{r4, r5, lr}
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  dhcp = netif->dhcp;
 800188a:	6a44      	ldr	r4, [r0, #36]	; 0x24
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
 800188c:	b083      	sub	sp, #12
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  dhcp = netif->dhcp;
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
 800188e:	2c00      	cmp	r4, #0
 8001890:	d044      	beq.n	800191c <dhcp_bind+0x98>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
 8001892:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001894:	1c5a      	adds	r2, r3, #1
 8001896:	d00a      	beq.n	80018ae <dhcp_bind+0x2a>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 8001898:	4a36      	ldr	r2, [pc, #216]	; (8001974 <dhcp_bind+0xf0>)
 800189a:	331e      	adds	r3, #30
 800189c:	fba2 2303 	umull	r2, r3, r2, r3
 80018a0:	095b      	lsrs	r3, r3, #5
    if(timeout > 0xffff) {
 80018a2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80018a6:	d23b      	bcs.n	8001920 <dhcp_bind+0x9c>
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
    if (dhcp->t1_timeout == 0) {
 80018a8:	b903      	cbnz	r3, 80018ac <dhcp_bind+0x28>
      dhcp->t1_timeout = 1;
 80018aa:	2301      	movs	r3, #1
 80018ac:	83a3      	strh	r3, [r4, #28]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
 80018ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80018b0:	1c5d      	adds	r5, r3, #1
 80018b2:	d050      	beq.n	8001956 <dhcp_bind+0xd2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 80018b4:	4a2f      	ldr	r2, [pc, #188]	; (8001974 <dhcp_bind+0xf0>)
 80018b6:	331e      	adds	r3, #30
 80018b8:	fba2 2303 	umull	r2, r3, r2, r3
 80018bc:	095b      	lsrs	r3, r3, #5
    if(timeout > 0xffff) {
 80018be:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80018c2:	d242      	bcs.n	800194a <dhcp_bind+0xc6>
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
    if (dhcp->t2_timeout == 0) {
 80018c4:	2b00      	cmp	r3, #0
 80018c6:	d145      	bne.n	8001954 <dhcp_bind+0xd0>
      dhcp->t2_timeout = 1;
 80018c8:	2301      	movs	r3, #1
 80018ca:	83e3      	strh	r3, [r4, #30]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
 80018cc:	8ba2      	ldrh	r2, [r4, #28]
 80018ce:	429a      	cmp	r2, r3
 80018d0:	d22f      	bcs.n	8001932 <dhcp_bind+0xae>
    dhcp->t1_timeout = 0;
  }

  if (dhcp->subnet_mask_given) {
 80018d2:	7ba3      	ldrb	r3, [r4, #14]
 80018d4:	2b00      	cmp	r3, #0
 80018d6:	d031      	beq.n	800193c <dhcp_bind+0xb8>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
 80018d8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80018da:	9300      	str	r3, [sp, #0]
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    }
  }

  ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
 80018dc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80018de:	9201      	str	r2, [sp, #4]
  /* gateway address not given? */
  if (ip_addr_isany(&gw_addr)) {
 80018e0:	b922      	cbnz	r2, 80018ec <dhcp_bind+0x68>
    /* copy network address */
    ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
 80018e2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80018e4:	4013      	ands	r3, r2
 80018e6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80018ea:	9301      	str	r3, [sp, #4]
 80018ec:	4605      	mov	r5, r0
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
 80018ee:	f104 0124 	add.w	r1, r4, #36	; 0x24
 80018f2:	f002 fa65 	bl	8003dc0 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&sn_mask)));
  netif_set_netmask(netif, &sn_mask);
 80018f6:	4669      	mov	r1, sp
 80018f8:	4628      	mov	r0, r5
 80018fa:	f002 fa99 	bl	8003e30 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&gw_addr)));
  netif_set_gw(netif, &gw_addr);
 80018fe:	a901      	add	r1, sp, #4
 8001900:	4628      	mov	r0, r5
 8001902:	f002 fa91 	bl	8003e28 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
 8001906:	4628      	mov	r0, r5
 8001908:	f002 fa9c 	bl	8003e44 <netif_set_up>
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 800190c:	7b23      	ldrb	r3, [r4, #12]
 800190e:	2b0a      	cmp	r3, #10
 8001910:	d004      	beq.n	800191c <dhcp_bind+0x98>
    dhcp->state = new_state;
    dhcp->tries = 0;
 8001912:	2300      	movs	r3, #0
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 8001914:	220a      	movs	r2, #10
 8001916:	7322      	strb	r2, [r4, #12]
    dhcp->tries = 0;
 8001918:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 800191a:	8363      	strh	r3, [r4, #26]
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
 800191c:	b003      	add	sp, #12
 800191e:	bd30      	pop	{r4, r5, pc}
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
 8001920:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
 8001922:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001926:	83a2      	strh	r2, [r4, #28]
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
 8001928:	1c5a      	adds	r2, r3, #1
 800192a:	d1c3      	bne.n	80018b4 <dhcp_bind+0x30>
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
 800192c:	8be3      	ldrh	r3, [r4, #30]
 800192e:	2b00      	cmp	r3, #0
 8001930:	d0cf      	beq.n	80018d2 <dhcp_bind+0x4e>
    dhcp->t1_timeout = 0;
 8001932:	2300      	movs	r3, #0
 8001934:	83a3      	strh	r3, [r4, #28]
  }

  if (dhcp->subnet_mask_given) {
 8001936:	7ba3      	ldrb	r3, [r4, #14]
 8001938:	2b00      	cmp	r3, #0
 800193a:	d1cd      	bne.n	80018d8 <dhcp_bind+0x54>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
 800193c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    if (first_octet <= 127) {
 8001940:	0619      	lsls	r1, r3, #24
 8001942:	d40f      	bmi.n	8001964 <dhcp_bind+0xe0>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
 8001944:	23ff      	movs	r3, #255	; 0xff
 8001946:	9300      	str	r3, [sp, #0]
 8001948:	e7c8      	b.n	80018dc <dhcp_bind+0x58>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
 800194a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800194e:	83e3      	strh	r3, [r4, #30]
 8001950:	e7bc      	b.n	80018cc <dhcp_bind+0x48>
 8001952:	4770      	bx	lr
 8001954:	83e3      	strh	r3, [r4, #30]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
 8001956:	8be3      	ldrh	r3, [r4, #30]
 8001958:	8ba2      	ldrh	r2, [r4, #28]
 800195a:	429a      	cmp	r2, r3
 800195c:	d3b9      	bcc.n	80018d2 <dhcp_bind+0x4e>
 800195e:	2b00      	cmp	r3, #0
 8001960:	d0b7      	beq.n	80018d2 <dhcp_bind+0x4e>
 8001962:	e7e6      	b.n	8001932 <dhcp_bind+0xae>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    if (first_octet <= 127) {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    } else if (first_octet >= 192) {
 8001964:	2bbf      	cmp	r3, #191	; 0xbf
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
 8001966:	bf8c      	ite	hi
 8001968:	f06f 437f 	mvnhi.w	r3, #4278190080	; 0xff000000
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
 800196c:	f64f 73ff 	movwls	r3, #65535	; 0xffff
 8001970:	9300      	str	r3, [sp, #0]
 8001972:	e7b3      	b.n	80018dc <dhcp_bind+0x58>
 8001974:	88888889 	.word	0x88888889

08001978 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
 8001978:	b5f0      	push	{r4, r5, r6, r7, lr}
  struct dhcp *dhcp = netif->dhcp;
 800197a:	6a44      	ldr	r4, [r0, #36]	; 0x24
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 800197c:	7b23      	ldrb	r3, [r4, #12]
 800197e:	2b04      	cmp	r3, #4
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
 8001980:	b083      	sub	sp, #12
 8001982:	4605      	mov	r5, r0
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8001984:	d004      	beq.n	8001990 <dhcp_rebind+0x18>
    dhcp->state = new_state;
    dhcp->tries = 0;
 8001986:	2300      	movs	r3, #0
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 8001988:	2204      	movs	r2, #4
 800198a:	7322      	strb	r2, [r4, #12]
    dhcp->tries = 0;
 800198c:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 800198e:	8363      	strh	r3, [r4, #26]
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 8001990:	2200      	movs	r2, #0
 8001992:	4610      	mov	r0, r2
 8001994:	f44f 719a 	mov.w	r1, #308	; 0x134
 8001998:	f002 faa6 	bl	8003ee8 <pbuf_alloc>
 800199c:	6120      	str	r0, [r4, #16]
  if (dhcp->p_out == NULL) {
 800199e:	2800      	cmp	r0, #0
 80019a0:	f000 817a 	beq.w	8001c98 <dhcp_rebind+0x320>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 80019a4:	7b63      	ldrb	r3, [r4, #13]
 80019a6:	2b00      	cmp	r3, #0
 80019a8:	f000 816d 	beq.w	8001c86 <dhcp_rebind+0x30e>
 80019ac:	4bbc      	ldr	r3, [pc, #752]	; (8001ca0 <dhcp_rebind+0x328>)
 80019ae:	681b      	ldr	r3, [r3, #0]
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 80019b0:	6841      	ldr	r1, [r0, #4]
 80019b2:	6161      	str	r1, [r4, #20]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 80019b4:	2201      	movs	r2, #1
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 80019b6:	6023      	str	r3, [r4, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 80019b8:	700a      	strb	r2, [r1, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 80019ba:	6963      	ldr	r3, [r4, #20]
 80019bc:	705a      	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
 80019be:	6963      	ldr	r3, [r4, #20]
 80019c0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80019c4:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
 80019c6:	6963      	ldr	r3, [r4, #20]
 80019c8:	2600      	movs	r6, #0
 80019ca:	70de      	strb	r6, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
 80019cc:	6820      	ldr	r0, [r4, #0]
 80019ce:	6967      	ldr	r7, [r4, #20]
 80019d0:	f7ff ff54 	bl	800187c <lwip_htonl>
  dhcp->msg_out->secs = 0;
 80019d4:	6963      	ldr	r3, [r4, #20]
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
 80019d6:	6078      	str	r0, [r7, #4]
  dhcp->msg_out->secs = 0;
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
 80019d8:	731e      	strb	r6, [r3, #12]
 80019da:	735e      	strb	r6, [r3, #13]
 80019dc:	739e      	strb	r6, [r3, #14]
 80019de:	73de      	strb	r6, [r3, #15]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
  dhcp->msg_out->secs = 0;
 80019e0:	721e      	strb	r6, [r3, #8]
 80019e2:	725e      	strb	r6, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 80019e4:	729e      	strb	r6, [r3, #10]
 80019e6:	72de      	strb	r6, [r3, #11]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
 80019e8:	7b22      	ldrb	r2, [r4, #12]
 80019ea:	3a04      	subs	r2, #4
 80019ec:	2a01      	cmp	r2, #1
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
 80019ee:	bf9c      	itt	ls
 80019f0:	686a      	ldrls	r2, [r5, #4]
 80019f2:	60da      	strls	r2, [r3, #12]
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 80019f4:	2200      	movs	r2, #0
 80019f6:	741a      	strb	r2, [r3, #16]
 80019f8:	745a      	strb	r2, [r3, #17]
 80019fa:	749a      	strb	r2, [r3, #18]
 80019fc:	74da      	strb	r2, [r3, #19]
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 80019fe:	751a      	strb	r2, [r3, #20]
 8001a00:	755a      	strb	r2, [r3, #21]
 8001a02:	759a      	strb	r2, [r3, #22]
 8001a04:	75da      	strb	r2, [r3, #23]
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 8001a06:	761a      	strb	r2, [r3, #24]
 8001a08:	765a      	strb	r2, [r3, #25]
 8001a0a:	769a      	strb	r2, [r3, #26]
 8001a0c:	76da      	strb	r2, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 8001a0e:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001a12:	b10a      	cbz	r2, 8001a18 <dhcp_rebind+0xa0>
 8001a14:	f895 202b 	ldrb.w	r2, [r5, #43]	; 0x2b
 8001a18:	771a      	strb	r2, [r3, #28]
 8001a1a:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001a1e:	6963      	ldr	r3, [r4, #20]
 8001a20:	2a01      	cmp	r2, #1
 8001a22:	bf8c      	ite	hi
 8001a24:	f895 202c 	ldrbhi.w	r2, [r5, #44]	; 0x2c
 8001a28:	2200      	movls	r2, #0
 8001a2a:	775a      	strb	r2, [r3, #29]
 8001a2c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001a30:	6963      	ldr	r3, [r4, #20]
 8001a32:	2a02      	cmp	r2, #2
 8001a34:	bf8c      	ite	hi
 8001a36:	f895 202d 	ldrbhi.w	r2, [r5, #45]	; 0x2d
 8001a3a:	2200      	movls	r2, #0
 8001a3c:	779a      	strb	r2, [r3, #30]
 8001a3e:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001a42:	6963      	ldr	r3, [r4, #20]
 8001a44:	2a03      	cmp	r2, #3
 8001a46:	bf8c      	ite	hi
 8001a48:	f895 202e 	ldrbhi.w	r2, [r5, #46]	; 0x2e
 8001a4c:	2200      	movls	r2, #0
 8001a4e:	77da      	strb	r2, [r3, #31]
 8001a50:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001a54:	6963      	ldr	r3, [r4, #20]
 8001a56:	2a04      	cmp	r2, #4
 8001a58:	bf8c      	ite	hi
 8001a5a:	f895 202f 	ldrbhi.w	r2, [r5, #47]	; 0x2f
 8001a5e:	2200      	movls	r2, #0
 8001a60:	f883 2020 	strb.w	r2, [r3, #32]
 8001a64:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001a68:	6963      	ldr	r3, [r4, #20]
 8001a6a:	2a05      	cmp	r2, #5
 8001a6c:	bf8c      	ite	hi
 8001a6e:	f895 2030 	ldrbhi.w	r2, [r5, #48]	; 0x30
 8001a72:	2200      	movls	r2, #0
 8001a74:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8001a78:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001a7c:	6963      	ldr	r3, [r4, #20]
 8001a7e:	2a06      	cmp	r2, #6
 8001a80:	bf8c      	ite	hi
 8001a82:	f895 2031 	ldrbhi.w	r2, [r5, #49]	; 0x31
 8001a86:	2200      	movls	r2, #0
 8001a88:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8001a8c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001a90:	6963      	ldr	r3, [r4, #20]
 8001a92:	2a07      	cmp	r2, #7
 8001a94:	bf8c      	ite	hi
 8001a96:	f895 2032 	ldrbhi.w	r2, [r5, #50]	; 0x32
 8001a9a:	2200      	movls	r2, #0
 8001a9c:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
 8001aa0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001aa4:	6963      	ldr	r3, [r4, #20]
 8001aa6:	2a08      	cmp	r2, #8
 8001aa8:	bf8c      	ite	hi
 8001aaa:	f895 2033 	ldrbhi.w	r2, [r5, #51]	; 0x33
 8001aae:	2200      	movls	r2, #0
 8001ab0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8001ab4:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001ab8:	6963      	ldr	r3, [r4, #20]
 8001aba:	2a09      	cmp	r2, #9
 8001abc:	bf8c      	ite	hi
 8001abe:	f895 2034 	ldrbhi.w	r2, [r5, #52]	; 0x34
 8001ac2:	2200      	movls	r2, #0
 8001ac4:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8001ac8:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001acc:	6963      	ldr	r3, [r4, #20]
 8001ace:	2a0a      	cmp	r2, #10
 8001ad0:	bf8c      	ite	hi
 8001ad2:	f895 2035 	ldrbhi.w	r2, [r5, #53]	; 0x35
 8001ad6:	2200      	movls	r2, #0
 8001ad8:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8001adc:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001ae0:	6963      	ldr	r3, [r4, #20]
 8001ae2:	2a0b      	cmp	r2, #11
 8001ae4:	bf8c      	ite	hi
 8001ae6:	f895 2036 	ldrbhi.w	r2, [r5, #54]	; 0x36
 8001aea:	2200      	movls	r2, #0
 8001aec:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 8001af0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001af4:	6963      	ldr	r3, [r4, #20]
 8001af6:	2a0c      	cmp	r2, #12
 8001af8:	bf8c      	ite	hi
 8001afa:	f895 2037 	ldrbhi.w	r2, [r5, #55]	; 0x37
 8001afe:	2200      	movls	r2, #0
 8001b00:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8001b04:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001b08:	6963      	ldr	r3, [r4, #20]
 8001b0a:	2a0d      	cmp	r2, #13
 8001b0c:	bf8c      	ite	hi
 8001b0e:	f895 2038 	ldrbhi.w	r2, [r5, #56]	; 0x38
 8001b12:	2200      	movls	r2, #0
 8001b14:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 8001b18:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001b1c:	6963      	ldr	r3, [r4, #20]
 8001b1e:	2a0e      	cmp	r2, #14
 8001b20:	bf8c      	ite	hi
 8001b22:	f895 2039 	ldrbhi.w	r2, [r5, #57]	; 0x39
 8001b26:	2200      	movls	r2, #0
 8001b28:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 8001b2c:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 8001b30:	6962      	ldr	r2, [r4, #20]
 8001b32:	2b0f      	cmp	r3, #15
 8001b34:	bf8c      	ite	hi
 8001b36:	f895 103a 	ldrbhi.w	r1, [r5, #58]	; 0x3a
 8001b3a:	2100      	movls	r1, #0
 8001b3c:	2300      	movs	r3, #0
 8001b3e:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
 8001b42:	4619      	mov	r1, r3
 8001b44:	6962      	ldr	r2, [r4, #20]
 8001b46:	441a      	add	r2, r3
 8001b48:	3301      	adds	r3, #1
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8001b4a:	2b40      	cmp	r3, #64	; 0x40
    dhcp->msg_out->sname[i] = 0;
 8001b4c:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8001b50:	d1f8      	bne.n	8001b44 <dhcp_rebind+0x1cc>
 8001b52:	2300      	movs	r3, #0
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
 8001b54:	4618      	mov	r0, r3
 8001b56:	6962      	ldr	r2, [r4, #20]
 8001b58:	441a      	add	r2, r3
 8001b5a:	3301      	adds	r3, #1
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 8001b5c:	2b80      	cmp	r3, #128	; 0x80
    dhcp->msg_out->file[i] = 0;
 8001b5e:	f882 006c 	strb.w	r0, [r2, #108]	; 0x6c
 8001b62:	f04f 0100 	mov.w	r1, #0
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 8001b66:	d1f6      	bne.n	8001b56 <dhcp_rebind+0x1de>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 8001b68:	6962      	ldr	r2, [r4, #20]
 8001b6a:	2363      	movs	r3, #99	; 0x63
 8001b6c:	f06f 067d 	mvn.w	r6, #125	; 0x7d
 8001b70:	2053      	movs	r0, #83	; 0x53
 8001b72:	f882 30ec 	strb.w	r3, [r2, #236]	; 0xec
 8001b76:	f882 30ef 	strb.w	r3, [r2, #239]	; 0xef
 8001b7a:	f882 60ed 	strb.w	r6, [r2, #237]	; 0xed
 8001b7e:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
  dhcp->options_out_len = 0;
 8001b82:	460b      	mov	r3, r1
 8001b84:	8321      	strh	r1, [r4, #24]
 8001b86:	e000      	b.n	8001b8a <dhcp_rebind+0x212>
 8001b88:	6962      	ldr	r2, [r4, #20]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 8001b8a:	441a      	add	r2, r3
 8001b8c:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
 8001b90:	3301      	adds	r3, #1
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 8001b92:	2b44      	cmp	r3, #68	; 0x44
 8001b94:	d1f8      	bne.n	8001b88 <dhcp_rebind+0x210>
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 8001b96:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8001b98:	6962      	ldr	r2, [r4, #20]
 8001b9a:	441a      	add	r2, r3
 8001b9c:	2135      	movs	r1, #53	; 0x35
 8001b9e:	3301      	adds	r3, #1
 8001ba0:	8323      	strh	r3, [r4, #24]
 8001ba2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 8001ba6:	8b23      	ldrh	r3, [r4, #24]
 8001ba8:	6962      	ldr	r2, [r4, #20]
 8001baa:	441a      	add	r2, r3
 8001bac:	2101      	movs	r1, #1
 8001bae:	3301      	adds	r3, #1
 8001bb0:	8323      	strh	r3, [r4, #24]
 8001bb2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 8001bb6:	8b23      	ldrh	r3, [r4, #24]
 8001bb8:	6962      	ldr	r2, [r4, #20]
 8001bba:	441a      	add	r2, r3
 8001bbc:	440b      	add	r3, r1
 8001bbe:	2103      	movs	r1, #3
 8001bc0:	8323      	strh	r3, [r4, #24]
 8001bc2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 8001bc6:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8001bc8:	6962      	ldr	r2, [r4, #20]
 8001bca:	441a      	add	r2, r3
 8001bcc:	2139      	movs	r1, #57	; 0x39
 8001bce:	3301      	adds	r3, #1
 8001bd0:	8323      	strh	r3, [r4, #24]
 8001bd2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 8001bd6:	8b23      	ldrh	r3, [r4, #24]
 8001bd8:	6962      	ldr	r2, [r4, #20]
 8001bda:	441a      	add	r2, r3
 8001bdc:	2102      	movs	r1, #2
 8001bde:	3301      	adds	r3, #1
 8001be0:	8323      	strh	r3, [r4, #24]
 8001be2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
 8001be6:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 8001be8:	6962      	ldr	r2, [r4, #20]

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 8001bea:	8d29      	ldrh	r1, [r5, #40]	; 0x28

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 8001bec:	441a      	add	r2, r3
 8001bee:	0a08      	lsrs	r0, r1, #8
 8001bf0:	3301      	adds	r3, #1
 8001bf2:	8323      	strh	r3, [r4, #24]
 8001bf4:	f882 00f0 	strb.w	r0, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 8001bf8:	8b23      	ldrh	r3, [r4, #24]
 8001bfa:	6962      	ldr	r2, [r4, #20]
 8001bfc:	441a      	add	r2, r3
 8001bfe:	3301      	adds	r3, #1
 8001c00:	8323      	strh	r3, [r4, #24]
 8001c02:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 8001c06:	8b23      	ldrh	r3, [r4, #24]
 8001c08:	6962      	ldr	r2, [r4, #20]
 8001c0a:	441a      	add	r2, r3
 8001c0c:	21ff      	movs	r1, #255	; 0xff
 8001c0e:	3301      	adds	r3, #1
 8001c10:	8323      	strh	r3, [r4, #24]
 8001c12:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 8001c16:	8b21      	ldrh	r1, [r4, #24]
 8001c18:	2943      	cmp	r1, #67	; 0x43
 8001c1a:	d809      	bhi.n	8001c30 <dhcp_rebind+0x2b8>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 8001c1c:	2200      	movs	r2, #0
 8001c1e:	6963      	ldr	r3, [r4, #20]
 8001c20:	440b      	add	r3, r1
 8001c22:	3101      	adds	r1, #1
 8001c24:	8321      	strh	r1, [r4, #24]
 8001c26:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 8001c2a:	8b21      	ldrh	r1, [r4, #24]
 8001c2c:	2943      	cmp	r1, #67	; 0x43
 8001c2e:	d9f6      	bls.n	8001c1e <dhcp_rebind+0x2a6>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 8001c30:	31f0      	adds	r1, #240	; 0xf0
 8001c32:	b289      	uxth	r1, r1
 8001c34:	6920      	ldr	r0, [r4, #16]
 8001c36:	f002 fa2f 	bl	8004098 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 8001c3a:	6921      	ldr	r1, [r4, #16]
 8001c3c:	6860      	ldr	r0, [r4, #4]
 8001c3e:	4a19      	ldr	r2, [pc, #100]	; (8001ca4 <dhcp_rebind+0x32c>)
 8001c40:	9500      	str	r5, [sp, #0]
 8001c42:	2343      	movs	r3, #67	; 0x43
 8001c44:	f005 fb38 	bl	80072b8 <udp_sendto_if>
dhcp_delete_msg(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 8001c48:	6920      	ldr	r0, [r4, #16]
 8001c4a:	b108      	cbz	r0, 8001c50 <dhcp_rebind+0x2d8>
    pbuf_free(dhcp->p_out);
 8001c4c:	f002 faa4 	bl	8004198 <pbuf_free>
  }
  dhcp->p_out = NULL;
 8001c50:	2000      	movs	r0, #0
 8001c52:	6120      	str	r0, [r4, #16]
  dhcp->msg_out = NULL;
 8001c54:	6160      	str	r0, [r4, #20]
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 8001c56:	7b63      	ldrb	r3, [r4, #13]
 8001c58:	3301      	adds	r3, #1
 8001c5a:	b2db      	uxtb	r3, r3
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 8001c5c:	2b09      	cmp	r3, #9
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 8001c5e:	7363      	strb	r3, [r4, #13]
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 8001c60:	d816      	bhi.n	8001c90 <dhcp_rebind+0x318>
 8001c62:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 8001c66:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8001c6a:	00db      	lsls	r3, r3, #3
 8001c6c:	b29b      	uxth	r3, r3
 8001c6e:	4a0e      	ldr	r2, [pc, #56]	; (8001ca8 <dhcp_rebind+0x330>)
 8001c70:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 8001c74:	fb82 1203 	smull	r1, r2, r2, r3
 8001c78:	17db      	asrs	r3, r3, #31
 8001c7a:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 8001c7e:	b29b      	uxth	r3, r3
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 8001c80:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 8001c82:	b003      	add	sp, #12
 8001c84:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 8001c86:	4a06      	ldr	r2, [pc, #24]	; (8001ca0 <dhcp_rebind+0x328>)
 8001c88:	6813      	ldr	r3, [r2, #0]
 8001c8a:	3301      	adds	r3, #1
 8001c8c:	6013      	str	r3, [r2, #0]
 8001c8e:	e68f      	b.n	80019b0 <dhcp_rebind+0x38>
 8001c90:	2314      	movs	r3, #20
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 8001c92:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 8001c94:	b003      	add	sp, #12
 8001c96:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
 8001c98:	f04f 30ff 	mov.w	r0, #4294967295
 8001c9c:	e7db      	b.n	8001c56 <dhcp_rebind+0x2de>
 8001c9e:	bf00      	nop
 8001ca0:	20000000 	.word	0x20000000
 8001ca4:	0800c9dc 	.word	0x0800c9dc
 8001ca8:	10624dd3 	.word	0x10624dd3

08001cac <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
 8001cac:	b5f0      	push	{r4, r5, r6, r7, lr}
  struct dhcp *dhcp = netif->dhcp;
 8001cae:	6a44      	ldr	r4, [r0, #36]	; 0x24
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8001cb0:	7b22      	ldrb	r2, [r4, #12]
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
 8001cb2:	2300      	movs	r3, #0
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8001cb4:	2a06      	cmp	r2, #6
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
 8001cb6:	b083      	sub	sp, #12
 8001cb8:	4605      	mov	r5, r0
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
 8001cba:	6263      	str	r3, [r4, #36]	; 0x24
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8001cbc:	d003      	beq.n	8001cc6 <dhcp_discover+0x1a>
    dhcp->state = new_state;
 8001cbe:	2206      	movs	r2, #6
    dhcp->tries = 0;
 8001cc0:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 8001cc2:	8363      	strh	r3, [r4, #26]
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 8001cc4:	7322      	strb	r2, [r4, #12]
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 8001cc6:	2200      	movs	r2, #0
 8001cc8:	4610      	mov	r0, r2
 8001cca:	f44f 719a 	mov.w	r1, #308	; 0x134
 8001cce:	f002 f90b 	bl	8003ee8 <pbuf_alloc>
 8001cd2:	6120      	str	r0, [r4, #16]
  if (dhcp->p_out == NULL) {
 8001cd4:	2800      	cmp	r0, #0
 8001cd6:	f000 81a0 	beq.w	800201a <dhcp_discover+0x36e>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 8001cda:	7b63      	ldrb	r3, [r4, #13]
 8001cdc:	2b00      	cmp	r3, #0
 8001cde:	f000 8193 	beq.w	8002008 <dhcp_discover+0x35c>
 8001ce2:	4b73      	ldr	r3, [pc, #460]	; (8001eb0 <dhcp_discover+0x204>)
 8001ce4:	681b      	ldr	r3, [r3, #0]
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 8001ce6:	6841      	ldr	r1, [r0, #4]
 8001ce8:	6161      	str	r1, [r4, #20]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 8001cea:	2201      	movs	r2, #1
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 8001cec:	6023      	str	r3, [r4, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 8001cee:	700a      	strb	r2, [r1, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 8001cf0:	6963      	ldr	r3, [r4, #20]
 8001cf2:	705a      	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
 8001cf4:	6963      	ldr	r3, [r4, #20]
 8001cf6:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001cfa:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
 8001cfc:	6963      	ldr	r3, [r4, #20]
 8001cfe:	2600      	movs	r6, #0
 8001d00:	70de      	strb	r6, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
 8001d02:	6820      	ldr	r0, [r4, #0]
 8001d04:	6967      	ldr	r7, [r4, #20]
 8001d06:	f7ff fdb9 	bl	800187c <lwip_htonl>
  dhcp->msg_out->secs = 0;
 8001d0a:	6963      	ldr	r3, [r4, #20]
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
 8001d0c:	6078      	str	r0, [r7, #4]
  dhcp->msg_out->secs = 0;
 8001d0e:	721e      	strb	r6, [r3, #8]
 8001d10:	725e      	strb	r6, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 8001d12:	729e      	strb	r6, [r3, #10]
 8001d14:	72de      	strb	r6, [r3, #11]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
 8001d16:	731e      	strb	r6, [r3, #12]
 8001d18:	735e      	strb	r6, [r3, #13]
 8001d1a:	739e      	strb	r6, [r3, #14]
 8001d1c:	73de      	strb	r6, [r3, #15]
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 8001d1e:	741e      	strb	r6, [r3, #16]
 8001d20:	745e      	strb	r6, [r3, #17]
 8001d22:	749e      	strb	r6, [r3, #18]
 8001d24:	74de      	strb	r6, [r3, #19]
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 8001d26:	751e      	strb	r6, [r3, #20]
 8001d28:	755e      	strb	r6, [r3, #21]
 8001d2a:	759e      	strb	r6, [r3, #22]
 8001d2c:	75de      	strb	r6, [r3, #23]
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 8001d2e:	761e      	strb	r6, [r3, #24]
 8001d30:	765e      	strb	r6, [r3, #25]
 8001d32:	769e      	strb	r6, [r3, #26]
 8001d34:	76de      	strb	r6, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 8001d36:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001d3a:	b10a      	cbz	r2, 8001d40 <dhcp_discover+0x94>
 8001d3c:	f895 202b 	ldrb.w	r2, [r5, #43]	; 0x2b
 8001d40:	771a      	strb	r2, [r3, #28]
 8001d42:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001d46:	6963      	ldr	r3, [r4, #20]
 8001d48:	2a01      	cmp	r2, #1
 8001d4a:	bf8c      	ite	hi
 8001d4c:	f895 202c 	ldrbhi.w	r2, [r5, #44]	; 0x2c
 8001d50:	2200      	movls	r2, #0
 8001d52:	775a      	strb	r2, [r3, #29]
 8001d54:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001d58:	6963      	ldr	r3, [r4, #20]
 8001d5a:	2a02      	cmp	r2, #2
 8001d5c:	bf8c      	ite	hi
 8001d5e:	f895 202d 	ldrbhi.w	r2, [r5, #45]	; 0x2d
 8001d62:	2200      	movls	r2, #0
 8001d64:	779a      	strb	r2, [r3, #30]
 8001d66:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001d6a:	6963      	ldr	r3, [r4, #20]
 8001d6c:	2a03      	cmp	r2, #3
 8001d6e:	bf8c      	ite	hi
 8001d70:	f895 202e 	ldrbhi.w	r2, [r5, #46]	; 0x2e
 8001d74:	2200      	movls	r2, #0
 8001d76:	77da      	strb	r2, [r3, #31]
 8001d78:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001d7c:	6963      	ldr	r3, [r4, #20]
 8001d7e:	2a04      	cmp	r2, #4
 8001d80:	bf8c      	ite	hi
 8001d82:	f895 202f 	ldrbhi.w	r2, [r5, #47]	; 0x2f
 8001d86:	2200      	movls	r2, #0
 8001d88:	f883 2020 	strb.w	r2, [r3, #32]
 8001d8c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001d90:	6963      	ldr	r3, [r4, #20]
 8001d92:	2a05      	cmp	r2, #5
 8001d94:	bf8c      	ite	hi
 8001d96:	f895 2030 	ldrbhi.w	r2, [r5, #48]	; 0x30
 8001d9a:	2200      	movls	r2, #0
 8001d9c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8001da0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001da4:	6963      	ldr	r3, [r4, #20]
 8001da6:	2a06      	cmp	r2, #6
 8001da8:	bf8c      	ite	hi
 8001daa:	f895 2031 	ldrbhi.w	r2, [r5, #49]	; 0x31
 8001dae:	2200      	movls	r2, #0
 8001db0:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8001db4:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001db8:	6963      	ldr	r3, [r4, #20]
 8001dba:	2a07      	cmp	r2, #7
 8001dbc:	bf8c      	ite	hi
 8001dbe:	f895 2032 	ldrbhi.w	r2, [r5, #50]	; 0x32
 8001dc2:	2200      	movls	r2, #0
 8001dc4:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
 8001dc8:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001dcc:	6963      	ldr	r3, [r4, #20]
 8001dce:	2a08      	cmp	r2, #8
 8001dd0:	bf8c      	ite	hi
 8001dd2:	f895 2033 	ldrbhi.w	r2, [r5, #51]	; 0x33
 8001dd6:	2200      	movls	r2, #0
 8001dd8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8001ddc:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001de0:	6963      	ldr	r3, [r4, #20]
 8001de2:	2a09      	cmp	r2, #9
 8001de4:	bf8c      	ite	hi
 8001de6:	f895 2034 	ldrbhi.w	r2, [r5, #52]	; 0x34
 8001dea:	2200      	movls	r2, #0
 8001dec:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8001df0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001df4:	6963      	ldr	r3, [r4, #20]
 8001df6:	2a0a      	cmp	r2, #10
 8001df8:	bf8c      	ite	hi
 8001dfa:	f895 2035 	ldrbhi.w	r2, [r5, #53]	; 0x35
 8001dfe:	2200      	movls	r2, #0
 8001e00:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8001e04:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001e08:	6963      	ldr	r3, [r4, #20]
 8001e0a:	2a0b      	cmp	r2, #11
 8001e0c:	bf8c      	ite	hi
 8001e0e:	f895 2036 	ldrbhi.w	r2, [r5, #54]	; 0x36
 8001e12:	2200      	movls	r2, #0
 8001e14:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 8001e18:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001e1c:	6963      	ldr	r3, [r4, #20]
 8001e1e:	2a0c      	cmp	r2, #12
 8001e20:	bf8c      	ite	hi
 8001e22:	f895 2037 	ldrbhi.w	r2, [r5, #55]	; 0x37
 8001e26:	2200      	movls	r2, #0
 8001e28:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8001e2c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001e30:	6963      	ldr	r3, [r4, #20]
 8001e32:	2a0d      	cmp	r2, #13
 8001e34:	bf8c      	ite	hi
 8001e36:	f895 2038 	ldrbhi.w	r2, [r5, #56]	; 0x38
 8001e3a:	2200      	movls	r2, #0
 8001e3c:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 8001e40:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8001e44:	6963      	ldr	r3, [r4, #20]
 8001e46:	2a0e      	cmp	r2, #14
 8001e48:	bf8c      	ite	hi
 8001e4a:	f895 2039 	ldrbhi.w	r2, [r5, #57]	; 0x39
 8001e4e:	2200      	movls	r2, #0
 8001e50:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 8001e54:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 8001e58:	6962      	ldr	r2, [r4, #20]
 8001e5a:	2b0f      	cmp	r3, #15
 8001e5c:	bf8c      	ite	hi
 8001e5e:	f895 103a 	ldrbhi.w	r1, [r5, #58]	; 0x3a
 8001e62:	2100      	movls	r1, #0
 8001e64:	2300      	movs	r3, #0
 8001e66:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
 8001e6a:	4619      	mov	r1, r3
 8001e6c:	6962      	ldr	r2, [r4, #20]
 8001e6e:	441a      	add	r2, r3
 8001e70:	3301      	adds	r3, #1
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8001e72:	2b40      	cmp	r3, #64	; 0x40
    dhcp->msg_out->sname[i] = 0;
 8001e74:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8001e78:	d1f8      	bne.n	8001e6c <dhcp_discover+0x1c0>
 8001e7a:	2300      	movs	r3, #0
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
 8001e7c:	4618      	mov	r0, r3
 8001e7e:	6962      	ldr	r2, [r4, #20]
 8001e80:	441a      	add	r2, r3
 8001e82:	3301      	adds	r3, #1
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 8001e84:	2b80      	cmp	r3, #128	; 0x80
    dhcp->msg_out->file[i] = 0;
 8001e86:	f882 006c 	strb.w	r0, [r2, #108]	; 0x6c
 8001e8a:	f04f 0100 	mov.w	r1, #0
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 8001e8e:	d1f6      	bne.n	8001e7e <dhcp_discover+0x1d2>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 8001e90:	6962      	ldr	r2, [r4, #20]
 8001e92:	2363      	movs	r3, #99	; 0x63
 8001e94:	f06f 067d 	mvn.w	r6, #125	; 0x7d
 8001e98:	2053      	movs	r0, #83	; 0x53
 8001e9a:	f882 30ec 	strb.w	r3, [r2, #236]	; 0xec
 8001e9e:	f882 30ef 	strb.w	r3, [r2, #239]	; 0xef
 8001ea2:	f882 60ed 	strb.w	r6, [r2, #237]	; 0xed
 8001ea6:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
  dhcp->options_out_len = 0;
 8001eaa:	460b      	mov	r3, r1
 8001eac:	8321      	strh	r1, [r4, #24]
 8001eae:	e002      	b.n	8001eb6 <dhcp_discover+0x20a>
 8001eb0:	20000000 	.word	0x20000000
 8001eb4:	6962      	ldr	r2, [r4, #20]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 8001eb6:	441a      	add	r2, r3
 8001eb8:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
 8001ebc:	3301      	adds	r3, #1
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 8001ebe:	2b44      	cmp	r3, #68	; 0x44
 8001ec0:	d1f8      	bne.n	8001eb4 <dhcp_discover+0x208>
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 8001ec2:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8001ec4:	6962      	ldr	r2, [r4, #20]
 8001ec6:	441a      	add	r2, r3
 8001ec8:	2135      	movs	r1, #53	; 0x35
 8001eca:	3301      	adds	r3, #1
 8001ecc:	8323      	strh	r3, [r4, #24]
 8001ece:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 8001ed2:	8b23      	ldrh	r3, [r4, #24]
 8001ed4:	6962      	ldr	r2, [r4, #20]
 8001ed6:	18d1      	adds	r1, r2, r3
 8001ed8:	2201      	movs	r2, #1
 8001eda:	3301      	adds	r3, #1
 8001edc:	8323      	strh	r3, [r4, #24]
 8001ede:	f881 20f0 	strb.w	r2, [r1, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 8001ee2:	8b23      	ldrh	r3, [r4, #24]
 8001ee4:	6961      	ldr	r1, [r4, #20]
 8001ee6:	4419      	add	r1, r3
 8001ee8:	4413      	add	r3, r2
 8001eea:	8323      	strh	r3, [r4, #24]
 8001eec:	f881 20f0 	strb.w	r2, [r1, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 8001ef0:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8001ef2:	6961      	ldr	r1, [r4, #20]
 8001ef4:	4419      	add	r1, r3
 8001ef6:	2039      	movs	r0, #57	; 0x39
 8001ef8:	4413      	add	r3, r2
 8001efa:	8323      	strh	r3, [r4, #24]
 8001efc:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 8001f00:	8b23      	ldrh	r3, [r4, #24]
 8001f02:	6961      	ldr	r1, [r4, #20]
 8001f04:	4419      	add	r1, r3
 8001f06:	2002      	movs	r0, #2
 8001f08:	4413      	add	r3, r2
 8001f0a:	8323      	strh	r3, [r4, #24]
 8001f0c:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
 8001f10:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 8001f12:	6961      	ldr	r1, [r4, #20]
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
  if (result == ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 8001f14:	8d28      	ldrh	r0, [r5, #40]	; 0x28

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 8001f16:	4419      	add	r1, r3
 8001f18:	0a06      	lsrs	r6, r0, #8
 8001f1a:	4413      	add	r3, r2
 8001f1c:	8323      	strh	r3, [r4, #24]
 8001f1e:	f881 60f0 	strb.w	r6, [r1, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 8001f22:	8b23      	ldrh	r3, [r4, #24]
 8001f24:	6961      	ldr	r1, [r4, #20]
 8001f26:	4419      	add	r1, r3
 8001f28:	4413      	add	r3, r2
 8001f2a:	8323      	strh	r3, [r4, #24]
 8001f2c:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 8001f30:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8001f32:	6961      	ldr	r1, [r4, #20]
 8001f34:	4419      	add	r1, r3
 8001f36:	2037      	movs	r0, #55	; 0x37
 8001f38:	4413      	add	r3, r2
 8001f3a:	8323      	strh	r3, [r4, #24]
 8001f3c:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 8001f40:	8b23      	ldrh	r3, [r4, #24]
 8001f42:	6961      	ldr	r1, [r4, #20]
 8001f44:	4419      	add	r1, r3
 8001f46:	2004      	movs	r0, #4
 8001f48:	4413      	add	r3, r2
 8001f4a:	8323      	strh	r3, [r4, #24]
 8001f4c:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 8001f50:	8b23      	ldrh	r3, [r4, #24]
 8001f52:	6961      	ldr	r1, [r4, #20]
 8001f54:	4419      	add	r1, r3
 8001f56:	4413      	add	r3, r2
 8001f58:	8323      	strh	r3, [r4, #24]
 8001f5a:	f881 20f0 	strb.w	r2, [r1, #240]	; 0xf0
 8001f5e:	8b23      	ldrh	r3, [r4, #24]
 8001f60:	6962      	ldr	r2, [r4, #20]
 8001f62:	441a      	add	r2, r3
 8001f64:	2103      	movs	r1, #3
 8001f66:	3301      	adds	r3, #1
 8001f68:	8323      	strh	r3, [r4, #24]
 8001f6a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 8001f6e:	8b23      	ldrh	r3, [r4, #24]
 8001f70:	6962      	ldr	r2, [r4, #20]
 8001f72:	441a      	add	r2, r3
 8001f74:	211c      	movs	r1, #28
 8001f76:	3301      	adds	r3, #1
 8001f78:	8323      	strh	r3, [r4, #24]
 8001f7a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 8001f7e:	8b23      	ldrh	r3, [r4, #24]
 8001f80:	6962      	ldr	r2, [r4, #20]
 8001f82:	441a      	add	r2, r3
 8001f84:	2106      	movs	r1, #6
 8001f86:	3301      	adds	r3, #1
 8001f88:	8323      	strh	r3, [r4, #24]
 8001f8a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 8001f8e:	8b23      	ldrh	r3, [r4, #24]
 8001f90:	6962      	ldr	r2, [r4, #20]
 8001f92:	441a      	add	r2, r3
 8001f94:	21ff      	movs	r1, #255	; 0xff
 8001f96:	3301      	adds	r3, #1
 8001f98:	8323      	strh	r3, [r4, #24]
 8001f9a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 8001f9e:	8b21      	ldrh	r1, [r4, #24]
 8001fa0:	2943      	cmp	r1, #67	; 0x43
 8001fa2:	d809      	bhi.n	8001fb8 <dhcp_discover+0x30c>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 8001fa4:	2200      	movs	r2, #0
 8001fa6:	6963      	ldr	r3, [r4, #20]
 8001fa8:	440b      	add	r3, r1
 8001faa:	3101      	adds	r1, #1
 8001fac:	8321      	strh	r1, [r4, #24]
 8001fae:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 8001fb2:	8b21      	ldrh	r1, [r4, #24]
 8001fb4:	2943      	cmp	r1, #67	; 0x43
 8001fb6:	d9f6      	bls.n	8001fa6 <dhcp_discover+0x2fa>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);

    dhcp_option_trailer(dhcp);

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 8001fb8:	31f0      	adds	r1, #240	; 0xf0
 8001fba:	b289      	uxth	r1, r1
 8001fbc:	6920      	ldr	r0, [r4, #16]
 8001fbe:	f002 f86b 	bl	8004098 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 8001fc2:	6921      	ldr	r1, [r4, #16]
 8001fc4:	6860      	ldr	r0, [r4, #4]
 8001fc6:	4a16      	ldr	r2, [pc, #88]	; (8002020 <dhcp_discover+0x374>)
 8001fc8:	9500      	str	r5, [sp, #0]
 8001fca:	2343      	movs	r3, #67	; 0x43
 8001fcc:	f005 f974 	bl	80072b8 <udp_sendto_if>
dhcp_delete_msg(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 8001fd0:	6920      	ldr	r0, [r4, #16]
 8001fd2:	b108      	cbz	r0, 8001fd8 <dhcp_discover+0x32c>
    pbuf_free(dhcp->p_out);
 8001fd4:	f002 f8e0 	bl	8004198 <pbuf_free>
  }
  dhcp->p_out = NULL;
 8001fd8:	2000      	movs	r0, #0
 8001fda:	6120      	str	r0, [r4, #16]
  dhcp->msg_out = NULL;
 8001fdc:	6160      	str	r0, [r4, #20]
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 8001fde:	7b63      	ldrb	r3, [r4, #13]
 8001fe0:	3301      	adds	r3, #1
 8001fe2:	b2da      	uxtb	r2, r3
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 8001fe4:	2a05      	cmp	r2, #5
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 8001fe6:	7362      	strb	r2, [r4, #13]
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 8001fe8:	d813      	bhi.n	8002012 <dhcp_discover+0x366>
 8001fea:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001fee:	4093      	lsls	r3, r2
 8001ff0:	4a0c      	ldr	r2, [pc, #48]	; (8002024 <dhcp_discover+0x378>)
 8001ff2:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 8001ff6:	fb82 1203 	smull	r1, r2, r2, r3
 8001ffa:	17db      	asrs	r3, r3, #31
 8001ffc:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 8002000:	b29b      	uxth	r3, r3
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 8002002:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 8002004:	b003      	add	sp, #12
 8002006:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 8002008:	4a07      	ldr	r2, [pc, #28]	; (8002028 <dhcp_discover+0x37c>)
 800200a:	6813      	ldr	r3, [r2, #0]
 800200c:	3301      	adds	r3, #1
 800200e:	6013      	str	r3, [r2, #0]
 8002010:	e669      	b.n	8001ce6 <dhcp_discover+0x3a>
 8002012:	2378      	movs	r3, #120	; 0x78
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 8002014:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 8002016:	b003      	add	sp, #12
 8002018:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
 800201a:	f04f 30ff 	mov.w	r0, #4294967295
 800201e:	e7de      	b.n	8001fde <dhcp_discover+0x332>
 8002020:	0800c9dc 	.word	0x0800c9dc
 8002024:	10624dd3 	.word	0x10624dd3
 8002028:	20000000 	.word	0x20000000

0800202c <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
 800202c:	b5f0      	push	{r4, r5, r6, r7, lr}
  struct dhcp *dhcp = netif->dhcp;
 800202e:	6a44      	ldr	r4, [r0, #36]	; 0x24
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8002030:	7b23      	ldrb	r3, [r4, #12]
 8002032:	2b03      	cmp	r3, #3
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
 8002034:	b083      	sub	sp, #12
 8002036:	4605      	mov	r5, r0
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8002038:	d004      	beq.n	8002044 <dhcp_reboot+0x18>
    dhcp->state = new_state;
    dhcp->tries = 0;
 800203a:	2300      	movs	r3, #0
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 800203c:	2203      	movs	r2, #3
 800203e:	7322      	strb	r2, [r4, #12]
    dhcp->tries = 0;
 8002040:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 8002042:	8363      	strh	r3, [r4, #26]
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 8002044:	2200      	movs	r2, #0
 8002046:	4610      	mov	r0, r2
 8002048:	f44f 719a 	mov.w	r1, #308	; 0x134
 800204c:	f001 ff4c 	bl	8003ee8 <pbuf_alloc>
 8002050:	6120      	str	r0, [r4, #16]
  if (dhcp->p_out == NULL) {
 8002052:	2800      	cmp	r0, #0
 8002054:	f000 81ae 	beq.w	80023b4 <dhcp_reboot+0x388>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 8002058:	7b63      	ldrb	r3, [r4, #13]
 800205a:	2b00      	cmp	r3, #0
 800205c:	f000 81a1 	beq.w	80023a2 <dhcp_reboot+0x376>
 8002060:	4b76      	ldr	r3, [pc, #472]	; (800223c <dhcp_reboot+0x210>)
 8002062:	681b      	ldr	r3, [r3, #0]
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 8002064:	6841      	ldr	r1, [r0, #4]
 8002066:	6161      	str	r1, [r4, #20]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 8002068:	2201      	movs	r2, #1
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 800206a:	6023      	str	r3, [r4, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 800206c:	700a      	strb	r2, [r1, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 800206e:	6963      	ldr	r3, [r4, #20]
 8002070:	705a      	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
 8002072:	6963      	ldr	r3, [r4, #20]
 8002074:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002078:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
 800207a:	6963      	ldr	r3, [r4, #20]
 800207c:	2600      	movs	r6, #0
 800207e:	70de      	strb	r6, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
 8002080:	6820      	ldr	r0, [r4, #0]
 8002082:	6967      	ldr	r7, [r4, #20]
 8002084:	f7ff fbfa 	bl	800187c <lwip_htonl>
  dhcp->msg_out->secs = 0;
 8002088:	6963      	ldr	r3, [r4, #20]
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
 800208a:	6078      	str	r0, [r7, #4]
  dhcp->msg_out->secs = 0;
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
 800208c:	731e      	strb	r6, [r3, #12]
 800208e:	735e      	strb	r6, [r3, #13]
 8002090:	739e      	strb	r6, [r3, #14]
 8002092:	73de      	strb	r6, [r3, #15]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
  dhcp->msg_out->secs = 0;
 8002094:	721e      	strb	r6, [r3, #8]
 8002096:	725e      	strb	r6, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 8002098:	729e      	strb	r6, [r3, #10]
 800209a:	72de      	strb	r6, [r3, #11]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
 800209c:	7b22      	ldrb	r2, [r4, #12]
 800209e:	3a04      	subs	r2, #4
 80020a0:	2a01      	cmp	r2, #1
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
 80020a2:	bf9c      	itt	ls
 80020a4:	686a      	ldrls	r2, [r5, #4]
 80020a6:	60da      	strls	r2, [r3, #12]
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 80020a8:	2200      	movs	r2, #0
 80020aa:	741a      	strb	r2, [r3, #16]
 80020ac:	745a      	strb	r2, [r3, #17]
 80020ae:	749a      	strb	r2, [r3, #18]
 80020b0:	74da      	strb	r2, [r3, #19]
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 80020b2:	751a      	strb	r2, [r3, #20]
 80020b4:	755a      	strb	r2, [r3, #21]
 80020b6:	759a      	strb	r2, [r3, #22]
 80020b8:	75da      	strb	r2, [r3, #23]
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 80020ba:	761a      	strb	r2, [r3, #24]
 80020bc:	765a      	strb	r2, [r3, #25]
 80020be:	769a      	strb	r2, [r3, #26]
 80020c0:	76da      	strb	r2, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 80020c2:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80020c6:	b10a      	cbz	r2, 80020cc <dhcp_reboot+0xa0>
 80020c8:	f895 202b 	ldrb.w	r2, [r5, #43]	; 0x2b
 80020cc:	771a      	strb	r2, [r3, #28]
 80020ce:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80020d2:	6963      	ldr	r3, [r4, #20]
 80020d4:	2a01      	cmp	r2, #1
 80020d6:	bf8c      	ite	hi
 80020d8:	f895 202c 	ldrbhi.w	r2, [r5, #44]	; 0x2c
 80020dc:	2200      	movls	r2, #0
 80020de:	775a      	strb	r2, [r3, #29]
 80020e0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80020e4:	6963      	ldr	r3, [r4, #20]
 80020e6:	2a02      	cmp	r2, #2
 80020e8:	bf8c      	ite	hi
 80020ea:	f895 202d 	ldrbhi.w	r2, [r5, #45]	; 0x2d
 80020ee:	2200      	movls	r2, #0
 80020f0:	779a      	strb	r2, [r3, #30]
 80020f2:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80020f6:	6963      	ldr	r3, [r4, #20]
 80020f8:	2a03      	cmp	r2, #3
 80020fa:	bf8c      	ite	hi
 80020fc:	f895 202e 	ldrbhi.w	r2, [r5, #46]	; 0x2e
 8002100:	2200      	movls	r2, #0
 8002102:	77da      	strb	r2, [r3, #31]
 8002104:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002108:	6963      	ldr	r3, [r4, #20]
 800210a:	2a04      	cmp	r2, #4
 800210c:	bf8c      	ite	hi
 800210e:	f895 202f 	ldrbhi.w	r2, [r5, #47]	; 0x2f
 8002112:	2200      	movls	r2, #0
 8002114:	f883 2020 	strb.w	r2, [r3, #32]
 8002118:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800211c:	6963      	ldr	r3, [r4, #20]
 800211e:	2a05      	cmp	r2, #5
 8002120:	bf8c      	ite	hi
 8002122:	f895 2030 	ldrbhi.w	r2, [r5, #48]	; 0x30
 8002126:	2200      	movls	r2, #0
 8002128:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 800212c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002130:	6963      	ldr	r3, [r4, #20]
 8002132:	2a06      	cmp	r2, #6
 8002134:	bf8c      	ite	hi
 8002136:	f895 2031 	ldrbhi.w	r2, [r5, #49]	; 0x31
 800213a:	2200      	movls	r2, #0
 800213c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8002140:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002144:	6963      	ldr	r3, [r4, #20]
 8002146:	2a07      	cmp	r2, #7
 8002148:	bf8c      	ite	hi
 800214a:	f895 2032 	ldrbhi.w	r2, [r5, #50]	; 0x32
 800214e:	2200      	movls	r2, #0
 8002150:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
 8002154:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002158:	6963      	ldr	r3, [r4, #20]
 800215a:	2a08      	cmp	r2, #8
 800215c:	bf8c      	ite	hi
 800215e:	f895 2033 	ldrbhi.w	r2, [r5, #51]	; 0x33
 8002162:	2200      	movls	r2, #0
 8002164:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8002168:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800216c:	6963      	ldr	r3, [r4, #20]
 800216e:	2a09      	cmp	r2, #9
 8002170:	bf8c      	ite	hi
 8002172:	f895 2034 	ldrbhi.w	r2, [r5, #52]	; 0x34
 8002176:	2200      	movls	r2, #0
 8002178:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 800217c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002180:	6963      	ldr	r3, [r4, #20]
 8002182:	2a0a      	cmp	r2, #10
 8002184:	bf8c      	ite	hi
 8002186:	f895 2035 	ldrbhi.w	r2, [r5, #53]	; 0x35
 800218a:	2200      	movls	r2, #0
 800218c:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8002190:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002194:	6963      	ldr	r3, [r4, #20]
 8002196:	2a0b      	cmp	r2, #11
 8002198:	bf8c      	ite	hi
 800219a:	f895 2036 	ldrbhi.w	r2, [r5, #54]	; 0x36
 800219e:	2200      	movls	r2, #0
 80021a0:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 80021a4:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80021a8:	6963      	ldr	r3, [r4, #20]
 80021aa:	2a0c      	cmp	r2, #12
 80021ac:	bf8c      	ite	hi
 80021ae:	f895 2037 	ldrbhi.w	r2, [r5, #55]	; 0x37
 80021b2:	2200      	movls	r2, #0
 80021b4:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 80021b8:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80021bc:	6963      	ldr	r3, [r4, #20]
 80021be:	2a0d      	cmp	r2, #13
 80021c0:	bf8c      	ite	hi
 80021c2:	f895 2038 	ldrbhi.w	r2, [r5, #56]	; 0x38
 80021c6:	2200      	movls	r2, #0
 80021c8:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 80021cc:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80021d0:	6963      	ldr	r3, [r4, #20]
 80021d2:	2a0e      	cmp	r2, #14
 80021d4:	bf8c      	ite	hi
 80021d6:	f895 2039 	ldrbhi.w	r2, [r5, #57]	; 0x39
 80021da:	2200      	movls	r2, #0
 80021dc:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 80021e0:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 80021e4:	6962      	ldr	r2, [r4, #20]
 80021e6:	2b0f      	cmp	r3, #15
 80021e8:	bf8c      	ite	hi
 80021ea:	f895 103a 	ldrbhi.w	r1, [r5, #58]	; 0x3a
 80021ee:	2100      	movls	r1, #0
 80021f0:	2300      	movs	r3, #0
 80021f2:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
 80021f6:	4619      	mov	r1, r3
 80021f8:	6962      	ldr	r2, [r4, #20]
 80021fa:	441a      	add	r2, r3
 80021fc:	3301      	adds	r3, #1
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 80021fe:	2b40      	cmp	r3, #64	; 0x40
    dhcp->msg_out->sname[i] = 0;
 8002200:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8002204:	d1f8      	bne.n	80021f8 <dhcp_reboot+0x1cc>
 8002206:	2300      	movs	r3, #0
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
 8002208:	4618      	mov	r0, r3
 800220a:	6962      	ldr	r2, [r4, #20]
 800220c:	441a      	add	r2, r3
 800220e:	3301      	adds	r3, #1
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 8002210:	2b80      	cmp	r3, #128	; 0x80
    dhcp->msg_out->file[i] = 0;
 8002212:	f882 006c 	strb.w	r0, [r2, #108]	; 0x6c
 8002216:	f04f 0100 	mov.w	r1, #0
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 800221a:	d1f6      	bne.n	800220a <dhcp_reboot+0x1de>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 800221c:	6962      	ldr	r2, [r4, #20]
 800221e:	2363      	movs	r3, #99	; 0x63
 8002220:	f06f 067d 	mvn.w	r6, #125	; 0x7d
 8002224:	2053      	movs	r0, #83	; 0x53
 8002226:	f882 30ec 	strb.w	r3, [r2, #236]	; 0xec
 800222a:	f882 30ef 	strb.w	r3, [r2, #239]	; 0xef
 800222e:	f882 60ed 	strb.w	r6, [r2, #237]	; 0xed
 8002232:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
  dhcp->options_out_len = 0;
 8002236:	460b      	mov	r3, r1
 8002238:	8321      	strh	r1, [r4, #24]
 800223a:	e002      	b.n	8002242 <dhcp_reboot+0x216>
 800223c:	20000000 	.word	0x20000000
 8002240:	6962      	ldr	r2, [r4, #20]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 8002242:	441a      	add	r2, r3
 8002244:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
 8002248:	3301      	adds	r3, #1
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 800224a:	2b44      	cmp	r3, #68	; 0x44
 800224c:	d1f8      	bne.n	8002240 <dhcp_reboot+0x214>
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800224e:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8002250:	6962      	ldr	r2, [r4, #20]
 8002252:	441a      	add	r2, r3
 8002254:	2135      	movs	r1, #53	; 0x35
 8002256:	3301      	adds	r3, #1
 8002258:	8323      	strh	r3, [r4, #24]
 800225a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800225e:	8b23      	ldrh	r3, [r4, #24]
 8002260:	6962      	ldr	r2, [r4, #20]
 8002262:	441a      	add	r2, r3
 8002264:	2101      	movs	r1, #1
 8002266:	3301      	adds	r3, #1
 8002268:	8323      	strh	r3, [r4, #24]
 800226a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 800226e:	8b23      	ldrh	r3, [r4, #24]
 8002270:	6962      	ldr	r2, [r4, #20]
 8002272:	441a      	add	r2, r3
 8002274:	440b      	add	r3, r1
 8002276:	2103      	movs	r1, #3
 8002278:	8323      	strh	r3, [r4, #24]
 800227a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800227e:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8002280:	6962      	ldr	r2, [r4, #20]
 8002282:	441a      	add	r2, r3
 8002284:	2139      	movs	r1, #57	; 0x39
 8002286:	3301      	adds	r3, #1
 8002288:	8323      	strh	r3, [r4, #24]
 800228a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800228e:	8b23      	ldrh	r3, [r4, #24]
 8002290:	6962      	ldr	r2, [r4, #20]
 8002292:	441a      	add	r2, r3
 8002294:	2102      	movs	r1, #2
 8002296:	3301      	adds	r3, #1
 8002298:	8323      	strh	r3, [r4, #24]
 800229a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
 800229e:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 80022a0:	6962      	ldr	r2, [r4, #20]
 80022a2:	441a      	add	r2, r3
 80022a4:	3301      	adds	r3, #1
 80022a6:	8323      	strh	r3, [r4, #24]
 80022a8:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 80022ac:	8b23      	ldrh	r3, [r4, #24]
 80022ae:	6962      	ldr	r2, [r4, #20]
 80022b0:	441a      	add	r2, r3
 80022b2:	2140      	movs	r1, #64	; 0x40
 80022b4:	3301      	adds	r3, #1
 80022b6:	8323      	strh	r3, [r4, #24]
 80022b8:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 80022bc:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 80022be:	6962      	ldr	r2, [r4, #20]
 80022c0:	441a      	add	r2, r3
 80022c2:	2132      	movs	r1, #50	; 0x32
 80022c4:	3301      	adds	r3, #1
 80022c6:	8323      	strh	r3, [r4, #24]
 80022c8:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 80022cc:	6962      	ldr	r2, [r4, #20]
 80022ce:	8b23      	ldrh	r3, [r4, #24]
 80022d0:	441a      	add	r2, r3
 80022d2:	2104      	movs	r1, #4
 80022d4:	3301      	adds	r3, #1
 80022d6:	8323      	strh	r3, [r4, #24]
 80022d8:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    dhcp_option_short(dhcp, 576);

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 80022dc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80022de:	f7ff facf 	bl	8001880 <lwip_ntohl>
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
 80022e2:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 80022e4:	6962      	ldr	r2, [r4, #20]
 80022e6:	441a      	add	r2, r3
 80022e8:	0e01      	lsrs	r1, r0, #24
 80022ea:	3301      	adds	r3, #1
 80022ec:	8323      	strh	r3, [r4, #24]
 80022ee:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 80022f2:	8b23      	ldrh	r3, [r4, #24]
 80022f4:	6962      	ldr	r2, [r4, #20]
 80022f6:	441a      	add	r2, r3
 80022f8:	0c01      	lsrs	r1, r0, #16
 80022fa:	3301      	adds	r3, #1
 80022fc:	8323      	strh	r3, [r4, #24]
 80022fe:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 8002302:	8b23      	ldrh	r3, [r4, #24]
 8002304:	6962      	ldr	r2, [r4, #20]
 8002306:	441a      	add	r2, r3
 8002308:	0a01      	lsrs	r1, r0, #8
 800230a:	3301      	adds	r3, #1
 800230c:	8323      	strh	r3, [r4, #24]
 800230e:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 8002312:	8b23      	ldrh	r3, [r4, #24]
 8002314:	6962      	ldr	r2, [r4, #20]
 8002316:	441a      	add	r2, r3
 8002318:	3301      	adds	r3, #1
 800231a:	8323      	strh	r3, [r4, #24]
 800231c:	f882 00f0 	strb.w	r0, [r2, #240]	; 0xf0
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 8002320:	8b23      	ldrh	r3, [r4, #24]
 8002322:	6962      	ldr	r2, [r4, #20]
 8002324:	441a      	add	r2, r3
 8002326:	21ff      	movs	r1, #255	; 0xff
 8002328:	3301      	adds	r3, #1
 800232a:	8323      	strh	r3, [r4, #24]
 800232c:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 8002330:	8b23      	ldrh	r3, [r4, #24]
 8002332:	2b43      	cmp	r3, #67	; 0x43
 8002334:	d809      	bhi.n	800234a <dhcp_reboot+0x31e>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 8002336:	2100      	movs	r1, #0
 8002338:	6962      	ldr	r2, [r4, #20]
 800233a:	441a      	add	r2, r3
 800233c:	3301      	adds	r3, #1
 800233e:	8323      	strh	r3, [r4, #24]
 8002340:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 8002344:	8b23      	ldrh	r3, [r4, #24]
 8002346:	2b43      	cmp	r3, #67	; 0x43
 8002348:	d9f6      	bls.n	8002338 <dhcp_reboot+0x30c>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 800234a:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 800234e:	b289      	uxth	r1, r1
 8002350:	6920      	ldr	r0, [r4, #16]
 8002352:	f001 fea1 	bl	8004098 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 8002356:	6921      	ldr	r1, [r4, #16]
 8002358:	6860      	ldr	r0, [r4, #4]
 800235a:	4a18      	ldr	r2, [pc, #96]	; (80023bc <dhcp_reboot+0x390>)
 800235c:	9500      	str	r5, [sp, #0]
 800235e:	2343      	movs	r3, #67	; 0x43
 8002360:	f004 ffaa 	bl	80072b8 <udp_sendto_if>
dhcp_delete_msg(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 8002364:	6920      	ldr	r0, [r4, #16]
 8002366:	b108      	cbz	r0, 800236c <dhcp_reboot+0x340>
    pbuf_free(dhcp->p_out);
 8002368:	f001 ff16 	bl	8004198 <pbuf_free>
  }
  dhcp->p_out = NULL;
 800236c:	2000      	movs	r0, #0
 800236e:	6120      	str	r0, [r4, #16]
  dhcp->msg_out = NULL;
 8002370:	6160      	str	r0, [r4, #20]
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 8002372:	7b63      	ldrb	r3, [r4, #13]
 8002374:	3301      	adds	r3, #1
 8002376:	b2db      	uxtb	r3, r3
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 8002378:	2b09      	cmp	r3, #9
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 800237a:	7363      	strb	r3, [r4, #13]
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 800237c:	d816      	bhi.n	80023ac <dhcp_reboot+0x380>
 800237e:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 8002382:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8002386:	00db      	lsls	r3, r3, #3
 8002388:	b29b      	uxth	r3, r3
 800238a:	4a0d      	ldr	r2, [pc, #52]	; (80023c0 <dhcp_reboot+0x394>)
 800238c:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 8002390:	fb82 1203 	smull	r1, r2, r2, r3
 8002394:	17db      	asrs	r3, r3, #31
 8002396:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 800239a:	b29b      	uxth	r3, r3
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800239c:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 800239e:	b003      	add	sp, #12
 80023a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 80023a2:	4a08      	ldr	r2, [pc, #32]	; (80023c4 <dhcp_reboot+0x398>)
 80023a4:	6813      	ldr	r3, [r2, #0]
 80023a6:	3301      	adds	r3, #1
 80023a8:	6013      	str	r3, [r2, #0]
 80023aa:	e65b      	b.n	8002064 <dhcp_reboot+0x38>
 80023ac:	2314      	movs	r3, #20
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 80023ae:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 80023b0:	b003      	add	sp, #12
 80023b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
 80023b4:	f04f 30ff 	mov.w	r0, #4294967295
 80023b8:	e7db      	b.n	8002372 <dhcp_reboot+0x346>
 80023ba:	bf00      	nop
 80023bc:	0800c9dc 	.word	0x0800c9dc
 80023c0:	10624dd3 	.word	0x10624dd3
 80023c4:	20000000 	.word	0x20000000

080023c8 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
 80023c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct dhcp *dhcp = netif->dhcp;
 80023cc:	6a44      	ldr	r4, [r0, #36]	; 0x24
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 80023ce:	7b23      	ldrb	r3, [r4, #12]
 80023d0:	2b01      	cmp	r3, #1
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
 80023d2:	b082      	sub	sp, #8
 80023d4:	4605      	mov	r5, r0
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 80023d6:	d004      	beq.n	80023e2 <dhcp_select+0x1a>
    dhcp->state = new_state;
    dhcp->tries = 0;
 80023d8:	2300      	movs	r3, #0
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 80023da:	2201      	movs	r2, #1
 80023dc:	7322      	strb	r2, [r4, #12]
    dhcp->tries = 0;
 80023de:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 80023e0:	8363      	strh	r3, [r4, #26]
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 80023e2:	2200      	movs	r2, #0
 80023e4:	4610      	mov	r0, r2
 80023e6:	f44f 719a 	mov.w	r1, #308	; 0x134
 80023ea:	f001 fd7d 	bl	8003ee8 <pbuf_alloc>
 80023ee:	6120      	str	r0, [r4, #16]
  if (dhcp->p_out == NULL) {
 80023f0:	2800      	cmp	r0, #0
 80023f2:	f000 820e 	beq.w	8002812 <dhcp_select+0x44a>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 80023f6:	7b63      	ldrb	r3, [r4, #13]
 80023f8:	2b00      	cmp	r3, #0
 80023fa:	f000 8200 	beq.w	80027fe <dhcp_select+0x436>
 80023fe:	4b77      	ldr	r3, [pc, #476]	; (80025dc <dhcp_select+0x214>)
 8002400:	681b      	ldr	r3, [r3, #0]
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 8002402:	6841      	ldr	r1, [r0, #4]
 8002404:	6161      	str	r1, [r4, #20]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 8002406:	2201      	movs	r2, #1
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 8002408:	6023      	str	r3, [r4, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 800240a:	700a      	strb	r2, [r1, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 800240c:	6963      	ldr	r3, [r4, #20]
 800240e:	705a      	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
 8002410:	6963      	ldr	r3, [r4, #20]
 8002412:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002416:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
 8002418:	6963      	ldr	r3, [r4, #20]
 800241a:	2600      	movs	r6, #0
 800241c:	70de      	strb	r6, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
 800241e:	6820      	ldr	r0, [r4, #0]
 8002420:	6967      	ldr	r7, [r4, #20]
 8002422:	f7ff fa2b 	bl	800187c <lwip_htonl>
  dhcp->msg_out->secs = 0;
 8002426:	6963      	ldr	r3, [r4, #20]
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
 8002428:	6078      	str	r0, [r7, #4]
  dhcp->msg_out->secs = 0;
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
 800242a:	731e      	strb	r6, [r3, #12]
 800242c:	735e      	strb	r6, [r3, #13]
 800242e:	739e      	strb	r6, [r3, #14]
 8002430:	73de      	strb	r6, [r3, #15]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
  dhcp->msg_out->secs = 0;
 8002432:	721e      	strb	r6, [r3, #8]
 8002434:	725e      	strb	r6, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 8002436:	729e      	strb	r6, [r3, #10]
 8002438:	72de      	strb	r6, [r3, #11]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
 800243a:	7b22      	ldrb	r2, [r4, #12]
 800243c:	3a04      	subs	r2, #4
 800243e:	2a01      	cmp	r2, #1
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
 8002440:	bf9c      	itt	ls
 8002442:	686a      	ldrls	r2, [r5, #4]
 8002444:	60da      	strls	r2, [r3, #12]
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 8002446:	2200      	movs	r2, #0
 8002448:	741a      	strb	r2, [r3, #16]
 800244a:	745a      	strb	r2, [r3, #17]
 800244c:	749a      	strb	r2, [r3, #18]
 800244e:	74da      	strb	r2, [r3, #19]
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 8002450:	751a      	strb	r2, [r3, #20]
 8002452:	755a      	strb	r2, [r3, #21]
 8002454:	759a      	strb	r2, [r3, #22]
 8002456:	75da      	strb	r2, [r3, #23]
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 8002458:	761a      	strb	r2, [r3, #24]
 800245a:	765a      	strb	r2, [r3, #25]
 800245c:	769a      	strb	r2, [r3, #26]
 800245e:	76da      	strb	r2, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 8002460:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002464:	b10a      	cbz	r2, 800246a <dhcp_select+0xa2>
 8002466:	f895 202b 	ldrb.w	r2, [r5, #43]	; 0x2b
 800246a:	771a      	strb	r2, [r3, #28]
 800246c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002470:	6963      	ldr	r3, [r4, #20]
 8002472:	2a01      	cmp	r2, #1
 8002474:	bf8c      	ite	hi
 8002476:	f895 202c 	ldrbhi.w	r2, [r5, #44]	; 0x2c
 800247a:	2200      	movls	r2, #0
 800247c:	775a      	strb	r2, [r3, #29]
 800247e:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002482:	6963      	ldr	r3, [r4, #20]
 8002484:	2a02      	cmp	r2, #2
 8002486:	bf8c      	ite	hi
 8002488:	f895 202d 	ldrbhi.w	r2, [r5, #45]	; 0x2d
 800248c:	2200      	movls	r2, #0
 800248e:	779a      	strb	r2, [r3, #30]
 8002490:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002494:	6963      	ldr	r3, [r4, #20]
 8002496:	2a03      	cmp	r2, #3
 8002498:	bf8c      	ite	hi
 800249a:	f895 202e 	ldrbhi.w	r2, [r5, #46]	; 0x2e
 800249e:	2200      	movls	r2, #0
 80024a0:	77da      	strb	r2, [r3, #31]
 80024a2:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80024a6:	6963      	ldr	r3, [r4, #20]
 80024a8:	2a04      	cmp	r2, #4
 80024aa:	bf8c      	ite	hi
 80024ac:	f895 202f 	ldrbhi.w	r2, [r5, #47]	; 0x2f
 80024b0:	2200      	movls	r2, #0
 80024b2:	f883 2020 	strb.w	r2, [r3, #32]
 80024b6:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80024ba:	6963      	ldr	r3, [r4, #20]
 80024bc:	2a05      	cmp	r2, #5
 80024be:	bf8c      	ite	hi
 80024c0:	f895 2030 	ldrbhi.w	r2, [r5, #48]	; 0x30
 80024c4:	2200      	movls	r2, #0
 80024c6:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 80024ca:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80024ce:	6963      	ldr	r3, [r4, #20]
 80024d0:	2a06      	cmp	r2, #6
 80024d2:	bf8c      	ite	hi
 80024d4:	f895 2031 	ldrbhi.w	r2, [r5, #49]	; 0x31
 80024d8:	2200      	movls	r2, #0
 80024da:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 80024de:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80024e2:	6963      	ldr	r3, [r4, #20]
 80024e4:	2a07      	cmp	r2, #7
 80024e6:	bf8c      	ite	hi
 80024e8:	f895 2032 	ldrbhi.w	r2, [r5, #50]	; 0x32
 80024ec:	2200      	movls	r2, #0
 80024ee:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
 80024f2:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80024f6:	6963      	ldr	r3, [r4, #20]
 80024f8:	2a08      	cmp	r2, #8
 80024fa:	bf8c      	ite	hi
 80024fc:	f895 2033 	ldrbhi.w	r2, [r5, #51]	; 0x33
 8002500:	2200      	movls	r2, #0
 8002502:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8002506:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800250a:	6963      	ldr	r3, [r4, #20]
 800250c:	2a09      	cmp	r2, #9
 800250e:	bf8c      	ite	hi
 8002510:	f895 2034 	ldrbhi.w	r2, [r5, #52]	; 0x34
 8002514:	2200      	movls	r2, #0
 8002516:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 800251a:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800251e:	6963      	ldr	r3, [r4, #20]
 8002520:	2a0a      	cmp	r2, #10
 8002522:	bf8c      	ite	hi
 8002524:	f895 2035 	ldrbhi.w	r2, [r5, #53]	; 0x35
 8002528:	2200      	movls	r2, #0
 800252a:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 800252e:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002532:	6963      	ldr	r3, [r4, #20]
 8002534:	2a0b      	cmp	r2, #11
 8002536:	bf8c      	ite	hi
 8002538:	f895 2036 	ldrbhi.w	r2, [r5, #54]	; 0x36
 800253c:	2200      	movls	r2, #0
 800253e:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 8002542:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002546:	6963      	ldr	r3, [r4, #20]
 8002548:	2a0c      	cmp	r2, #12
 800254a:	bf8c      	ite	hi
 800254c:	f895 2037 	ldrbhi.w	r2, [r5, #55]	; 0x37
 8002550:	2200      	movls	r2, #0
 8002552:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8002556:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800255a:	6963      	ldr	r3, [r4, #20]
 800255c:	2a0d      	cmp	r2, #13
 800255e:	bf8c      	ite	hi
 8002560:	f895 2038 	ldrbhi.w	r2, [r5, #56]	; 0x38
 8002564:	2200      	movls	r2, #0
 8002566:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 800256a:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800256e:	6963      	ldr	r3, [r4, #20]
 8002570:	2a0e      	cmp	r2, #14
 8002572:	bf8c      	ite	hi
 8002574:	f895 2039 	ldrbhi.w	r2, [r5, #57]	; 0x39
 8002578:	2200      	movls	r2, #0
 800257a:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 800257e:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 8002582:	6962      	ldr	r2, [r4, #20]
 8002584:	2b0f      	cmp	r3, #15
 8002586:	bf8c      	ite	hi
 8002588:	f895 103a 	ldrbhi.w	r1, [r5, #58]	; 0x3a
 800258c:	2100      	movls	r1, #0
 800258e:	2300      	movs	r3, #0
 8002590:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
 8002594:	4619      	mov	r1, r3
 8002596:	6962      	ldr	r2, [r4, #20]
 8002598:	441a      	add	r2, r3
 800259a:	3301      	adds	r3, #1
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 800259c:	2b40      	cmp	r3, #64	; 0x40
    dhcp->msg_out->sname[i] = 0;
 800259e:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 80025a2:	d1f8      	bne.n	8002596 <dhcp_select+0x1ce>
 80025a4:	2300      	movs	r3, #0
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
 80025a6:	4618      	mov	r0, r3
 80025a8:	6962      	ldr	r2, [r4, #20]
 80025aa:	441a      	add	r2, r3
 80025ac:	3301      	adds	r3, #1
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 80025ae:	2b80      	cmp	r3, #128	; 0x80
    dhcp->msg_out->file[i] = 0;
 80025b0:	f882 006c 	strb.w	r0, [r2, #108]	; 0x6c
 80025b4:	f04f 0100 	mov.w	r1, #0
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 80025b8:	d1f6      	bne.n	80025a8 <dhcp_select+0x1e0>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 80025ba:	6962      	ldr	r2, [r4, #20]
 80025bc:	2363      	movs	r3, #99	; 0x63
 80025be:	f06f 067d 	mvn.w	r6, #125	; 0x7d
 80025c2:	2053      	movs	r0, #83	; 0x53
 80025c4:	f882 30ec 	strb.w	r3, [r2, #236]	; 0xec
 80025c8:	f882 30ef 	strb.w	r3, [r2, #239]	; 0xef
 80025cc:	f882 60ed 	strb.w	r6, [r2, #237]	; 0xed
 80025d0:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
  dhcp->options_out_len = 0;
 80025d4:	460b      	mov	r3, r1
 80025d6:	8321      	strh	r1, [r4, #24]
 80025d8:	e003      	b.n	80025e2 <dhcp_select+0x21a>
 80025da:	bf00      	nop
 80025dc:	20000000 	.word	0x20000000
 80025e0:	6962      	ldr	r2, [r4, #20]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 80025e2:	441a      	add	r2, r3
 80025e4:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
 80025e8:	3301      	adds	r3, #1
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 80025ea:	2b44      	cmp	r3, #68	; 0x44
 80025ec:	d1f8      	bne.n	80025e0 <dhcp_select+0x218>
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 80025ee:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 80025f0:	6962      	ldr	r2, [r4, #20]
 80025f2:	441a      	add	r2, r3
 80025f4:	2135      	movs	r1, #53	; 0x35
 80025f6:	3301      	adds	r3, #1
 80025f8:	8323      	strh	r3, [r4, #24]
 80025fa:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 80025fe:	8b23      	ldrh	r3, [r4, #24]
 8002600:	6962      	ldr	r2, [r4, #20]
 8002602:	441a      	add	r2, r3
 8002604:	2701      	movs	r7, #1
 8002606:	3301      	adds	r3, #1
 8002608:	8323      	strh	r3, [r4, #24]
 800260a:	f882 70f0 	strb.w	r7, [r2, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 800260e:	8b23      	ldrh	r3, [r4, #24]
 8002610:	6962      	ldr	r2, [r4, #20]
 8002612:	441a      	add	r2, r3
 8002614:	2603      	movs	r6, #3
 8002616:	443b      	add	r3, r7
 8002618:	8323      	strh	r3, [r4, #24]
 800261a:	f882 60f0 	strb.w	r6, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800261e:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8002620:	6962      	ldr	r2, [r4, #20]
 8002622:	441a      	add	r2, r3
 8002624:	2139      	movs	r1, #57	; 0x39
 8002626:	443b      	add	r3, r7
 8002628:	8323      	strh	r3, [r4, #24]
 800262a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800262e:	8b23      	ldrh	r3, [r4, #24]
 8002630:	6962      	ldr	r2, [r4, #20]
 8002632:	441a      	add	r2, r3
 8002634:	2102      	movs	r1, #2
 8002636:	443b      	add	r3, r7
 8002638:	8323      	strh	r3, [r4, #24]
 800263a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
 800263e:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 8002640:	6962      	ldr	r2, [r4, #20]

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 8002642:	8d29      	ldrh	r1, [r5, #40]	; 0x28

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 8002644:	441a      	add	r2, r3
 8002646:	0a08      	lsrs	r0, r1, #8
 8002648:	443b      	add	r3, r7
 800264a:	8323      	strh	r3, [r4, #24]
 800264c:	f882 00f0 	strb.w	r0, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 8002650:	8b23      	ldrh	r3, [r4, #24]
 8002652:	6962      	ldr	r2, [r4, #20]
 8002654:	441a      	add	r2, r3
 8002656:	443b      	add	r3, r7
 8002658:	8323      	strh	r3, [r4, #24]
 800265a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800265e:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8002660:	6962      	ldr	r2, [r4, #20]
 8002662:	441a      	add	r2, r3
 8002664:	2132      	movs	r1, #50	; 0x32
 8002666:	443b      	add	r3, r7
 8002668:	8323      	strh	r3, [r4, #24]
 800266a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800266e:	8b23      	ldrh	r3, [r4, #24]
 8002670:	6962      	ldr	r2, [r4, #20]
 8002672:	441a      	add	r2, r3
 8002674:	f04f 0804 	mov.w	r8, #4
 8002678:	443b      	add	r3, r7
 800267a:	8323      	strh	r3, [r4, #24]
 800267c:	f882 80f0 	strb.w	r8, [r2, #240]	; 0xf0
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 8002680:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002682:	f7ff f8fd 	bl	8001880 <lwip_ntohl>
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
 8002686:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 8002688:	6962      	ldr	r2, [r4, #20]
 800268a:	441a      	add	r2, r3
 800268c:	0e01      	lsrs	r1, r0, #24
 800268e:	443b      	add	r3, r7
 8002690:	8323      	strh	r3, [r4, #24]
 8002692:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 8002696:	8b23      	ldrh	r3, [r4, #24]
 8002698:	6962      	ldr	r2, [r4, #20]
 800269a:	441a      	add	r2, r3
 800269c:	0c01      	lsrs	r1, r0, #16
 800269e:	443b      	add	r3, r7
 80026a0:	8323      	strh	r3, [r4, #24]
 80026a2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 80026a6:	8b23      	ldrh	r3, [r4, #24]
 80026a8:	6962      	ldr	r2, [r4, #20]
 80026aa:	441a      	add	r2, r3
 80026ac:	0a01      	lsrs	r1, r0, #8
 80026ae:	443b      	add	r3, r7
 80026b0:	8323      	strh	r3, [r4, #24]
 80026b2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 80026b6:	8b23      	ldrh	r3, [r4, #24]
 80026b8:	6962      	ldr	r2, [r4, #20]
 80026ba:	441a      	add	r2, r3
 80026bc:	443b      	add	r3, r7
 80026be:	8323      	strh	r3, [r4, #24]
 80026c0:	f882 00f0 	strb.w	r0, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 80026c4:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 80026c6:	6962      	ldr	r2, [r4, #20]
 80026c8:	441a      	add	r2, r3
 80026ca:	2136      	movs	r1, #54	; 0x36
 80026cc:	443b      	add	r3, r7
 80026ce:	8323      	strh	r3, [r4, #24]
 80026d0:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 80026d4:	8b23      	ldrh	r3, [r4, #24]
 80026d6:	6962      	ldr	r2, [r4, #20]
 80026d8:	441a      	add	r2, r3
 80026da:	443b      	add	r3, r7
 80026dc:	8323      	strh	r3, [r4, #24]
 80026de:	f882 80f0 	strb.w	r8, [r2, #240]	; 0xf0
    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
 80026e2:	6a20      	ldr	r0, [r4, #32]
 80026e4:	f7ff f8cc 	bl	8001880 <lwip_ntohl>
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
 80026e8:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 80026ea:	6962      	ldr	r2, [r4, #20]
 80026ec:	441a      	add	r2, r3
 80026ee:	0e01      	lsrs	r1, r0, #24
 80026f0:	443b      	add	r3, r7
 80026f2:	8323      	strh	r3, [r4, #24]
 80026f4:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 80026f8:	8b23      	ldrh	r3, [r4, #24]
 80026fa:	6962      	ldr	r2, [r4, #20]
 80026fc:	441a      	add	r2, r3
 80026fe:	0c01      	lsrs	r1, r0, #16
 8002700:	443b      	add	r3, r7
 8002702:	8323      	strh	r3, [r4, #24]
 8002704:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 8002708:	8b23      	ldrh	r3, [r4, #24]
 800270a:	6962      	ldr	r2, [r4, #20]
 800270c:	441a      	add	r2, r3
 800270e:	0a01      	lsrs	r1, r0, #8
 8002710:	443b      	add	r3, r7
 8002712:	8323      	strh	r3, [r4, #24]
 8002714:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 8002718:	8b23      	ldrh	r3, [r4, #24]
 800271a:	6962      	ldr	r2, [r4, #20]
 800271c:	441a      	add	r2, r3
 800271e:	443b      	add	r3, r7
 8002720:	8323      	strh	r3, [r4, #24]
 8002722:	f882 00f0 	strb.w	r0, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 8002726:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8002728:	6962      	ldr	r2, [r4, #20]
 800272a:	441a      	add	r2, r3
 800272c:	2137      	movs	r1, #55	; 0x37
 800272e:	443b      	add	r3, r7
 8002730:	8323      	strh	r3, [r4, #24]
 8002732:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 8002736:	8b23      	ldrh	r3, [r4, #24]
 8002738:	6962      	ldr	r2, [r4, #20]
 800273a:	441a      	add	r2, r3
 800273c:	443b      	add	r3, r7
 800273e:	8323      	strh	r3, [r4, #24]
 8002740:	f882 80f0 	strb.w	r8, [r2, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 8002744:	8b23      	ldrh	r3, [r4, #24]
 8002746:	6962      	ldr	r2, [r4, #20]
 8002748:	441a      	add	r2, r3
 800274a:	443b      	add	r3, r7
 800274c:	8323      	strh	r3, [r4, #24]
 800274e:	f882 70f0 	strb.w	r7, [r2, #240]	; 0xf0
 8002752:	8b23      	ldrh	r3, [r4, #24]
 8002754:	6962      	ldr	r2, [r4, #20]
 8002756:	441a      	add	r2, r3
 8002758:	443b      	add	r3, r7
 800275a:	8323      	strh	r3, [r4, #24]
 800275c:	f882 60f0 	strb.w	r6, [r2, #240]	; 0xf0
 8002760:	6962      	ldr	r2, [r4, #20]
 8002762:	8b23      	ldrh	r3, [r4, #24]
 8002764:	441a      	add	r2, r3
 8002766:	211c      	movs	r1, #28
 8002768:	443b      	add	r3, r7
 800276a:	8323      	strh	r3, [r4, #24]
 800276c:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 8002770:	8b23      	ldrh	r3, [r4, #24]
 8002772:	6962      	ldr	r2, [r4, #20]
 8002774:	441a      	add	r2, r3
 8002776:	2106      	movs	r1, #6
 8002778:	443b      	add	r3, r7
 800277a:	8323      	strh	r3, [r4, #24]
 800277c:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 8002780:	8b23      	ldrh	r3, [r4, #24]
 8002782:	6962      	ldr	r2, [r4, #20]
 8002784:	441a      	add	r2, r3
 8002786:	21ff      	movs	r1, #255	; 0xff
 8002788:	443b      	add	r3, r7
 800278a:	8323      	strh	r3, [r4, #24]
 800278c:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 8002790:	8b23      	ldrh	r3, [r4, #24]
 8002792:	2b43      	cmp	r3, #67	; 0x43
 8002794:	d809      	bhi.n	80027aa <dhcp_select+0x3e2>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 8002796:	2100      	movs	r1, #0
 8002798:	6962      	ldr	r2, [r4, #20]
 800279a:	441a      	add	r2, r3
 800279c:	3301      	adds	r3, #1
 800279e:	8323      	strh	r3, [r4, #24]
 80027a0:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 80027a4:	8b23      	ldrh	r3, [r4, #24]
 80027a6:	2b43      	cmp	r3, #67	; 0x43
 80027a8:	d9f6      	bls.n	8002798 <dhcp_select+0x3d0>
    dhcp_option_hostname(dhcp, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 80027aa:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 80027ae:	b289      	uxth	r1, r1
 80027b0:	6920      	ldr	r0, [r4, #16]
 80027b2:	f001 fc71 	bl	8004098 <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 80027b6:	6921      	ldr	r1, [r4, #16]
 80027b8:	6860      	ldr	r0, [r4, #4]
 80027ba:	4a17      	ldr	r2, [pc, #92]	; (8002818 <dhcp_select+0x450>)
 80027bc:	9500      	str	r5, [sp, #0]
 80027be:	2343      	movs	r3, #67	; 0x43
 80027c0:	f004 fd7a 	bl	80072b8 <udp_sendto_if>
dhcp_delete_msg(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 80027c4:	6920      	ldr	r0, [r4, #16]
 80027c6:	b108      	cbz	r0, 80027cc <dhcp_select+0x404>
    pbuf_free(dhcp->p_out);
 80027c8:	f001 fce6 	bl	8004198 <pbuf_free>
  }
  dhcp->p_out = NULL;
 80027cc:	2000      	movs	r0, #0
 80027ce:	6120      	str	r0, [r4, #16]
  dhcp->msg_out = NULL;
 80027d0:	6160      	str	r0, [r4, #20]
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 80027d2:	7b63      	ldrb	r3, [r4, #13]
 80027d4:	3301      	adds	r3, #1
 80027d6:	b2da      	uxtb	r2, r3
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 80027d8:	2a05      	cmp	r2, #5
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 80027da:	7362      	strb	r2, [r4, #13]
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 80027dc:	d814      	bhi.n	8002808 <dhcp_select+0x440>
 80027de:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80027e2:	4093      	lsls	r3, r2
 80027e4:	4a0d      	ldr	r2, [pc, #52]	; (800281c <dhcp_select+0x454>)
 80027e6:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 80027ea:	fb82 1203 	smull	r1, r2, r2, r3
 80027ee:	17db      	asrs	r3, r3, #31
 80027f0:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 80027f4:	b29b      	uxth	r3, r3
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 80027f6:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 80027f8:	b002      	add	sp, #8
 80027fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 80027fe:	4a08      	ldr	r2, [pc, #32]	; (8002820 <dhcp_select+0x458>)
 8002800:	6813      	ldr	r3, [r2, #0]
 8002802:	3301      	adds	r3, #1
 8002804:	6013      	str	r3, [r2, #0]
 8002806:	e5fc      	b.n	8002402 <dhcp_select+0x3a>
 8002808:	2378      	movs	r3, #120	; 0x78
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800280a:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 800280c:	b002      	add	sp, #8
 800280e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
 8002812:	f04f 30ff 	mov.w	r0, #4294967295
 8002816:	e7dc      	b.n	80027d2 <dhcp_select+0x40a>
 8002818:	0800c9dc 	.word	0x0800c9dc
 800281c:	10624dd3 	.word	0x10624dd3
 8002820:	20000000 	.word	0x20000000

08002824 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
 8002824:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
 8002828:	8953      	ldrh	r3, [r2, #10]
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
 800282a:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
 800282e:	2b2b      	cmp	r3, #43	; 0x2b
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
 8002830:	b08b      	sub	sp, #44	; 0x2c
 8002832:	4691      	mov	r9, r2
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
 8002834:	d903      	bls.n	800283e <dhcp_recv+0x1a>
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
 8002836:	6853      	ldr	r3, [r2, #4]
  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
 8002838:	781a      	ldrb	r2, [r3, #0]
 800283a:	2a02      	cmp	r2, #2
 800283c:	d008      	beq.n	8002850 <dhcp_recv+0x2c>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = NULL;
 800283e:	2300      	movs	r3, #0
  pbuf_free(p);
 8002840:	4648      	mov	r0, r9
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = NULL;
 8002842:	f8cb 3008 	str.w	r3, [fp, #8]
  pbuf_free(p);
 8002846:	f001 fca7 	bl	8004198 <pbuf_free>
}
 800284a:	b00b      	add	sp, #44	; 0x2c
 800284c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 8002850:	f890 202a 	ldrb.w	r2, [r0, #42]	; 0x2a
 8002854:	4682      	mov	sl, r0
 8002856:	b34a      	cbz	r2, 80028ac <dhcp_recv+0x88>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 8002858:	f890 002b 	ldrb.w	r0, [r0, #43]	; 0x2b
 800285c:	7f19      	ldrb	r1, [r3, #28]
 800285e:	4288      	cmp	r0, r1
 8002860:	d1ed      	bne.n	800283e <dhcp_recv+0x1a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 8002862:	2a01      	cmp	r2, #1
 8002864:	d922      	bls.n	80028ac <dhcp_recv+0x88>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 8002866:	7f58      	ldrb	r0, [r3, #29]
 8002868:	f89a 102c 	ldrb.w	r1, [sl, #44]	; 0x2c
 800286c:	4288      	cmp	r0, r1
 800286e:	d1e6      	bne.n	800283e <dhcp_recv+0x1a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 8002870:	2a02      	cmp	r2, #2
 8002872:	d01b      	beq.n	80028ac <dhcp_recv+0x88>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 8002874:	7f98      	ldrb	r0, [r3, #30]
 8002876:	f89a 102d 	ldrb.w	r1, [sl, #45]	; 0x2d
 800287a:	4288      	cmp	r0, r1
 800287c:	d1df      	bne.n	800283e <dhcp_recv+0x1a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 800287e:	2a03      	cmp	r2, #3
 8002880:	d014      	beq.n	80028ac <dhcp_recv+0x88>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 8002882:	7fd8      	ldrb	r0, [r3, #31]
 8002884:	f89a 102e 	ldrb.w	r1, [sl, #46]	; 0x2e
 8002888:	4288      	cmp	r0, r1
 800288a:	d1d8      	bne.n	800283e <dhcp_recv+0x1a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 800288c:	2a04      	cmp	r2, #4
 800288e:	d00d      	beq.n	80028ac <dhcp_recv+0x88>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 8002890:	f893 0020 	ldrb.w	r0, [r3, #32]
 8002894:	f89a 102f 	ldrb.w	r1, [sl, #47]	; 0x2f
 8002898:	4288      	cmp	r0, r1
 800289a:	d1d0      	bne.n	800283e <dhcp_recv+0x1a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 800289c:	2a05      	cmp	r2, #5
 800289e:	d005      	beq.n	80028ac <dhcp_recv+0x88>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 80028a0:	f893 1021 	ldrb.w	r1, [r3, #33]	; 0x21
 80028a4:	f89a 2030 	ldrb.w	r2, [sl, #48]	; 0x30
 80028a8:	4291      	cmp	r1, r2
 80028aa:	d1c8      	bne.n	800283e <dhcp_recv+0x1a>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
 80028ac:	6858      	ldr	r0, [r3, #4]
 80028ae:	f7fe ffe7 	bl	8001880 <lwip_ntohl>
 80028b2:	f8db 3000 	ldr.w	r3, [fp]
 80028b6:	4298      	cmp	r0, r3
 80028b8:	d1c1      	bne.n	800283e <dhcp_recv+0x1a>
  struct pbuf *q;
  int parse_file_as_options = 0;
  int parse_sname_as_options = 0;

  /* clear received options */
  dhcp_clear_all_options(dhcp);
 80028ba:	4b9e      	ldr	r3, [pc, #632]	; (8002b34 <dhcp_recv+0x310>)
 80028bc:	499d      	ldr	r1, [pc, #628]	; (8002b34 <dhcp_recv+0x310>)
 80028be:	2200      	movs	r2, #0
 80028c0:	605a      	str	r2, [r3, #4]
 80028c2:	811a      	strh	r2, [r3, #8]
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
 80028c4:	f8b9 300a 	ldrh.w	r3, [r9, #10]
  struct pbuf *q;
  int parse_file_as_options = 0;
  int parse_sname_as_options = 0;

  /* clear received options */
  dhcp_clear_all_options(dhcp);
 80028c8:	600a      	str	r2, [r1, #0]
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
 80028ca:	2b2b      	cmp	r3, #43	; 0x2b
 80028cc:	d9b7      	bls.n	800283e <dhcp_recv+0x1a>
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
  int parse_sname_as_options = 0;
 80028ce:	9206      	str	r2, [sp, #24]
  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
 80028d0:	f8b9 2008 	ldrh.w	r2, [r9, #8]
  dhcp_clear_all_options(dhcp);
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
    return ERR_BUF;
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
 80028d4:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80028d8:	f8cb 1008 	str.w	r1, [fp, #8]
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
 80028dc:	f04f 08f0 	mov.w	r8, #240	; 0xf0
 80028e0:	f8cd b010 	str.w	fp, [sp, #16]
 80028e4:	f8cd a01c 	str.w	sl, [sp, #28]
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
 80028e8:	9201      	str	r2, [sp, #4]
 80028ea:	46c2      	mov	sl, r8
 80028ec:	f8cd 900c 	str.w	r9, [sp, #12]
 80028f0:	4693      	mov	fp, r2
 80028f2:	464a      	mov	r2, r9
 80028f4:	e000      	b.n	80028f8 <dhcp_recv+0xd4>
 80028f6:	8953      	ldrh	r3, [r2, #10]
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
 80028f8:	459a      	cmp	sl, r3
    options_idx -= q->len;
 80028fa:	ebc3 010a 	rsb	r1, r3, sl
    options_idx_max -= q->len;
 80028fe:	ebc3 030b 	rsb	r3, r3, fp
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
 8002902:	d30b      	bcc.n	800291c <dhcp_recv+0xf8>
    options_idx -= q->len;
    options_idx_max -= q->len;
    q = q->next;
 8002904:	6812      	ldr	r2, [r2, #0]
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
    options_idx -= q->len;
 8002906:	fa1f fa81 	uxth.w	sl, r1
    options_idx_max -= q->len;
 800290a:	fa1f fb83 	uxth.w	fp, r3
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
 800290e:	2a00      	cmp	r2, #0
 8002910:	d1f1      	bne.n	80028f6 <dhcp_recv+0xd2>
 8002912:	f8dd b010 	ldr.w	fp, [sp, #16]
 8002916:	f8dd 900c 	ldr.w	r9, [sp, #12]
 800291a:	e790      	b.n	800283e <dhcp_recv+0x1a>
  if (q == NULL) {
    return ERR_BUF;
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t*)q->payload;
 800291c:	6853      	ldr	r3, [r2, #4]
 800291e:	f8cd b004 	str.w	fp, [sp, #4]
 8002922:	9302      	str	r3, [sp, #8]
 8002924:	4693      	mov	fp, r2
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
 8002926:	9b02      	ldr	r3, [sp, #8]
 8002928:	f813 200a 	ldrb.w	r2, [r3, sl]
 800292c:	2aff      	cmp	r2, #255	; 0xff
 800292e:	f000 80df 	beq.w	8002af0 <dhcp_recv+0x2cc>
 8002932:	9b01      	ldr	r3, [sp, #4]
 8002934:	459a      	cmp	sl, r3
 8002936:	f080 80db 	bcs.w	8002af0 <dhcp_recv+0x2cc>
    u8_t len;
    u8_t decode_len = 0;
    int decode_idx = -1;
    u16_t val_offset = offset + 2;
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
 800293a:	f8bb 300a 	ldrh.w	r3, [fp, #10]
 800293e:	f10a 0101 	add.w	r1, sl, #1
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    u8_t op = options[offset];
    u8_t len;
    u8_t decode_len = 0;
    int decode_idx = -1;
    u16_t val_offset = offset + 2;
 8002942:	f10a 0502 	add.w	r5, sl, #2
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
 8002946:	4299      	cmp	r1, r3
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    u8_t op = options[offset];
    u8_t len;
    u8_t decode_len = 0;
    int decode_idx = -1;
    u16_t val_offset = offset + 2;
 8002948:	b2ad      	uxth	r5, r5
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
 800294a:	f280 809f 	bge.w	8002a8c <dhcp_recv+0x268>
      len = options[offset + 1];
 800294e:	9802      	ldr	r0, [sp, #8]
 8002950:	4482      	add	sl, r0
 8002952:	f89a 4001 	ldrb.w	r4, [sl, #1]
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
    switch(op) {
 8002956:	2a3b      	cmp	r2, #59	; 0x3b
 8002958:	f200 8096 	bhi.w	8002a88 <dhcp_recv+0x264>
 800295c:	e8df f002 	tbb	[pc, r2]
 8002960:	8c941e53 	.word	0x8c941e53
 8002964:	947a9494 	.word	0x947a9494
 8002968:	94949494 	.word	0x94949494
 800296c:	94949494 	.word	0x94949494
 8002970:	94949494 	.word	0x94949494
 8002974:	94949494 	.word	0x94949494
 8002978:	94949494 	.word	0x94949494
 800297c:	94949494 	.word	0x94949494
 8002980:	94949494 	.word	0x94949494
 8002984:	94949494 	.word	0x94949494
 8002988:	94949494 	.word	0x94949494
 800298c:	94949494 	.word	0x94949494
 8002990:	74949494 	.word	0x74949494
 8002994:	94656b6e 	.word	0x94656b6e
 8002998:	595f9494 	.word	0x595f9494
        decode_len = len = 0;
        /* will be increased below */
        offset--;
        break;
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 800299c:	2c04      	cmp	r4, #4
 800299e:	d1b8      	bne.n	8002912 <dhcp_recv+0xee>
 80029a0:	46a2      	mov	sl, r4
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
 80029a2:	2706      	movs	r7, #6
      default:
        decode_len = 0;
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    }
    offset += len + 2;
 80029a4:	44aa      	add	sl, r5
 80029a6:	fa1f fa8a 	uxth.w	sl, sl
    if (decode_len > 0) {
      u32_t value = 0;
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
 80029aa:	4a62      	ldr	r2, [pc, #392]	; (8002b34 <dhcp_recv+0x310>)
 80029ac:	5dd2      	ldrb	r2, [r2, r7]
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    }
    offset += len + 2;
    if (decode_len > 0) {
      u32_t value = 0;
 80029ae:	2100      	movs	r1, #0
 80029b0:	9109      	str	r1, [sp, #36]	; 0x24
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
 80029b2:	b9b2      	cbnz	r2, 80029e2 <dhcp_recv+0x1be>
        copy_len = LWIP_MIN(decode_len, 4);
 80029b4:	2c03      	cmp	r4, #3
 80029b6:	d870      	bhi.n	8002a9a <dhcp_recv+0x276>
 80029b8:	f10d 0924 	add.w	r9, sp, #36	; 0x24
        pbuf_copy_partial(q, &value, copy_len, val_offset);
 80029bc:	462b      	mov	r3, r5
 80029be:	4649      	mov	r1, r9
 80029c0:	4622      	mov	r2, r4
 80029c2:	4658      	mov	r0, fp
 80029c4:	f001 fcbe 	bl	8004344 <pbuf_copy_partial>
          decode_idx++;
          goto decode_next;
        } else if (decode_len == 4) {
          value = ntohl(value);
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
 80029c8:	2c01      	cmp	r4, #1
 80029ca:	d1a2      	bne.n	8002912 <dhcp_recv+0xee>
 80029cc:	4b5a      	ldr	r3, [pc, #360]	; (8002b38 <dhcp_recv+0x314>)
          value = ((u8_t*)&value)[0];
 80029ce:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
 80029d2:	9305      	str	r3, [sp, #20]
        }
        dhcp_got_option(dhcp, decode_idx);
 80029d4:	4a57      	ldr	r2, [pc, #348]	; (8002b34 <dhcp_recv+0x310>)
        dhcp_set_option_value(dhcp, decode_idx, value);
 80029d6:	f843 0027 	str.w	r0, [r3, r7, lsl #2]
          value = ntohl(value);
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
          value = ((u8_t*)&value)[0];
        }
        dhcp_got_option(dhcp, decode_idx);
 80029da:	2301      	movs	r3, #1
 80029dc:	55d3      	strb	r3, [r2, r7]
 80029de:	f8bb 300a 	ldrh.w	r3, [fp, #10]
        dhcp_set_option_value(dhcp, decode_idx, value);
      }
    }
    if (offset >= q->len) {
 80029e2:	459a      	cmp	sl, r3
 80029e4:	d39f      	bcc.n	8002926 <dhcp_recv+0x102>
      offset -= q->len;
      offset_max -= q->len;
 80029e6:	9a01      	ldr	r2, [sp, #4]
        dhcp_got_option(dhcp, decode_idx);
        dhcp_set_option_value(dhcp, decode_idx, value);
      }
    }
    if (offset >= q->len) {
      offset -= q->len;
 80029e8:	ebc3 0a0a 	rsb	sl, r3, sl
      offset_max -= q->len;
 80029ec:	1ad3      	subs	r3, r2, r3
 80029ee:	b29b      	uxth	r3, r3
        dhcp_got_option(dhcp, decode_idx);
        dhcp_set_option_value(dhcp, decode_idx, value);
      }
    }
    if (offset >= q->len) {
      offset -= q->len;
 80029f0:	fa1f fa8a 	uxth.w	sl, sl
      offset_max -= q->len;
      if ((offset < offset_max) && offset_max) {
 80029f4:	459a      	cmp	sl, r3
        dhcp_set_option_value(dhcp, decode_idx, value);
      }
    }
    if (offset >= q->len) {
      offset -= q->len;
      offset_max -= q->len;
 80029f6:	9301      	str	r3, [sp, #4]
      if ((offset < offset_max) && offset_max) {
 80029f8:	d27a      	bcs.n	8002af0 <dhcp_recv+0x2cc>
        q = q->next;
 80029fa:	f8db b000 	ldr.w	fp, [fp]
        LWIP_ASSERT("next pbuf was null", q);
        options = (u8_t*)q->payload;
 80029fe:	f8db 3004 	ldr.w	r3, [fp, #4]
 8002a02:	9302      	str	r3, [sp, #8]
 8002a04:	e78f      	b.n	8002926 <dhcp_recv+0x102>
 8002a06:	b28d      	uxth	r5, r1
 8002a08:	2400      	movs	r4, #0
      default:
        decode_len = 0;
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    }
    offset += len + 2;
 8002a0a:	442c      	add	r4, r5
 8002a0c:	fa1f fa84 	uxth.w	sl, r4
 8002a10:	e7e7      	b.n	80029e2 <dhcp_recv+0x1be>
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_T1;
        break;
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 8002a12:	2c04      	cmp	r4, #4
 8002a14:	f47f af7d 	bne.w	8002912 <dhcp_recv+0xee>
 8002a18:	46a2      	mov	sl, r4
        decode_idx = DHCP_OPTION_IDX_T2;
 8002a1a:	2705      	movs	r7, #5
 8002a1c:	e7c2      	b.n	80029a4 <dhcp_recv+0x180>
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
        break;
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 8002a1e:	2c04      	cmp	r4, #4
 8002a20:	f47f af77 	bne.w	8002912 <dhcp_recv+0xee>
 8002a24:	46a2      	mov	sl, r4
        decode_idx = DHCP_OPTION_IDX_T1;
 8002a26:	4627      	mov	r7, r4
 8002a28:	e7bc      	b.n	80029a4 <dhcp_recv+0x180>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
        break;
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 8002a2a:	2c04      	cmp	r4, #4
 8002a2c:	f47f af71 	bne.w	8002912 <dhcp_recv+0xee>
 8002a30:	46a2      	mov	sl, r4
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
 8002a32:	2702      	movs	r7, #2
 8002a34:	e7b6      	b.n	80029a4 <dhcp_recv+0x180>
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
        break;
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
 8002a36:	2c01      	cmp	r4, #1
 8002a38:	d0f4      	beq.n	8002a24 <dhcp_recv+0x200>
 8002a3a:	e76a      	b.n	8002912 <dhcp_recv+0xee>
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
        break;
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
 8002a3c:	2c01      	cmp	r4, #1
 8002a3e:	f47f af68 	bne.w	8002912 <dhcp_recv+0xee>
 8002a42:	46a2      	mov	sl, r4
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
 8002a44:	2700      	movs	r7, #0
 8002a46:	e7ad      	b.n	80029a4 <dhcp_recv+0x180>
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
        break;
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 8002a48:	2c04      	cmp	r4, #4
 8002a4a:	f47f af62 	bne.w	8002912 <dhcp_recv+0xee>
 8002a4e:	46a2      	mov	sl, r4
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
 8002a50:	2703      	movs	r7, #3
 8002a52:	e7a7      	b.n	80029a4 <dhcp_recv+0x180>
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_ROUTER;
        break;
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
 8002a54:	07a2      	lsls	r2, r4, #30
 8002a56:	f47f af5c 	bne.w	8002912 <dhcp_recv+0xee>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
 8002a5a:	2c08      	cmp	r4, #8
 8002a5c:	4622      	mov	r2, r4
 8002a5e:	bf28      	it	cs
 8002a60:	2208      	movcs	r2, #8
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 8002a62:	42a2      	cmp	r2, r4
 8002a64:	f63f af55 	bhi.w	8002912 <dhcp_recv+0xee>
      default:
        decode_len = 0;
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    }
    offset += len + 2;
 8002a68:	442c      	add	r4, r5
 8002a6a:	fa1f fa84 	uxth.w	sl, r4
    if (decode_len > 0) {
 8002a6e:	2a00      	cmp	r2, #0
 8002a70:	d0b7      	beq.n	80029e2 <dhcp_recv+0x1be>
 8002a72:	4614      	mov	r4, r2
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
 8002a74:	2708      	movs	r7, #8
 8002a76:	e798      	b.n	80029aa <dhcp_recv+0x186>
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
        break;
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 8002a78:	2c03      	cmp	r4, #3
 8002a7a:	f67f af4a 	bls.w	8002912 <dhcp_recv+0xee>
 8002a7e:	fa1f fa84 	uxth.w	sl, r4
        decode_idx = DHCP_OPTION_IDX_ROUTER;
 8002a82:	2707      	movs	r7, #7
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
        break;
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
 8002a84:	2404      	movs	r4, #4
 8002a86:	e78d      	b.n	80029a4 <dhcp_recv+0x180>
 8002a88:	b2a4      	uxth	r4, r4
 8002a8a:	e7be      	b.n	8002a0a <dhcp_recv+0x1e6>
    u16_t val_offset = offset + 2;
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
      len = options[offset + 1];
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
 8002a8c:	f8db 0000 	ldr.w	r0, [fp]
 8002a90:	2800      	cmp	r0, #0
 8002a92:	d053      	beq.n	8002b3c <dhcp_recv+0x318>
 8002a94:	6840      	ldr	r0, [r0, #4]
 8002a96:	7804      	ldrb	r4, [r0, #0]
 8002a98:	e75d      	b.n	8002956 <dhcp_recv+0x132>
 8002a9a:	4b27      	ldr	r3, [pc, #156]	; (8002b38 <dhcp_recv+0x314>)
 8002a9c:	9305      	str	r3, [sp, #20]
 8002a9e:	4b25      	ldr	r3, [pc, #148]	; (8002b34 <dhcp_recv+0x310>)
 8002aa0:	18fe      	adds	r6, r7, r3
 8002aa2:	4b25      	ldr	r3, [pc, #148]	; (8002b38 <dhcp_recv+0x314>)
 8002aa4:	f10d 0924 	add.w	r9, sp, #36	; 0x24
 8002aa8:	eb03 0887 	add.w	r8, r3, r7, lsl #2
 8002aac:	e013      	b.n	8002ad6 <dhcp_recv+0x2b2>
        copy_len = LWIP_MIN(decode_len, 4);
        pbuf_copy_partial(q, &value, copy_len, val_offset);
        if (decode_len > 4) {
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
          dhcp_got_option(dhcp, decode_idx);
 8002aae:	f04f 0301 	mov.w	r3, #1
 8002ab2:	7033      	strb	r3, [r6, #0]
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
 8002ab4:	9809      	ldr	r0, [sp, #36]	; 0x24
 8002ab6:	f7fe fee1 	bl	800187c <lwip_htonl>
    if (decode_len > 0) {
      u32_t value = 0;
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
 8002aba:	7873      	ldrb	r3, [r6, #1]
        pbuf_copy_partial(q, &value, copy_len, val_offset);
        if (decode_len > 4) {
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
          dhcp_got_option(dhcp, decode_idx);
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
 8002abc:	f848 0b04 	str.w	r0, [r8], #4
          decode_len -= 4;
 8002ac0:	3c04      	subs	r4, #4
          val_offset += 4;
 8002ac2:	3504      	adds	r5, #4
 8002ac4:	3601      	adds	r6, #1
          decode_idx++;
 8002ac6:	3701      	adds	r7, #1
        if (decode_len > 4) {
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
          dhcp_got_option(dhcp, decode_idx);
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
          decode_len -= 4;
 8002ac8:	b2e4      	uxtb	r4, r4
          val_offset += 4;
 8002aca:	b2ad      	uxth	r5, r5
    if (decode_len > 0) {
      u32_t value = 0;
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
 8002acc:	2b00      	cmp	r3, #0
 8002ace:	d186      	bne.n	80029de <dhcp_recv+0x1ba>
        copy_len = LWIP_MIN(decode_len, 4);
 8002ad0:	2c04      	cmp	r4, #4
 8002ad2:	f47f af73 	bne.w	80029bc <dhcp_recv+0x198>
        pbuf_copy_partial(q, &value, copy_len, val_offset);
 8002ad6:	462b      	mov	r3, r5
 8002ad8:	2204      	movs	r2, #4
 8002ada:	4649      	mov	r1, r9
 8002adc:	4658      	mov	r0, fp
 8002ade:	f001 fc31 	bl	8004344 <pbuf_copy_partial>
        if (decode_len > 4) {
 8002ae2:	2c04      	cmp	r4, #4
 8002ae4:	f000 80ac 	beq.w	8002c40 <dhcp_recv+0x41c>
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
 8002ae8:	07a3      	lsls	r3, r4, #30
 8002aea:	f47f af12 	bne.w	8002912 <dhcp_recv+0xee>
 8002aee:	e7de      	b.n	8002aae <dhcp_recv+0x28a>
        break;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
 8002af0:	4b10      	ldr	r3, [pc, #64]	; (8002b34 <dhcp_recv+0x310>)
 8002af2:	781b      	ldrb	r3, [r3, #0]
 8002af4:	b163      	cbz	r3, 8002b10 <dhcp_recv+0x2ec>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 8002af6:	4b10      	ldr	r3, [pc, #64]	; (8002b38 <dhcp_recv+0x314>)
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 8002af8:	490e      	ldr	r1, [pc, #56]	; (8002b34 <dhcp_recv+0x310>)
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 8002afa:	681b      	ldr	r3, [r3, #0]
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 8002afc:	2200      	movs	r2, #0
    if (overload == DHCP_OVERLOAD_FILE) {
 8002afe:	2b01      	cmp	r3, #1
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 8002b00:	700a      	strb	r2, [r1, #0]
    if (overload == DHCP_OVERLOAD_FILE) {
 8002b02:	f000 80a4 	beq.w	8002c4e <dhcp_recv+0x42a>
      parse_file_as_options = 1;
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
 8002b06:	2b02      	cmp	r3, #2
 8002b08:	d006      	beq.n	8002b18 <dhcp_recv+0x2f4>
      parse_sname_as_options = 1;
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
 8002b0a:	2b03      	cmp	r3, #3
 8002b0c:	f000 809d 	beq.w	8002c4a <dhcp_recv+0x426>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
    options_idx = DHCP_FILE_OFS;
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
    goto again;
  } else if (parse_sname_as_options) {
 8002b10:	9b06      	ldr	r3, [sp, #24]
 8002b12:	2b00      	cmp	r3, #0
 8002b14:	f000 80a0 	beq.w	8002c58 <dhcp_recv+0x434>
    parse_sname_as_options = 0;
 8002b18:	2300      	movs	r3, #0
 8002b1a:	9306      	str	r3, [sp, #24]
    options_idx = DHCP_SNAME_OFS;
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
 8002b1c:	236c      	movs	r3, #108	; 0x6c
 8002b1e:	9301      	str	r3, [sp, #4]
    options_idx = DHCP_FILE_OFS;
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
    goto again;
  } else if (parse_sname_as_options) {
    parse_sname_as_options = 0;
    options_idx = DHCP_SNAME_OFS;
 8002b20:	f04f 0a2c 	mov.w	sl, #44	; 0x2c
 8002b24:	9b03      	ldr	r3, [sp, #12]
 8002b26:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8002b2a:	895b      	ldrh	r3, [r3, #10]
 8002b2c:	f8dd b004 	ldr.w	fp, [sp, #4]
 8002b30:	e6df      	b.n	80028f2 <dhcp_recv+0xce>
 8002b32:	bf00      	nop
 8002b34:	20002ef4 	.word	0x20002ef4
 8002b38:	20002f00 	.word	0x20002f00
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
    switch(op) {
 8002b3c:	2a3b      	cmp	r2, #59	; 0x3b
 8002b3e:	d87d      	bhi.n	8002c3c <dhcp_recv+0x418>
 8002b40:	a001      	add	r0, pc, #4	; (adr r0, 8002b48 <dhcp_recv+0x324>)
 8002b42:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 8002b46:	bf00      	nop
 8002b48:	08002a07 	.word	0x08002a07
 8002b4c:	08002913 	.word	0x08002913
 8002b50:	08002c3d 	.word	0x08002c3d
 8002b54:	08002913 	.word	0x08002913
 8002b58:	08002c3d 	.word	0x08002c3d
 8002b5c:	08002c3d 	.word	0x08002c3d
 8002b60:	08002c39 	.word	0x08002c39
 8002b64:	08002c3d 	.word	0x08002c3d
 8002b68:	08002c3d 	.word	0x08002c3d
 8002b6c:	08002c3d 	.word	0x08002c3d
 8002b70:	08002c3d 	.word	0x08002c3d
 8002b74:	08002c3d 	.word	0x08002c3d
 8002b78:	08002c3d 	.word	0x08002c3d
 8002b7c:	08002c3d 	.word	0x08002c3d
 8002b80:	08002c3d 	.word	0x08002c3d
 8002b84:	08002c3d 	.word	0x08002c3d
 8002b88:	08002c3d 	.word	0x08002c3d
 8002b8c:	08002c3d 	.word	0x08002c3d
 8002b90:	08002c3d 	.word	0x08002c3d
 8002b94:	08002c3d 	.word	0x08002c3d
 8002b98:	08002c3d 	.word	0x08002c3d
 8002b9c:	08002c3d 	.word	0x08002c3d
 8002ba0:	08002c3d 	.word	0x08002c3d
 8002ba4:	08002c3d 	.word	0x08002c3d
 8002ba8:	08002c3d 	.word	0x08002c3d
 8002bac:	08002c3d 	.word	0x08002c3d
 8002bb0:	08002c3d 	.word	0x08002c3d
 8002bb4:	08002c3d 	.word	0x08002c3d
 8002bb8:	08002c3d 	.word	0x08002c3d
 8002bbc:	08002c3d 	.word	0x08002c3d
 8002bc0:	08002c3d 	.word	0x08002c3d
 8002bc4:	08002c3d 	.word	0x08002c3d
 8002bc8:	08002c3d 	.word	0x08002c3d
 8002bcc:	08002c3d 	.word	0x08002c3d
 8002bd0:	08002c3d 	.word	0x08002c3d
 8002bd4:	08002c3d 	.word	0x08002c3d
 8002bd8:	08002c3d 	.word	0x08002c3d
 8002bdc:	08002c3d 	.word	0x08002c3d
 8002be0:	08002c3d 	.word	0x08002c3d
 8002be4:	08002c3d 	.word	0x08002c3d
 8002be8:	08002c3d 	.word	0x08002c3d
 8002bec:	08002c3d 	.word	0x08002c3d
 8002bf0:	08002c3d 	.word	0x08002c3d
 8002bf4:	08002c3d 	.word	0x08002c3d
 8002bf8:	08002c3d 	.word	0x08002c3d
 8002bfc:	08002c3d 	.word	0x08002c3d
 8002c00:	08002c3d 	.word	0x08002c3d
 8002c04:	08002c3d 	.word	0x08002c3d
 8002c08:	08002c3d 	.word	0x08002c3d
 8002c0c:	08002c3d 	.word	0x08002c3d
 8002c10:	08002c3d 	.word	0x08002c3d
 8002c14:	08002913 	.word	0x08002913
 8002c18:	08002913 	.word	0x08002913
 8002c1c:	08002913 	.word	0x08002913
 8002c20:	08002913 	.word	0x08002913
 8002c24:	08002c3d 	.word	0x08002c3d
 8002c28:	08002c3d 	.word	0x08002c3d
 8002c2c:	08002c3d 	.word	0x08002c3d
 8002c30:	08002913 	.word	0x08002913
 8002c34:	08002913 	.word	0x08002913
    u16_t val_offset = offset + 2;
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
      len = options[offset + 1];
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
 8002c38:	2400      	movs	r4, #0
 8002c3a:	e70e      	b.n	8002a5a <dhcp_recv+0x236>
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
    switch(op) {
 8002c3c:	2400      	movs	r4, #0
 8002c3e:	e6e4      	b.n	8002a0a <dhcp_recv+0x1e6>
          decode_len -= 4;
          val_offset += 4;
          decode_idx++;
          goto decode_next;
        } else if (decode_len == 4) {
          value = ntohl(value);
 8002c40:	9809      	ldr	r0, [sp, #36]	; 0x24
 8002c42:	f7fe fe1d 	bl	8001880 <lwip_ntohl>
 8002c46:	9b05      	ldr	r3, [sp, #20]
 8002c48:	e6c4      	b.n	80029d4 <dhcp_recv+0x1b0>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
      parse_sname_as_options = 1;
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
      parse_sname_as_options = 1;
 8002c4a:	2301      	movs	r3, #1
 8002c4c:	9306      	str	r3, [sp, #24]
  }
  if (parse_file_as_options) {
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
    options_idx = DHCP_FILE_OFS;
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
 8002c4e:	23ec      	movs	r3, #236	; 0xec
 8002c50:	9301      	str	r3, [sp, #4]
#endif /* LWIP_DHCP_BOOTP_FILE */
  }
  if (parse_file_as_options) {
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
    options_idx = DHCP_FILE_OFS;
 8002c52:	f04f 0a6c 	mov.w	sl, #108	; 0x6c
 8002c56:	e765      	b.n	8002b24 <dhcp_recv+0x300>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
 8002c58:	4b52      	ldr	r3, [pc, #328]	; (8002da4 <dhcp_recv+0x580>)
 8002c5a:	f8dd b010 	ldr.w	fp, [sp, #16]
 8002c5e:	785b      	ldrb	r3, [r3, #1]
 8002c60:	f8dd a01c 	ldr.w	sl, [sp, #28]
 8002c64:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8002c68:	4a4e      	ldr	r2, [pc, #312]	; (8002da4 <dhcp_recv+0x580>)
 8002c6a:	2b00      	cmp	r3, #0
 8002c6c:	f43f ade7 	beq.w	800283e <dhcp_recv+0x1a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
 8002c70:	4d4d      	ldr	r5, [pc, #308]	; (8002da8 <dhcp_recv+0x584>)
 8002c72:	792b      	ldrb	r3, [r5, #4]
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
 8002c74:	2b05      	cmp	r3, #5
 8002c76:	d01e      	beq.n	8002cb6 <dhcp_recv+0x492>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 8002c78:	2b06      	cmp	r3, #6
 8002c7a:	d028      	beq.n	8002cce <dhcp_recv+0x4aa>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
 8002c7c:	2b02      	cmp	r3, #2
 8002c7e:	f47f adde 	bne.w	800283e <dhcp_recv+0x1a>
 8002c82:	f89b 300c 	ldrb.w	r3, [fp, #12]
 8002c86:	2b06      	cmp	r3, #6
 8002c88:	f47f add9 	bne.w	800283e <dhcp_recv+0x1a>
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
 8002c8c:	7893      	ldrb	r3, [r2, #2]
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
 8002c8e:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 8002c92:	f8ab 201a 	strh.w	r2, [fp, #26]
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
 8002c96:	2b00      	cmp	r3, #0
 8002c98:	f43f add1 	beq.w	800283e <dhcp_recv+0x1a>
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
 8002c9c:	68a8      	ldr	r0, [r5, #8]
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
 8002c9e:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
 8002ca2:	f7fe fdeb 	bl	800187c <lwip_htonl>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
 8002ca6:	68a3      	ldr	r3, [r4, #8]
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
 8002ca8:	6220      	str	r0, [r4, #32]
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
 8002caa:	691b      	ldr	r3, [r3, #16]
 8002cac:	6263      	str	r3, [r4, #36]	; 0x24
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
 8002cae:	4650      	mov	r0, sl
 8002cb0:	f7ff fb8a 	bl	80023c8 <dhcp_select>
 8002cb4:	e5c3      	b.n	800283e <dhcp_recv+0x1a>
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
 8002cb6:	f89b 300c 	ldrb.w	r3, [fp, #12]
 8002cba:	2b01      	cmp	r3, #1
 8002cbc:	d02c      	beq.n	8002d18 <dhcp_recv+0x4f4>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
 8002cbe:	3b03      	subs	r3, #3
 8002cc0:	2b02      	cmp	r3, #2
 8002cc2:	f63f adbc 	bhi.w	800283e <dhcp_recv+0x1a>
      dhcp_bind(netif);
 8002cc6:	4650      	mov	r0, sl
 8002cc8:	f7fe fddc 	bl	8001884 <dhcp_bind>
 8002ccc:	e5b7      	b.n	800283e <dhcp_recv+0x1a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
 8002cce:	f89b 300c 	ldrb.w	r3, [fp, #12]
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 8002cd2:	1eda      	subs	r2, r3, #3
 8002cd4:	2a02      	cmp	r2, #2
 8002cd6:	d902      	bls.n	8002cde <dhcp_recv+0x4ba>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
 8002cd8:	2b01      	cmp	r3, #1
 8002cda:	f47f adb0 	bne.w	800283e <dhcp_recv+0x1a>
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
 8002cde:	4650      	mov	r0, sl
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
 8002ce0:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
 8002ce4:	f001 f8c0 	bl	8003e68 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
 8002ce8:	4930      	ldr	r1, [pc, #192]	; (8002dac <dhcp_recv+0x588>)
 8002cea:	4650      	mov	r0, sl
 8002cec:	f001 f868 	bl	8003dc0 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
 8002cf0:	492e      	ldr	r1, [pc, #184]	; (8002dac <dhcp_recv+0x588>)
 8002cf2:	4650      	mov	r0, sl
 8002cf4:	f001 f898 	bl	8003e28 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
 8002cf8:	492c      	ldr	r1, [pc, #176]	; (8002dac <dhcp_recv+0x588>)
 8002cfa:	4650      	mov	r0, sl
 8002cfc:	f001 f898 	bl	8003e30 <netif_set_netmask>
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8002d00:	7b23      	ldrb	r3, [r4, #12]
 8002d02:	2b0c      	cmp	r3, #12
 8002d04:	d004      	beq.n	8002d10 <dhcp_recv+0x4ec>
    dhcp->state = new_state;
    dhcp->tries = 0;
 8002d06:	2300      	movs	r3, #0
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 8002d08:	220c      	movs	r2, #12
 8002d0a:	7322      	strb	r2, [r4, #12]
    dhcp->tries = 0;
 8002d0c:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 8002d0e:	8363      	strh	r3, [r4, #26]
  netif_set_gw(netif, IP_ADDR_ANY);
  netif_set_netmask(netif, IP_ADDR_ANY); 
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  /* We can immediately restart discovery */
  dhcp_discover(netif);
 8002d10:	4650      	mov	r0, sl
 8002d12:	f7fe ffcb 	bl	8001cac <dhcp_discover>
 8002d16:	e592      	b.n	800283e <dhcp_recv+0x1a>
 8002d18:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
 8002d1c:	78d3      	ldrb	r3, [r2, #3]
#if LWIP_DNS
  u8_t n;
#endif /* LWIP_DNS */

  /* clear options we might not get from the ACK */
  ip_addr_set_zero(&dhcp->offered_sn_mask);
 8002d1e:	9a06      	ldr	r2, [sp, #24]
 8002d20:	62a2      	str	r2, [r4, #40]	; 0x28
  ip_addr_set_zero(&dhcp->offered_gw_addr);
 8002d22:	62e2      	str	r2, [r4, #44]	; 0x2c
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
 8002d24:	b10b      	cbz	r3, 8002d2a <dhcp_recv+0x506>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
 8002d26:	68eb      	ldr	r3, [r5, #12]
 8002d28:	6323      	str	r3, [r4, #48]	; 0x30
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
 8002d2a:	4b1e      	ldr	r3, [pc, #120]	; (8002da4 <dhcp_recv+0x580>)
 8002d2c:	791b      	ldrb	r3, [r3, #4]
 8002d2e:	2b00      	cmp	r3, #0
 8002d30:	d034      	beq.n	8002d9c <dhcp_recv+0x578>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
 8002d32:	692b      	ldr	r3, [r5, #16]
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
 8002d34:	4a1b      	ldr	r2, [pc, #108]	; (8002da4 <dhcp_recv+0x580>)
 8002d36:	6363      	str	r3, [r4, #52]	; 0x34
 8002d38:	7952      	ldrb	r2, [r2, #5]
 8002d3a:	b36a      	cbz	r2, 8002d98 <dhcp_recv+0x574>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
 8002d3c:	696b      	ldr	r3, [r5, #20]
 8002d3e:	63a3      	str	r3, [r4, #56]	; 0x38
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
 8002d40:	4b18      	ldr	r3, [pc, #96]	; (8002da4 <dhcp_recv+0x580>)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
 8002d42:	68a2      	ldr	r2, [r4, #8]
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
 8002d44:	799b      	ldrb	r3, [r3, #6]
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
 8002d46:	6912      	ldr	r2, [r2, #16]
 8002d48:	6262      	str	r2, [r4, #36]	; 0x24
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
 8002d4a:	b9f3      	cbnz	r3, 8002d8a <dhcp_recv+0x566>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    dhcp->subnet_mask_given = 1;
  } else {
    dhcp->subnet_mask_given = 0;
 8002d4c:	73a3      	strb	r3, [r4, #14]
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
 8002d4e:	4b15      	ldr	r3, [pc, #84]	; (8002da4 <dhcp_recv+0x580>)
 8002d50:	79db      	ldrb	r3, [r3, #7]
 8002d52:	b9ab      	cbnz	r3, 8002d80 <dhcp_recv+0x55c>
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
 8002d54:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8002d58:	7b23      	ldrb	r3, [r4, #12]
 8002d5a:	2b08      	cmp	r3, #8
 8002d5c:	d004      	beq.n	8002d68 <dhcp_recv+0x544>
    dhcp->state = new_state;
    dhcp->tries = 0;
 8002d5e:	2300      	movs	r3, #0
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 8002d60:	2208      	movs	r2, #8
 8002d62:	7322      	strb	r2, [r4, #12]
    dhcp->tries = 0;
 8002d64:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 8002d66:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
 8002d68:	2200      	movs	r2, #0
 8002d6a:	4650      	mov	r0, sl
 8002d6c:	f104 0124 	add.w	r1, r4, #36	; 0x24
 8002d70:	f005 f8b8 	bl	8007ee4 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
 8002d74:	7b63      	ldrb	r3, [r4, #13]
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 8002d76:	2201      	movs	r2, #1
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
 8002d78:	4413      	add	r3, r2
 8002d7a:	7363      	strb	r3, [r4, #13]
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 8002d7c:	8362      	strh	r2, [r4, #26]
 8002d7e:	e55e      	b.n	800283e <dhcp_recv+0x1a>
    dhcp->subnet_mask_given = 0;
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
    ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
 8002d80:	69e8      	ldr	r0, [r5, #28]
 8002d82:	f7fe fd7b 	bl	800187c <lwip_htonl>
 8002d86:	62e0      	str	r0, [r4, #44]	; 0x2c
 8002d88:	e7e4      	b.n	8002d54 <dhcp_recv+0x530>
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
 8002d8a:	69a8      	ldr	r0, [r5, #24]
 8002d8c:	f7fe fd76 	bl	800187c <lwip_htonl>
    dhcp->subnet_mask_given = 1;
 8002d90:	2301      	movs	r3, #1
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
 8002d92:	62a0      	str	r0, [r4, #40]	; 0x28
    dhcp->subnet_mask_given = 1;
 8002d94:	73a3      	strb	r3, [r4, #14]
 8002d96:	e7da      	b.n	8002d4e <dhcp_recv+0x52a>
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
 8002d98:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002d9a:	e7d0      	b.n	8002d3e <dhcp_recv+0x51a>
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
 8002d9c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002d9e:	085b      	lsrs	r3, r3, #1
 8002da0:	e7c8      	b.n	8002d34 <dhcp_recv+0x510>
 8002da2:	bf00      	nop
 8002da4:	20002ef4 	.word	0x20002ef4
 8002da8:	20002f00 	.word	0x20002f00
 8002dac:	0800c9e0 	.word	0x0800c9e0

08002db0 <dhcp_start>:
dhcp_start(struct netif *netif)
{
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
 8002db0:	2800      	cmp	r0, #0
 8002db2:	d05b      	beq.n	8002e6c <dhcp_start+0xbc>
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
 8002db4:	b538      	push	{r3, r4, r5, lr}
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 8002db6:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
{
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  dhcp = netif->dhcp;
 8002dba:	6a44      	ldr	r4, [r0, #36]	; 0x24
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 8002dbc:	f023 0208 	bic.w	r2, r3, #8

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
 8002dc0:	069b      	lsls	r3, r3, #26
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 8002dc2:	f880 2031 	strb.w	r2, [r0, #49]	; 0x31

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
 8002dc6:	d54e      	bpl.n	8002e66 <dhcp_start+0xb6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    return ERR_ARG;
  }

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
 8002dc8:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 8002dca:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 8002dce:	d33f      	bcc.n	8002e50 <dhcp_start+0xa0>
 8002dd0:	4605      	mov	r5, r0
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
 8002dd2:	2c00      	cmp	r4, #0
 8002dd4:	d03f      	beq.n	8002e56 <dhcp_start+0xa6>
    netif->dhcp = dhcp;
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
 8002dd6:	6860      	ldr	r0, [r4, #4]
 8002dd8:	b108      	cbz	r0, 8002dde <dhcp_start+0x2e>
      udp_remove(dhcp->pcb);
 8002dda:	f004 faff 	bl	80073dc <udp_remove>
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
 8002dde:	223c      	movs	r2, #60	; 0x3c
 8002de0:	2100      	movs	r1, #0
 8002de2:	4620      	mov	r0, r4
 8002de4:	f008 fba2 	bl	800b52c <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
 8002de8:	f004 fb16 	bl	8007418 <udp_new>
 8002dec:	6060      	str	r0, [r4, #4]
  if (dhcp->pcb == NULL) {
 8002dee:	b378      	cbz	r0, 8002e50 <dhcp_start+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
 8002df0:	7a03      	ldrb	r3, [r0, #8]
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
 8002df2:	4920      	ldr	r1, [pc, #128]	; (8002e74 <dhcp_start+0xc4>)
  dhcp->pcb = udp_new();
  if (dhcp->pcb == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
 8002df4:	f043 0320 	orr.w	r3, r3, #32
 8002df8:	7203      	strb	r3, [r0, #8]
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
 8002dfa:	2244      	movs	r2, #68	; 0x44
 8002dfc:	6860      	ldr	r0, [r4, #4]
 8002dfe:	f004 f9f5 	bl	80071ec <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
 8002e02:	2243      	movs	r2, #67	; 0x43
 8002e04:	491b      	ldr	r1, [pc, #108]	; (8002e74 <dhcp_start+0xc4>)
 8002e06:	6860      	ldr	r0, [r4, #4]
 8002e08:	f004 faba 	bl	8007380 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
 8002e0c:	462a      	mov	r2, r5
 8002e0e:	6860      	ldr	r0, [r4, #4]
 8002e10:	4919      	ldr	r1, [pc, #100]	; (8002e78 <dhcp_start+0xc8>)
 8002e12:	f004 fadf 	bl	80073d4 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
 8002e16:	4628      	mov	r0, r5
 8002e18:	f7fe ff48 	bl	8001cac <dhcp_discover>
{
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  dhcp = netif->dhcp;
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 8002e1c:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  if (result != ERR_OK) {
 8002e20:	b920      	cbnz	r0, 8002e2c <dhcp_start+0x7c>
    /* free resources allocated above */
    dhcp_stop(netif);
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
 8002e22:	f043 0308 	orr.w	r3, r3, #8
 8002e26:	f885 3031 	strb.w	r3, [r5, #49]	; 0x31
  return result;
}
 8002e2a:	bd38      	pop	{r3, r4, r5, pc}
void
dhcp_stop(struct netif *netif)
{
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  dhcp = netif->dhcp;
 8002e2c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 8002e2e:	f023 0308 	bic.w	r3, r3, #8
 8002e32:	f885 3031 	strb.w	r3, [r5, #49]	; 0x31

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
 8002e36:	b15c      	cbz	r4, 8002e50 <dhcp_start+0xa0>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
 8002e38:	6860      	ldr	r0, [r4, #4]
 8002e3a:	b118      	cbz	r0, 8002e44 <dhcp_start+0x94>
      udp_remove(dhcp->pcb);
 8002e3c:	f004 face 	bl	80073dc <udp_remove>
      dhcp->pcb = NULL;
 8002e40:	2300      	movs	r3, #0
 8002e42:	6063      	str	r3, [r4, #4]
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8002e44:	7b23      	ldrb	r3, [r4, #12]
 8002e46:	b11b      	cbz	r3, 8002e50 <dhcp_start+0xa0>
    dhcp->state = new_state;
 8002e48:	2300      	movs	r3, #0
 8002e4a:	7323      	strb	r3, [r4, #12]
    dhcp->tries = 0;
 8002e4c:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 8002e4e:	8363      	strh	r3, [r4, #26]
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  if (result != ERR_OK) {
    /* free resources allocated above */
    dhcp_stop(netif);
    return ERR_MEM;
 8002e50:	f04f 30ff 	mov.w	r0, #4294967295
 8002e54:	bd38      	pop	{r3, r4, r5, pc}
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
 8002e56:	203c      	movs	r0, #60	; 0x3c
 8002e58:	f000 fe44 	bl	8003ae4 <mem_malloc>
    if (dhcp == NULL) {
 8002e5c:	4604      	mov	r4, r0
 8002e5e:	2800      	cmp	r0, #0
 8002e60:	d0f6      	beq.n	8002e50 <dhcp_start+0xa0>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
 8002e62:	6268      	str	r0, [r5, #36]	; 0x24
 8002e64:	e7bb      	b.n	8002dde <dhcp_start+0x2e>
dhcp_start(struct netif *netif)
{
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
 8002e66:	f06f 000d 	mvn.w	r0, #13
 8002e6a:	bd38      	pop	{r3, r4, r5, pc}
 8002e6c:	f06f 000d 	mvn.w	r0, #13
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
 8002e70:	4770      	bx	lr
 8002e72:	bf00      	nop
 8002e74:	0800c9e0 	.word	0x0800c9e0
 8002e78:	08002825 	.word	0x08002825

08002e7c <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
 8002e7c:	b538      	push	{r3, r4, r5, lr}
  struct dhcp *dhcp = netif->dhcp;
 8002e7e:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (!dhcp)
 8002e80:	b154      	cbz	r4, 8002e98 <dhcp_network_changed+0x1c>
    return;
  switch (dhcp->state) {
 8002e82:	7b23      	ldrb	r3, [r4, #12]
 8002e84:	2b0a      	cmp	r3, #10
 8002e86:	d812      	bhi.n	8002eae <dhcp_network_changed+0x32>
 8002e88:	e8df f003 	tbb	[pc, r3]
 8002e8c:	07111106 	.word	0x07111106
 8002e90:	11110707 	.word	0x11110707
 8002e94:	1111      	.short	0x1111
 8002e96:	07          	.byte	0x07
 8002e97:	00          	.byte	0x00
 8002e98:	bd38      	pop	{r3, r4, r5, pc}
 8002e9a:	4605      	mov	r5, r0
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
 8002e9c:	f000 ffe4 	bl	8003e68 <netif_set_down>
    dhcp->tries = 0;
 8002ea0:	2300      	movs	r3, #0
 8002ea2:	7363      	strb	r3, [r4, #13]
    dhcp_reboot(netif);
 8002ea4:	4628      	mov	r0, r5
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
 8002ea6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
    dhcp->tries = 0;
    dhcp_reboot(netif);
 8002eaa:	f7ff b8bf 	b.w	800202c <dhcp_reboot>
    break;
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
 8002eae:	2300      	movs	r3, #0
 8002eb0:	7363      	strb	r3, [r4, #13]
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
 8002eb2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
 8002eb6:	f7fe bef9 	b.w	8001cac <dhcp_discover>
 8002eba:	bf00      	nop

08002ebc <dhcp_arp_reply>:
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8002ebc:	2800      	cmp	r0, #0
 8002ebe:	f000 8183 	beq.w	80031c8 <dhcp_arp_reply+0x30c>
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
 8002ec2:	b5f0      	push	{r4, r5, r6, r7, lr}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
 8002ec4:	6a44      	ldr	r4, [r0, #36]	; 0x24
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
 8002ec6:	b083      	sub	sp, #12
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
 8002ec8:	b114      	cbz	r4, 8002ed0 <dhcp_arp_reply+0x14>
 8002eca:	7b23      	ldrb	r3, [r4, #12]
 8002ecc:	2b08      	cmp	r3, #8
 8002ece:	d001      	beq.n	8002ed4 <dhcp_arp_reply+0x18>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
 8002ed0:	b003      	add	sp, #12
 8002ed2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
      ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
 8002ed4:	680a      	ldr	r2, [r1, #0]
 8002ed6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002ed8:	429a      	cmp	r2, r3
 8002eda:	d1f9      	bne.n	8002ed0 <dhcp_arp_reply+0x14>
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
    dhcp->tries = 0;
 8002edc:	2200      	movs	r2, #0
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 8002ede:	230c      	movs	r3, #12
 8002ee0:	4605      	mov	r5, r0
 8002ee2:	7323      	strb	r3, [r4, #12]
    dhcp->tries = 0;
 8002ee4:	7362      	strb	r2, [r4, #13]
    dhcp->request_timeout = 0;
 8002ee6:	8362      	strh	r2, [r4, #26]
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 8002ee8:	4610      	mov	r0, r2
 8002eea:	f44f 719a 	mov.w	r1, #308	; 0x134
 8002eee:	f000 fffb 	bl	8003ee8 <pbuf_alloc>
 8002ef2:	6120      	str	r0, [r4, #16]
  if (dhcp->p_out == NULL) {
 8002ef4:	2800      	cmp	r0, #0
 8002ef6:	f000 8161 	beq.w	80031bc <dhcp_arp_reply+0x300>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 8002efa:	7b63      	ldrb	r3, [r4, #13]
 8002efc:	2b00      	cmp	r3, #0
 8002efe:	f000 8164 	beq.w	80031ca <dhcp_arp_reply+0x30e>
 8002f02:	4bb4      	ldr	r3, [pc, #720]	; (80031d4 <dhcp_arp_reply+0x318>)
 8002f04:	681b      	ldr	r3, [r3, #0]
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 8002f06:	6841      	ldr	r1, [r0, #4]
 8002f08:	6161      	str	r1, [r4, #20]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 8002f0a:	2201      	movs	r2, #1
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 8002f0c:	6023      	str	r3, [r4, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 8002f0e:	700a      	strb	r2, [r1, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 8002f10:	6963      	ldr	r3, [r4, #20]
 8002f12:	705a      	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
 8002f14:	6963      	ldr	r3, [r4, #20]
 8002f16:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002f1a:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
 8002f1c:	6963      	ldr	r3, [r4, #20]
 8002f1e:	2600      	movs	r6, #0
 8002f20:	70de      	strb	r6, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
 8002f22:	6820      	ldr	r0, [r4, #0]
 8002f24:	6967      	ldr	r7, [r4, #20]
 8002f26:	f7fe fca9 	bl	800187c <lwip_htonl>
  dhcp->msg_out->secs = 0;
 8002f2a:	6963      	ldr	r3, [r4, #20]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
 8002f2c:	686a      	ldr	r2, [r5, #4]
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
 8002f2e:	6078      	str	r0, [r7, #4]
  dhcp->msg_out->secs = 0;
 8002f30:	721e      	strb	r6, [r3, #8]
 8002f32:	725e      	strb	r6, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 8002f34:	729e      	strb	r6, [r3, #10]
 8002f36:	72de      	strb	r6, [r3, #11]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
 8002f38:	60da      	str	r2, [r3, #12]
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 8002f3a:	741e      	strb	r6, [r3, #16]
 8002f3c:	745e      	strb	r6, [r3, #17]
 8002f3e:	749e      	strb	r6, [r3, #18]
 8002f40:	74de      	strb	r6, [r3, #19]
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 8002f42:	751e      	strb	r6, [r3, #20]
 8002f44:	755e      	strb	r6, [r3, #21]
 8002f46:	759e      	strb	r6, [r3, #22]
 8002f48:	75de      	strb	r6, [r3, #23]
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 8002f4a:	761e      	strb	r6, [r3, #24]
 8002f4c:	765e      	strb	r6, [r3, #25]
 8002f4e:	769e      	strb	r6, [r3, #26]
 8002f50:	76de      	strb	r6, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 8002f52:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002f56:	b10a      	cbz	r2, 8002f5c <dhcp_arp_reply+0xa0>
 8002f58:	f895 202b 	ldrb.w	r2, [r5, #43]	; 0x2b
 8002f5c:	771a      	strb	r2, [r3, #28]
 8002f5e:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002f62:	6963      	ldr	r3, [r4, #20]
 8002f64:	2a01      	cmp	r2, #1
 8002f66:	bf8c      	ite	hi
 8002f68:	f895 202c 	ldrbhi.w	r2, [r5, #44]	; 0x2c
 8002f6c:	2200      	movls	r2, #0
 8002f6e:	775a      	strb	r2, [r3, #29]
 8002f70:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002f74:	6963      	ldr	r3, [r4, #20]
 8002f76:	2a02      	cmp	r2, #2
 8002f78:	bf8c      	ite	hi
 8002f7a:	f895 202d 	ldrbhi.w	r2, [r5, #45]	; 0x2d
 8002f7e:	2200      	movls	r2, #0
 8002f80:	779a      	strb	r2, [r3, #30]
 8002f82:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002f86:	6963      	ldr	r3, [r4, #20]
 8002f88:	2a03      	cmp	r2, #3
 8002f8a:	bf8c      	ite	hi
 8002f8c:	f895 202e 	ldrbhi.w	r2, [r5, #46]	; 0x2e
 8002f90:	2200      	movls	r2, #0
 8002f92:	77da      	strb	r2, [r3, #31]
 8002f94:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002f98:	6963      	ldr	r3, [r4, #20]
 8002f9a:	2a04      	cmp	r2, #4
 8002f9c:	bf8c      	ite	hi
 8002f9e:	f895 202f 	ldrbhi.w	r2, [r5, #47]	; 0x2f
 8002fa2:	2200      	movls	r2, #0
 8002fa4:	f883 2020 	strb.w	r2, [r3, #32]
 8002fa8:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002fac:	6963      	ldr	r3, [r4, #20]
 8002fae:	2a05      	cmp	r2, #5
 8002fb0:	bf8c      	ite	hi
 8002fb2:	f895 2030 	ldrbhi.w	r2, [r5, #48]	; 0x30
 8002fb6:	2200      	movls	r2, #0
 8002fb8:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8002fbc:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002fc0:	6963      	ldr	r3, [r4, #20]
 8002fc2:	2a06      	cmp	r2, #6
 8002fc4:	bf8c      	ite	hi
 8002fc6:	f895 2031 	ldrbhi.w	r2, [r5, #49]	; 0x31
 8002fca:	2200      	movls	r2, #0
 8002fcc:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8002fd0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002fd4:	6963      	ldr	r3, [r4, #20]
 8002fd6:	2a07      	cmp	r2, #7
 8002fd8:	bf8c      	ite	hi
 8002fda:	f895 2032 	ldrbhi.w	r2, [r5, #50]	; 0x32
 8002fde:	2200      	movls	r2, #0
 8002fe0:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
 8002fe4:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002fe8:	6963      	ldr	r3, [r4, #20]
 8002fea:	2a08      	cmp	r2, #8
 8002fec:	bf8c      	ite	hi
 8002fee:	f895 2033 	ldrbhi.w	r2, [r5, #51]	; 0x33
 8002ff2:	2200      	movls	r2, #0
 8002ff4:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8002ff8:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8002ffc:	6963      	ldr	r3, [r4, #20]
 8002ffe:	2a09      	cmp	r2, #9
 8003000:	bf8c      	ite	hi
 8003002:	f895 2034 	ldrbhi.w	r2, [r5, #52]	; 0x34
 8003006:	2200      	movls	r2, #0
 8003008:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 800300c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003010:	6963      	ldr	r3, [r4, #20]
 8003012:	2a0a      	cmp	r2, #10
 8003014:	bf8c      	ite	hi
 8003016:	f895 2035 	ldrbhi.w	r2, [r5, #53]	; 0x35
 800301a:	2200      	movls	r2, #0
 800301c:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8003020:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003024:	6963      	ldr	r3, [r4, #20]
 8003026:	2a0b      	cmp	r2, #11
 8003028:	bf8c      	ite	hi
 800302a:	f895 2036 	ldrbhi.w	r2, [r5, #54]	; 0x36
 800302e:	2200      	movls	r2, #0
 8003030:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 8003034:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003038:	6963      	ldr	r3, [r4, #20]
 800303a:	2a0c      	cmp	r2, #12
 800303c:	bf8c      	ite	hi
 800303e:	f895 2037 	ldrbhi.w	r2, [r5, #55]	; 0x37
 8003042:	2200      	movls	r2, #0
 8003044:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8003048:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800304c:	6963      	ldr	r3, [r4, #20]
 800304e:	2a0d      	cmp	r2, #13
 8003050:	bf8c      	ite	hi
 8003052:	f895 2038 	ldrbhi.w	r2, [r5, #56]	; 0x38
 8003056:	2200      	movls	r2, #0
 8003058:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 800305c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003060:	6963      	ldr	r3, [r4, #20]
 8003062:	2a0e      	cmp	r2, #14
 8003064:	bf8c      	ite	hi
 8003066:	f895 2039 	ldrbhi.w	r2, [r5, #57]	; 0x39
 800306a:	2200      	movls	r2, #0
 800306c:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 8003070:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 8003074:	6962      	ldr	r2, [r4, #20]
 8003076:	2b0f      	cmp	r3, #15
 8003078:	bf8c      	ite	hi
 800307a:	f895 103a 	ldrbhi.w	r1, [r5, #58]	; 0x3a
 800307e:	2100      	movls	r1, #0
 8003080:	2300      	movs	r3, #0
 8003082:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
 8003086:	4619      	mov	r1, r3
 8003088:	6962      	ldr	r2, [r4, #20]
 800308a:	441a      	add	r2, r3
 800308c:	3301      	adds	r3, #1
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 800308e:	2b40      	cmp	r3, #64	; 0x40
    dhcp->msg_out->sname[i] = 0;
 8003090:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8003094:	d1f8      	bne.n	8003088 <dhcp_arp_reply+0x1cc>
 8003096:	2300      	movs	r3, #0
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
 8003098:	4618      	mov	r0, r3
 800309a:	6962      	ldr	r2, [r4, #20]
 800309c:	441a      	add	r2, r3
 800309e:	3301      	adds	r3, #1
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 80030a0:	2b80      	cmp	r3, #128	; 0x80
    dhcp->msg_out->file[i] = 0;
 80030a2:	f882 006c 	strb.w	r0, [r2, #108]	; 0x6c
 80030a6:	f04f 0100 	mov.w	r1, #0
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 80030aa:	d1f6      	bne.n	800309a <dhcp_arp_reply+0x1de>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 80030ac:	6962      	ldr	r2, [r4, #20]
 80030ae:	2363      	movs	r3, #99	; 0x63
 80030b0:	f06f 067d 	mvn.w	r6, #125	; 0x7d
 80030b4:	2053      	movs	r0, #83	; 0x53
 80030b6:	f882 30ec 	strb.w	r3, [r2, #236]	; 0xec
 80030ba:	f882 30ef 	strb.w	r3, [r2, #239]	; 0xef
 80030be:	f882 60ed 	strb.w	r6, [r2, #237]	; 0xed
 80030c2:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
  dhcp->options_out_len = 0;
 80030c6:	460b      	mov	r3, r1
 80030c8:	8321      	strh	r1, [r4, #24]
 80030ca:	e000      	b.n	80030ce <dhcp_arp_reply+0x212>
 80030cc:	6962      	ldr	r2, [r4, #20]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 80030ce:	441a      	add	r2, r3
 80030d0:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
 80030d4:	3301      	adds	r3, #1
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 80030d6:	2b44      	cmp	r3, #68	; 0x44
 80030d8:	d1f8      	bne.n	80030cc <dhcp_arp_reply+0x210>
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 80030da:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 80030dc:	6962      	ldr	r2, [r4, #20]
 80030de:	441a      	add	r2, r3
 80030e0:	2135      	movs	r1, #53	; 0x35
 80030e2:	3301      	adds	r3, #1
 80030e4:	8323      	strh	r3, [r4, #24]
 80030e6:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 80030ea:	8b23      	ldrh	r3, [r4, #24]
 80030ec:	6962      	ldr	r2, [r4, #20]
 80030ee:	441a      	add	r2, r3
 80030f0:	2101      	movs	r1, #1
 80030f2:	3301      	adds	r3, #1
 80030f4:	8323      	strh	r3, [r4, #24]
 80030f6:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 80030fa:	8b23      	ldrh	r3, [r4, #24]
 80030fc:	6962      	ldr	r2, [r4, #20]
 80030fe:	441a      	add	r2, r3
 8003100:	440b      	add	r3, r1
 8003102:	2104      	movs	r1, #4
 8003104:	8323      	strh	r3, [r4, #24]
 8003106:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800310a:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 800310c:	6962      	ldr	r2, [r4, #20]
 800310e:	441a      	add	r2, r3
 8003110:	2032      	movs	r0, #50	; 0x32
 8003112:	3301      	adds	r3, #1
 8003114:	8323      	strh	r3, [r4, #24]
 8003116:	f882 00f0 	strb.w	r0, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800311a:	8b23      	ldrh	r3, [r4, #24]
 800311c:	6962      	ldr	r2, [r4, #20]
 800311e:	441a      	add	r2, r3
 8003120:	3301      	adds	r3, #1
 8003122:	8323      	strh	r3, [r4, #24]
 8003124:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 8003128:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800312a:	f7fe fba9 	bl	8001880 <lwip_ntohl>
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
 800312e:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 8003130:	6962      	ldr	r2, [r4, #20]
 8003132:	441a      	add	r2, r3
 8003134:	0e01      	lsrs	r1, r0, #24
 8003136:	3301      	adds	r3, #1
 8003138:	8323      	strh	r3, [r4, #24]
 800313a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 800313e:	8b23      	ldrh	r3, [r4, #24]
 8003140:	6962      	ldr	r2, [r4, #20]
 8003142:	441a      	add	r2, r3
 8003144:	0c01      	lsrs	r1, r0, #16
 8003146:	3301      	adds	r3, #1
 8003148:	8323      	strh	r3, [r4, #24]
 800314a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 800314e:	8b23      	ldrh	r3, [r4, #24]
 8003150:	6962      	ldr	r2, [r4, #20]
 8003152:	441a      	add	r2, r3
 8003154:	0a01      	lsrs	r1, r0, #8
 8003156:	3301      	adds	r3, #1
 8003158:	8323      	strh	r3, [r4, #24]
 800315a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 800315e:	8b23      	ldrh	r3, [r4, #24]
 8003160:	6962      	ldr	r2, [r4, #20]
 8003162:	441a      	add	r2, r3
 8003164:	3301      	adds	r3, #1
 8003166:	8323      	strh	r3, [r4, #24]
 8003168:	f882 00f0 	strb.w	r0, [r2, #240]	; 0xf0
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 800316c:	8b23      	ldrh	r3, [r4, #24]
 800316e:	6962      	ldr	r2, [r4, #20]
 8003170:	441a      	add	r2, r3
 8003172:	21ff      	movs	r1, #255	; 0xff
 8003174:	3301      	adds	r3, #1
 8003176:	8323      	strh	r3, [r4, #24]
 8003178:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 800317c:	8b21      	ldrh	r1, [r4, #24]
 800317e:	2943      	cmp	r1, #67	; 0x43
 8003180:	d809      	bhi.n	8003196 <dhcp_arp_reply+0x2da>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 8003182:	2200      	movs	r2, #0
 8003184:	6963      	ldr	r3, [r4, #20]
 8003186:	440b      	add	r3, r1
 8003188:	3101      	adds	r1, #1
 800318a:	8321      	strh	r1, [r4, #24]
 800318c:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 8003190:	8b21      	ldrh	r1, [r4, #24]
 8003192:	2943      	cmp	r1, #67	; 0x43
 8003194:	d9f6      	bls.n	8003184 <dhcp_arp_reply+0x2c8>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_option_trailer(dhcp);
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 8003196:	31f0      	adds	r1, #240	; 0xf0
 8003198:	b289      	uxth	r1, r1
 800319a:	6920      	ldr	r0, [r4, #16]
 800319c:	f000 ff7c 	bl	8004098 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 80031a0:	6921      	ldr	r1, [r4, #16]
 80031a2:	6860      	ldr	r0, [r4, #4]
 80031a4:	4a0c      	ldr	r2, [pc, #48]	; (80031d8 <dhcp_arp_reply+0x31c>)
 80031a6:	9500      	str	r5, [sp, #0]
 80031a8:	2343      	movs	r3, #67	; 0x43
 80031aa:	f004 f885 	bl	80072b8 <udp_sendto_if>
dhcp_delete_msg(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 80031ae:	6920      	ldr	r0, [r4, #16]
 80031b0:	b108      	cbz	r0, 80031b6 <dhcp_arp_reply+0x2fa>
    pbuf_free(dhcp->p_out);
 80031b2:	f000 fff1 	bl	8004198 <pbuf_free>
  }
  dhcp->p_out = NULL;
 80031b6:	2300      	movs	r3, #0
 80031b8:	6123      	str	r3, [r4, #16]
  dhcp->msg_out = NULL;
 80031ba:	6163      	str	r3, [r4, #20]
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 80031bc:	7b63      	ldrb	r3, [r4, #13]
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 80031be:	2214      	movs	r2, #20
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 80031c0:	3301      	adds	r3, #1
 80031c2:	7363      	strb	r3, [r4, #13]
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 80031c4:	8362      	strh	r2, [r4, #26]
 80031c6:	e683      	b.n	8002ed0 <dhcp_arp_reply+0x14>
 80031c8:	4770      	bx	lr
  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 80031ca:	4a02      	ldr	r2, [pc, #8]	; (80031d4 <dhcp_arp_reply+0x318>)
 80031cc:	6813      	ldr	r3, [r2, #0]
 80031ce:	3301      	adds	r3, #1
 80031d0:	6013      	str	r3, [r2, #0]
 80031d2:	e698      	b.n	8002f06 <dhcp_arp_reply+0x4a>
 80031d4:	20000000 	.word	0x20000000
 80031d8:	0800c9dc 	.word	0x0800c9dc

080031dc <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
 80031dc:	b5f0      	push	{r4, r5, r6, r7, lr}
  struct dhcp *dhcp = netif->dhcp;
 80031de:	6a44      	ldr	r4, [r0, #36]	; 0x24
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 80031e0:	7b23      	ldrb	r3, [r4, #12]
 80031e2:	2b05      	cmp	r3, #5
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
 80031e4:	b083      	sub	sp, #12
 80031e6:	4605      	mov	r5, r0
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 80031e8:	d004      	beq.n	80031f4 <dhcp_renew+0x18>
    dhcp->state = new_state;
    dhcp->tries = 0;
 80031ea:	2300      	movs	r3, #0
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
 80031ec:	2205      	movs	r2, #5
 80031ee:	7322      	strb	r2, [r4, #12]
    dhcp->tries = 0;
 80031f0:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 80031f2:	8363      	strh	r3, [r4, #26]
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 80031f4:	2200      	movs	r2, #0
 80031f6:	4610      	mov	r0, r2
 80031f8:	f44f 719a 	mov.w	r1, #308	; 0x134
 80031fc:	f000 fe74 	bl	8003ee8 <pbuf_alloc>
 8003200:	6120      	str	r0, [r4, #16]
  if (dhcp->p_out == NULL) {
 8003202:	2800      	cmp	r0, #0
 8003204:	f000 817b 	beq.w	80034fe <dhcp_renew+0x322>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 8003208:	7b63      	ldrb	r3, [r4, #13]
 800320a:	2b00      	cmp	r3, #0
 800320c:	f000 816e 	beq.w	80034ec <dhcp_renew+0x310>
 8003210:	4bbc      	ldr	r3, [pc, #752]	; (8003504 <dhcp_renew+0x328>)
 8003212:	681b      	ldr	r3, [r3, #0]
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 8003214:	6841      	ldr	r1, [r0, #4]
 8003216:	6161      	str	r1, [r4, #20]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 8003218:	2201      	movs	r2, #1
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 800321a:	6023      	str	r3, [r4, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 800321c:	700a      	strb	r2, [r1, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 800321e:	6963      	ldr	r3, [r4, #20]
 8003220:	705a      	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
 8003222:	6963      	ldr	r3, [r4, #20]
 8003224:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003228:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
 800322a:	6963      	ldr	r3, [r4, #20]
 800322c:	2600      	movs	r6, #0
 800322e:	70de      	strb	r6, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
 8003230:	6820      	ldr	r0, [r4, #0]
 8003232:	6967      	ldr	r7, [r4, #20]
 8003234:	f7fe fb22 	bl	800187c <lwip_htonl>
  dhcp->msg_out->secs = 0;
 8003238:	6963      	ldr	r3, [r4, #20]
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
 800323a:	6078      	str	r0, [r7, #4]
  dhcp->msg_out->secs = 0;
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
 800323c:	731e      	strb	r6, [r3, #12]
 800323e:	735e      	strb	r6, [r3, #13]
 8003240:	739e      	strb	r6, [r3, #14]
 8003242:	73de      	strb	r6, [r3, #15]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
  dhcp->msg_out->secs = 0;
 8003244:	721e      	strb	r6, [r3, #8]
 8003246:	725e      	strb	r6, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 8003248:	729e      	strb	r6, [r3, #10]
 800324a:	72de      	strb	r6, [r3, #11]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
 800324c:	7b22      	ldrb	r2, [r4, #12]
 800324e:	3a04      	subs	r2, #4
 8003250:	2a01      	cmp	r2, #1
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
 8003252:	bf9c      	itt	ls
 8003254:	686a      	ldrls	r2, [r5, #4]
 8003256:	60da      	strls	r2, [r3, #12]
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 8003258:	2200      	movs	r2, #0
 800325a:	741a      	strb	r2, [r3, #16]
 800325c:	745a      	strb	r2, [r3, #17]
 800325e:	749a      	strb	r2, [r3, #18]
 8003260:	74da      	strb	r2, [r3, #19]
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 8003262:	751a      	strb	r2, [r3, #20]
 8003264:	755a      	strb	r2, [r3, #21]
 8003266:	759a      	strb	r2, [r3, #22]
 8003268:	75da      	strb	r2, [r3, #23]
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 800326a:	761a      	strb	r2, [r3, #24]
 800326c:	765a      	strb	r2, [r3, #25]
 800326e:	769a      	strb	r2, [r3, #26]
 8003270:	76da      	strb	r2, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 8003272:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003276:	b10a      	cbz	r2, 800327c <dhcp_renew+0xa0>
 8003278:	f895 202b 	ldrb.w	r2, [r5, #43]	; 0x2b
 800327c:	771a      	strb	r2, [r3, #28]
 800327e:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003282:	6963      	ldr	r3, [r4, #20]
 8003284:	2a01      	cmp	r2, #1
 8003286:	bf8c      	ite	hi
 8003288:	f895 202c 	ldrbhi.w	r2, [r5, #44]	; 0x2c
 800328c:	2200      	movls	r2, #0
 800328e:	775a      	strb	r2, [r3, #29]
 8003290:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003294:	6963      	ldr	r3, [r4, #20]
 8003296:	2a02      	cmp	r2, #2
 8003298:	bf8c      	ite	hi
 800329a:	f895 202d 	ldrbhi.w	r2, [r5, #45]	; 0x2d
 800329e:	2200      	movls	r2, #0
 80032a0:	779a      	strb	r2, [r3, #30]
 80032a2:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80032a6:	6963      	ldr	r3, [r4, #20]
 80032a8:	2a03      	cmp	r2, #3
 80032aa:	bf8c      	ite	hi
 80032ac:	f895 202e 	ldrbhi.w	r2, [r5, #46]	; 0x2e
 80032b0:	2200      	movls	r2, #0
 80032b2:	77da      	strb	r2, [r3, #31]
 80032b4:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80032b8:	6963      	ldr	r3, [r4, #20]
 80032ba:	2a04      	cmp	r2, #4
 80032bc:	bf8c      	ite	hi
 80032be:	f895 202f 	ldrbhi.w	r2, [r5, #47]	; 0x2f
 80032c2:	2200      	movls	r2, #0
 80032c4:	f883 2020 	strb.w	r2, [r3, #32]
 80032c8:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80032cc:	6963      	ldr	r3, [r4, #20]
 80032ce:	2a05      	cmp	r2, #5
 80032d0:	bf8c      	ite	hi
 80032d2:	f895 2030 	ldrbhi.w	r2, [r5, #48]	; 0x30
 80032d6:	2200      	movls	r2, #0
 80032d8:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 80032dc:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80032e0:	6963      	ldr	r3, [r4, #20]
 80032e2:	2a06      	cmp	r2, #6
 80032e4:	bf8c      	ite	hi
 80032e6:	f895 2031 	ldrbhi.w	r2, [r5, #49]	; 0x31
 80032ea:	2200      	movls	r2, #0
 80032ec:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 80032f0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80032f4:	6963      	ldr	r3, [r4, #20]
 80032f6:	2a07      	cmp	r2, #7
 80032f8:	bf8c      	ite	hi
 80032fa:	f895 2032 	ldrbhi.w	r2, [r5, #50]	; 0x32
 80032fe:	2200      	movls	r2, #0
 8003300:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
 8003304:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003308:	6963      	ldr	r3, [r4, #20]
 800330a:	2a08      	cmp	r2, #8
 800330c:	bf8c      	ite	hi
 800330e:	f895 2033 	ldrbhi.w	r2, [r5, #51]	; 0x33
 8003312:	2200      	movls	r2, #0
 8003314:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8003318:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800331c:	6963      	ldr	r3, [r4, #20]
 800331e:	2a09      	cmp	r2, #9
 8003320:	bf8c      	ite	hi
 8003322:	f895 2034 	ldrbhi.w	r2, [r5, #52]	; 0x34
 8003326:	2200      	movls	r2, #0
 8003328:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 800332c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003330:	6963      	ldr	r3, [r4, #20]
 8003332:	2a0a      	cmp	r2, #10
 8003334:	bf8c      	ite	hi
 8003336:	f895 2035 	ldrbhi.w	r2, [r5, #53]	; 0x35
 800333a:	2200      	movls	r2, #0
 800333c:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8003340:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003344:	6963      	ldr	r3, [r4, #20]
 8003346:	2a0b      	cmp	r2, #11
 8003348:	bf8c      	ite	hi
 800334a:	f895 2036 	ldrbhi.w	r2, [r5, #54]	; 0x36
 800334e:	2200      	movls	r2, #0
 8003350:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 8003354:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003358:	6963      	ldr	r3, [r4, #20]
 800335a:	2a0c      	cmp	r2, #12
 800335c:	bf8c      	ite	hi
 800335e:	f895 2037 	ldrbhi.w	r2, [r5, #55]	; 0x37
 8003362:	2200      	movls	r2, #0
 8003364:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8003368:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800336c:	6963      	ldr	r3, [r4, #20]
 800336e:	2a0d      	cmp	r2, #13
 8003370:	bf8c      	ite	hi
 8003372:	f895 2038 	ldrbhi.w	r2, [r5, #56]	; 0x38
 8003376:	2200      	movls	r2, #0
 8003378:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 800337c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003380:	6963      	ldr	r3, [r4, #20]
 8003382:	2a0e      	cmp	r2, #14
 8003384:	bf8c      	ite	hi
 8003386:	f895 2039 	ldrbhi.w	r2, [r5, #57]	; 0x39
 800338a:	2200      	movls	r2, #0
 800338c:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 8003390:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 8003394:	6962      	ldr	r2, [r4, #20]
 8003396:	2b0f      	cmp	r3, #15
 8003398:	bf8c      	ite	hi
 800339a:	f895 103a 	ldrbhi.w	r1, [r5, #58]	; 0x3a
 800339e:	2100      	movls	r1, #0
 80033a0:	2300      	movs	r3, #0
 80033a2:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
 80033a6:	4619      	mov	r1, r3
 80033a8:	6962      	ldr	r2, [r4, #20]
 80033aa:	441a      	add	r2, r3
 80033ac:	3301      	adds	r3, #1
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 80033ae:	2b40      	cmp	r3, #64	; 0x40
    dhcp->msg_out->sname[i] = 0;
 80033b0:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 80033b4:	d1f8      	bne.n	80033a8 <dhcp_renew+0x1cc>
 80033b6:	2300      	movs	r3, #0
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
 80033b8:	4618      	mov	r0, r3
 80033ba:	6962      	ldr	r2, [r4, #20]
 80033bc:	441a      	add	r2, r3
 80033be:	3301      	adds	r3, #1
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 80033c0:	2b80      	cmp	r3, #128	; 0x80
    dhcp->msg_out->file[i] = 0;
 80033c2:	f882 006c 	strb.w	r0, [r2, #108]	; 0x6c
 80033c6:	f04f 0100 	mov.w	r1, #0
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 80033ca:	d1f6      	bne.n	80033ba <dhcp_renew+0x1de>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 80033cc:	6962      	ldr	r2, [r4, #20]
 80033ce:	2363      	movs	r3, #99	; 0x63
 80033d0:	f06f 067d 	mvn.w	r6, #125	; 0x7d
 80033d4:	2053      	movs	r0, #83	; 0x53
 80033d6:	f882 30ec 	strb.w	r3, [r2, #236]	; 0xec
 80033da:	f882 30ef 	strb.w	r3, [r2, #239]	; 0xef
 80033de:	f882 60ed 	strb.w	r6, [r2, #237]	; 0xed
 80033e2:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
  dhcp->options_out_len = 0;
 80033e6:	460b      	mov	r3, r1
 80033e8:	8321      	strh	r1, [r4, #24]
 80033ea:	e000      	b.n	80033ee <dhcp_renew+0x212>
 80033ec:	6962      	ldr	r2, [r4, #20]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 80033ee:	441a      	add	r2, r3
 80033f0:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
 80033f4:	3301      	adds	r3, #1
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 80033f6:	2b44      	cmp	r3, #68	; 0x44
 80033f8:	d1f8      	bne.n	80033ec <dhcp_renew+0x210>
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 80033fa:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 80033fc:	6962      	ldr	r2, [r4, #20]
 80033fe:	441a      	add	r2, r3
 8003400:	2135      	movs	r1, #53	; 0x35
 8003402:	3301      	adds	r3, #1
 8003404:	8323      	strh	r3, [r4, #24]
 8003406:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800340a:	8b23      	ldrh	r3, [r4, #24]
 800340c:	6962      	ldr	r2, [r4, #20]
 800340e:	441a      	add	r2, r3
 8003410:	2101      	movs	r1, #1
 8003412:	3301      	adds	r3, #1
 8003414:	8323      	strh	r3, [r4, #24]
 8003416:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 800341a:	8b23      	ldrh	r3, [r4, #24]
 800341c:	6962      	ldr	r2, [r4, #20]
 800341e:	441a      	add	r2, r3
 8003420:	440b      	add	r3, r1
 8003422:	2103      	movs	r1, #3
 8003424:	8323      	strh	r3, [r4, #24]
 8003426:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800342a:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 800342c:	6962      	ldr	r2, [r4, #20]
 800342e:	441a      	add	r2, r3
 8003430:	2139      	movs	r1, #57	; 0x39
 8003432:	3301      	adds	r3, #1
 8003434:	8323      	strh	r3, [r4, #24]
 8003436:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800343a:	8b23      	ldrh	r3, [r4, #24]
 800343c:	6962      	ldr	r2, [r4, #20]
 800343e:	441a      	add	r2, r3
 8003440:	2102      	movs	r1, #2
 8003442:	3301      	adds	r3, #1
 8003444:	8323      	strh	r3, [r4, #24]
 8003446:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
 800344a:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 800344c:	6962      	ldr	r2, [r4, #20]

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 800344e:	8d29      	ldrh	r1, [r5, #40]	; 0x28

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 8003450:	441a      	add	r2, r3
 8003452:	0a08      	lsrs	r0, r1, #8
 8003454:	3301      	adds	r3, #1
 8003456:	8323      	strh	r3, [r4, #24]
 8003458:	f882 00f0 	strb.w	r0, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 800345c:	8b23      	ldrh	r3, [r4, #24]
 800345e:	6962      	ldr	r2, [r4, #20]
 8003460:	441a      	add	r2, r3
 8003462:	3301      	adds	r3, #1
 8003464:	8323      	strh	r3, [r4, #24]
 8003466:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 800346a:	8b23      	ldrh	r3, [r4, #24]
 800346c:	6962      	ldr	r2, [r4, #20]
 800346e:	441a      	add	r2, r3
 8003470:	21ff      	movs	r1, #255	; 0xff
 8003472:	3301      	adds	r3, #1
 8003474:	8323      	strh	r3, [r4, #24]
 8003476:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 800347a:	8b21      	ldrh	r1, [r4, #24]
 800347c:	2943      	cmp	r1, #67	; 0x43
 800347e:	d809      	bhi.n	8003494 <dhcp_renew+0x2b8>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 8003480:	2200      	movs	r2, #0
 8003482:	6963      	ldr	r3, [r4, #20]
 8003484:	440b      	add	r3, r1
 8003486:	3101      	adds	r1, #1
 8003488:	8321      	strh	r1, [r4, #24]
 800348a:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 800348e:	8b21      	ldrh	r1, [r4, #24]
 8003490:	2943      	cmp	r1, #67	; 0x43
 8003492:	d9f6      	bls.n	8003482 <dhcp_renew+0x2a6>
#endif /* LWIP_NETIF_HOSTNAME */

    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 8003494:	31f0      	adds	r1, #240	; 0xf0
 8003496:	b289      	uxth	r1, r1
 8003498:	6920      	ldr	r0, [r4, #16]
 800349a:	f000 fdfd 	bl	8004098 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
 800349e:	6921      	ldr	r1, [r4, #16]
 80034a0:	6860      	ldr	r0, [r4, #4]
 80034a2:	9500      	str	r5, [sp, #0]
 80034a4:	2343      	movs	r3, #67	; 0x43
 80034a6:	f104 0220 	add.w	r2, r4, #32
 80034aa:	f003 ff05 	bl	80072b8 <udp_sendto_if>
dhcp_delete_msg(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 80034ae:	6920      	ldr	r0, [r4, #16]
 80034b0:	b108      	cbz	r0, 80034b6 <dhcp_renew+0x2da>
    pbuf_free(dhcp->p_out);
 80034b2:	f000 fe71 	bl	8004198 <pbuf_free>
  }
  dhcp->p_out = NULL;
 80034b6:	2000      	movs	r0, #0
 80034b8:	6120      	str	r0, [r4, #16]
  dhcp->msg_out = NULL;
 80034ba:	6160      	str	r0, [r4, #20]

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 80034bc:	7b63      	ldrb	r3, [r4, #13]
 80034be:	3301      	adds	r3, #1
 80034c0:	b2db      	uxtb	r3, r3
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
 80034c2:	2b09      	cmp	r3, #9

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 80034c4:	7363      	strb	r3, [r4, #13]
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
 80034c6:	d816      	bhi.n	80034f6 <dhcp_renew+0x31a>
 80034c8:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 80034cc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80034d0:	011b      	lsls	r3, r3, #4
 80034d2:	b29b      	uxth	r3, r3
 80034d4:	4a0c      	ldr	r2, [pc, #48]	; (8003508 <dhcp_renew+0x32c>)
 80034d6:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 80034da:	fb82 1203 	smull	r1, r2, r2, r3
 80034de:	17db      	asrs	r3, r3, #31
 80034e0:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 80034e4:	b29b      	uxth	r3, r3
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 80034e6:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 80034e8:	b003      	add	sp, #12
 80034ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 80034ec:	4a05      	ldr	r2, [pc, #20]	; (8003504 <dhcp_renew+0x328>)
 80034ee:	6813      	ldr	r3, [r2, #0]
 80034f0:	3301      	adds	r3, #1
 80034f2:	6013      	str	r3, [r2, #0]
 80034f4:	e68e      	b.n	8003214 <dhcp_renew+0x38>
 80034f6:	2328      	movs	r3, #40	; 0x28
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 80034f8:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
 80034fa:	b003      	add	sp, #12
 80034fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
 80034fe:	f04f 30ff 	mov.w	r0, #4294967295
 8003502:	e7db      	b.n	80034bc <dhcp_renew+0x2e0>
 8003504:	20000000 	.word	0x20000000
 8003508:	10624dd3 	.word	0x10624dd3

0800350c <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
 800350c:	4b16      	ldr	r3, [pc, #88]	; (8003568 <dhcp_coarse_tmr+0x5c>)
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
 800350e:	b510      	push	{r4, lr}
  struct netif *netif = netif_list;
 8003510:	681c      	ldr	r4, [r3, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
 8003512:	b93c      	cbnz	r4, 8003524 <dhcp_coarse_tmr+0x18>
 8003514:	e01b      	b.n	800354e <dhcp_coarse_tmr+0x42>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
 8003516:	8b9a      	ldrh	r2, [r3, #28]
 8003518:	1e51      	subs	r1, r2, #1
 800351a:	2a01      	cmp	r2, #1
 800351c:	8399      	strh	r1, [r3, #28]
 800351e:	d017      	beq.n	8003550 <dhcp_coarse_tmr+0x44>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
 8003520:	6824      	ldr	r4, [r4, #0]
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
 8003522:	b1a4      	cbz	r4, 800354e <dhcp_coarse_tmr+0x42>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
 8003524:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003526:	2b00      	cmp	r3, #0
 8003528:	d0fa      	beq.n	8003520 <dhcp_coarse_tmr+0x14>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
 800352a:	8bda      	ldrh	r2, [r3, #30]
 800352c:	1e51      	subs	r1, r2, #1
 800352e:	2a01      	cmp	r2, #1
 8003530:	83d9      	strh	r1, [r3, #30]
 8003532:	d1f0      	bne.n	8003516 <dhcp_coarse_tmr+0xa>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 8003534:	7b1b      	ldrb	r3, [r3, #12]
 8003536:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
 800353a:	2a01      	cmp	r2, #1
 800353c:	d001      	beq.n	8003542 <dhcp_coarse_tmr+0x36>
 800353e:	2b0a      	cmp	r3, #10
 8003540:	d1ee      	bne.n	8003520 <dhcp_coarse_tmr+0x14>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_REBINDING, not DHCP_BOUND */
    dhcp_rebind(netif);
 8003542:	4620      	mov	r0, r4
 8003544:	f7fe fa18 	bl	8001978 <dhcp_rebind>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
 8003548:	6824      	ldr	r4, [r4, #0]
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
 800354a:	2c00      	cmp	r4, #0
 800354c:	d1ea      	bne.n	8003524 <dhcp_coarse_tmr+0x18>
 800354e:	bd10      	pop	{r4, pc}
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 8003550:	7b1b      	ldrb	r3, [r3, #12]
 8003552:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
 8003556:	2a01      	cmp	r2, #1
 8003558:	d001      	beq.n	800355e <dhcp_coarse_tmr+0x52>
 800355a:	2b0a      	cmp	r3, #10
 800355c:	d1e0      	bne.n	8003520 <dhcp_coarse_tmr+0x14>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_RENEWING, not DHCP_BOUND */
    dhcp_renew(netif);
 800355e:	4620      	mov	r0, r4
 8003560:	f7ff fe3c 	bl	80031dc <dhcp_renew>
 8003564:	e7dc      	b.n	8003520 <dhcp_coarse_tmr+0x14>
 8003566:	bf00      	nop
 8003568:	2000573c 	.word	0x2000573c

0800356c <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
 800356c:	b5f0      	push	{r4, r5, r6, r7, lr}
  struct dhcp *dhcp = netif->dhcp;
 800356e:	6a44      	ldr	r4, [r0, #36]	; 0x24
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8003570:	7b23      	ldrb	r3, [r4, #12]
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
 8003572:	b083      	sub	sp, #12
 8003574:	4605      	mov	r5, r0
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8003576:	b11b      	cbz	r3, 8003580 <dhcp_release+0x14>
    dhcp->state = new_state;
 8003578:	2300      	movs	r3, #0
 800357a:	7323      	strb	r3, [r4, #12]
    dhcp->tries = 0;
 800357c:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 800357e:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  /* clean old DHCP offer */
  ip_addr_set_zero(&dhcp->server_ip_addr);
 8003580:	2200      	movs	r2, #0
 8003582:	6222      	str	r2, [r4, #32]
  ip_addr_set_zero(&dhcp->offered_ip_addr);
 8003584:	6262      	str	r2, [r4, #36]	; 0x24
  ip_addr_set_zero(&dhcp->offered_sn_mask);
 8003586:	62a2      	str	r2, [r4, #40]	; 0x28
  ip_addr_set_zero(&dhcp->offered_gw_addr);
 8003588:	62e2      	str	r2, [r4, #44]	; 0x2c
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
 800358a:	63a2      	str	r2, [r4, #56]	; 0x38
 800358c:	6362      	str	r2, [r4, #52]	; 0x34
 800358e:	6322      	str	r2, [r4, #48]	; 0x30
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 8003590:	4610      	mov	r0, r2
 8003592:	f44f 719a 	mov.w	r1, #308	; 0x134
 8003596:	f000 fca7 	bl	8003ee8 <pbuf_alloc>
 800359a:	6120      	str	r0, [r4, #16]
  if (dhcp->p_out == NULL) {
 800359c:	2800      	cmp	r0, #0
 800359e:	f000 8162 	beq.w	8003866 <dhcp_release+0x2fa>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 80035a2:	7b63      	ldrb	r3, [r4, #13]
 80035a4:	2b00      	cmp	r3, #0
 80035a6:	f000 8157 	beq.w	8003858 <dhcp_release+0x2ec>
 80035aa:	4bb0      	ldr	r3, [pc, #704]	; (800386c <dhcp_release+0x300>)
 80035ac:	681b      	ldr	r3, [r3, #0]
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 80035ae:	6841      	ldr	r1, [r0, #4]
 80035b0:	6161      	str	r1, [r4, #20]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 80035b2:	2201      	movs	r2, #1
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 80035b4:	6023      	str	r3, [r4, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 80035b6:	700a      	strb	r2, [r1, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 80035b8:	6963      	ldr	r3, [r4, #20]
 80035ba:	705a      	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
 80035bc:	6963      	ldr	r3, [r4, #20]
 80035be:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80035c2:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
 80035c4:	6963      	ldr	r3, [r4, #20]
 80035c6:	2600      	movs	r6, #0
 80035c8:	70de      	strb	r6, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
 80035ca:	6820      	ldr	r0, [r4, #0]
 80035cc:	6967      	ldr	r7, [r4, #20]
 80035ce:	f7fe f955 	bl	800187c <lwip_htonl>
  dhcp->msg_out->secs = 0;
 80035d2:	6963      	ldr	r3, [r4, #20]
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
 80035d4:	6078      	str	r0, [r7, #4]
  dhcp->msg_out->secs = 0;
 80035d6:	721e      	strb	r6, [r3, #8]
 80035d8:	725e      	strb	r6, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 80035da:	729e      	strb	r6, [r3, #10]
 80035dc:	72de      	strb	r6, [r3, #11]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
 80035de:	731e      	strb	r6, [r3, #12]
 80035e0:	735e      	strb	r6, [r3, #13]
 80035e2:	739e      	strb	r6, [r3, #14]
 80035e4:	73de      	strb	r6, [r3, #15]
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 80035e6:	741e      	strb	r6, [r3, #16]
 80035e8:	745e      	strb	r6, [r3, #17]
 80035ea:	749e      	strb	r6, [r3, #18]
 80035ec:	74de      	strb	r6, [r3, #19]
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 80035ee:	751e      	strb	r6, [r3, #20]
 80035f0:	755e      	strb	r6, [r3, #21]
 80035f2:	759e      	strb	r6, [r3, #22]
 80035f4:	75de      	strb	r6, [r3, #23]
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 80035f6:	761e      	strb	r6, [r3, #24]
 80035f8:	765e      	strb	r6, [r3, #25]
 80035fa:	769e      	strb	r6, [r3, #26]
 80035fc:	76de      	strb	r6, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 80035fe:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003602:	b10a      	cbz	r2, 8003608 <dhcp_release+0x9c>
 8003604:	f895 202b 	ldrb.w	r2, [r5, #43]	; 0x2b
 8003608:	771a      	strb	r2, [r3, #28]
 800360a:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800360e:	6963      	ldr	r3, [r4, #20]
 8003610:	2a01      	cmp	r2, #1
 8003612:	bf8c      	ite	hi
 8003614:	f895 202c 	ldrbhi.w	r2, [r5, #44]	; 0x2c
 8003618:	2200      	movls	r2, #0
 800361a:	775a      	strb	r2, [r3, #29]
 800361c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003620:	6963      	ldr	r3, [r4, #20]
 8003622:	2a02      	cmp	r2, #2
 8003624:	bf8c      	ite	hi
 8003626:	f895 202d 	ldrbhi.w	r2, [r5, #45]	; 0x2d
 800362a:	2200      	movls	r2, #0
 800362c:	779a      	strb	r2, [r3, #30]
 800362e:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003632:	6963      	ldr	r3, [r4, #20]
 8003634:	2a03      	cmp	r2, #3
 8003636:	bf8c      	ite	hi
 8003638:	f895 202e 	ldrbhi.w	r2, [r5, #46]	; 0x2e
 800363c:	2200      	movls	r2, #0
 800363e:	77da      	strb	r2, [r3, #31]
 8003640:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003644:	6963      	ldr	r3, [r4, #20]
 8003646:	2a04      	cmp	r2, #4
 8003648:	bf8c      	ite	hi
 800364a:	f895 202f 	ldrbhi.w	r2, [r5, #47]	; 0x2f
 800364e:	2200      	movls	r2, #0
 8003650:	f883 2020 	strb.w	r2, [r3, #32]
 8003654:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003658:	6963      	ldr	r3, [r4, #20]
 800365a:	2a05      	cmp	r2, #5
 800365c:	bf8c      	ite	hi
 800365e:	f895 2030 	ldrbhi.w	r2, [r5, #48]	; 0x30
 8003662:	2200      	movls	r2, #0
 8003664:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8003668:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800366c:	6963      	ldr	r3, [r4, #20]
 800366e:	2a06      	cmp	r2, #6
 8003670:	bf8c      	ite	hi
 8003672:	f895 2031 	ldrbhi.w	r2, [r5, #49]	; 0x31
 8003676:	2200      	movls	r2, #0
 8003678:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800367c:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003680:	6963      	ldr	r3, [r4, #20]
 8003682:	2a07      	cmp	r2, #7
 8003684:	bf8c      	ite	hi
 8003686:	f895 2032 	ldrbhi.w	r2, [r5, #50]	; 0x32
 800368a:	2200      	movls	r2, #0
 800368c:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
 8003690:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 8003694:	6963      	ldr	r3, [r4, #20]
 8003696:	2a08      	cmp	r2, #8
 8003698:	bf8c      	ite	hi
 800369a:	f895 2033 	ldrbhi.w	r2, [r5, #51]	; 0x33
 800369e:	2200      	movls	r2, #0
 80036a0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 80036a4:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80036a8:	6963      	ldr	r3, [r4, #20]
 80036aa:	2a09      	cmp	r2, #9
 80036ac:	bf8c      	ite	hi
 80036ae:	f895 2034 	ldrbhi.w	r2, [r5, #52]	; 0x34
 80036b2:	2200      	movls	r2, #0
 80036b4:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 80036b8:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80036bc:	6963      	ldr	r3, [r4, #20]
 80036be:	2a0a      	cmp	r2, #10
 80036c0:	bf8c      	ite	hi
 80036c2:	f895 2035 	ldrbhi.w	r2, [r5, #53]	; 0x35
 80036c6:	2200      	movls	r2, #0
 80036c8:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 80036cc:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80036d0:	6963      	ldr	r3, [r4, #20]
 80036d2:	2a0b      	cmp	r2, #11
 80036d4:	bf8c      	ite	hi
 80036d6:	f895 2036 	ldrbhi.w	r2, [r5, #54]	; 0x36
 80036da:	2200      	movls	r2, #0
 80036dc:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 80036e0:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80036e4:	6963      	ldr	r3, [r4, #20]
 80036e6:	2a0c      	cmp	r2, #12
 80036e8:	bf8c      	ite	hi
 80036ea:	f895 2037 	ldrbhi.w	r2, [r5, #55]	; 0x37
 80036ee:	2200      	movls	r2, #0
 80036f0:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 80036f4:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 80036f8:	6963      	ldr	r3, [r4, #20]
 80036fa:	2a0d      	cmp	r2, #13
 80036fc:	bf8c      	ite	hi
 80036fe:	f895 2038 	ldrbhi.w	r2, [r5, #56]	; 0x38
 8003702:	2200      	movls	r2, #0
 8003704:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 8003708:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
 800370c:	6963      	ldr	r3, [r4, #20]
 800370e:	2a0e      	cmp	r2, #14
 8003710:	bf8c      	ite	hi
 8003712:	f895 2039 	ldrbhi.w	r2, [r5, #57]	; 0x39
 8003716:	2200      	movls	r2, #0
 8003718:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 800371c:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 8003720:	6962      	ldr	r2, [r4, #20]
 8003722:	2b0f      	cmp	r3, #15
 8003724:	bf8c      	ite	hi
 8003726:	f895 103a 	ldrbhi.w	r1, [r5, #58]	; 0x3a
 800372a:	2100      	movls	r1, #0
 800372c:	2300      	movs	r3, #0
 800372e:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
 8003732:	4619      	mov	r1, r3
 8003734:	6962      	ldr	r2, [r4, #20]
 8003736:	441a      	add	r2, r3
 8003738:	3301      	adds	r3, #1
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 800373a:	2b40      	cmp	r3, #64	; 0x40
    dhcp->msg_out->sname[i] = 0;
 800373c:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8003740:	d1f8      	bne.n	8003734 <dhcp_release+0x1c8>
 8003742:	2300      	movs	r3, #0
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
 8003744:	4618      	mov	r0, r3
 8003746:	6962      	ldr	r2, [r4, #20]
 8003748:	441a      	add	r2, r3
 800374a:	3301      	adds	r3, #1
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 800374c:	2b80      	cmp	r3, #128	; 0x80
    dhcp->msg_out->file[i] = 0;
 800374e:	f882 006c 	strb.w	r0, [r2, #108]	; 0x6c
 8003752:	f04f 0100 	mov.w	r1, #0
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 8003756:	d1f6      	bne.n	8003746 <dhcp_release+0x1da>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 8003758:	6962      	ldr	r2, [r4, #20]
 800375a:	2363      	movs	r3, #99	; 0x63
 800375c:	f06f 067d 	mvn.w	r6, #125	; 0x7d
 8003760:	2053      	movs	r0, #83	; 0x53
 8003762:	f882 30ec 	strb.w	r3, [r2, #236]	; 0xec
 8003766:	f882 30ef 	strb.w	r3, [r2, #239]	; 0xef
 800376a:	f882 60ed 	strb.w	r6, [r2, #237]	; 0xed
 800376e:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
  dhcp->options_out_len = 0;
 8003772:	460b      	mov	r3, r1
 8003774:	8321      	strh	r1, [r4, #24]
 8003776:	e000      	b.n	800377a <dhcp_release+0x20e>
 8003778:	6962      	ldr	r2, [r4, #20]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 800377a:	441a      	add	r2, r3
 800377c:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
 8003780:	3301      	adds	r3, #1
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 8003782:	2b44      	cmp	r3, #68	; 0x44
 8003784:	d1f8      	bne.n	8003778 <dhcp_release+0x20c>
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 8003786:	8b23      	ldrh	r3, [r4, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 8003788:	6962      	ldr	r2, [r4, #20]
 800378a:	441a      	add	r2, r3
 800378c:	2135      	movs	r1, #53	; 0x35
 800378e:	3301      	adds	r3, #1
 8003790:	8323      	strh	r3, [r4, #24]
 8003792:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 8003796:	8b23      	ldrh	r3, [r4, #24]
 8003798:	6962      	ldr	r2, [r4, #20]
 800379a:	441a      	add	r2, r3
 800379c:	2101      	movs	r1, #1
 800379e:	3301      	adds	r3, #1
 80037a0:	8323      	strh	r3, [r4, #24]
 80037a2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 80037a6:	8b23      	ldrh	r3, [r4, #24]
 80037a8:	6962      	ldr	r2, [r4, #20]
 80037aa:	441a      	add	r2, r3
 80037ac:	440b      	add	r3, r1
 80037ae:	2107      	movs	r1, #7
 80037b0:	8323      	strh	r3, [r4, #24]
 80037b2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 80037b6:	8b23      	ldrh	r3, [r4, #24]
 80037b8:	6962      	ldr	r2, [r4, #20]
 80037ba:	441a      	add	r2, r3
 80037bc:	21ff      	movs	r1, #255	; 0xff
 80037be:	3301      	adds	r3, #1
 80037c0:	8323      	strh	r3, [r4, #24]
 80037c2:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 80037c6:	8b21      	ldrh	r1, [r4, #24]
 80037c8:	2943      	cmp	r1, #67	; 0x43
 80037ca:	d809      	bhi.n	80037e0 <dhcp_release+0x274>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 80037cc:	2200      	movs	r2, #0
 80037ce:	6963      	ldr	r3, [r4, #20]
 80037d0:	440b      	add	r3, r1
 80037d2:	3101      	adds	r1, #1
 80037d4:	8321      	strh	r1, [r4, #24]
 80037d6:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 80037da:	8b21      	ldrh	r1, [r4, #24]
 80037dc:	2943      	cmp	r1, #67	; 0x43
 80037de:	d9f6      	bls.n	80037ce <dhcp_release+0x262>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
  if (result == ERR_OK) {
    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 80037e0:	31f0      	adds	r1, #240	; 0xf0
 80037e2:	b289      	uxth	r1, r1
 80037e4:	6920      	ldr	r0, [r4, #16]
 80037e6:	f000 fc57 	bl	8004098 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
 80037ea:	6921      	ldr	r1, [r4, #16]
 80037ec:	6860      	ldr	r0, [r4, #4]
 80037ee:	9500      	str	r5, [sp, #0]
 80037f0:	2343      	movs	r3, #67	; 0x43
 80037f2:	f104 0220 	add.w	r2, r4, #32
 80037f6:	f003 fd5f 	bl	80072b8 <udp_sendto_if>
dhcp_delete_msg(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 80037fa:	6920      	ldr	r0, [r4, #16]
 80037fc:	b108      	cbz	r0, 8003802 <dhcp_release+0x296>
    pbuf_free(dhcp->p_out);
 80037fe:	f000 fccb 	bl	8004198 <pbuf_free>
  }
  dhcp->p_out = NULL;
 8003802:	2600      	movs	r6, #0
 8003804:	6126      	str	r6, [r4, #16]
  dhcp->msg_out = NULL;
 8003806:	6166      	str	r6, [r4, #20]
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 8003808:	7b63      	ldrb	r3, [r4, #13]
 800380a:	3301      	adds	r3, #1
 800380c:	b2db      	uxtb	r3, r3
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 800380e:	2b09      	cmp	r3, #9
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 8003810:	7363      	strb	r3, [r4, #13]
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 8003812:	d826      	bhi.n	8003862 <dhcp_release+0x2f6>
 8003814:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 8003818:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800381c:	00db      	lsls	r3, r3, #3
 800381e:	b29b      	uxth	r3, r3
 8003820:	4a13      	ldr	r2, [pc, #76]	; (8003870 <dhcp_release+0x304>)
 8003822:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 8003826:	fb82 1203 	smull	r1, r2, r2, r3
 800382a:	17db      	asrs	r3, r3, #31
 800382c:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 8003830:	b29b      	uxth	r3, r3
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 8003832:	8363      	strh	r3, [r4, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
 8003834:	4628      	mov	r0, r5
 8003836:	f000 fb17 	bl	8003e68 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
 800383a:	4628      	mov	r0, r5
 800383c:	490d      	ldr	r1, [pc, #52]	; (8003874 <dhcp_release+0x308>)
 800383e:	f000 fabf 	bl	8003dc0 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
 8003842:	4628      	mov	r0, r5
 8003844:	490b      	ldr	r1, [pc, #44]	; (8003874 <dhcp_release+0x308>)
 8003846:	f000 faef 	bl	8003e28 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
 800384a:	4628      	mov	r0, r5
 800384c:	4909      	ldr	r1, [pc, #36]	; (8003874 <dhcp_release+0x308>)
 800384e:	f000 faef 	bl	8003e30 <netif_set_netmask>
  
  return result;
}
 8003852:	4630      	mov	r0, r6
 8003854:	b003      	add	sp, #12
 8003856:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 8003858:	4a04      	ldr	r2, [pc, #16]	; (800386c <dhcp_release+0x300>)
 800385a:	6813      	ldr	r3, [r2, #0]
 800385c:	3301      	adds	r3, #1
 800385e:	6013      	str	r3, [r2, #0]
 8003860:	e6a5      	b.n	80035ae <dhcp_release+0x42>
 8003862:	2314      	movs	r3, #20
 8003864:	e7e5      	b.n	8003832 <dhcp_release+0x2c6>
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
 8003866:	f04f 36ff 	mov.w	r6, #4294967295
 800386a:	e7cd      	b.n	8003808 <dhcp_release+0x29c>
 800386c:	20000000 	.word	0x20000000
 8003870:	10624dd3 	.word	0x10624dd3
 8003874:	0800c9e0 	.word	0x0800c9e0

08003878 <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
 8003878:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct netif *netif = netif_list;
 800387a:	4b2a      	ldr	r3, [pc, #168]	; (8003924 <dhcp_fine_tmr+0xac>)
 800387c:	681c      	ldr	r4, [r3, #0]
  /* loop through netif's */
  while (netif != NULL) {
 800387e:	b31c      	cbz	r4, 80038c8 <dhcp_fine_tmr+0x50>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
        netif->dhcp->request_timeout--;
      }
      else if (netif->dhcp->request_timeout == 1) {
        netif->dhcp->request_timeout--;
 8003880:	2700      	movs	r7, #0
 8003882:	e003      	b.n	800388c <dhcp_fine_tmr+0x14>
  while (netif != NULL) {
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
        netif->dhcp->request_timeout--;
 8003884:	3d01      	subs	r5, #1
 8003886:	8375      	strh	r5, [r6, #26]
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
 8003888:	6824      	ldr	r4, [r4, #0]
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
 800388a:	b1ec      	cbz	r4, 80038c8 <dhcp_fine_tmr+0x50>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
 800388c:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800388e:	2e00      	cmp	r6, #0
 8003890:	d0fa      	beq.n	8003888 <dhcp_fine_tmr+0x10>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
 8003892:	8b75      	ldrh	r5, [r6, #26]
 8003894:	2d01      	cmp	r5, #1
 8003896:	d8f5      	bhi.n	8003884 <dhcp_fine_tmr+0xc>
        netif->dhcp->request_timeout--;
      }
      else if (netif->dhcp->request_timeout == 1) {
 8003898:	d1f6      	bne.n	8003888 <dhcp_fine_tmr+0x10>
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
 800389a:	7b33      	ldrb	r3, [r6, #12]
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
        netif->dhcp->request_timeout--;
      }
      else if (netif->dhcp->request_timeout == 1) {
        netif->dhcp->request_timeout--;
 800389c:	8377      	strh	r7, [r6, #26]
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
 800389e:	2b0c      	cmp	r3, #12
 80038a0:	d01c      	beq.n	80038dc <dhcp_fine_tmr+0x64>
 80038a2:	2b06      	cmp	r3, #6
 80038a4:	d01a      	beq.n	80038dc <dhcp_fine_tmr+0x64>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
 80038a6:	2b01      	cmp	r3, #1
 80038a8:	d00f      	beq.n	80038ca <dhcp_fine_tmr+0x52>
      dhcp_release(netif);
      dhcp_discover(netif);
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
 80038aa:	2b08      	cmp	r3, #8
 80038ac:	d01a      	beq.n	80038e4 <dhcp_fine_tmr+0x6c>
      dhcp_bind(netif);
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
 80038ae:	2b05      	cmp	r3, #5
 80038b0:	d031      	beq.n	8003916 <dhcp_fine_tmr+0x9e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
 80038b2:	2b04      	cmp	r3, #4
 80038b4:	d01d      	beq.n	80038f2 <dhcp_fine_tmr+0x7a>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
 80038b6:	2b03      	cmp	r3, #3
 80038b8:	d1e6      	bne.n	8003888 <dhcp_fine_tmr+0x10>
    if (dhcp->tries < REBOOT_TRIES) {
 80038ba:	7b73      	ldrb	r3, [r6, #13]
 80038bc:	2b01      	cmp	r3, #1
      dhcp_reboot(netif);
 80038be:	4620      	mov	r0, r4
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    if (dhcp->tries < REBOOT_TRIES) {
 80038c0:	d92d      	bls.n	800391e <dhcp_fine_tmr+0xa6>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
 80038c2:	f7fe f9f3 	bl	8001cac <dhcp_discover>
 80038c6:	e7df      	b.n	8003888 <dhcp_fine_tmr+0x10>
 80038c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
 80038ca:	7b73      	ldrb	r3, [r6, #13]
 80038cc:	2b05      	cmp	r3, #5
      dhcp_select(netif);
 80038ce:	4620      	mov	r0, r4
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
 80038d0:	d802      	bhi.n	80038d8 <dhcp_fine_tmr+0x60>
      dhcp_select(netif);
 80038d2:	f7fe fd79 	bl	80023c8 <dhcp_select>
 80038d6:	e7d7      	b.n	8003888 <dhcp_fine_tmr+0x10>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
      dhcp_rebind(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
 80038d8:	f7ff fe48 	bl	800356c <dhcp_release>
      dhcp_discover(netif);
 80038dc:	4620      	mov	r0, r4
 80038de:	f7fe f9e5 	bl	8001cac <dhcp_discover>
 80038e2:	e7d1      	b.n	8003888 <dhcp_fine_tmr+0x10>
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
 80038e4:	7b73      	ldrb	r3, [r6, #13]
 80038e6:	2b01      	cmp	r3, #1
 80038e8:	d90a      	bls.n	8003900 <dhcp_fine_tmr+0x88>
      dhcp_check(netif);
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
 80038ea:	4620      	mov	r0, r4
 80038ec:	f7fd ffca 	bl	8001884 <dhcp_bind>
 80038f0:	e7ca      	b.n	8003888 <dhcp_fine_tmr+0x10>
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
 80038f2:	7b73      	ldrb	r3, [r6, #13]
 80038f4:	2b08      	cmp	r3, #8
      dhcp_rebind(netif);
 80038f6:	4620      	mov	r0, r4
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
 80038f8:	d8ee      	bhi.n	80038d8 <dhcp_fine_tmr+0x60>
      dhcp_rebind(netif);
 80038fa:	f7fe f83d 	bl	8001978 <dhcp_rebind>
 80038fe:	e7c3      	b.n	8003888 <dhcp_fine_tmr+0x10>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
 8003900:	2200      	movs	r2, #0
 8003902:	f106 0124 	add.w	r1, r6, #36	; 0x24
 8003906:	4620      	mov	r0, r4
 8003908:	f004 faec 	bl	8007ee4 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
 800390c:	7b73      	ldrb	r3, [r6, #13]
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800390e:	8375      	strh	r5, [r6, #26]
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
 8003910:	3301      	adds	r3, #1
 8003912:	7373      	strb	r3, [r6, #13]
 8003914:	e7b8      	b.n	8003888 <dhcp_fine_tmr+0x10>
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
 8003916:	4620      	mov	r0, r4
 8003918:	f7ff fc60 	bl	80031dc <dhcp_renew>
 800391c:	e7b4      	b.n	8003888 <dhcp_fine_tmr+0x10>
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    if (dhcp->tries < REBOOT_TRIES) {
      dhcp_reboot(netif);
 800391e:	f7fe fb85 	bl	800202c <dhcp_reboot>
 8003922:	e7b1      	b.n	8003888 <dhcp_fine_tmr+0x10>
 8003924:	2000573c 	.word	0x2000573c

08003928 <dhcp_stop>:
 */
void
dhcp_stop(struct netif *netif)
{
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
 8003928:	b1a8      	cbz	r0, 8003956 <dhcp_stop+0x2e>
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
 800392a:	b510      	push	{r4, lr}
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  dhcp = netif->dhcp;
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 800392c:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
void
dhcp_stop(struct netif *netif)
{
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  dhcp = netif->dhcp;
 8003930:	6a44      	ldr	r4, [r0, #36]	; 0x24
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 8003932:	f023 0308 	bic.w	r3, r3, #8
 8003936:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
 800393a:	b15c      	cbz	r4, 8003954 <dhcp_stop+0x2c>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
 800393c:	6860      	ldr	r0, [r4, #4]
 800393e:	b118      	cbz	r0, 8003948 <dhcp_stop+0x20>
      udp_remove(dhcp->pcb);
 8003940:	f003 fd4c 	bl	80073dc <udp_remove>
      dhcp->pcb = NULL;
 8003944:	2300      	movs	r3, #0
 8003946:	6063      	str	r3, [r4, #4]
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 8003948:	7b23      	ldrb	r3, [r4, #12]
 800394a:	b11b      	cbz	r3, 8003954 <dhcp_stop+0x2c>
    dhcp->state = new_state;
 800394c:	2300      	movs	r3, #0
 800394e:	7323      	strb	r3, [r4, #12]
    dhcp->tries = 0;
 8003950:	7363      	strb	r3, [r4, #13]
    dhcp->request_timeout = 0;
 8003952:	8363      	strh	r3, [r4, #26]
 8003954:	bd10      	pop	{r4, pc}
 8003956:	4770      	bx	lr

08003958 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8003958:	4b0b      	ldr	r3, [pc, #44]	; (8003988 <mem_init+0x30>)
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 800395a:	b4f0      	push	{r4, r5, r6, r7}

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800395c:	f023 0303 	bic.w	r3, r3, #3
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 8003960:	f503 5220 	add.w	r2, r3, #10240	; 0x2800

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 8003964:	f44f 5120 	mov.w	r1, #10240	; 0x2800

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8003968:	4f08      	ldr	r7, [pc, #32]	; (800398c <mem_init+0x34>)
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 800396a:	4e09      	ldr	r6, [pc, #36]	; (8003990 <mem_init+0x38>)
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800396c:	4d09      	ldr	r5, [pc, #36]	; (8003994 <mem_init+0x3c>)

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 800396e:	8019      	strh	r1, [r3, #0]
  mem->prev = 0;
 8003970:	2000      	movs	r0, #0
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
 8003972:	2401      	movs	r4, #1
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
 8003974:	7118      	strb	r0, [r3, #4]
  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
 8003976:	8058      	strh	r0, [r3, #2]
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
 8003978:	7114      	strb	r4, [r2, #4]

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800397a:	603b      	str	r3, [r7, #0]
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 800397c:	6033      	str	r3, [r6, #0]
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800397e:	602a      	str	r2, [r5, #0]
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
 8003980:	8011      	strh	r1, [r2, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 8003982:	8051      	strh	r1, [r2, #2]
  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 8003984:	bcf0      	pop	{r4, r5, r6, r7}
 8003986:	4770      	bx	lr
 8003988:	20002f2b 	.word	0x20002f2b
 800398c:	20000580 	.word	0x20000580
 8003990:	20000578 	.word	0x20000578
 8003994:	2000057c 	.word	0x2000057c

08003998 <mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 8003998:	2800      	cmp	r0, #0
 800399a:	d03c      	beq.n	8003a16 <mem_free+0x7e>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 800399c:	4b1e      	ldr	r3, [pc, #120]	; (8003a18 <mem_free+0x80>)
 800399e:	681b      	ldr	r3, [r3, #0]
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80039a0:	4298      	cmp	r0, r3
 80039a2:	d338      	bcc.n	8003a16 <mem_free+0x7e>
 80039a4:	4a1d      	ldr	r2, [pc, #116]	; (8003a1c <mem_free+0x84>)
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 80039a6:	b5f0      	push	{r4, r5, r6, r7, lr}
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80039a8:	6814      	ldr	r4, [r2, #0]
 80039aa:	42a0      	cmp	r0, r4
 80039ac:	d232      	bcs.n	8003a14 <mem_free+0x7c>
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
 80039ae:	4e1c      	ldr	r6, [pc, #112]	; (8003a20 <mem_free+0x88>)
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
 80039b0:	f830 5c08 	ldrh.w	r5, [r0, #-8]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
 80039b4:	6837      	ldr	r7, [r6, #0]
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 80039b6:	f1a0 0208 	sub.w	r2, r0, #8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 80039ba:	2100      	movs	r1, #0

  if (mem < lfree) {
 80039bc:	42ba      	cmp	r2, r7
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 80039be:	f800 1c04 	strb.w	r1, [r0, #-4]
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
 80039c2:	eb03 0105 	add.w	r1, r3, r5
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
    /* the newly freed struct is now the lowest */
    lfree = mem;
 80039c6:	bf3c      	itt	cc
 80039c8:	6032      	strcc	r2, [r6, #0]
 80039ca:	4617      	movcc	r7, r2

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 80039cc:	428a      	cmp	r2, r1
 80039ce:	d010      	beq.n	80039f2 <mem_free+0x5a>
 80039d0:	f891 e004 	ldrb.w	lr, [r1, #4]
 80039d4:	f1be 0f00 	cmp.w	lr, #0
 80039d8:	d10b      	bne.n	80039f2 <mem_free+0x5a>
 80039da:	428c      	cmp	r4, r1
 80039dc:	d009      	beq.n	80039f2 <mem_free+0x5a>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
      lfree = mem;
    }
    mem->next = nmem->next;
 80039de:	880d      	ldrh	r5, [r1, #0]
 80039e0:	f820 5c08 	strh.w	r5, [r0, #-8]
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 80039e4:	42b9      	cmp	r1, r7
      lfree = mem;
    }
    mem->next = nmem->next;
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 80039e6:	8809      	ldrh	r1, [r1, #0]

  nmem = (struct mem *)(void *)&ram[mem->next];
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
      lfree = mem;
 80039e8:	bf08      	it	eq
 80039ea:	6032      	streq	r2, [r6, #0]
    }
    mem->next = nmem->next;
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 80039ec:	4419      	add	r1, r3
 80039ee:	1ad4      	subs	r4, r2, r3
 80039f0:	804c      	strh	r4, [r1, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
 80039f2:	f830 1c06 	ldrh.w	r1, [r0, #-6]
 80039f6:	185c      	adds	r4, r3, r1
  if (pmem != mem && pmem->used == 0) {
 80039f8:	42a2      	cmp	r2, r4
 80039fa:	d00b      	beq.n	8003a14 <mem_free+0x7c>
 80039fc:	7927      	ldrb	r7, [r4, #4]
 80039fe:	b94f      	cbnz	r7, 8003a14 <mem_free+0x7c>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
      lfree = pmem;
    }
    pmem->next = mem->next;
 8003a00:	525d      	strh	r5, [r3, r1]

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
  if (pmem != mem && pmem->used == 0) {
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 8003a02:	6836      	ldr	r6, [r6, #0]
 8003a04:	4f06      	ldr	r7, [pc, #24]	; (8003a20 <mem_free+0x88>)
 8003a06:	42b2      	cmp	r2, r6
      lfree = pmem;
    }
    pmem->next = mem->next;
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 8003a08:	f830 2c08 	ldrh.w	r2, [r0, #-8]
  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
  if (pmem != mem && pmem->used == 0) {
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
      lfree = pmem;
 8003a0c:	bf08      	it	eq
 8003a0e:	603c      	streq	r4, [r7, #0]
    }
    pmem->next = mem->next;
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 8003a10:	4413      	add	r3, r2
 8003a12:	8059      	strh	r1, [r3, #2]
 8003a14:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003a16:	4770      	bx	lr
 8003a18:	20000580 	.word	0x20000580
 8003a1c:	2000057c 	.word	0x2000057c
 8003a20:	20000578 	.word	0x20000578

08003a24 <mem_trim>:
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8003a24:	3103      	adds	r1, #3
 8003a26:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 8003a2a:	400b      	ands	r3, r1

  if(newsize < MIN_SIZE_ALIGNED) {
 8003a2c:	2b0b      	cmp	r3, #11
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 8003a2e:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
 8003a30:	d937      	bls.n	8003aa2 <mem_trim+0x7e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 8003a32:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
 8003a36:	d832      	bhi.n	8003a9e <mem_trim+0x7a>
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8003a38:	4a27      	ldr	r2, [pc, #156]	; (8003ad8 <mem_trim+0xb4>)
 8003a3a:	6814      	ldr	r4, [r2, #0]
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8003a3c:	4284      	cmp	r4, r0
 8003a3e:	d82f      	bhi.n	8003aa0 <mem_trim+0x7c>
 8003a40:	4a26      	ldr	r2, [pc, #152]	; (8003adc <mem_trim+0xb8>)
 8003a42:	6812      	ldr	r2, [r2, #0]
 8003a44:	4290      	cmp	r0, r2
 8003a46:	d22b      	bcs.n	8003aa0 <mem_trim+0x7c>
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 8003a48:	f1a0 0208 	sub.w	r2, r0, #8

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8003a4c:	f830 5c08 	ldrh.w	r5, [r0, #-8]
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 8003a50:	1b12      	subs	r2, r2, r4
 8003a52:	b292      	uxth	r2, r2

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8003a54:	f1a5 0108 	sub.w	r1, r5, #8
 8003a58:	1a89      	subs	r1, r1, r2
 8003a5a:	b289      	uxth	r1, r1
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 8003a5c:	4299      	cmp	r1, r3
 8003a5e:	d31e      	bcc.n	8003a9e <mem_trim+0x7a>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 8003a60:	d01e      	beq.n	8003aa0 <mem_trim+0x7c>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = (struct mem *)(void *)&ram[mem->next];
 8003a62:	1966      	adds	r6, r4, r5
  if(mem2->used == 0) {
 8003a64:	7937      	ldrb	r7, [r6, #4]
 8003a66:	b1f7      	cbz	r7, 8003aa6 <mem_trim+0x82>
    if (mem2->next != MEM_SIZE_ALIGNED) {
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8003a68:	f103 0614 	add.w	r6, r3, #20
 8003a6c:	428e      	cmp	r6, r1
 8003a6e:	d817      	bhi.n	8003aa0 <mem_trim+0x7c>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8003a70:	f102 0108 	add.w	r1, r2, #8
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
 8003a74:	4e1a      	ldr	r6, [pc, #104]	; (8003ae0 <mem_trim+0xbc>)
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8003a76:	440b      	add	r3, r1
 8003a78:	b29b      	uxth	r3, r3
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
 8003a7a:	6837      	ldr	r7, [r6, #0]
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)(void *)&ram[ptr2];
 8003a7c:	18e1      	adds	r1, r4, r3
    if (mem2 < lfree) {
 8003a7e:	42b9      	cmp	r1, r7
      lfree = mem2;
 8003a80:	bf38      	it	cc
 8003a82:	6031      	strcc	r1, [r6, #0]
    }
    mem2->used = 0;
 8003a84:	2600      	movs	r6, #0
 8003a86:	710e      	strb	r6, [r1, #4]
    mem2->next = mem->next;
 8003a88:	52e5      	strh	r5, [r4, r3]
    mem2->prev = ptr;
 8003a8a:	804a      	strh	r2, [r1, #2]
    mem->next = ptr2;
 8003a8c:	f820 3c08 	strh.w	r3, [r0, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8003a90:	5ae2      	ldrh	r2, [r4, r3]
 8003a92:	f5b2 5f20 	cmp.w	r2, #10240	; 0x2800
 8003a96:	d003      	beq.n	8003aa0 <mem_trim+0x7c>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8003a98:	4414      	add	r4, r2
 8003a9a:	8063      	strh	r3, [r4, #2]
 8003a9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
 8003a9e:	2000      	movs	r0, #0
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 8003aa0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 8003aa2:	230c      	movs	r3, #12
 8003aa4:	e7c8      	b.n	8003a38 <mem_trim+0x14>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8003aa6:	f102 0108 	add.w	r1, r2, #8
    if (lfree == mem2) {
 8003aaa:	4f0d      	ldr	r7, [pc, #52]	; (8003ae0 <mem_trim+0xbc>)
  mem2 = (struct mem *)(void *)&ram[mem->next];
  if(mem2->used == 0) {
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 8003aac:	f834 e005 	ldrh.w	lr, [r4, r5]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
 8003ab0:	683d      	ldr	r5, [r7, #0]
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8003ab2:	440b      	add	r3, r1
 8003ab4:	b29b      	uxth	r3, r3
    if (lfree == mem2) {
      lfree = (struct mem *)(void *)&ram[ptr2];
 8003ab6:	18e1      	adds	r1, r4, r3
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
 8003ab8:	42ae      	cmp	r6, r5
      lfree = (struct mem *)(void *)&ram[ptr2];
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    mem2->used = 0;
 8003aba:	f04f 0500 	mov.w	r5, #0
    /* restore the next pointer */
    mem2->next = next;
 8003abe:	f8a1 e000 	strh.w	lr, [r1]
    /* link it back to mem */
    mem2->prev = ptr;
 8003ac2:	804a      	strh	r2, [r1, #2]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
      lfree = (struct mem *)(void *)&ram[ptr2];
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    mem2->used = 0;
 8003ac4:	710d      	strb	r5, [r1, #4]
    /* restore the next pointer */
    mem2->next = next;
    /* link it back to mem */
    mem2->prev = ptr;
    /* link mem to it */
    mem->next = ptr2;
 8003ac6:	f820 3c08 	strh.w	r3, [r0, #-8]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8003aca:	880a      	ldrh	r2, [r1, #0]
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
      lfree = (struct mem *)(void *)&ram[ptr2];
 8003acc:	bf08      	it	eq
 8003ace:	6039      	streq	r1, [r7, #0]
    /* link mem to it */
    mem->next = ptr2;
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8003ad0:	f5b2 5f20 	cmp.w	r2, #10240	; 0x2800
 8003ad4:	d1e0      	bne.n	8003a98 <mem_trim+0x74>
 8003ad6:	e7e3      	b.n	8003aa0 <mem_trim+0x7c>
 8003ad8:	20000580 	.word	0x20000580
 8003adc:	2000057c 	.word	0x2000057c
 8003ae0:	20000578 	.word	0x20000578

08003ae4 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 8003ae4:	b5f0      	push	{r4, r5, r6, r7, lr}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 8003ae6:	b318      	cbz	r0, 8003b30 <mem_malloc+0x4c>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 8003ae8:	3003      	adds	r0, #3
 8003aea:	f64f 7cfc 	movw	ip, #65532	; 0xfffc
 8003aee:	ea00 0c0c 	and.w	ip, r0, ip

  if(size < MIN_SIZE_ALIGNED) {
 8003af2:	f1bc 0f0b 	cmp.w	ip, #11
 8003af6:	d91c      	bls.n	8003b32 <mem_malloc+0x4e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 8003af8:	f5bc 5f20 	cmp.w	ip, #10240	; 0x2800
 8003afc:	d817      	bhi.n	8003b2e <mem_malloc+0x4a>
 8003afe:	f5cc 5120 	rsb	r1, ip, #10240	; 0x2800
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8003b02:	4b27      	ldr	r3, [pc, #156]	; (8003ba0 <mem_malloc+0xbc>)
 8003b04:	f8df e0a0 	ldr.w	lr, [pc, #160]	; 8003ba8 <mem_malloc+0xc4>
 8003b08:	681c      	ldr	r4, [r3, #0]
 8003b0a:	f8de 7000 	ldr.w	r7, [lr]
 8003b0e:	1b3b      	subs	r3, r7, r4
 8003b10:	b29b      	uxth	r3, r3
 8003b12:	428b      	cmp	r3, r1
 8003b14:	da0b      	bge.n	8003b2e <mem_malloc+0x4a>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
 8003b16:	18e0      	adds	r0, r4, r3
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8003b18:	7905      	ldrb	r5, [r0, #4]
 8003b1a:	b97d      	cbnz	r5, 8003b3c <mem_malloc+0x58>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8003b1c:	5ae6      	ldrh	r6, [r4, r3]
 8003b1e:	f1a6 0208 	sub.w	r2, r6, #8
 8003b22:	1ad2      	subs	r2, r2, r3
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8003b24:	4562      	cmp	r2, ip
 8003b26:	d20b      	bcs.n	8003b40 <mem_malloc+0x5c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8003b28:	4633      	mov	r3, r6
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8003b2a:	428b      	cmp	r3, r1
 8003b2c:	dbf3      	blt.n	8003b16 <mem_malloc+0x32>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
 8003b2e:	2000      	movs	r0, #0
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
 8003b30:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b32:	f242 71f4 	movw	r1, #10228	; 0x27f4
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 8003b36:	f04f 0c0c 	mov.w	ip, #12
 8003b3a:	e7e2      	b.n	8003b02 <mem_malloc+0x1e>
 8003b3c:	5ae3      	ldrh	r3, [r4, r3]
 8003b3e:	e7e8      	b.n	8003b12 <mem_malloc+0x2e>
      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8003b40:	f10c 0114 	add.w	r1, ip, #20
 8003b44:	428a      	cmp	r2, r1
 8003b46:	d205      	bcs.n	8003b54 <mem_malloc+0x70>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8003b48:	2301      	movs	r3, #1
 8003b4a:	7103      	strb	r3, [r0, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8003b4c:	4287      	cmp	r7, r0
 8003b4e:	d015      	beq.n	8003b7c <mem_malloc+0x98>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 8003b50:	3008      	adds	r0, #8
 8003b52:	bdf0      	pop	{r4, r5, r6, r7, pc}
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8003b54:	f10c 0208 	add.w	r2, ip, #8
 8003b58:	441a      	add	r2, r3
 8003b5a:	b292      	uxth	r2, r2
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
 8003b5c:	18a1      	adds	r1, r4, r2
          mem2->used = 0;
          mem2->next = mem->next;
          mem2->prev = ptr;
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
          mem->used = 1;
 8003b5e:	f04f 0c01 	mov.w	ip, #1
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
          mem2->used = 0;
 8003b62:	710d      	strb	r5, [r1, #4]
          mem2->next = mem->next;
 8003b64:	52a6      	strh	r6, [r4, r2]
          mem2->prev = ptr;
 8003b66:	804b      	strh	r3, [r1, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 8003b68:	8002      	strh	r2, [r0, #0]
          mem->used = 1;
 8003b6a:	f880 c004 	strb.w	ip, [r0, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 8003b6e:	5aa3      	ldrh	r3, [r4, r2]
 8003b70:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
 8003b74:	d0ea      	beq.n	8003b4c <mem_malloc+0x68>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8003b76:	4423      	add	r3, r4
 8003b78:	805a      	strh	r2, [r3, #2]
 8003b7a:	e7e7      	b.n	8003b4c <mem_malloc+0x68>
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 8003b7c:	793b      	ldrb	r3, [r7, #4]
 8003b7e:	b16b      	cbz	r3, 8003b9c <mem_malloc+0xb8>
 8003b80:	4b08      	ldr	r3, [pc, #32]	; (8003ba4 <mem_malloc+0xc0>)
 8003b82:	681a      	ldr	r2, [r3, #0]
 8003b84:	e003      	b.n	8003b8e <mem_malloc+0xaa>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
 8003b86:	883f      	ldrh	r7, [r7, #0]
 8003b88:	4427      	add	r7, r4
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 8003b8a:	793b      	ldrb	r3, [r7, #4]
 8003b8c:	b123      	cbz	r3, 8003b98 <mem_malloc+0xb4>
 8003b8e:	4297      	cmp	r7, r2
 8003b90:	d1f9      	bne.n	8003b86 <mem_malloc+0xa2>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
 8003b92:	f8ce 2000 	str.w	r2, [lr]
 8003b96:	e7db      	b.n	8003b50 <mem_malloc+0x6c>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
 8003b98:	463a      	mov	r2, r7
 8003b9a:	e7fa      	b.n	8003b92 <mem_malloc+0xae>
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 8003b9c:	4602      	mov	r2, r0
 8003b9e:	e7f8      	b.n	8003b92 <mem_malloc+0xae>
 8003ba0:	20000580 	.word	0x20000580
 8003ba4:	2000057c 	.word	0x2000057c
 8003ba8:	20000578 	.word	0x20000578

08003bac <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 8003bac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 8003bb0:	4e16      	ldr	r6, [pc, #88]	; (8003c0c <memp_init+0x60>)
 8003bb2:	4d17      	ldr	r5, [pc, #92]	; (8003c10 <memp_init+0x64>)
 8003bb4:	f8df e060 	ldr.w	lr, [pc, #96]	; 8003c18 <memp_init+0x6c>
 8003bb8:	4f16      	ldr	r7, [pc, #88]	; (8003c14 <memp_init+0x68>)
 8003bba:	f026 0603 	bic.w	r6, r6, #3
 8003bbe:	f105 0824 	add.w	r8, r5, #36	; 0x24
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 8003bc2:	f04f 0c00 	mov.w	ip, #0
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 8003bc6:	f83e 4f02 	ldrh.w	r4, [lr, #2]!
#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 8003bca:	f845 cf04 	str.w	ip, [r5, #4]!
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 8003bce:	b1b4      	cbz	r4, 8003bfe <memp_init+0x52>
 8003bd0:	2200      	movs	r2, #0
 8003bd2:	4611      	mov	r1, r2
 8003bd4:	f8b7 9000 	ldrh.w	r9, [r7]
 8003bd8:	4633      	mov	r3, r6
 8003bda:	e000      	b.n	8003bde <memp_init+0x32>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 8003bdc:	4653      	mov	r3, sl
 8003bde:	3201      	adds	r2, #1
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 8003be0:	b290      	uxth	r0, r2
 8003be2:	4284      	cmp	r4, r0
      memp->next = memp_tab[i];
 8003be4:	6019      	str	r1, [r3, #0]
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 8003be6:	eb03 0a09 	add.w	sl, r3, r9
 8003bea:	4619      	mov	r1, r3
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 8003bec:	d8f6      	bhi.n	8003bdc <memp_init+0x30>
 8003bee:	1e63      	subs	r3, r4, #1
 8003bf0:	b29c      	uxth	r4, r3
 8003bf2:	fb04 9309 	mla	r3, r4, r9, r9
 8003bf6:	fb09 6404 	mla	r4, r9, r4, r6
 8003bfa:	602c      	str	r4, [r5, #0]
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 8003bfc:	441e      	add	r6, r3

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
 8003bfe:	4545      	cmp	r5, r8
 8003c00:	f107 0702 	add.w	r7, r7, #2
 8003c04:	d1df      	bne.n	8003bc6 <memp_init+0x1a>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 8003c06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003c0a:	bf00      	nop
 8003c0c:	20000587 	.word	0x20000587
 8003c10:	2000294c 	.word	0x2000294c
 8003c14:	0800c9f8 	.word	0x0800c9f8
 8003c18:	0800c9e2 	.word	0x0800c9e2

08003c1c <memp_malloc>:
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8003c1c:	2808      	cmp	r0, #8
 8003c1e:	d808      	bhi.n	8003c32 <memp_malloc+0x16>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 8003c20:	4a06      	ldr	r2, [pc, #24]	; (8003c3c <memp_malloc+0x20>)
 8003c22:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]
  
  if (memp != NULL) {
 8003c26:	b133      	cbz	r3, 8003c36 <memp_malloc+0x1a>
    memp_tab[type] = memp->next;
 8003c28:	6819      	ldr	r1, [r3, #0]
 8003c2a:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
 8003c2e:	4618      	mov	r0, r3
 8003c30:	4770      	bx	lr
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8003c32:	2000      	movs	r0, #0
 8003c34:	4770      	bx	lr
 8003c36:	4618      	mov	r0, r3
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
 8003c38:	4770      	bx	lr
 8003c3a:	bf00      	nop
 8003c3c:	20002950 	.word	0x20002950

08003c40 <memp_free>:
memp_free(memp_t type, void *mem)
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 8003c40:	b129      	cbz	r1, 8003c4e <memp_free+0xe>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
 8003c42:	4b03      	ldr	r3, [pc, #12]	; (8003c50 <memp_free+0x10>)
 8003c44:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8003c48:	600a      	str	r2, [r1, #0]
  memp_tab[type] = memp;
 8003c4a:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
 8003c4e:	4770      	bx	lr
 8003c50:	20002950 	.word	0x20002950

08003c54 <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 8003c54:	e92d 42f0 	stmdb	sp!, {r4, r5, r6, r7, r9, lr}
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 8003c58:	f8df e0c4 	ldr.w	lr, [pc, #196]	; 8003d20 <netif_add+0xcc>
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 8003c5c:	9e06      	ldr	r6, [sp, #24]
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 8003c5e:	f89e c000 	ldrb.w	ip, [lr]
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 8003c62:	6206      	str	r6, [r0, #32]
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 8003c64:	4617      	mov	r7, r2

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
 8003c66:	2600      	movs	r6, #0
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 8003c68:	461d      	mov	r5, r3
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
  netif->input = input;
 8003c6a:	9a08      	ldr	r2, [sp, #32]
 8003c6c:	6102      	str	r2, [r0, #16]
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 8003c6e:	f10c 0301 	add.w	r3, ip, #1
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 8003c72:	4604      	mov	r4, r0
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 8003c74:	f880 c034 	strb.w	ip, [r0, #52]	; 0x34
 8003c78:	f88e 3000 	strb.w	r3, [lr]
{

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
 8003c7c:	6046      	str	r6, [r0, #4]
  ip_addr_set_zero(&netif->netmask);
 8003c7e:	6086      	str	r6, [r0, #8]
  ip_addr_set_zero(&netif->gw);
 8003c80:	60c6      	str	r6, [r0, #12]
  netif->flags = 0;
 8003c82:	f880 6031 	strb.w	r6, [r0, #49]	; 0x31
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
 8003c86:	6246      	str	r6, [r0, #36]	; 0x24
#endif /* LWIP_AUTOIP */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 8003c88:	61c6      	str	r6, [r0, #28]
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 8003c8a:	4689      	mov	r9, r1
 8003c8c:	2900      	cmp	r1, #0
 8003c8e:	d035      	beq.n	8003cfc <netif_add+0xa8>
 8003c90:	6809      	ldr	r1, [r1, #0]
 8003c92:	b309      	cbz	r1, 8003cd8 <netif_add+0x84>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 8003c94:	4b1f      	ldr	r3, [pc, #124]	; (8003d14 <netif_add+0xc0>)
 8003c96:	6818      	ldr	r0, [r3, #0]
    while (pcb != NULL) {
 8003c98:	b180      	cbz	r0, 8003cbc <netif_add+0x68>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8003c9a:	6803      	ldr	r3, [r0, #0]
 8003c9c:	42b3      	cmp	r3, r6
 8003c9e:	d005      	beq.n	8003cac <netif_add+0x58>
        struct tcp_pcb *next = pcb->next;
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
        pcb = next;
      } else {
        pcb = pcb->next;
 8003ca0:	68c0      	ldr	r0, [r0, #12]
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8003ca2:	b148      	cbz	r0, 8003cb8 <netif_add+0x64>
 8003ca4:	6866      	ldr	r6, [r4, #4]
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8003ca6:	6803      	ldr	r3, [r0, #0]
 8003ca8:	42b3      	cmp	r3, r6
 8003caa:	d1f9      	bne.n	8003ca0 <netif_add+0x4c>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 8003cac:	68c6      	ldr	r6, [r0, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 8003cae:	f001 f9d9 	bl	8005064 <tcp_abort>
        pcb = next;
 8003cb2:	4630      	mov	r0, r6
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8003cb4:	2800      	cmp	r0, #0
 8003cb6:	d1f5      	bne.n	8003ca4 <netif_add+0x50>
 8003cb8:	f8d9 1000 	ldr.w	r1, [r9]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8003cbc:	4b16      	ldr	r3, [pc, #88]	; (8003d18 <netif_add+0xc4>)
 8003cbe:	6818      	ldr	r0, [r3, #0]
 8003cc0:	b150      	cbz	r0, 8003cd8 <netif_add+0x84>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 8003cc2:	6803      	ldr	r3, [r0, #0]
 8003cc4:	b12b      	cbz	r3, 8003cd2 <netif_add+0x7e>
 8003cc6:	6862      	ldr	r2, [r4, #4]
 8003cc8:	4293      	cmp	r3, r2
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 8003cca:	bf04      	itt	eq
 8003ccc:	6001      	streq	r1, [r0, #0]
 8003cce:	f8d9 1000 	ldreq.w	r1, [r9]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8003cd2:	68c0      	ldr	r0, [r0, #12]
 8003cd4:	2800      	cmp	r0, #0
 8003cd6:	d1f4      	bne.n	8003cc2 <netif_add+0x6e>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8003cd8:	6061      	str	r1, [r4, #4]
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8003cda:	b107      	cbz	r7, 8003cde <netif_add+0x8a>
 8003cdc:	683f      	ldr	r7, [r7, #0]
 8003cde:	60a7      	str	r7, [r4, #8]
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 8003ce0:	b16d      	cbz	r5, 8003cfe <netif_add+0xaa>
 8003ce2:	682b      	ldr	r3, [r5, #0]
 8003ce4:	60e3      	str	r3, [r4, #12]
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 8003ce6:	4620      	mov	r0, r4
 8003ce8:	9b07      	ldr	r3, [sp, #28]
 8003cea:	4798      	blx	r3
 8003cec:	b970      	cbnz	r0, 8003d0c <netif_add+0xb8>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8003cee:	4b0b      	ldr	r3, [pc, #44]	; (8003d1c <netif_add+0xc8>)
 8003cf0:	681a      	ldr	r2, [r3, #0]
 8003cf2:	6022      	str	r2, [r4, #0]
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 8003cf4:	4620      	mov	r0, r4
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  netif_list = netif;
 8003cf6:	601c      	str	r4, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 8003cf8:	e8bd 82f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}
 8003cfc:	e7ec      	b.n	8003cd8 <netif_add+0x84>
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 8003cfe:	462b      	mov	r3, r5
 8003d00:	60e3      	str	r3, [r4, #12]
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 8003d02:	4620      	mov	r0, r4
 8003d04:	9b07      	ldr	r3, [sp, #28]
 8003d06:	4798      	blx	r3
 8003d08:	2800      	cmp	r0, #0
 8003d0a:	d0f0      	beq.n	8003cee <netif_add+0x9a>
    return NULL;
 8003d0c:	2000      	movs	r0, #0
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
 8003d0e:	e8bd 82f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}
 8003d12:	bf00      	nop
 8003d14:	20005748 	.word	0x20005748
 8003d18:	20005750 	.word	0x20005750
 8003d1c:	2000573c 	.word	0x2000573c
 8003d20:	20002974 	.word	0x20002974

08003d24 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
 8003d24:	e92d 45f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
 8003d28:	4606      	mov	r6, r0
 8003d2a:	4690      	mov	r8, r2
 8003d2c:	461f      	mov	r7, r3
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 8003d2e:	468a      	mov	sl, r1
 8003d30:	2900      	cmp	r1, #0
 8003d32:	d032      	beq.n	8003d9a <netif_set_addr+0x76>
 8003d34:	680b      	ldr	r3, [r1, #0]
 8003d36:	6844      	ldr	r4, [r0, #4]
 8003d38:	42a3      	cmp	r3, r4
 8003d3a:	d022      	beq.n	8003d82 <netif_set_addr+0x5e>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 8003d3c:	4a1e      	ldr	r2, [pc, #120]	; (8003db8 <netif_set_addr+0x94>)
 8003d3e:	6810      	ldr	r0, [r2, #0]
    while (pcb != NULL) {
 8003d40:	2800      	cmp	r0, #0
 8003d42:	d037      	beq.n	8003db4 <netif_set_addr+0x90>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8003d44:	6805      	ldr	r5, [r0, #0]
 8003d46:	42a5      	cmp	r5, r4
 8003d48:	d005      	beq.n	8003d56 <netif_set_addr+0x32>
        struct tcp_pcb *next = pcb->next;
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
        pcb = next;
      } else {
        pcb = pcb->next;
 8003d4a:	68c0      	ldr	r0, [r0, #12]
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8003d4c:	b148      	cbz	r0, 8003d62 <netif_set_addr+0x3e>
 8003d4e:	6874      	ldr	r4, [r6, #4]
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8003d50:	6805      	ldr	r5, [r0, #0]
 8003d52:	42a5      	cmp	r5, r4
 8003d54:	d1f9      	bne.n	8003d4a <netif_set_addr+0x26>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 8003d56:	68c4      	ldr	r4, [r0, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 8003d58:	f001 f984 	bl	8005064 <tcp_abort>
        pcb = next;
 8003d5c:	4620      	mov	r0, r4
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8003d5e:	2800      	cmp	r0, #0
 8003d60:	d1f5      	bne.n	8003d4e <netif_set_addr+0x2a>
 8003d62:	f8da 4000 	ldr.w	r4, [sl]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8003d66:	4b15      	ldr	r3, [pc, #84]	; (8003dbc <netif_set_addr+0x98>)
 8003d68:	6818      	ldr	r0, [r3, #0]
 8003d6a:	b150      	cbz	r0, 8003d82 <netif_set_addr+0x5e>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 8003d6c:	6805      	ldr	r5, [r0, #0]
 8003d6e:	b12d      	cbz	r5, 8003d7c <netif_set_addr+0x58>
 8003d70:	6873      	ldr	r3, [r6, #4]
 8003d72:	429d      	cmp	r5, r3
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 8003d74:	bf04      	itt	eq
 8003d76:	6004      	streq	r4, [r0, #0]
 8003d78:	f8da 4000 	ldreq.w	r4, [sl]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8003d7c:	68c0      	ldr	r0, [r0, #12]
 8003d7e:	2800      	cmp	r0, #0
 8003d80:	d1f4      	bne.n	8003d6c <netif_set_addr+0x48>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8003d82:	6074      	str	r4, [r6, #4]
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8003d84:	f1b8 0f00 	cmp.w	r8, #0
 8003d88:	d00c      	beq.n	8003da4 <netif_set_addr+0x80>
 8003d8a:	f8d8 2000 	ldr.w	r2, [r8]
 8003d8e:	60b2      	str	r2, [r6, #8]
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 8003d90:	b167      	cbz	r7, 8003dac <netif_set_addr+0x88>
 8003d92:	683b      	ldr	r3, [r7, #0]
 8003d94:	60f3      	str	r3, [r6, #12]
 8003d96:	e8bd 85f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, sl, pc}
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8003d9a:	460c      	mov	r4, r1
 8003d9c:	6074      	str	r4, [r6, #4]
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8003d9e:	f1b8 0f00 	cmp.w	r8, #0
 8003da2:	d1f2      	bne.n	8003d8a <netif_set_addr+0x66>
 8003da4:	4642      	mov	r2, r8
 8003da6:	60b2      	str	r2, [r6, #8]
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 8003da8:	2f00      	cmp	r7, #0
 8003daa:	d1f2      	bne.n	8003d92 <netif_set_addr+0x6e>
 8003dac:	463b      	mov	r3, r7
 8003dae:	60f3      	str	r3, [r6, #12]
 8003db0:	e8bd 85f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, sl, pc}
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8003db4:	461c      	mov	r4, r3
 8003db6:	e7d6      	b.n	8003d66 <netif_set_addr+0x42>
 8003db8:	20005748 	.word	0x20005748
 8003dbc:	20005750 	.word	0x20005750

08003dc0 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 8003dc0:	b570      	push	{r4, r5, r6, lr}
 8003dc2:	4604      	mov	r4, r0
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 8003dc4:	460e      	mov	r6, r1
 8003dc6:	b329      	cbz	r1, 8003e14 <netif_set_ipaddr+0x54>
 8003dc8:	680b      	ldr	r3, [r1, #0]
 8003dca:	6842      	ldr	r2, [r0, #4]
 8003dcc:	4293      	cmp	r3, r2
 8003dce:	d01f      	beq.n	8003e10 <netif_set_ipaddr+0x50>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 8003dd0:	4913      	ldr	r1, [pc, #76]	; (8003e20 <netif_set_ipaddr+0x60>)
 8003dd2:	6808      	ldr	r0, [r1, #0]
    while (pcb != NULL) {
 8003dd4:	b308      	cbz	r0, 8003e1a <netif_set_ipaddr+0x5a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8003dd6:	6803      	ldr	r3, [r0, #0]
 8003dd8:	4293      	cmp	r3, r2
 8003dda:	d005      	beq.n	8003de8 <netif_set_ipaddr+0x28>
        struct tcp_pcb *next = pcb->next;
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
        pcb = next;
      } else {
        pcb = pcb->next;
 8003ddc:	68c0      	ldr	r0, [r0, #12]
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8003dde:	b148      	cbz	r0, 8003df4 <netif_set_ipaddr+0x34>
 8003de0:	6862      	ldr	r2, [r4, #4]
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8003de2:	6803      	ldr	r3, [r0, #0]
 8003de4:	4293      	cmp	r3, r2
 8003de6:	d1f9      	bne.n	8003ddc <netif_set_ipaddr+0x1c>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 8003de8:	68c5      	ldr	r5, [r0, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 8003dea:	f001 f93b 	bl	8005064 <tcp_abort>
        pcb = next;
 8003dee:	4628      	mov	r0, r5
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8003df0:	2800      	cmp	r0, #0
 8003df2:	d1f5      	bne.n	8003de0 <netif_set_ipaddr+0x20>
 8003df4:	6832      	ldr	r2, [r6, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8003df6:	4b0b      	ldr	r3, [pc, #44]	; (8003e24 <netif_set_ipaddr+0x64>)
 8003df8:	681b      	ldr	r3, [r3, #0]
 8003dfa:	b14b      	cbz	r3, 8003e10 <netif_set_ipaddr+0x50>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 8003dfc:	6818      	ldr	r0, [r3, #0]
 8003dfe:	b120      	cbz	r0, 8003e0a <netif_set_ipaddr+0x4a>
 8003e00:	6865      	ldr	r5, [r4, #4]
 8003e02:	42a8      	cmp	r0, r5
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 8003e04:	bf04      	itt	eq
 8003e06:	601a      	streq	r2, [r3, #0]
 8003e08:	6832      	ldreq	r2, [r6, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8003e0a:	68db      	ldr	r3, [r3, #12]
 8003e0c:	2b00      	cmp	r3, #0
 8003e0e:	d1f5      	bne.n	8003dfc <netif_set_ipaddr+0x3c>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8003e10:	6062      	str	r2, [r4, #4]
 8003e12:	bd70      	pop	{r4, r5, r6, pc}
 8003e14:	460a      	mov	r2, r1
 8003e16:	6062      	str	r2, [r4, #4]
 8003e18:	bd70      	pop	{r4, r5, r6, pc}
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8003e1a:	461a      	mov	r2, r3
 8003e1c:	e7eb      	b.n	8003df6 <netif_set_ipaddr+0x36>
 8003e1e:	bf00      	nop
 8003e20:	20005748 	.word	0x20005748
 8003e24:	20005750 	.word	0x20005750

08003e28 <netif_set_gw>:
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 8003e28:	b101      	cbz	r1, 8003e2c <netif_set_gw+0x4>
 8003e2a:	6809      	ldr	r1, [r1, #0]
 8003e2c:	60c1      	str	r1, [r0, #12]
 8003e2e:	4770      	bx	lr

08003e30 <netif_set_netmask>:
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8003e30:	b101      	cbz	r1, 8003e34 <netif_set_netmask+0x4>
 8003e32:	6809      	ldr	r1, [r1, #0]
 8003e34:	6081      	str	r1, [r0, #8]
 8003e36:	4770      	bx	lr

08003e38 <netif_set_default>:
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 8003e38:	4b01      	ldr	r3, [pc, #4]	; (8003e40 <netif_set_default+0x8>)
 8003e3a:	6018      	str	r0, [r3, #0]
 8003e3c:	4770      	bx	lr
 8003e3e:	bf00      	nop
 8003e40:	20005740 	.word	0x20005740

08003e44 <netif_set_up>:
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  if (!(netif->flags & NETIF_FLAG_UP)) {
 8003e44:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
 8003e48:	07da      	lsls	r2, r3, #31
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
 8003e4a:	4601      	mov	r1, r0
  if (!(netif->flags & NETIF_FLAG_UP)) {
 8003e4c:	d407      	bmi.n	8003e5e <netif_set_up+0x1a>
    netif->flags |= NETIF_FLAG_UP;
 8003e4e:	f043 0201 	orr.w	r2, r3, #1
    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 8003e52:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8003e56:	2b30      	cmp	r3, #48	; 0x30
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  if (!(netif->flags & NETIF_FLAG_UP)) {
    netif->flags |= NETIF_FLAG_UP;
 8003e58:	f880 2031 	strb.w	r2, [r0, #49]	; 0x31
    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 8003e5c:	d000      	beq.n	8003e60 <netif_set_up+0x1c>
 8003e5e:	4770      	bx	lr
        etharp_gratuitous(netif);
 8003e60:	3104      	adds	r1, #4
 8003e62:	f004 ba47 	b.w	80082f4 <etharp_request>
 8003e66:	bf00      	nop

08003e68 <netif_set_down>:
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  if (netif->flags & NETIF_FLAG_UP) {
 8003e68:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
 8003e6c:	07d9      	lsls	r1, r3, #31
 8003e6e:	d505      	bpl.n	8003e7c <netif_set_down+0x14>
    netif->flags &= ~NETIF_FLAG_UP;
 8003e70:	f023 0101 	bic.w	r1, r3, #1
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8003e74:	069b      	lsls	r3, r3, #26
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  if (netif->flags & NETIF_FLAG_UP) {
    netif->flags &= ~NETIF_FLAG_UP;
 8003e76:	f880 1031 	strb.w	r1, [r0, #49]	; 0x31
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8003e7a:	d400      	bmi.n	8003e7e <netif_set_down+0x16>
 8003e7c:	4770      	bx	lr
      etharp_cleanup_netif(netif);
 8003e7e:	f003 bf79 	b.w	8007d74 <etharp_cleanup_netif>
 8003e82:	bf00      	nop

08003e84 <netif_set_link_up>:
/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 8003e84:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
 8003e88:	06da      	lsls	r2, r3, #27
 8003e8a:	d415      	bmi.n	8003eb8 <netif_set_link_up+0x34>
    netif->flags |= NETIF_FLAG_LINK_UP;

#if LWIP_DHCP
    if (netif->dhcp) {
 8003e8c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
    netif->flags |= NETIF_FLAG_LINK_UP;
 8003e8e:	f043 0310 	orr.w	r3, r3, #16

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
 8003e92:	b510      	push	{r4, lr}
 8003e94:	4604      	mov	r4, r0
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
    netif->flags |= NETIF_FLAG_LINK_UP;
 8003e96:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31

#if LWIP_DHCP
    if (netif->dhcp) {
 8003e9a:	b11a      	cbz	r2, 8003ea4 <netif_set_link_up+0x20>
      dhcp_network_changed(netif);
 8003e9c:	f7fe ffee 	bl	8002e7c <dhcp_network_changed>
 8003ea0:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
 8003ea4:	f003 0321 	and.w	r3, r3, #33	; 0x21
 8003ea8:	2b21      	cmp	r3, #33	; 0x21
 8003eaa:	d006      	beq.n	8003eba <netif_set_link_up+0x36>
      if (netif->flags & NETIF_FLAG_IGMP) {
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
 8003eac:	69e3      	ldr	r3, [r4, #28]
 8003eae:	b14b      	cbz	r3, 8003ec4 <netif_set_link_up+0x40>
 8003eb0:	4620      	mov	r0, r4
  }
}
 8003eb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      if (netif->flags & NETIF_FLAG_IGMP) {
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
 8003eb6:	4718      	bx	r3
 8003eb8:	4770      	bx	lr

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
        etharp_gratuitous(netif);
 8003eba:	1d21      	adds	r1, r4, #4
 8003ebc:	4620      	mov	r0, r4
 8003ebe:	f004 fa19 	bl	80082f4 <etharp_request>
 8003ec2:	e7f3      	b.n	8003eac <netif_set_link_up+0x28>
 8003ec4:	bd10      	pop	{r4, pc}
 8003ec6:	bf00      	nop

08003ec8 <netif_set_link_down>:
/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
  if (netif->flags & NETIF_FLAG_LINK_UP) {
 8003ec8:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
 8003ecc:	06d9      	lsls	r1, r3, #27
 8003ece:	d506      	bpl.n	8003ede <netif_set_link_down+0x16>
    netif->flags &= ~NETIF_FLAG_LINK_UP;
    NETIF_LINK_CALLBACK(netif);
 8003ed0:	69c1      	ldr	r1, [r0, #28]
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
  if (netif->flags & NETIF_FLAG_LINK_UP) {
    netif->flags &= ~NETIF_FLAG_LINK_UP;
 8003ed2:	f023 0310 	bic.w	r3, r3, #16
 8003ed6:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31
    NETIF_LINK_CALLBACK(netif);
 8003eda:	b101      	cbz	r1, 8003ede <netif_set_link_down+0x16>
 8003edc:	4708      	bx	r1
 8003ede:	4770      	bx	lr

08003ee0 <netif_set_link_callback>:
/**
 * Set callback to be called when link is brought up/down
 */
void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
  if (netif) {
 8003ee0:	b100      	cbz	r0, 8003ee4 <netif_set_link_callback+0x4>
    netif->link_callback = link_callback;
 8003ee2:	61c1      	str	r1, [r0, #28]
 8003ee4:	4770      	bx	lr
 8003ee6:	bf00      	nop

08003ee8 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 8003ee8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
 8003eec:	2803      	cmp	r0, #3
 8003eee:	f200 8099 	bhi.w	8004024 <pbuf_alloc+0x13c>
 8003ef2:	e8df f000 	tbb	[pc, r0]
 8003ef6:	0288      	.short	0x0288
 8003ef8:	8d92      	.short	0x8d92
 8003efa:	2034      	movs	r0, #52	; 0x34
 8003efc:	f44f 78ee 	mov.w	r8, #476	; 0x1dc
 8003f00:	2632      	movs	r6, #50	; 0x32
 8003f02:	4615      	mov	r5, r2
 8003f04:	460f      	mov	r7, r1
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
 8003f06:	2a03      	cmp	r2, #3
 8003f08:	f200 808c 	bhi.w	8004024 <pbuf_alloc+0x13c>
 8003f0c:	e8df f002 	tbb	[pc, r2]
 8003f10:	02555561 	.word	0x02555561
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8003f14:	2008      	movs	r0, #8
 8003f16:	f7ff fe81 	bl	8003c1c <memp_malloc>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
 8003f1a:	4604      	mov	r4, r0
 8003f1c:	2800      	cmp	r0, #0
 8003f1e:	f000 8081 	beq.w	8004024 <pbuf_alloc+0x13c>
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8003f22:	45b8      	cmp	r8, r7
 8003f24:	bfa8      	it	ge
 8003f26:	46b8      	movge	r8, r7
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8003f28:	1983      	adds	r3, r0, r6
 8003f2a:	3303      	adds	r3, #3
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    }
    p->type = type;
    p->next = NULL;
 8003f2c:	2600      	movs	r6, #0
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
 8003f2e:	ebc8 0507 	rsb	r5, r8, r7
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8003f32:	f023 0303 	bic.w	r3, r3, #3
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    }
    p->type = type;
 8003f36:	2203      	movs	r2, #3
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 8003f38:	2101      	movs	r1, #1
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8003f3a:	42b5      	cmp	r5, r6
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8003f3c:	6043      	str	r3, [r0, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8003f3e:	f8a0 800a 	strh.w	r8, [r0, #10]
    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
 8003f42:	8107      	strh	r7, [r0, #8]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    }
    p->type = type;
 8003f44:	7302      	strb	r2, [r0, #12]
    p->next = NULL;
 8003f46:	6006      	str	r6, [r0, #0]
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 8003f48:	81c1      	strh	r1, [r0, #14]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8003f4a:	dd55      	ble.n	8003ff8 <pbuf_alloc+0x110>
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
 8003f4c:	4690      	mov	r8, r2
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8003f4e:	4607      	mov	r7, r0
 8003f50:	e00c      	b.n	8003f6c <pbuf_alloc+0x84>
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
 8003f52:	f880 800c 	strb.w	r8, [r0, #12]
      q->flags = 0;
 8003f56:	7346      	strb	r6, [r0, #13]
      q->next = NULL;
 8003f58:	6006      	str	r6, [r0, #0]
      /* make previous pbuf point to this pbuf */
      r->next = q;
 8003f5a:	6038      	str	r0, [r7, #0]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 8003f5c:	8105      	strh	r5, [r0, #8]
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 8003f5e:	1aed      	subs	r5, r5, r3
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8003f60:	2d00      	cmp	r5, #0
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8003f62:	8143      	strh	r3, [r0, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8003f64:	6041      	str	r1, [r0, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 8003f66:	81c2      	strh	r2, [r0, #14]
 8003f68:	4607      	mov	r7, r0
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8003f6a:	dd45      	ble.n	8003ff8 <pbuf_alloc+0x110>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8003f6c:	2008      	movs	r0, #8
 8003f6e:	f7ff fe55 	bl	8003c1c <memp_malloc>
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8003f72:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 8003f76:	462b      	mov	r3, r5
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8003f78:	f100 0110 	add.w	r1, r0, #16
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8003f7c:	bfa8      	it	ge
 8003f7e:	f44f 7300 	movge.w	r3, #512	; 0x200
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 8003f82:	2201      	movs	r2, #1
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
 8003f84:	2800      	cmp	r0, #0
 8003f86:	d1e4      	bne.n	8003f52 <pbuf_alloc+0x6a>
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 8003f88:	89e3      	ldrh	r3, [r4, #14]
 8003f8a:	3b01      	subs	r3, #1
 8003f8c:	b29b      	uxth	r3, r3
 8003f8e:	81e3      	strh	r3, [r4, #14]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 8003f90:	2b00      	cmp	r3, #0
 8003f92:	d147      	bne.n	8004024 <pbuf_alloc+0x13c>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8003f94:	7b63      	ldrb	r3, [r4, #13]
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 8003f96:	6825      	ldr	r5, [r4, #0]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8003f98:	f013 0f02 	tst.w	r3, #2
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 8003f9c:	4620      	mov	r0, r4
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8003f9e:	d144      	bne.n	800402a <pbuf_alloc+0x142>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 8003fa0:	7b23      	ldrb	r3, [r4, #12]
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 8003fa2:	2b03      	cmp	r3, #3
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8003fa4:	f103 32ff 	add.w	r2, r3, #4294967295
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 8003fa8:	d047      	beq.n	800403a <pbuf_alloc+0x152>
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8003faa:	2a01      	cmp	r2, #1
 8003fac:	d940      	bls.n	8004030 <pbuf_alloc+0x148>
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 8003fae:	f7ff fcf3 	bl	8003998 <mem_free>
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8003fb2:	2d00      	cmp	r5, #0
 8003fb4:	d036      	beq.n	8004024 <pbuf_alloc+0x13c>
 8003fb6:	462c      	mov	r4, r5
 8003fb8:	e7e6      	b.n	8003f88 <pbuf_alloc+0xa0>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 8003fba:	2007      	movs	r0, #7
 8003fbc:	f7ff fe2e 	bl	8003c1c <memp_malloc>
    if (p == NULL) {
 8003fc0:	4604      	mov	r4, r0
 8003fc2:	b378      	cbz	r0, 8004024 <pbuf_alloc+0x13c>
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 8003fc4:	2300      	movs	r3, #0
    p->len = p->tot_len = length;
 8003fc6:	8107      	strh	r7, [r0, #8]
 8003fc8:	8147      	strh	r7, [r0, #10]
    p->next = NULL;
    p->type = type;
 8003fca:	7305      	strb	r5, [r0, #12]
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 8003fcc:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
    p->next = NULL;
 8003fce:	6003      	str	r3, [r0, #0]
    p->type = type;
    break;
 8003fd0:	e012      	b.n	8003ff8 <pbuf_alloc+0x110>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 8003fd2:	1ccb      	adds	r3, r1, #3
 8003fd4:	f023 0303 	bic.w	r3, r3, #3
 8003fd8:	4418      	add	r0, r3
 8003fda:	b280      	uxth	r0, r0
 8003fdc:	f7ff fd82 	bl	8003ae4 <mem_malloc>
    if (p == NULL) {
 8003fe0:	4604      	mov	r4, r0
 8003fe2:	b1f8      	cbz	r0, 8004024 <pbuf_alloc+0x13c>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8003fe4:	4406      	add	r6, r0
 8003fe6:	3603      	adds	r6, #3
    p->len = p->tot_len = length;
    p->next = NULL;
 8003fe8:	2300      	movs	r3, #0
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8003fea:	f026 0603 	bic.w	r6, r6, #3
 8003fee:	6046      	str	r6, [r0, #4]
    p->len = p->tot_len = length;
 8003ff0:	8107      	strh	r7, [r0, #8]
 8003ff2:	8147      	strh	r7, [r0, #10]
    p->next = NULL;
 8003ff4:	6003      	str	r3, [r0, #0]
    p->type = type;
 8003ff6:	7303      	strb	r3, [r0, #12]
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  /* set flags */
  p->flags = 0;
 8003ff8:	2300      	movs	r3, #0
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
 8003ffa:	2201      	movs	r2, #1
  /* set flags */
  p->flags = 0;
 8003ffc:	7363      	strb	r3, [r4, #13]
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
 8003ffe:	81e2      	strh	r2, [r4, #14]
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 8004000:	4620      	mov	r0, r4
 8004002:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
 8004006:	2048      	movs	r0, #72	; 0x48
 8004008:	f44f 78e4 	mov.w	r8, #456	; 0x1c8
 800400c:	2646      	movs	r6, #70	; 0x46
 800400e:	e778      	b.n	8003f02 <pbuf_alloc+0x1a>
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    offset = 0;
    break;
 8004010:	2010      	movs	r0, #16
 8004012:	4606      	mov	r6, r0
 8004014:	f44f 7800 	mov.w	r8, #512	; 0x200
 8004018:	e773      	b.n	8003f02 <pbuf_alloc+0x1a>
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    break;
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    break;
 800401a:	2020      	movs	r0, #32
 800401c:	f44f 78f8 	mov.w	r8, #496	; 0x1f0
 8004020:	261e      	movs	r6, #30
 8004022:	e76e      	b.n	8003f02 <pbuf_alloc+0x1a>
    p->next = NULL;
    p->type = type;
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
 8004024:	2000      	movs	r0, #0
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
 8004026:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
 800402a:	6923      	ldr	r3, [r4, #16]
 800402c:	4798      	blx	r3
 800402e:	e7c0      	b.n	8003fb2 <pbuf_alloc+0xca>
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 8004030:	4621      	mov	r1, r4
 8004032:	2007      	movs	r0, #7
 8004034:	f7ff fe04 	bl	8003c40 <memp_free>
 8004038:	e7bb      	b.n	8003fb2 <pbuf_alloc+0xca>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
 800403a:	4621      	mov	r1, r4
 800403c:	2008      	movs	r0, #8
 800403e:	f7ff fdff 	bl	8003c40 <memp_free>
 8004042:	e7b6      	b.n	8003fb2 <pbuf_alloc+0xca>

08004044 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 8004044:	b470      	push	{r4, r5, r6}
 8004046:	9c03      	ldr	r4, [sp, #12]
 8004048:	f8bd 6010 	ldrh.w	r6, [sp, #16]
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 800404c:	2803      	cmp	r0, #3
 800404e:	d821      	bhi.n	8004094 <pbuf_alloced_custom+0x50>
 8004050:	e8df f000 	tbb	[pc, r0]
 8004054:	1a1d0217 	.word	0x1a1d0217
 8004058:	2524      	movs	r5, #36	; 0x24
 800405a:	4628      	mov	r0, r5
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 800405c:	4408      	add	r0, r1
 800405e:	42b0      	cmp	r0, r6
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
 8004060:	f04f 0000 	mov.w	r0, #0
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 8004064:	dc0b      	bgt.n	800407e <pbuf_alloced_custom+0x3a>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
  }

  p->pbuf.next = NULL;
 8004066:	6018      	str	r0, [r3, #0]
  if (payload_mem != NULL) {
 8004068:	b104      	cbz	r4, 800406c <pbuf_alloced_custom+0x28>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 800406a:	442c      	add	r4, r5
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
  p->pbuf.len = p->pbuf.tot_len = length;
  p->pbuf.type = type;
  p->pbuf.ref = 1;
 800406c:	2001      	movs	r0, #1
  if (payload_mem != NULL) {
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 800406e:	2502      	movs	r5, #2
  p->pbuf.len = p->pbuf.tot_len = length;
  p->pbuf.type = type;
  p->pbuf.ref = 1;
 8004070:	81d8      	strh	r0, [r3, #14]
 8004072:	605c      	str	r4, [r3, #4]
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
  p->pbuf.len = p->pbuf.tot_len = length;
 8004074:	8119      	strh	r1, [r3, #8]
 8004076:	8159      	strh	r1, [r3, #10]
  p->pbuf.type = type;
 8004078:	731a      	strb	r2, [r3, #12]
  if (payload_mem != NULL) {
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 800407a:	735d      	strb	r5, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
  p->pbuf.type = type;
  p->pbuf.ref = 1;
  return &p->pbuf;
 800407c:	4618      	mov	r0, r3
}
 800407e:	bc70      	pop	{r4, r5, r6}
 8004080:	4770      	bx	lr
{
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 8004082:	2538      	movs	r5, #56	; 0x38
 8004084:	4628      	mov	r0, r5
 8004086:	e7e9      	b.n	800405c <pbuf_alloced_custom+0x18>
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    offset = 0;
    break;
 8004088:	2500      	movs	r5, #0
 800408a:	4628      	mov	r0, r5
 800408c:	e7e6      	b.n	800405c <pbuf_alloced_custom+0x18>
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    break;
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    break;
 800408e:	2510      	movs	r5, #16
 8004090:	4628      	mov	r0, r5
 8004092:	e7e3      	b.n	800405c <pbuf_alloced_custom+0x18>
  case PBUF_RAW:
    offset = 0;
    break;
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
 8004094:	2000      	movs	r0, #0
 8004096:	e7f2      	b.n	800407e <pbuf_alloced_custom+0x3a>

08004098 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 8004098:	b538      	push	{r3, r4, r5, lr}
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 800409a:	8903      	ldrh	r3, [r0, #8]
 800409c:	428b      	cmp	r3, r1
 800409e:	d940      	bls.n	8004122 <pbuf_realloc+0x8a>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 80040a0:	8942      	ldrh	r2, [r0, #10]
 80040a2:	4291      	cmp	r1, r2
 80040a4:	4604      	mov	r4, r0
 80040a6:	460d      	mov	r5, r1
 80040a8:	d90a      	bls.n	80040c0 <pbuf_realloc+0x28>
 80040aa:	1ac9      	subs	r1, r1, r3
 80040ac:	e000      	b.n	80040b0 <pbuf_realloc+0x18>
 80040ae:	8923      	ldrh	r3, [r4, #8]
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
 80040b0:	440b      	add	r3, r1
 80040b2:	8123      	strh	r3, [r4, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 80040b4:	6824      	ldr	r4, [r4, #0]
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 80040b6:	1aad      	subs	r5, r5, r2

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 80040b8:	8962      	ldrh	r2, [r4, #10]
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 80040ba:	b2ad      	uxth	r5, r5

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 80040bc:	42aa      	cmp	r2, r5
 80040be:	d3f6      	bcc.n	80040ae <pbuf_realloc+0x16>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 80040c0:	7b23      	ldrb	r3, [r4, #12]
 80040c2:	b94b      	cbnz	r3, 80040d8 <pbuf_realloc+0x40>
 80040c4:	4295      	cmp	r5, r2
 80040c6:	d007      	beq.n	80040d8 <pbuf_realloc+0x40>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 80040c8:	6863      	ldr	r3, [r4, #4]
 80040ca:	1b1b      	subs	r3, r3, r4
 80040cc:	18e9      	adds	r1, r5, r3
 80040ce:	4620      	mov	r0, r4
 80040d0:	b289      	uxth	r1, r1
 80040d2:	f7ff fca7 	bl	8003a24 <mem_trim>
 80040d6:	4604      	mov	r4, r0
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  q->tot_len = q->len;

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 80040d8:	6821      	ldr	r1, [r4, #0]
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 80040da:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 80040dc:	8125      	strh	r5, [r4, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 80040de:	b1b1      	cbz	r1, 800410e <pbuf_realloc+0x76>
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 80040e0:	89cb      	ldrh	r3, [r1, #14]
 80040e2:	3b01      	subs	r3, #1
 80040e4:	b29b      	uxth	r3, r3
 80040e6:	81cb      	strh	r3, [r1, #14]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 80040e8:	b98b      	cbnz	r3, 800410e <pbuf_realloc+0x76>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 80040ea:	7b4b      	ldrb	r3, [r1, #13]
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 80040ec:	680d      	ldr	r5, [r1, #0]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 80040ee:	f013 0f02 	tst.w	r3, #2
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 80040f2:	4608      	mov	r0, r1
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 80040f4:	d10e      	bne.n	8004114 <pbuf_realloc+0x7c>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 80040f6:	7b0b      	ldrb	r3, [r1, #12]
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 80040f8:	2b03      	cmp	r3, #3
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 80040fa:	f103 32ff 	add.w	r2, r3, #4294967295
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 80040fe:	d011      	beq.n	8004124 <pbuf_realloc+0x8c>
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8004100:	2a01      	cmp	r2, #1
 8004102:	d90a      	bls.n	800411a <pbuf_realloc+0x82>
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 8004104:	f7ff fc48 	bl	8003998 <mem_free>
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8004108:	b10d      	cbz	r5, 800410e <pbuf_realloc+0x76>
 800410a:	4629      	mov	r1, r5
 800410c:	e7e8      	b.n	80040e0 <pbuf_realloc+0x48>
  if (q->next != NULL) {
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;
 800410e:	2300      	movs	r3, #0
 8004110:	6023      	str	r3, [r4, #0]
 8004112:	bd38      	pop	{r3, r4, r5, pc}
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
 8004114:	690b      	ldr	r3, [r1, #16]
 8004116:	4798      	blx	r3
 8004118:	e7f6      	b.n	8004108 <pbuf_realloc+0x70>
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 800411a:	2007      	movs	r0, #7
 800411c:	f7ff fd90 	bl	8003c40 <memp_free>
 8004120:	e7f2      	b.n	8004108 <pbuf_realloc+0x70>
 8004122:	bd38      	pop	{r3, r4, r5, pc}
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
 8004124:	2008      	movs	r0, #8
 8004126:	f7ff fd8b 	bl	8003c40 <memp_free>
 800412a:	e7ed      	b.n	8004108 <pbuf_realloc+0x70>

0800412c <pbuf_header>:
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
 800412c:	b1f9      	cbz	r1, 800416e <pbuf_header+0x42>
 800412e:	b170      	cbz	r0, 800414e <pbuf_header+0x22>
    return 0;
  }
 
  if (header_size_increment < 0){
 8004130:	2900      	cmp	r1, #0
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 8004132:	b430      	push	{r4, r5}
  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
  }
 
  if (header_size_increment < 0){
 8004134:	db1d      	blt.n	8004172 <pbuf_header+0x46>
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
 8004136:	b28a      	uxth	r2, r1
 8004138:	4614      	mov	r4, r2
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 800413a:	7b03      	ldrb	r3, [r0, #12]
  /* remember current payload pointer */
  payload = p->payload;
 800413c:	6845      	ldr	r5, [r0, #4]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 800413e:	b13b      	cbz	r3, 8004150 <pbuf_header+0x24>
 8004140:	2b03      	cmp	r3, #3
 8004142:	d005      	beq.n	8004150 <pbuf_header+0x24>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8004144:	3b01      	subs	r3, #1
 8004146:	2b01      	cmp	r3, #1
 8004148:	d91d      	bls.n	8004186 <pbuf_header+0x5a>

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
 800414a:	bc30      	pop	{r4, r5}
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800414c:	2001      	movs	r0, #1

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
 800414e:	4770      	bx	lr
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 8004150:	1a69      	subs	r1, r5, r1
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8004152:	f100 0310 	add.w	r3, r0, #16
 8004156:	4299      	cmp	r1, r3
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 8004158:	6041      	str	r1, [r0, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800415a:	d311      	bcc.n	8004180 <pbuf_header+0x54>
 800415c:	8943      	ldrh	r3, [r0, #10]
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  p->tot_len += header_size_increment;
 800415e:	8902      	ldrh	r2, [r0, #8]
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 8004160:	4423      	add	r3, r4
  p->tot_len += header_size_increment;
 8004162:	4414      	add	r4, r2
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 8004164:	8143      	strh	r3, [r0, #10]
  p->tot_len += header_size_increment;
 8004166:	8104      	strh	r4, [r0, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 8004168:	2000      	movs	r0, #0
}
 800416a:	bc30      	pop	{r4, r5}
 800416c:	4770      	bx	lr
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
 800416e:	4608      	mov	r0, r1

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
 8004170:	4770      	bx	lr
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
 8004172:	b28c      	uxth	r4, r1
 8004174:	4262      	negs	r2, r4
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8004176:	8943      	ldrh	r3, [r0, #10]
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
 8004178:	b292      	uxth	r2, r2
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800417a:	4293      	cmp	r3, r2
 800417c:	d2dd      	bcs.n	800413a <pbuf_header+0xe>
 800417e:	e7e4      	b.n	800414a <pbuf_header+0x1e>
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
 8004180:	6045      	str	r5, [r0, #4]
      /* bail out unsuccesfully */
      return 1;
 8004182:	2001      	movs	r0, #1
 8004184:	e7f1      	b.n	800416a <pbuf_header+0x3e>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8004186:	2900      	cmp	r1, #0
 8004188:	dadf      	bge.n	800414a <pbuf_header+0x1e>
 800418a:	8943      	ldrh	r3, [r0, #10]
 800418c:	429a      	cmp	r2, r3
 800418e:	d8dc      	bhi.n	800414a <pbuf_header+0x1e>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
 8004190:	1a69      	subs	r1, r5, r1
 8004192:	6041      	str	r1, [r0, #4]
 8004194:	e7e3      	b.n	800415e <pbuf_header+0x32>
 8004196:	bf00      	nop

08004198 <pbuf_free>:
{
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8004198:	4601      	mov	r1, r0
 800419a:	b350      	cbz	r0, 80041f2 <pbuf_free+0x5a>
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 800419c:	b538      	push	{r3, r4, r5, lr}
 800419e:	2400      	movs	r4, #0
 80041a0:	e00c      	b.n	80041bc <pbuf_free+0x24>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 80041a2:	7b0b      	ldrb	r3, [r1, #12]
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 80041a4:	2b03      	cmp	r3, #3
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 80041a6:	f103 32ff 	add.w	r2, r3, #4294967295
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 80041aa:	d01e      	beq.n	80041ea <pbuf_free+0x52>
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 80041ac:	2a01      	cmp	r2, #1
 80041ae:	d918      	bls.n	80041e2 <pbuf_free+0x4a>
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 80041b0:	f7ff fbf2 	bl	8003998 <mem_free>
        }
      }
      count++;
 80041b4:	3401      	adds	r4, #1
 80041b6:	b2e4      	uxtb	r4, r4
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 80041b8:	b18d      	cbz	r5, 80041de <pbuf_free+0x46>
 80041ba:	4629      	mov	r1, r5
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 80041bc:	89cb      	ldrh	r3, [r1, #14]
 80041be:	3b01      	subs	r3, #1
 80041c0:	b29b      	uxth	r3, r3
 80041c2:	81cb      	strh	r3, [r1, #14]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 80041c4:	b95b      	cbnz	r3, 80041de <pbuf_free+0x46>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 80041c6:	7b4b      	ldrb	r3, [r1, #13]
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 80041c8:	680d      	ldr	r5, [r1, #0]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 80041ca:	f013 0f02 	tst.w	r3, #2
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 80041ce:	4608      	mov	r0, r1
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 80041d0:	d0e7      	beq.n	80041a2 <pbuf_free+0xa>
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
 80041d2:	690b      	ldr	r3, [r1, #16]
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
 80041d4:	3401      	adds	r4, #1
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
 80041d6:	4798      	blx	r3
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
 80041d8:	b2e4      	uxtb	r4, r4
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 80041da:	2d00      	cmp	r5, #0
 80041dc:	d1ed      	bne.n	80041ba <pbuf_free+0x22>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 80041de:	4620      	mov	r0, r4
 80041e0:	bd38      	pop	{r3, r4, r5, pc}
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 80041e2:	2007      	movs	r0, #7
 80041e4:	f7ff fd2c 	bl	8003c40 <memp_free>
 80041e8:	e7e4      	b.n	80041b4 <pbuf_free+0x1c>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
 80041ea:	2008      	movs	r0, #8
 80041ec:	f7ff fd28 	bl	8003c40 <memp_free>
 80041f0:	e7e0      	b.n	80041b4 <pbuf_free+0x1c>
 80041f2:	4770      	bx	lr

080041f4 <pbuf_clen>:
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 80041f4:	4603      	mov	r3, r0
 80041f6:	b130      	cbz	r0, 8004206 <pbuf_clen+0x12>
 80041f8:	2000      	movs	r0, #0
    ++len;
    p = p->next;
 80041fa:	681b      	ldr	r3, [r3, #0]
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    ++len;
 80041fc:	3001      	adds	r0, #1
 80041fe:	b2c0      	uxtb	r0, r0
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 8004200:	2b00      	cmp	r3, #0
 8004202:	d1fa      	bne.n	80041fa <pbuf_clen+0x6>
 8004204:	4770      	bx	lr
    ++len;
    p = p->next;
  }
  return len;
}
 8004206:	4770      	bx	lr

08004208 <pbuf_ref>:
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 8004208:	b110      	cbz	r0, 8004210 <pbuf_ref+0x8>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 800420a:	89c3      	ldrh	r3, [r0, #14]
 800420c:	3301      	adds	r3, #1
 800420e:	81c3      	strh	r3, [r0, #14]
 8004210:	4770      	bx	lr
 8004212:	bf00      	nop

08004214 <pbuf_cat>:
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8004214:	b198      	cbz	r0, 800423e <pbuf_cat+0x2a>
 8004216:	b191      	cbz	r1, 800423e <pbuf_cat+0x2a>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8004218:	6802      	ldr	r2, [r0, #0]
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 800421a:	b430      	push	{r4, r5}

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 800421c:	b90a      	cbnz	r2, 8004222 <pbuf_cat+0xe>
 800421e:	e00f      	b.n	8004240 <pbuf_cat+0x2c>
 8004220:	4622      	mov	r2, r4
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 8004222:	8905      	ldrh	r5, [r0, #8]
 8004224:	890b      	ldrh	r3, [r1, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8004226:	6814      	ldr	r4, [r2, #0]
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 8004228:	442b      	add	r3, r5
 800422a:	8103      	strh	r3, [r0, #8]
 800422c:	4610      	mov	r0, r2

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 800422e:	2c00      	cmp	r4, #0
 8004230:	d1f6      	bne.n	8004220 <pbuf_cat+0xc>
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 8004232:	bc30      	pop	{r4, r5}
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 8004234:	890b      	ldrh	r3, [r1, #8]
 8004236:	8910      	ldrh	r0, [r2, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 8004238:	6011      	str	r1, [r2, #0]
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 800423a:	4403      	add	r3, r0
 800423c:	8113      	strh	r3, [r2, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 800423e:	4770      	bx	lr

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8004240:	4602      	mov	r2, r0
 8004242:	e7f6      	b.n	8004232 <pbuf_cat+0x1e>

08004244 <pbuf_chain>:
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8004244:	b1b8      	cbz	r0, 8004276 <pbuf_chain+0x32>
 8004246:	b1a9      	cbz	r1, 8004274 <pbuf_chain+0x30>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8004248:	6802      	ldr	r2, [r0, #0]
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 800424a:	b430      	push	{r4, r5}

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 800424c:	b90a      	cbnz	r2, 8004252 <pbuf_chain+0xe>
 800424e:	e018      	b.n	8004282 <pbuf_chain+0x3e>
 8004250:	4622      	mov	r2, r4
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 8004252:	8905      	ldrh	r5, [r0, #8]
 8004254:	890b      	ldrh	r3, [r1, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8004256:	6814      	ldr	r4, [r2, #0]
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 8004258:	442b      	add	r3, r5
 800425a:	8103      	strh	r3, [r0, #8]
 800425c:	4610      	mov	r0, r2

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 800425e:	2c00      	cmp	r4, #0
 8004260:	d1f6      	bne.n	8004250 <pbuf_chain+0xc>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 8004262:	8910      	ldrh	r0, [r2, #8]
 8004264:	890b      	ldrh	r3, [r1, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 8004266:	6011      	str	r1, [r2, #0]
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 8004268:	4403      	add	r3, r0
{
  pbuf_cat(h, t);
  /* t is now referenced by h */
  pbuf_ref(t);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 800426a:	bc30      	pop	{r4, r5}
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 800426c:	8113      	strh	r3, [r2, #8]
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 800426e:	89cb      	ldrh	r3, [r1, #14]
 8004270:	3301      	adds	r3, #1
 8004272:	81cb      	strh	r3, [r1, #14]
{
  pbuf_cat(h, t);
  /* t is now referenced by h */
  pbuf_ref(t);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 8004274:	4770      	bx	lr
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 8004276:	2900      	cmp	r1, #0
 8004278:	d0fc      	beq.n	8004274 <pbuf_chain+0x30>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 800427a:	89cb      	ldrh	r3, [r1, #14]
 800427c:	3301      	adds	r3, #1
 800427e:	81cb      	strh	r3, [r1, #14]
 8004280:	4770      	bx	lr

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8004282:	4602      	mov	r2, r0
 8004284:	e7ed      	b.n	8004262 <pbuf_chain+0x1e>
 8004286:	bf00      	nop

08004288 <pbuf_copy>:

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8004288:	2800      	cmp	r0, #0
 800428a:	d057      	beq.n	800433c <pbuf_copy+0xb4>
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 800428c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004290:	460e      	mov	r6, r1

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8004292:	2900      	cmp	r1, #0
 8004294:	d04e      	beq.n	8004334 <pbuf_copy+0xac>
 8004296:	8902      	ldrh	r2, [r0, #8]
 8004298:	890b      	ldrh	r3, [r1, #8]
 800429a:	429a      	cmp	r2, r3
 800429c:	4607      	mov	r7, r0
 800429e:	d349      	bcc.n	8004334 <pbuf_copy+0xac>
 80042a0:	2500      	movs	r5, #0
 80042a2:	8943      	ldrh	r3, [r0, #10]
 80042a4:	894a      	ldrh	r2, [r1, #10]
 80042a6:	46a8      	mov	r8, r5

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 80042a8:	ebc8 0303 	rsb	r3, r8, r3
 80042ac:	1b52      	subs	r2, r2, r5
 80042ae:	4293      	cmp	r3, r2
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 80042b0:	6871      	ldr	r1, [r6, #4]
 80042b2:	6878      	ldr	r0, [r7, #4]
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 80042b4:	bfb4      	ite	lt
 80042b6:	b29c      	uxthlt	r4, r3
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 80042b8:	b294      	uxthge	r4, r2
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 80042ba:	4440      	add	r0, r8
 80042bc:	4429      	add	r1, r5
 80042be:	4622      	mov	r2, r4
 80042c0:	f007 f929 	bl	800b516 <memcpy>
    offset_to += len;
    offset_from += len;
 80042c4:	4425      	add	r5, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 80042c6:	8973      	ldrh	r3, [r6, #10]
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
 80042c8:	b2ad      	uxth	r5, r5
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 80042ca:	42ab      	cmp	r3, r5
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
 80042cc:	4444      	add	r4, r8
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
 80042ce:	897b      	ldrh	r3, [r7, #10]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
 80042d0:	bf98      	it	ls
 80042d2:	6836      	ldrls	r6, [r6, #0]
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
 80042d4:	fa1f f884 	uxth.w	r8, r4
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
 80042d8:	bf98      	it	ls
 80042da:	2500      	movls	r5, #0
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
 80042dc:	4543      	cmp	r3, r8
 80042de:	d00d      	beq.n	80042fc <pbuf_copy+0x74>
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 80042e0:	b196      	cbz	r6, 8004308 <pbuf_copy+0x80>
 80042e2:	8972      	ldrh	r2, [r6, #10]
 80042e4:	8933      	ldrh	r3, [r6, #8]
 80042e6:	429a      	cmp	r2, r3
 80042e8:	d019      	beq.n	800431e <pbuf_copy+0x96>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 80042ea:	897b      	ldrh	r3, [r7, #10]
 80042ec:	8939      	ldrh	r1, [r7, #8]
 80042ee:	4299      	cmp	r1, r3
 80042f0:	d1da      	bne.n	80042a8 <pbuf_copy+0x20>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 80042f2:	683a      	ldr	r2, [r7, #0]
 80042f4:	b97a      	cbnz	r2, 8004316 <pbuf_copy+0x8e>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 80042f6:	b1d6      	cbz	r6, 800432e <pbuf_copy+0xa6>
 80042f8:	8972      	ldrh	r2, [r6, #10]
 80042fa:	e7d5      	b.n	80042a8 <pbuf_copy+0x20>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 80042fc:	683f      	ldr	r7, [r7, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 80042fe:	b1af      	cbz	r7, 800432c <pbuf_copy+0xa4>
      offset_from = 0;
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
 8004300:	f04f 0800 	mov.w	r8, #0
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8004304:	2e00      	cmp	r6, #0
 8004306:	d1ec      	bne.n	80042e2 <pbuf_copy+0x5a>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8004308:	897b      	ldrh	r3, [r7, #10]
 800430a:	893a      	ldrh	r2, [r7, #8]
 800430c:	429a      	cmp	r2, r3
 800430e:	d10e      	bne.n	800432e <pbuf_copy+0xa6>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8004310:	683a      	ldr	r2, [r7, #0]
 8004312:	2a00      	cmp	r2, #0
 8004314:	d0ef      	beq.n	80042f6 <pbuf_copy+0x6e>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8004316:	f06f 0005 	mvn.w	r0, #5
 800431a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800431e:	6833      	ldr	r3, [r6, #0]
 8004320:	2b00      	cmp	r3, #0
 8004322:	d0e2      	beq.n	80042ea <pbuf_copy+0x62>
 8004324:	f06f 0005 	mvn.w	r0, #5
 8004328:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 800432c:	b916      	cbnz	r6, 8004334 <pbuf_copy+0xac>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 800432e:	4630      	mov	r0, r6
 8004330:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8004334:	f06f 000d 	mvn.w	r0, #13
 8004338:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800433c:	f06f 000d 	mvn.w	r0, #13
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
 8004340:	4770      	bx	lr
 8004342:	bf00      	nop

08004344 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8004344:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8004348:	4605      	mov	r5, r0
 800434a:	b360      	cbz	r0, 80043a6 <pbuf_copy_partial+0x62>
 800434c:	4688      	mov	r8, r1
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 800434e:	b361      	cbz	r1, 80043aa <pbuf_copy_partial+0x66>
 8004350:	4616      	mov	r6, r2
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8004352:	b36a      	cbz	r2, 80043b0 <pbuf_copy_partial+0x6c>
 8004354:	2700      	movs	r7, #0
 8004356:	46b9      	mov	r9, r7
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8004358:	eb08 0009 	add.w	r0, r8, r9
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
 800435c:	896a      	ldrh	r2, [r5, #10]
 800435e:	b153      	cbz	r3, 8004376 <pbuf_copy_partial+0x32>
 8004360:	429a      	cmp	r2, r3
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 8004362:	eba3 0102 	sub.w	r1, r3, r2
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
 8004366:	d806      	bhi.n	8004376 <pbuf_copy_partial+0x32>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8004368:	682d      	ldr	r5, [r5, #0]
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 800436a:	b28b      	uxth	r3, r1
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 800436c:	2d00      	cmp	r5, #0
 800436e:	d1f3      	bne.n	8004358 <pbuf_copy_partial+0x14>
 8004370:	4638      	mov	r0, r7
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
 8004372:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
 8004376:	1ad4      	subs	r4, r2, r3
 8004378:	b2a4      	uxth	r4, r4
 800437a:	42b4      	cmp	r4, r6
 800437c:	bf28      	it	cs
 800437e:	4634      	movcs	r4, r6
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8004380:	6869      	ldr	r1, [r5, #4]
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
 8004382:	1b36      	subs	r6, r6, r4
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8004384:	4622      	mov	r2, r4
 8004386:	4419      	add	r1, r3
      copied_total += buf_copy_len;
 8004388:	4427      	add	r7, r4
      left += buf_copy_len;
 800438a:	44a1      	add	r9, r4
      len -= buf_copy_len;
 800438c:	b2b6      	uxth	r6, r6
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 800438e:	f007 f8c2 	bl	800b516 <memcpy>
      copied_total += buf_copy_len;
 8004392:	b2bf      	uxth	r7, r7
      left += buf_copy_len;
 8004394:	fa1f f989 	uxth.w	r9, r9
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8004398:	682d      	ldr	r5, [r5, #0]
 800439a:	2e00      	cmp	r6, #0
 800439c:	d0e8      	beq.n	8004370 <pbuf_copy_partial+0x2c>
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
 800439e:	2300      	movs	r3, #0
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 80043a0:	2d00      	cmp	r5, #0
 80043a2:	d1d9      	bne.n	8004358 <pbuf_copy_partial+0x14>
 80043a4:	e7e4      	b.n	8004370 <pbuf_copy_partial+0x2c>
 80043a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 80043aa:	4608      	mov	r0, r1
 80043ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80043b0:	4610      	mov	r0, r2
 80043b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80043b6:	bf00      	nop

080043b8 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 80043b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  pcb = raw_pcbs;
 80043bc:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8004428 <raw_input+0x70>
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 80043c0:	6843      	ldr	r3, [r0, #4]

  prev = NULL;
  pcb = raw_pcbs;
 80043c2:	f8d8 4000 	ldr.w	r4, [r8]
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 80043c6:	7a5e      	ldrb	r6, [r3, #9]

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 80043c8:	b344      	cbz	r4, 800441c <raw_input+0x64>
 80043ca:	4683      	mov	fp, r0
 80043cc:	2500      	movs	r5, #0
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
 80043ce:	f8df 905c 	ldr.w	r9, [pc, #92]	; 800442c <raw_input+0x74>
 80043d2:	e003      	b.n	80043dc <raw_input+0x24>
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
 80043d4:	68e3      	ldr	r3, [r4, #12]
 80043d6:	4625      	mov	r5, r4

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 80043d8:	b303      	cbz	r3, 800441c <raw_input+0x64>
 80043da:	461c      	mov	r4, r3
    if ((pcb->protocol == proto) &&
 80043dc:	7c23      	ldrb	r3, [r4, #16]
 80043de:	42b3      	cmp	r3, r6
 80043e0:	d1f8      	bne.n	80043d4 <raw_input+0x1c>
        (ip_addr_isany(&pcb->local_ip) ||
 80043e2:	6820      	ldr	r0, [r4, #0]
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 80043e4:	4b0f      	ldr	r3, [pc, #60]	; (8004424 <raw_input+0x6c>)
 80043e6:	4621      	mov	r1, r4
 80043e8:	465a      	mov	r2, fp
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
 80043ea:	b118      	cbz	r0, 80043f4 <raw_input+0x3c>
 80043ec:	f8d9 7000 	ldr.w	r7, [r9]
 80043f0:	42b8      	cmp	r0, r7
 80043f2:	d1ef      	bne.n	80043d4 <raw_input+0x1c>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
 80043f4:	f8d4 a014 	ldr.w	sl, [r4, #20]
 80043f8:	f1ba 0f00 	cmp.w	sl, #0
 80043fc:	d0ea      	beq.n	80043d4 <raw_input+0x1c>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 80043fe:	69a0      	ldr	r0, [r4, #24]
 8004400:	47d0      	blx	sl
 8004402:	2800      	cmp	r0, #0
 8004404:	d0e6      	beq.n	80043d4 <raw_input+0x1c>
            /* receive function ate the packet */
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
 8004406:	b135      	cbz	r5, 8004416 <raw_input+0x5e>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 8004408:	68e2      	ldr	r2, [r4, #12]
              pcb->next = raw_pcbs;
 800440a:	f8d8 3000 	ldr.w	r3, [r8]
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 800440e:	60ea      	str	r2, [r5, #12]
              pcb->next = raw_pcbs;
              raw_pcbs = pcb;
 8004410:	f8c8 4000 	str.w	r4, [r8]
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
              pcb->next = raw_pcbs;
 8004414:	60e3      	str	r3, [r4, #12]
 8004416:	2001      	movs	r0, #1
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
 8004418:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800441c:	2000      	movs	r0, #0
 800441e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004422:	bf00      	nop
 8004424:	20002ee4 	.word	0x20002ee4
 8004428:	20002978 	.word	0x20002978
 800442c:	20002eec 	.word	0x20002eec

08004430 <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
 8004430:	f06f 0009 	mvn.w	r0, #9
 8004434:	4770      	bx	lr
 8004436:	bf00      	nop

08004438 <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 8004438:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 800443a:	7e03      	ldrb	r3, [r0, #24]
 800443c:	2b00      	cmp	r3, #0
 800443e:	d15a      	bne.n	80044f6 <tcp_bind+0xbe>
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
 8004440:	2a00      	cmp	r2, #0
 8004442:	d02e      	beq.n	80044a2 <tcp_bind+0x6a>
 8004444:	4e2d      	ldr	r6, [pc, #180]	; (80044fc <tcp_bind+0xc4>)
 8004446:	f106 0710 	add.w	r7, r6, #16
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800444a:	f856 3b04 	ldr.w	r3, [r6], #4
 800444e:	681b      	ldr	r3, [r3, #0]
 8004450:	b17b      	cbz	r3, 8004472 <tcp_bind+0x3a>
 8004452:	b911      	cbnz	r1, 800445a <tcp_bind+0x22>
 8004454:	e01f      	b.n	8004496 <tcp_bind+0x5e>
 8004456:	68db      	ldr	r3, [r3, #12]
 8004458:	b15b      	cbz	r3, 8004472 <tcp_bind+0x3a>
      if (cpcb->local_port == port) {
 800445a:	8b5c      	ldrh	r4, [r3, #26]
 800445c:	4294      	cmp	r4, r2
 800445e:	d1fa      	bne.n	8004456 <tcp_bind+0x1e>
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
 8004460:	681c      	ldr	r4, [r3, #0]
 8004462:	b11c      	cbz	r4, 800446c <tcp_bind+0x34>
              ip_addr_isany(ipaddr) ||
 8004464:	680d      	ldr	r5, [r1, #0]
 8004466:	b10d      	cbz	r5, 800446c <tcp_bind+0x34>
 8004468:	42ac      	cmp	r4, r5
 800446a:	d1f4      	bne.n	8004456 <tcp_bind+0x1e>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
 800446c:	f06f 0007 	mvn.w	r0, #7
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
 8004470:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
 8004472:	42b7      	cmp	r7, r6
 8004474:	d1e9      	bne.n	800444a <tcp_bind+0x12>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
 8004476:	b111      	cbz	r1, 800447e <tcp_bind+0x46>
 8004478:	680b      	ldr	r3, [r1, #0]
 800447a:	b103      	cbz	r3, 800447e <tcp_bind+0x46>
    pcb->local_ip = *ipaddr;
 800447c:	6003      	str	r3, [r0, #0]
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
 800447e:	4b20      	ldr	r3, [pc, #128]	; (8004500 <tcp_bind+0xc8>)
  }

  if (!ip_addr_isany(ipaddr)) {
    pcb->local_ip = *ipaddr;
  }
  pcb->local_port = port;
 8004480:	8342      	strh	r2, [r0, #26]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8004482:	681a      	ldr	r2, [r3, #0]
 8004484:	60c2      	str	r2, [r0, #12]
 8004486:	6018      	str	r0, [r3, #0]
 8004488:	f002 fdd2 	bl	8007030 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 800448c:	2000      	movs	r0, #0
 800448e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 8004490:	68db      	ldr	r3, [r3, #12]
 8004492:	2b00      	cmp	r3, #0
 8004494:	d0ed      	beq.n	8004472 <tcp_bind+0x3a>
      if (cpcb->local_port == port) {
 8004496:	8b5c      	ldrh	r4, [r3, #26]
 8004498:	4294      	cmp	r4, r2
 800449a:	d1f9      	bne.n	8004490 <tcp_bind+0x58>
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
              ip_addr_isany(ipaddr) ||
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
 800449c:	f06f 0007 	mvn.w	r0, #7
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
 80044a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80044a2:	f8df e060 	ldr.w	lr, [pc, #96]	; 8004504 <tcp_bind+0xcc>
 80044a6:	f8be 3000 	ldrh.w	r3, [lr]
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
 80044aa:	f44f 4680 	mov.w	r6, #16384	; 0x4000
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 80044ae:	f64f 77ff 	movw	r7, #65535	; 0xffff
 80044b2:	42bb      	cmp	r3, r7
 80044b4:	4d11      	ldr	r5, [pc, #68]	; (80044fc <tcp_bind+0xc4>)
 80044b6:	bf1a      	itte	ne
 80044b8:	1c5a      	addne	r2, r3, #1
 80044ba:	b292      	uxthne	r2, r2
 80044bc:	f44f 4240 	moveq.w	r2, #49152	; 0xc000
 80044c0:	f105 0c10 	add.w	ip, r5, #16
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 80044c4:	f855 3b04 	ldr.w	r3, [r5], #4
 80044c8:	681b      	ldr	r3, [r3, #0]
 80044ca:	b913      	cbnz	r3, 80044d2 <tcp_bind+0x9a>
 80044cc:	e00e      	b.n	80044ec <tcp_bind+0xb4>
 80044ce:	68db      	ldr	r3, [r3, #12]
 80044d0:	b163      	cbz	r3, 80044ec <tcp_bind+0xb4>
      if (pcb->local_port == tcp_port) {
 80044d2:	8b5c      	ldrh	r4, [r3, #26]
 80044d4:	4294      	cmp	r4, r2
 80044d6:	d1fa      	bne.n	80044ce <tcp_bind+0x96>
 80044d8:	3e01      	subs	r6, #1
 80044da:	b2b6      	uxth	r6, r6
 80044dc:	4613      	mov	r3, r2
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 80044de:	2e00      	cmp	r6, #0
 80044e0:	d1e7      	bne.n	80044b2 <tcp_bind+0x7a>
 80044e2:	f8ae 2000 	strh.w	r2, [lr]
#endif /* SO_REUSE */

  if (port == 0) {
    port = tcp_new_port();
    if (port == 0) {
      return ERR_BUF;
 80044e6:	f06f 0001 	mvn.w	r0, #1
 80044ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 80044ec:	45ac      	cmp	ip, r5
 80044ee:	d1e9      	bne.n	80044c4 <tcp_bind+0x8c>
 80044f0:	f8ae 2000 	strh.w	r2, [lr]
 80044f4:	e7a6      	b.n	8004444 <tcp_bind+0xc>
{
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 80044f6:	f06f 0005 	mvn.w	r0, #5
 80044fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80044fc:	0800ca0c 	.word	0x0800ca0c
 8004500:	20005758 	.word	0x20005758
 8004504:	20000008 	.word	0x20000008

08004508 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 8004508:	b538      	push	{r3, r4, r5, lr}
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 800450a:	7e03      	ldrb	r3, [r0, #24]
 800450c:	2b00      	cmp	r3, #0
 800450e:	d13c      	bne.n	800458a <tcp_listen_with_backlog+0x82>
 8004510:	4604      	mov	r4, r0
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 8004512:	2003      	movs	r0, #3
 8004514:	f7ff fb82 	bl	8003c1c <memp_malloc>
  if (lpcb == NULL) {
 8004518:	4605      	mov	r5, r0
 800451a:	2800      	cmp	r0, #0
 800451c:	d035      	beq.n	800458a <tcp_listen_with_backlog+0x82>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
 800451e:	6923      	ldr	r3, [r4, #16]
  lpcb->local_port = pcb->local_port;
 8004520:	8b62      	ldrh	r2, [r4, #26]
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
 8004522:	6103      	str	r3, [r0, #16]
  lpcb->local_port = pcb->local_port;
  lpcb->state = LISTEN;
 8004524:	2301      	movs	r3, #1
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  lpcb->local_port = pcb->local_port;
 8004526:	8342      	strh	r2, [r0, #26]
  lpcb->state = LISTEN;
 8004528:	7603      	strb	r3, [r0, #24]
  lpcb->prio = pcb->prio;
 800452a:	7e63      	ldrb	r3, [r4, #25]
 800452c:	7643      	strb	r3, [r0, #25]
  lpcb->so_options = pcb->so_options;
  ip_set_option(lpcb, SOF_ACCEPTCONN);
 800452e:	7a23      	ldrb	r3, [r4, #8]
 8004530:	f043 0302 	orr.w	r3, r3, #2
 8004534:	7203      	strb	r3, [r0, #8]
  lpcb->ttl = pcb->ttl;
 8004536:	7aa3      	ldrb	r3, [r4, #10]
 8004538:	7283      	strb	r3, [r0, #10]
  lpcb->tos = pcb->tos;
 800453a:	7a63      	ldrb	r3, [r4, #9]
 800453c:	7243      	strb	r3, [r0, #9]
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
  if (pcb->local_port != 0) {
 800453e:	8b63      	ldrh	r3, [r4, #26]
  lpcb->prio = pcb->prio;
  lpcb->so_options = pcb->so_options;
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 8004540:	6822      	ldr	r2, [r4, #0]
 8004542:	6002      	str	r2, [r0, #0]
  if (pcb->local_port != 0) {
 8004544:	b19b      	cbz	r3, 800456e <tcp_listen_with_backlog+0x66>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 8004546:	4b17      	ldr	r3, [pc, #92]	; (80045a4 <tcp_listen_with_backlog+0x9c>)
 8004548:	681a      	ldr	r2, [r3, #0]
 800454a:	4294      	cmp	r4, r2
 800454c:	d027      	beq.n	800459e <tcp_listen_with_backlog+0x96>
 800454e:	4916      	ldr	r1, [pc, #88]	; (80045a8 <tcp_listen_with_backlog+0xa0>)
 8004550:	600a      	str	r2, [r1, #0]
 8004552:	b152      	cbz	r2, 800456a <tcp_listen_with_backlog+0x62>
 8004554:	68d3      	ldr	r3, [r2, #12]
 8004556:	429c      	cmp	r4, r3
 8004558:	d01f      	beq.n	800459a <tcp_listen_with_backlog+0x92>
 800455a:	b12b      	cbz	r3, 8004568 <tcp_listen_with_backlog+0x60>
 800455c:	68da      	ldr	r2, [r3, #12]
 800455e:	4294      	cmp	r4, r2
 8004560:	d015      	beq.n	800458e <tcp_listen_with_backlog+0x86>
 8004562:	4613      	mov	r3, r2
 8004564:	2b00      	cmp	r3, #0
 8004566:	d1f9      	bne.n	800455c <tcp_listen_with_backlog+0x54>
 8004568:	600b      	str	r3, [r1, #0]
 800456a:	2300      	movs	r3, #0
 800456c:	60e3      	str	r3, [r4, #12]
  }
  memp_free(MEMP_TCP_PCB, pcb);
 800456e:	4621      	mov	r1, r4
 8004570:	2002      	movs	r0, #2
 8004572:	f7ff fb65 	bl	8003c40 <memp_free>
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 8004576:	4b0d      	ldr	r3, [pc, #52]	; (80045ac <tcp_listen_with_backlog+0xa4>)
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
  }
  memp_free(MEMP_TCP_PCB, pcb);
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 8004578:	4a0d      	ldr	r2, [pc, #52]	; (80045b0 <tcp_listen_with_backlog+0xa8>)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 800457a:	6819      	ldr	r1, [r3, #0]
 800457c:	60e9      	str	r1, [r5, #12]
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
  }
  memp_free(MEMP_TCP_PCB, pcb);
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 800457e:	616a      	str	r2, [r5, #20]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 8004580:	601d      	str	r5, [r3, #0]
 8004582:	f002 fd55 	bl	8007030 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
 8004586:	4628      	mov	r0, r5
}
 8004588:	bd38      	pop	{r3, r4, r5, pc}
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 800458a:	2000      	movs	r0, #0
 800458c:	bd38      	pop	{r3, r4, r5, pc}
 800458e:	600b      	str	r3, [r1, #0]
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
 8004590:	68e2      	ldr	r2, [r4, #12]
 8004592:	60da      	str	r2, [r3, #12]
 8004594:	2300      	movs	r3, #0
 8004596:	60e3      	str	r3, [r4, #12]
 8004598:	e7e9      	b.n	800456e <tcp_listen_with_backlog+0x66>
 800459a:	4613      	mov	r3, r2
 800459c:	e7f8      	b.n	8004590 <tcp_listen_with_backlog+0x88>
 800459e:	68e2      	ldr	r2, [r4, #12]
 80045a0:	601a      	str	r2, [r3, #0]
 80045a2:	e7e2      	b.n	800456a <tcp_listen_with_backlog+0x62>
 80045a4:	20005758 	.word	0x20005758
 80045a8:	20005754 	.word	0x20005754
 80045ac:	20005750 	.word	0x20005750
 80045b0:	08004431 	.word	0x08004431

080045b4 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 80045b4:	b4f0      	push	{r4, r5, r6, r7}
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 80045b6:	8d85      	ldrh	r5, [r0, #44]	; 0x2c

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 80045b8:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80045ba:	8ec1      	ldrh	r1, [r0, #54]	; 0x36
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 80045bc:	6a86      	ldr	r6, [r0, #40]	; 0x28
 80045be:	1b2b      	subs	r3, r5, r4

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 80045c0:	f240 57b4 	movw	r7, #1460	; 0x5b4
 80045c4:	42b9      	cmp	r1, r7
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 80045c6:	4602      	mov	r2, r0
 80045c8:	eb03 0006 	add.w	r0, r3, r6
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 80045cc:	bf94      	ite	ls
 80045ce:	1a43      	subls	r3, r0, r1
 80045d0:	1bc3      	subhi	r3, r0, r7
 80045d2:	2b00      	cmp	r3, #0
 80045d4:	db02      	blt.n	80045dc <tcp_update_rcv_ann_wnd+0x28>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 80045d6:	85d5      	strh	r5, [r2, #46]	; 0x2e
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
 80045d8:	bcf0      	pop	{r4, r5, r6, r7}
 80045da:	4770      	bx	lr
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    return new_right_edge - pcb->rcv_ann_right_edge;
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 80045dc:	1b33      	subs	r3, r6, r4
 80045de:	2b00      	cmp	r3, #0
 80045e0:	dd04      	ble.n	80045ec <tcp_update_rcv_ann_wnd+0x38>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 80045e2:	2300      	movs	r3, #0
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
 80045e4:	4618      	mov	r0, r3
    return new_right_edge - pcb->rcv_ann_right_edge;
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 80045e6:	85d3      	strh	r3, [r2, #46]	; 0x2e
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
 80045e8:	bcf0      	pop	{r4, r5, r6, r7}
 80045ea:	4770      	bx	lr
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 80045ec:	1ba4      	subs	r4, r4, r6
 80045ee:	85d4      	strh	r4, [r2, #46]	; 0x2e
    }
    return 0;
 80045f0:	2000      	movs	r0, #0
  }
}
 80045f2:	bcf0      	pop	{r4, r5, r6, r7}
 80045f4:	4770      	bx	lr
 80045f6:	bf00      	nop

080045f8 <tcp_recved>:
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 80045f8:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 80045fa:	4419      	add	r1, r3
  if (pcb->rcv_wnd > TCP_WND) {
 80045fc:	f640 3268 	movw	r2, #2920	; 0xb68
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8004600:	b289      	uxth	r1, r1
  if (pcb->rcv_wnd > TCP_WND) {
 8004602:	4291      	cmp	r1, r2
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8004604:	b4f0      	push	{r4, r5, r6, r7}
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
  if (pcb->rcv_wnd > TCP_WND) {
 8004606:	d820      	bhi.n	800464a <tcp_recved+0x52>
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8004608:	8581      	strh	r1, [r0, #44]	; 0x2c
 800460a:	460b      	mov	r3, r1
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800460c:	6a86      	ldr	r6, [r0, #40]	; 0x28

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800460e:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8004610:	8ec2      	ldrh	r2, [r0, #54]	; 0x36
 8004612:	f240 57b4 	movw	r7, #1460	; 0x5b4
 8004616:	1b35      	subs	r5, r6, r4
 8004618:	42ba      	cmp	r2, r7
 800461a:	442b      	add	r3, r5
 800461c:	bf94      	ite	ls
 800461e:	1a9a      	subls	r2, r3, r2
 8004620:	1bda      	subhi	r2, r3, r7
 8004622:	2a00      	cmp	r2, #0
 8004624:	db0b      	blt.n	800463e <tcp_recved+0x46>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8004626:	f240 22d9 	movw	r2, #729	; 0x2d9
 800462a:	4293      	cmp	r3, r2
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 800462c:	85c1      	strh	r1, [r0, #46]	; 0x2e

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 800462e:	dd0a      	ble.n	8004646 <tcp_recved+0x4e>
    tcp_ack_now(pcb);
 8004630:	7f83      	ldrb	r3, [r0, #30]
 8004632:	f043 0302 	orr.w	r3, r3, #2
 8004636:	7783      	strb	r3, [r0, #30]
    tcp_output(pcb);
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8004638:	bcf0      	pop	{r4, r5, r6, r7}
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    tcp_ack_now(pcb);
    tcp_output(pcb);
 800463a:	f002 ba23 	b.w	8006a84 <tcp_output>
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    return new_right_edge - pcb->rcv_ann_right_edge;
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 800463e:	2d00      	cmp	r5, #0
 8004640:	dd07      	ble.n	8004652 <tcp_recved+0x5a>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 8004642:	2400      	movs	r4, #0
 8004644:	85c4      	strh	r4, [r0, #46]	; 0x2e
    tcp_output(pcb);
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8004646:	bcf0      	pop	{r4, r5, r6, r7}
 8004648:	4770      	bx	lr
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
  if (pcb->rcv_wnd > TCP_WND) {
    pcb->rcv_wnd = TCP_WND;
 800464a:	4613      	mov	r3, r2
 800464c:	8582      	strh	r2, [r0, #44]	; 0x2c
 800464e:	4611      	mov	r1, r2
 8004650:	e7dc      	b.n	800460c <tcp_recved+0x14>
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 8004652:	1ba4      	subs	r4, r4, r6
 8004654:	b2a4      	uxth	r4, r4
 8004656:	e7f5      	b.n	8004644 <tcp_recved+0x4c>

08004658 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 8004658:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 800465c:	4fa1      	ldr	r7, [pc, #644]	; (80048e4 <tcp_slowtmr+0x28c>)
  ++tcp_timer_ctr;
 800465e:	4ea2      	ldr	r6, [pc, #648]	; (80048e8 <tcp_slowtmr+0x290>)
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 8004660:	683a      	ldr	r2, [r7, #0]
  ++tcp_timer_ctr;
 8004662:	7833      	ldrb	r3, [r6, #0]
      err_arg = pcb->callback_arg;
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);

      tcp_active_pcbs_changed = 0;
 8004664:	f8df 9298 	ldr.w	r9, [pc, #664]	; 8004900 <tcp_slowtmr+0x2a8>
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 8004668:	3201      	adds	r2, #1
  ++tcp_timer_ctr;
 800466a:	3301      	adds	r3, #1
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 800466c:	b085      	sub	sp, #20
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 800466e:	603a      	str	r2, [r7, #0]
  ++tcp_timer_ctr;
 8004670:	7033      	strb	r3, [r6, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
 8004672:	4b9e      	ldr	r3, [pc, #632]	; (80048ec <tcp_slowtmr+0x294>)
 8004674:	681c      	ldr	r4, [r3, #0]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 8004676:	2c00      	cmp	r4, #0
 8004678:	d07a      	beq.n	8004770 <tcp_slowtmr+0x118>
 800467a:	f04f 0800 	mov.w	r8, #0
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
 800467e:	7832      	ldrb	r2, [r6, #0]
 8004680:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8004684:	4293      	cmp	r3, r2
 8004686:	f000 8169 	beq.w	800495c <tcp_slowtmr+0x304>
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 800468a:	7e23      	ldrb	r3, [r4, #24]
    if (pcb->last_timer == tcp_timer_ctr) {
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;
 800468c:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8004690:	2b02      	cmp	r3, #2
 8004692:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8004696:	f000 81a0 	beq.w	80049da <tcp_slowtmr+0x382>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 800469a:	2a0c      	cmp	r2, #12
 800469c:	f000 81b8 	beq.w	8004a10 <tcp_slowtmr+0x3b8>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 80046a0:	f894 1091 	ldrb.w	r1, [r4, #145]	; 0x91
 80046a4:	2900      	cmp	r1, #0
 80046a6:	f000 815e 	beq.w	8004966 <tcp_slowtmr+0x30e>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 80046aa:	4891      	ldr	r0, [pc, #580]	; (80048f0 <tcp_slowtmr+0x298>)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 80046ac:	f894 2090 	ldrb.w	r2, [r4, #144]	; 0x90
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 80046b0:	4408      	add	r0, r1
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 80046b2:	3201      	adds	r2, #1
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 80046b4:	f810 0c01 	ldrb.w	r0, [r0, #-1]
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 80046b8:	b2d2      	uxtb	r2, r2
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 80046ba:	4290      	cmp	r0, r2
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 80046bc:	f884 2090 	strb.w	r2, [r4, #144]	; 0x90
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 80046c0:	f200 8188 	bhi.w	80049d4 <tcp_slowtmr+0x37c>
          pcb->persist_cnt = 0;
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 80046c4:	2906      	cmp	r1, #6
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
 80046c6:	f04f 0300 	mov.w	r3, #0
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
 80046ca:	bf98      	it	ls
 80046cc:	3101      	addls	r1, #1
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
 80046ce:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
 80046d2:	bf98      	it	ls
 80046d4:	f884 1091 	strbls.w	r1, [r4, #145]	; 0x91
          }
          tcp_zero_window_probe(pcb);
 80046d8:	4620      	mov	r0, r4
 80046da:	f002 fc33 	bl	8006f44 <tcp_zero_window_probe>
 80046de:	7e23      	ldrb	r3, [r4, #24]
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 80046e0:	2500      	movs	r5, #0
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
          }
          tcp_zero_window_probe(pcb);
 80046e2:	2201      	movs	r2, #1
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 80046e4:	2b06      	cmp	r3, #6
 80046e6:	f000 810d 	beq.w	8004904 <tcp_slowtmr+0x2ac>
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 80046ea:	7a22      	ldrb	r2, [r4, #8]
 80046ec:	0712      	lsls	r2, r2, #28
 80046ee:	f140 80a5 	bpl.w	800483c <tcp_slowtmr+0x1e4>
 80046f2:	2b04      	cmp	r3, #4
 80046f4:	d002      	beq.n	80046fc <tcp_slowtmr+0xa4>
       ((pcb->state == ESTABLISHED) ||
 80046f6:	2b07      	cmp	r3, #7
 80046f8:	f040 80a0 	bne.w	800483c <tcp_slowtmr+0x1e4>
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 80046fc:	f8d4 e08c 	ldr.w	lr, [r4, #140]	; 0x8c

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 8004700:	683a      	ldr	r2, [r7, #0]
 8004702:	9203      	str	r2, [sp, #12]
 8004704:	f50e 2024 	add.w	r0, lr, #671744	; 0xa4000
 8004708:	4a7a      	ldr	r2, [pc, #488]	; (80048f4 <tcp_slowtmr+0x29c>)
 800470a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800470c:	f600 40b8 	addw	r0, r0, #3256	; 0xcb8
 8004710:	fba2 2000 	umull	r2, r0, r2, r0
 8004714:	9a03      	ldr	r2, [sp, #12]
 8004716:	1a52      	subs	r2, r2, r1
 8004718:	ebb2 1f50 	cmp.w	r2, r0, lsr #5
 800471c:	d97a      	bls.n	8004814 <tcp_slowtmr+0x1bc>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 800471e:	2b01      	cmp	r3, #1
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
 8004720:	f04f 0a01 	mov.w	sl, #1
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8004724:	f200 8163 	bhi.w	80049ee <tcp_slowtmr+0x396>
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 8004728:	68e3      	ldr	r3, [r4, #12]
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 800472a:	f1b8 0f00 	cmp.w	r8, #0
 800472e:	f000 80c7 	beq.w	80048c0 <tcp_slowtmr+0x268>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 8004732:	f8c8 300c 	str.w	r3, [r8, #12]
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
 8004736:	f1ba 0f00 	cmp.w	sl, #0
 800473a:	f040 80c7 	bne.w	80048cc <tcp_slowtmr+0x274>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
 800473e:	f8d4 5088 	ldr.w	r5, [r4, #136]	; 0x88
      err_arg = pcb->callback_arg;
 8004742:	f8d4 b010 	ldr.w	fp, [r4, #16]
      pcb2 = pcb;
      pcb = pcb->next;
 8004746:	f8d4 a00c 	ldr.w	sl, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 800474a:	4621      	mov	r1, r4
 800474c:	2002      	movs	r0, #2
 800474e:	f7ff fa77 	bl	8003c40 <memp_free>

      tcp_active_pcbs_changed = 0;
 8004752:	2300      	movs	r3, #0
 8004754:	f889 3000 	strb.w	r3, [r9]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 8004758:	b13d      	cbz	r5, 800476a <tcp_slowtmr+0x112>
 800475a:	4658      	mov	r0, fp
 800475c:	f06f 0109 	mvn.w	r1, #9
 8004760:	47a8      	blx	r5
      if (tcp_active_pcbs_changed) {
 8004762:	f899 3000 	ldrb.w	r3, [r9]
 8004766:	2b00      	cmp	r3, #0
 8004768:	d183      	bne.n	8004672 <tcp_slowtmr+0x1a>
      }

      err_fn = pcb->errf;
      err_arg = pcb->callback_arg;
      pcb2 = pcb;
      pcb = pcb->next;
 800476a:	4654      	mov	r4, sl
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800476c:	2c00      	cmp	r4, #0
 800476e:	d186      	bne.n	800467e <tcp_slowtmr+0x26>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
 8004770:	4e61      	ldr	r6, [pc, #388]	; (80048f8 <tcp_slowtmr+0x2a0>)
 8004772:	6834      	ldr	r4, [r6, #0]
  while (pcb != NULL) {
 8004774:	2c00      	cmp	r4, #0
 8004776:	d04a      	beq.n	800480e <tcp_slowtmr+0x1b6>
 8004778:	2500      	movs	r5, #0
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 800477a:	f64f 78ff 	movw	r8, #65535	; 0xffff
 800477e:	46a9      	mov	r9, r5
  while (pcb != NULL) {
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8004780:	683b      	ldr	r3, [r7, #0]
 8004782:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004784:	1a9b      	subs	r3, r3, r2
 8004786:	2bf0      	cmp	r3, #240	; 0xf0
 8004788:	f240 813c 	bls.w	8004a04 <tcp_slowtmr+0x3ac>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 800478c:	7e23      	ldrb	r3, [r4, #24]
 800478e:	2b01      	cmp	r3, #1
 8004790:	d92e      	bls.n	80047f0 <tcp_slowtmr+0x198>
 8004792:	2b0a      	cmp	r3, #10
 8004794:	d02c      	beq.n	80047f0 <tcp_slowtmr+0x198>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8004796:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8004798:	b118      	cbz	r0, 80047a2 <tcp_slowtmr+0x14a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 800479a:	f7ff fcfd 	bl	8004198 <pbuf_free>
      pcb->refused_data = NULL;
 800479e:	2300      	movs	r3, #0
 80047a0:	6763      	str	r3, [r4, #116]	; 0x74

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
 80047a2:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 80047a4:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80047a8:	b16d      	cbz	r5, 80047c6 <tcp_slowtmr+0x16e>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 80047aa:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 80047ac:	f8d5 a000 	ldr.w	sl, [r5]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 80047b0:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 80047b2:	b10b      	cbz	r3, 80047b8 <tcp_slowtmr+0x160>
      pbuf_free(seg->p);
 80047b4:	f7ff fcf0 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 80047b8:	4629      	mov	r1, r5
 80047ba:	2004      	movs	r0, #4
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80047bc:	4655      	mov	r5, sl
      pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 80047be:	f7ff fa3f 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80047c2:	2d00      	cmp	r5, #0
 80047c4:	d1f1      	bne.n	80047aa <tcp_slowtmr+0x152>
    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
 80047c6:	6f25      	ldr	r5, [r4, #112]	; 0x70
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80047c8:	b16d      	cbz	r5, 80047e6 <tcp_slowtmr+0x18e>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 80047ca:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 80047cc:	f8d5 a000 	ldr.w	sl, [r5]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 80047d0:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 80047d2:	b10b      	cbz	r3, 80047d8 <tcp_slowtmr+0x180>
      pbuf_free(seg->p);
 80047d4:	f7ff fce0 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 80047d8:	4629      	mov	r1, r5
 80047da:	2004      	movs	r0, #4
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80047dc:	4655      	mov	r5, sl
      pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 80047de:	f7ff fa2f 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80047e2:	2d00      	cmp	r5, #0
 80047e4:	d1f1      	bne.n	80047ca <tcp_slowtmr+0x172>
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 80047e6:	2300      	movs	r3, #0
 80047e8:	66e3      	str	r3, [r4, #108]	; 0x6c
 80047ea:	6723      	str	r3, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 80047ec:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 80047f0:	f1b9 0f00 	cmp.w	r9, #0
 80047f4:	f000 8120 	beq.w	8004a38 <tcp_slowtmr+0x3e0>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
 80047f8:	68e3      	ldr	r3, [r4, #12]
 80047fa:	f8c9 300c 	str.w	r3, [r9, #12]
 80047fe:	68e5      	ldr	r5, [r4, #12]
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
 8004800:	4621      	mov	r1, r4
 8004802:	2002      	movs	r0, #2
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb;
      pcb = pcb->next;
 8004804:	462c      	mov	r4, r5
      memp_free(MEMP_TCP_PCB, pcb2);
 8004806:	f7ff fa1b 	bl	8003c40 <memp_free>

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 800480a:	2c00      	cmp	r4, #0
 800480c:	d1b8      	bne.n	8004780 <tcp_slowtmr+0x128>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
 800480e:	b005      	add	sp, #20
 8004810:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 8004814:	4839      	ldr	r0, [pc, #228]	; (80048fc <tcp_slowtmr+0x2a4>)
 8004816:	f894 1092 	ldrb.w	r1, [r4, #146]	; 0x92
 800481a:	fb00 e101 	mla	r1, r0, r1, lr
 800481e:	4835      	ldr	r0, [pc, #212]	; (80048f4 <tcp_slowtmr+0x29c>)
 8004820:	fba0 0101 	umull	r0, r1, r0, r1
 8004824:	ebb2 1f51 	cmp.w	r2, r1, lsr #5
 8004828:	d908      	bls.n	800483c <tcp_slowtmr+0x1e4>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
 800482a:	4620      	mov	r0, r4
 800482c:	f002 fb4a 	bl	8006ec4 <tcp_keepalive>
        pcb->keep_cnt_sent++;
 8004830:	f894 2092 	ldrb.w	r2, [r4, #146]	; 0x92
 8004834:	7e23      	ldrb	r3, [r4, #24]
 8004836:	3201      	adds	r2, #1
 8004838:	f884 2092 	strb.w	r2, [r4, #146]	; 0x92
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800483c:	2b03      	cmp	r3, #3
 800483e:	f000 80da 	beq.w	80049f6 <tcp_slowtmr+0x39e>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 8004842:	2b09      	cmp	r3, #9
 8004844:	f040 80e7 	bne.w	8004a16 <tcp_slowtmr+0x3be>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8004848:	683b      	ldr	r3, [r7, #0]
 800484a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800484c:	1a9b      	subs	r3, r3, r2
 800484e:	2bf0      	cmp	r3, #240	; 0xf0
 8004850:	d961      	bls.n	8004916 <tcp_slowtmr+0x2be>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8004852:	f04f 0a00 	mov.w	sl, #0
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8004856:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8004858:	b118      	cbz	r0, 8004862 <tcp_slowtmr+0x20a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 800485a:	f7ff fc9d 	bl	8004198 <pbuf_free>
      pcb->refused_data = NULL;
 800485e:	2300      	movs	r3, #0
 8004860:	6763      	str	r3, [r4, #116]	; 0x74

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
 8004862:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8004864:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004868:	86a3      	strh	r3, [r4, #52]	; 0x34
 800486a:	46a3      	mov	fp, r4
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800486c:	b16d      	cbz	r5, 800488a <tcp_slowtmr+0x232>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 800486e:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004870:	682c      	ldr	r4, [r5, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004872:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004874:	b10b      	cbz	r3, 800487a <tcp_slowtmr+0x222>
      pbuf_free(seg->p);
 8004876:	f7ff fc8f 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800487a:	4629      	mov	r1, r5
 800487c:	2004      	movs	r0, #4
 800487e:	f7ff f9df 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004882:	4625      	mov	r5, r4
 8004884:	2c00      	cmp	r4, #0
 8004886:	d1f2      	bne.n	800486e <tcp_slowtmr+0x216>
 8004888:	465c      	mov	r4, fp
    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
 800488a:	6f25      	ldr	r5, [r4, #112]	; 0x70
 800488c:	46a3      	mov	fp, r4
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800488e:	b16d      	cbz	r5, 80048ac <tcp_slowtmr+0x254>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004890:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004892:	682c      	ldr	r4, [r5, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004894:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004896:	b10b      	cbz	r3, 800489c <tcp_slowtmr+0x244>
      pbuf_free(seg->p);
 8004898:	f7ff fc7e 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800489c:	4629      	mov	r1, r5
 800489e:	2004      	movs	r0, #4
 80048a0:	f7ff f9ce 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80048a4:	4625      	mov	r5, r4
 80048a6:	2c00      	cmp	r4, #0
 80048a8:	d1f2      	bne.n	8004890 <tcp_slowtmr+0x238>
 80048aa:	465c      	mov	r4, fp
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 80048ac:	2300      	movs	r3, #0
 80048ae:	66e3      	str	r3, [r4, #108]	; 0x6c
 80048b0:	6723      	str	r3, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 80048b2:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 80048b6:	68e3      	ldr	r3, [r4, #12]
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 80048b8:	f1b8 0f00 	cmp.w	r8, #0
 80048bc:	f47f af39 	bne.w	8004732 <tcp_slowtmr+0xda>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
 80048c0:	4a0a      	ldr	r2, [pc, #40]	; (80048ec <tcp_slowtmr+0x294>)
 80048c2:	6013      	str	r3, [r2, #0]
      }

      if (pcb_reset) {
 80048c4:	f1ba 0f00 	cmp.w	sl, #0
 80048c8:	f43f af39 	beq.w	800473e <tcp_slowtmr+0xe6>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 80048cc:	8ba3      	ldrh	r3, [r4, #28]
 80048ce:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80048d0:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80048d2:	9301      	str	r3, [sp, #4]
 80048d4:	8b63      	ldrh	r3, [r4, #26]
 80048d6:	9300      	str	r3, [sp, #0]
 80048d8:	4622      	mov	r2, r4
 80048da:	1d23      	adds	r3, r4, #4
 80048dc:	f002 fa20 	bl	8006d20 <tcp_rst>
 80048e0:	e72d      	b.n	800473e <tcp_slowtmr+0xe6>
 80048e2:	bf00      	nop
 80048e4:	2000574c 	.word	0x2000574c
 80048e8:	2000297d 	.word	0x2000297d
 80048ec:	20005748 	.word	0x20005748
 80048f0:	0800ca2c 	.word	0x0800ca2c
 80048f4:	10624dd3 	.word	0x10624dd3
 80048f8:	2000575c 	.word	0x2000575c
 80048fc:	000124f8 	.word	0x000124f8
 8004900:	20005744 	.word	0x20005744
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 8004904:	7fa3      	ldrb	r3, [r4, #30]
 8004906:	06d9      	lsls	r1, r3, #27
 8004908:	d505      	bpl.n	8004916 <tcp_slowtmr+0x2be>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 800490a:	683b      	ldr	r3, [r7, #0]
 800490c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800490e:	1a5b      	subs	r3, r3, r1
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 8004910:	2b28      	cmp	r3, #40	; 0x28
 8004912:	bf88      	it	hi
 8004914:	4615      	movhi	r5, r2
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8004916:	2d00      	cmp	r5, #0
 8004918:	d19b      	bne.n	8004852 <tcp_slowtmr+0x1fa>
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 800491a:	7fe3      	ldrb	r3, [r4, #31]
      if (prev->polltmr >= prev->pollinterval) {
 800491c:	f894 2020 	ldrb.w	r2, [r4, #32]
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 8004920:	68e5      	ldr	r5, [r4, #12]

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 8004922:	3301      	adds	r3, #1
 8004924:	b2db      	uxtb	r3, r3
      if (prev->polltmr >= prev->pollinterval) {
 8004926:	429a      	cmp	r2, r3
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 8004928:	77e3      	strb	r3, [r4, #31]
      if (prev->polltmr >= prev->pollinterval) {
 800492a:	d811      	bhi.n	8004950 <tcp_slowtmr+0x2f8>
        prev->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
        TCP_EVENT_POLL(prev, err);
 800492c:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
      if (prev->polltmr >= prev->pollinterval) {
        prev->polltmr = 0;
 8004930:	2300      	movs	r3, #0
 8004932:	77e3      	strb	r3, [r4, #31]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 8004934:	f889 3000 	strb.w	r3, [r9]
        TCP_EVENT_POLL(prev, err);
 8004938:	2a00      	cmp	r2, #0
 800493a:	d072      	beq.n	8004a22 <tcp_slowtmr+0x3ca>
 800493c:	4621      	mov	r1, r4
 800493e:	6920      	ldr	r0, [r4, #16]
 8004940:	4790      	blx	r2
        if (tcp_active_pcbs_changed) {
 8004942:	f899 3000 	ldrb.w	r3, [r9]
 8004946:	2b00      	cmp	r3, #0
 8004948:	f47f ae93 	bne.w	8004672 <tcp_slowtmr+0x1a>
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 800494c:	2800      	cmp	r0, #0
 800494e:	d068      	beq.n	8004a22 <tcp_slowtmr+0x3ca>
 8004950:	46a0      	mov	r8, r4
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 8004952:	462c      	mov	r4, r5
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 8004954:	2c00      	cmp	r4, #0
 8004956:	f47f ae92 	bne.w	800467e <tcp_slowtmr+0x26>
 800495a:	e709      	b.n	8004770 <tcp_slowtmr+0x118>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
 800495c:	68e4      	ldr	r4, [r4, #12]
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800495e:	2c00      	cmp	r4, #0
 8004960:	f47f ae8d 	bne.w	800467e <tcp_slowtmr+0x26>
 8004964:	e704      	b.n	8004770 <tcp_slowtmr+0x118>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
 8004966:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
 800496a:	2900      	cmp	r1, #0
 800496c:	db02      	blt.n	8004974 <tcp_slowtmr+0x31c>
          ++pcb->rtime;
 800496e:	3101      	adds	r1, #1
 8004970:	b209      	sxth	r1, r1
 8004972:	86a1      	strh	r1, [r4, #52]	; 0x34
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 8004974:	6f25      	ldr	r5, [r4, #112]	; 0x70
 8004976:	2d00      	cmp	r5, #0
 8004978:	d05c      	beq.n	8004a34 <tcp_slowtmr+0x3dc>
 800497a:	f9b4 0044 	ldrsh.w	r0, [r4, #68]	; 0x44
 800497e:	4288      	cmp	r0, r1
 8004980:	dc28      	bgt.n	80049d4 <tcp_slowtmr+0x37c>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
 8004982:	2b02      	cmp	r3, #2
 8004984:	d00a      	beq.n	800499c <tcp_slowtmr+0x344>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 8004986:	482e      	ldr	r0, [pc, #184]	; (8004a40 <tcp_slowtmr+0x3e8>)
 8004988:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	; 0x40
 800498c:	f9b4 1042 	ldrsh.w	r1, [r4, #66]	; 0x42
 8004990:	5c82      	ldrb	r2, [r0, r2]
 8004992:	eb01 03e3 	add.w	r3, r1, r3, asr #3
 8004996:	4093      	lsls	r3, r2
 8004998:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 800499c:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 80049a0:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
          if (pcb->ssthresh < (pcb->mss << 1)) {
 80049a4:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
            pcb->ssthresh = (pcb->mss << 1);
          }
          pcb->cwnd = pcb->mss;
 80049a6:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 80049aa:	428b      	cmp	r3, r1
 80049ac:	bf28      	it	cs
 80049ae:	460b      	movcs	r3, r1
 80049b0:	085b      	lsrs	r3, r3, #1
          if (pcb->ssthresh < (pcb->mss << 1)) {
 80049b2:	0051      	lsls	r1, r2, #1
 80049b4:	428b      	cmp	r3, r1
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 80049b6:	f04f 0000 	mov.w	r0, #0

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 80049ba:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 80049be:	86a0      	strh	r0, [r4, #52]	; 0x34

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
          if (pcb->ssthresh < (pcb->mss << 1)) {
            pcb->ssthresh = (pcb->mss << 1);
 80049c0:	bfb8      	it	lt
 80049c2:	f8a4 104e 	strhlt.w	r1, [r4, #78]	; 0x4e
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
 80049c6:	4620      	mov	r0, r4
 80049c8:	f002 f9f0 	bl	8006dac <tcp_rexmit_rto>
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 80049cc:	2500      	movs	r5, #0
 80049ce:	7e23      	ldrb	r3, [r4, #24]
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
 80049d0:	2201      	movs	r2, #1
 80049d2:	e687      	b.n	80046e4 <tcp_slowtmr+0x8c>
 80049d4:	2201      	movs	r2, #1
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 80049d6:	2500      	movs	r5, #0
 80049d8:	e684      	b.n	80046e4 <tcp_slowtmr+0x8c>
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 80049da:	2a06      	cmp	r2, #6
 80049dc:	d002      	beq.n	80049e4 <tcp_slowtmr+0x38c>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 80049de:	2a0c      	cmp	r2, #12
 80049e0:	f47f ae5e 	bne.w	80046a0 <tcp_slowtmr+0x48>
 80049e4:	f04f 0a00 	mov.w	sl, #0
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 80049e8:	2b01      	cmp	r3, #1
 80049ea:	f67f ae9d 	bls.w	8004728 <tcp_slowtmr+0xd0>
 80049ee:	2b0a      	cmp	r3, #10
 80049f0:	f47f af31 	bne.w	8004856 <tcp_slowtmr+0x1fe>
 80049f4:	e698      	b.n	8004728 <tcp_slowtmr+0xd0>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 80049f6:	683b      	ldr	r3, [r7, #0]
 80049f8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80049fa:	1a9b      	subs	r3, r3, r2
 80049fc:	2b28      	cmp	r3, #40	; 0x28
 80049fe:	f63f af28 	bhi.w	8004852 <tcp_slowtmr+0x1fa>
 8004a02:	e788      	b.n	8004916 <tcp_slowtmr+0x2be>
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
    } else {
      prev = pcb;
      pcb = pcb->next;
 8004a04:	46a1      	mov	r9, r4
 8004a06:	68e4      	ldr	r4, [r4, #12]

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 8004a08:	2c00      	cmp	r4, #0
 8004a0a:	f47f aeb9 	bne.w	8004780 <tcp_slowtmr+0x128>
 8004a0e:	e6fe      	b.n	800480e <tcp_slowtmr+0x1b6>
 8004a10:	2202      	movs	r2, #2
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
      ++pcb_remove;
 8004a12:	2501      	movs	r5, #1
 8004a14:	e666      	b.n	80046e4 <tcp_slowtmr+0x8c>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8004a16:	2d00      	cmp	r5, #0
 8004a18:	f43f af7f 	beq.w	800491a <tcp_slowtmr+0x2c2>
 8004a1c:	f04f 0a00 	mov.w	sl, #0
 8004a20:	e7e2      	b.n	80049e8 <tcp_slowtmr+0x390>
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
          tcp_output(prev);
 8004a22:	4620      	mov	r0, r4
 8004a24:	46a0      	mov	r8, r4
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 8004a26:	462c      	mov	r4, r5
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
          tcp_output(prev);
 8004a28:	f002 f82c 	bl	8006a84 <tcp_output>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 8004a2c:	2c00      	cmp	r4, #0
 8004a2e:	f47f ae26 	bne.w	800467e <tcp_slowtmr+0x26>
 8004a32:	e69d      	b.n	8004770 <tcp_slowtmr+0x118>
 8004a34:	2201      	movs	r2, #1
 8004a36:	e655      	b.n	80046e4 <tcp_slowtmr+0x8c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
 8004a38:	68e5      	ldr	r5, [r4, #12]
 8004a3a:	6035      	str	r5, [r6, #0]
 8004a3c:	e6e0      	b.n	8004800 <tcp_slowtmr+0x1a8>
 8004a3e:	bf00      	nop
 8004a40:	0800ca1c 	.word	0x0800ca1c

08004a44 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004a44:	b178      	cbz	r0, 8004a66 <tcp_segs_free+0x22>
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 8004a46:	b538      	push	{r3, r4, r5, lr}
 8004a48:	4604      	mov	r4, r0
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004a4a:	6863      	ldr	r3, [r4, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004a4c:	6825      	ldr	r5, [r4, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004a4e:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004a50:	b10b      	cbz	r3, 8004a56 <tcp_segs_free+0x12>
      pbuf_free(seg->p);
 8004a52:	f7ff fba1 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004a56:	4621      	mov	r1, r4
 8004a58:	2004      	movs	r0, #4
 8004a5a:	f7ff f8f1 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004a5e:	462c      	mov	r4, r5
 8004a60:	2d00      	cmp	r5, #0
 8004a62:	d1f2      	bne.n	8004a4a <tcp_segs_free+0x6>
 8004a64:	bd38      	pop	{r3, r4, r5, pc}
 8004a66:	4770      	bx	lr

08004a68 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
 8004a68:	b158      	cbz	r0, 8004a82 <tcp_seg_free+0x1a>
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 8004a6a:	b510      	push	{r4, lr}
 8004a6c:	4604      	mov	r4, r0
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004a6e:	6840      	ldr	r0, [r0, #4]
 8004a70:	b108      	cbz	r0, 8004a76 <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 8004a72:	f7ff fb91 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004a76:	4621      	mov	r1, r4
 8004a78:	2004      	movs	r0, #4
  }
}
 8004a7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004a7e:	f7ff b8df 	b.w	8003c40 <memp_free>
 8004a82:	4770      	bx	lr

08004a84 <tcp_setprio>:
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  pcb->prio = prio;
 8004a84:	7641      	strb	r1, [r0, #25]
 8004a86:	4770      	bx	lr

08004a88 <tcp_arg>:
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
 8004a88:	6101      	str	r1, [r0, #16]
 8004a8a:	4770      	bx	lr

08004a8c <tcp_recv>:
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
  pcb->recv = recv;
 8004a8c:	67c1      	str	r1, [r0, #124]	; 0x7c
 8004a8e:	4770      	bx	lr

08004a90 <tcp_sent>:
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
  pcb->sent = sent;
 8004a90:	6781      	str	r1, [r0, #120]	; 0x78
 8004a92:	4770      	bx	lr

08004a94 <tcp_err>:
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
  pcb->errf = err;
 8004a94:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
 8004a98:	4770      	bx	lr
 8004a9a:	bf00      	nop

08004a9c <tcp_accept>:
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
 8004a9c:	6141      	str	r1, [r0, #20]
 8004a9e:	4770      	bx	lr

08004aa0 <tcp_poll>:
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 8004aa0:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 8004aa4:	f880 2020 	strb.w	r2, [r0, #32]
 8004aa8:	4770      	bx	lr
 8004aaa:	bf00      	nop

08004aac <tcp_pcb_purge>:
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8004aac:	7e03      	ldrb	r3, [r0, #24]
 8004aae:	2b01      	cmp	r3, #1
 8004ab0:	d930      	bls.n	8004b14 <tcp_pcb_purge+0x68>
 8004ab2:	2b0a      	cmp	r3, #10
 8004ab4:	d02e      	beq.n	8004b14 <tcp_pcb_purge+0x68>
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 8004ab6:	b570      	push	{r4, r5, r6, lr}
 8004ab8:	4606      	mov	r6, r0
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8004aba:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8004abc:	b118      	cbz	r0, 8004ac6 <tcp_pcb_purge+0x1a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8004abe:	f7ff fb6b 	bl	8004198 <pbuf_free>
      pcb->refused_data = NULL;
 8004ac2:	2300      	movs	r3, #0
 8004ac4:	6773      	str	r3, [r6, #116]	; 0x74

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
 8004ac6:	6ef4      	ldr	r4, [r6, #108]	; 0x6c
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8004ac8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004acc:	86b3      	strh	r3, [r6, #52]	; 0x34
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004ace:	b164      	cbz	r4, 8004aea <tcp_pcb_purge+0x3e>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004ad0:	6863      	ldr	r3, [r4, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004ad2:	6825      	ldr	r5, [r4, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004ad4:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004ad6:	b10b      	cbz	r3, 8004adc <tcp_pcb_purge+0x30>
      pbuf_free(seg->p);
 8004ad8:	f7ff fb5e 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004adc:	4621      	mov	r1, r4
 8004ade:	2004      	movs	r0, #4
 8004ae0:	f7ff f8ae 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004ae4:	462c      	mov	r4, r5
 8004ae6:	2d00      	cmp	r5, #0
 8004ae8:	d1f2      	bne.n	8004ad0 <tcp_pcb_purge+0x24>
    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
 8004aea:	6f34      	ldr	r4, [r6, #112]	; 0x70
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004aec:	b164      	cbz	r4, 8004b08 <tcp_pcb_purge+0x5c>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004aee:	6863      	ldr	r3, [r4, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004af0:	6825      	ldr	r5, [r4, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004af2:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004af4:	b10b      	cbz	r3, 8004afa <tcp_pcb_purge+0x4e>
      pbuf_free(seg->p);
 8004af6:	f7ff fb4f 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004afa:	4621      	mov	r1, r4
 8004afc:	2004      	movs	r0, #4
 8004afe:	f7ff f89f 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004b02:	462c      	mov	r4, r5
 8004b04:	2d00      	cmp	r5, #0
 8004b06:	d1f2      	bne.n	8004aee <tcp_pcb_purge+0x42>
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 8004b08:	2300      	movs	r3, #0
 8004b0a:	66f3      	str	r3, [r6, #108]	; 0x6c
 8004b0c:	6733      	str	r3, [r6, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8004b0e:	f8a6 306a 	strh.w	r3, [r6, #106]	; 0x6a
 8004b12:	bd70      	pop	{r4, r5, r6, pc}
 8004b14:	4770      	bx	lr
 8004b16:	bf00      	nop

08004b18 <tcp_pcb_remove>:
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 8004b18:	6802      	ldr	r2, [r0, #0]
 8004b1a:	428a      	cmp	r2, r1
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8004b1c:	b570      	push	{r4, r5, r6, lr}
 8004b1e:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 8004b20:	d059      	beq.n	8004bd6 <tcp_pcb_remove+0xbe>
 8004b22:	492f      	ldr	r1, [pc, #188]	; (8004be0 <tcp_pcb_remove+0xc8>)
 8004b24:	600a      	str	r2, [r1, #0]
 8004b26:	b152      	cbz	r2, 8004b3e <tcp_pcb_remove+0x26>
 8004b28:	68d3      	ldr	r3, [r2, #12]
 8004b2a:	429c      	cmp	r4, r3
 8004b2c:	d056      	beq.n	8004bdc <tcp_pcb_remove+0xc4>
 8004b2e:	b12b      	cbz	r3, 8004b3c <tcp_pcb_remove+0x24>
 8004b30:	68da      	ldr	r2, [r3, #12]
 8004b32:	4294      	cmp	r4, r2
 8004b34:	d04b      	beq.n	8004bce <tcp_pcb_remove+0xb6>
 8004b36:	4613      	mov	r3, r2
 8004b38:	2b00      	cmp	r3, #0
 8004b3a:	d1f9      	bne.n	8004b30 <tcp_pcb_remove+0x18>
 8004b3c:	600b      	str	r3, [r1, #0]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8004b3e:	7e23      	ldrb	r3, [r4, #24]
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 8004b40:	2500      	movs	r5, #0
 8004b42:	60e5      	str	r5, [r4, #12]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8004b44:	2b00      	cmp	r3, #0
 8004b46:	d033      	beq.n	8004bb0 <tcp_pcb_remove+0x98>
 8004b48:	2b0a      	cmp	r3, #10
 8004b4a:	d034      	beq.n	8004bb6 <tcp_pcb_remove+0x9e>
     pcb->state != TIME_WAIT &&
 8004b4c:	2b01      	cmp	r3, #1
 8004b4e:	d032      	beq.n	8004bb6 <tcp_pcb_remove+0x9e>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8004b50:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8004b52:	b110      	cbz	r0, 8004b5a <tcp_pcb_remove+0x42>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8004b54:	f7ff fb20 	bl	8004198 <pbuf_free>
      pcb->refused_data = NULL;
 8004b58:	6765      	str	r5, [r4, #116]	; 0x74

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
 8004b5a:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8004b5c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004b60:	86a3      	strh	r3, [r4, #52]	; 0x34
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004b62:	b165      	cbz	r5, 8004b7e <tcp_pcb_remove+0x66>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004b64:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004b66:	682e      	ldr	r6, [r5, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004b68:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004b6a:	b10b      	cbz	r3, 8004b70 <tcp_pcb_remove+0x58>
      pbuf_free(seg->p);
 8004b6c:	f7ff fb14 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004b70:	4629      	mov	r1, r5
 8004b72:	2004      	movs	r0, #4
 8004b74:	f7ff f864 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004b78:	4635      	mov	r5, r6
 8004b7a:	2e00      	cmp	r6, #0
 8004b7c:	d1f2      	bne.n	8004b64 <tcp_pcb_remove+0x4c>
    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
 8004b7e:	6f25      	ldr	r5, [r4, #112]	; 0x70
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004b80:	b165      	cbz	r5, 8004b9c <tcp_pcb_remove+0x84>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004b82:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004b84:	682e      	ldr	r6, [r5, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004b86:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004b88:	b10b      	cbz	r3, 8004b8e <tcp_pcb_remove+0x76>
      pbuf_free(seg->p);
 8004b8a:	f7ff fb05 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004b8e:	4629      	mov	r1, r5
 8004b90:	2004      	movs	r0, #4
 8004b92:	f7ff f855 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004b96:	4635      	mov	r5, r6
 8004b98:	2e00      	cmp	r6, #0
 8004b9a:	d1f2      	bne.n	8004b82 <tcp_pcb_remove+0x6a>
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8004b9c:	7e22      	ldrb	r2, [r4, #24]
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 8004b9e:	2300      	movs	r3, #0
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8004ba0:	2a0a      	cmp	r2, #10
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 8004ba2:	66e3      	str	r3, [r4, #108]	; 0x6c
 8004ba4:	6723      	str	r3, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8004ba6:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8004baa:	d004      	beq.n	8004bb6 <tcp_pcb_remove+0x9e>
 8004bac:	2a01      	cmp	r2, #1
 8004bae:	d002      	beq.n	8004bb6 <tcp_pcb_remove+0x9e>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8004bb0:	7fa3      	ldrb	r3, [r4, #30]

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
 8004bb2:	07da      	lsls	r2, r3, #31
 8004bb4:	d402      	bmi.n	8004bbc <tcp_pcb_remove+0xa4>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8004bb6:	2300      	movs	r3, #0
 8004bb8:	7623      	strb	r3, [r4, #24]
 8004bba:	bd70      	pop	{r4, r5, r6, pc}
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
 8004bbc:	f043 0302 	orr.w	r3, r3, #2
 8004bc0:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8004bc2:	4620      	mov	r0, r4
 8004bc4:	f001 ff5e 	bl	8006a84 <tcp_output>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8004bc8:	2300      	movs	r3, #0
 8004bca:	7623      	strb	r3, [r4, #24]
 8004bcc:	bd70      	pop	{r4, r5, r6, pc}
 8004bce:	600b      	str	r3, [r1, #0]
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 8004bd0:	68e2      	ldr	r2, [r4, #12]
 8004bd2:	60da      	str	r2, [r3, #12]
 8004bd4:	e7b3      	b.n	8004b3e <tcp_pcb_remove+0x26>
 8004bd6:	68cb      	ldr	r3, [r1, #12]
 8004bd8:	6003      	str	r3, [r0, #0]
 8004bda:	e7b0      	b.n	8004b3e <tcp_pcb_remove+0x26>
 8004bdc:	4613      	mov	r3, r2
 8004bde:	e7f7      	b.n	8004bd0 <tcp_pcb_remove+0xb8>
 8004be0:	20005754 	.word	0x20005754

08004be4 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 8004be4:	b570      	push	{r4, r5, r6, lr}
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8004be6:	7e03      	ldrb	r3, [r0, #24]
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 8004be8:	b082      	sub	sp, #8
 8004bea:	4604      	mov	r4, r0
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8004bec:	b119      	cbz	r1, 8004bf6 <tcp_close_shutdown+0x12>
 8004bee:	2b04      	cmp	r3, #4
 8004bf0:	d01d      	beq.n	8004c2e <tcp_close_shutdown+0x4a>
 8004bf2:	2b07      	cmp	r3, #7
 8004bf4:	d01b      	beq.n	8004c2e <tcp_close_shutdown+0x4a>
      }
      return ERR_OK;
    }
  }

  switch (pcb->state) {
 8004bf6:	2b07      	cmp	r3, #7
 8004bf8:	d80e      	bhi.n	8004c18 <tcp_close_shutdown+0x34>
 8004bfa:	e8df f003 	tbb	[pc, r3]
 8004bfe:	8975      	.short	0x8975
 8004c00:	0d101069 	.word	0x0d101069
 8004c04:	040d      	.short	0x040d
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
 8004c06:	4620      	mov	r0, r4
 8004c08:	f001 fb6a 	bl	80062e0 <tcp_send_fin>
    if (err == ERR_OK) {
 8004c0c:	b928      	cbnz	r0, 8004c1a <tcp_close_shutdown+0x36>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
 8004c0e:	2309      	movs	r3, #9
 8004c10:	7623      	strb	r3, [r4, #24]
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
 8004c12:	4620      	mov	r0, r4
 8004c14:	f001 ff36 	bl	8006a84 <tcp_output>
 8004c18:	2000      	movs	r0, #0
  }
  return err;
}
 8004c1a:	b002      	add	sp, #8
 8004c1c:	bd70      	pop	{r4, r5, r6, pc}
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
 8004c1e:	4620      	mov	r0, r4
 8004c20:	f001 fb5e 	bl	80062e0 <tcp_send_fin>
    if (err == ERR_OK) {
 8004c24:	2800      	cmp	r0, #0
 8004c26:	d1f8      	bne.n	8004c1a <tcp_close_shutdown+0x36>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
 8004c28:	2305      	movs	r3, #5
 8004c2a:	7623      	strb	r3, [r4, #24]
 8004c2c:	e7f1      	b.n	8004c12 <tcp_close_shutdown+0x2e>
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8004c2e:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8004c30:	2a00      	cmp	r2, #0
 8004c32:	d076      	beq.n	8004d22 <tcp_close_shutdown+0x13e>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8004c34:	8ba2      	ldrh	r2, [r4, #28]
 8004c36:	8b63      	ldrh	r3, [r4, #26]
 8004c38:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8004c3a:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8004c3c:	9201      	str	r2, [sp, #4]
 8004c3e:	9300      	str	r3, [sp, #0]
 8004c40:	4622      	mov	r2, r4
 8004c42:	1d23      	adds	r3, r4, #4
 8004c44:	f002 f86c 	bl	8006d20 <tcp_rst>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8004c48:	7e21      	ldrb	r1, [r4, #24]
 8004c4a:	2901      	cmp	r1, #1
 8004c4c:	d92e      	bls.n	8004cac <tcp_close_shutdown+0xc8>
 8004c4e:	290a      	cmp	r1, #10
 8004c50:	d02c      	beq.n	8004cac <tcp_close_shutdown+0xc8>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8004c52:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8004c54:	b118      	cbz	r0, 8004c5e <tcp_close_shutdown+0x7a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8004c56:	f7ff fa9f 	bl	8004198 <pbuf_free>
      pcb->refused_data = NULL;
 8004c5a:	2300      	movs	r3, #0
 8004c5c:	6763      	str	r3, [r4, #116]	; 0x74

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
 8004c5e:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8004c60:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004c64:	86a3      	strh	r3, [r4, #52]	; 0x34
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004c66:	b165      	cbz	r5, 8004c82 <tcp_close_shutdown+0x9e>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004c68:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004c6a:	682e      	ldr	r6, [r5, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004c6c:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004c6e:	b10b      	cbz	r3, 8004c74 <tcp_close_shutdown+0x90>
      pbuf_free(seg->p);
 8004c70:	f7ff fa92 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004c74:	4629      	mov	r1, r5
 8004c76:	2004      	movs	r0, #4
 8004c78:	f7fe ffe2 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004c7c:	4635      	mov	r5, r6
 8004c7e:	2e00      	cmp	r6, #0
 8004c80:	d1f2      	bne.n	8004c68 <tcp_close_shutdown+0x84>
    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
 8004c82:	6f25      	ldr	r5, [r4, #112]	; 0x70
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004c84:	b165      	cbz	r5, 8004ca0 <tcp_close_shutdown+0xbc>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004c86:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004c88:	682e      	ldr	r6, [r5, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004c8a:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004c8c:	b10b      	cbz	r3, 8004c92 <tcp_close_shutdown+0xae>
      pbuf_free(seg->p);
 8004c8e:	f7ff fa83 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004c92:	4629      	mov	r1, r5
 8004c94:	2004      	movs	r0, #4
 8004c96:	f7fe ffd3 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004c9a:	4635      	mov	r5, r6
 8004c9c:	2e00      	cmp	r6, #0
 8004c9e:	d1f2      	bne.n	8004c86 <tcp_close_shutdown+0xa2>
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 8004ca0:	2300      	movs	r3, #0
 8004ca2:	7e21      	ldrb	r1, [r4, #24]
 8004ca4:	66e3      	str	r3, [r4, #108]	; 0x6c
 8004ca6:	6723      	str	r3, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8004ca8:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8004cac:	4b39      	ldr	r3, [pc, #228]	; (8004d94 <tcp_close_shutdown+0x1b0>)
 8004cae:	681a      	ldr	r2, [r3, #0]
 8004cb0:	4294      	cmp	r4, r2
 8004cb2:	d062      	beq.n	8004d7a <tcp_close_shutdown+0x196>
 8004cb4:	4838      	ldr	r0, [pc, #224]	; (8004d98 <tcp_close_shutdown+0x1b4>)
 8004cb6:	6002      	str	r2, [r0, #0]
 8004cb8:	2a00      	cmp	r2, #0
 8004cba:	d03b      	beq.n	8004d34 <tcp_close_shutdown+0x150>
 8004cbc:	68d3      	ldr	r3, [r2, #12]
 8004cbe:	429c      	cmp	r4, r3
 8004cc0:	d05e      	beq.n	8004d80 <tcp_close_shutdown+0x19c>
 8004cc2:	2b00      	cmp	r3, #0
 8004cc4:	d04d      	beq.n	8004d62 <tcp_close_shutdown+0x17e>
 8004cc6:	68da      	ldr	r2, [r3, #12]
 8004cc8:	4294      	cmp	r4, r2
 8004cca:	d030      	beq.n	8004d2e <tcp_close_shutdown+0x14a>
 8004ccc:	4613      	mov	r3, r2
 8004cce:	e7f8      	b.n	8004cc2 <tcp_close_shutdown+0xde>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8004cd0:	4621      	mov	r1, r4
 8004cd2:	4830      	ldr	r0, [pc, #192]	; (8004d94 <tcp_close_shutdown+0x1b0>)
 8004cd4:	f7ff ff20 	bl	8004b18 <tcp_pcb_remove>
 8004cd8:	4b30      	ldr	r3, [pc, #192]	; (8004d9c <tcp_close_shutdown+0x1b8>)
 8004cda:	2201      	movs	r2, #1
    memp_free(MEMP_TCP_PCB, pcb);
 8004cdc:	4621      	mov	r1, r4
 8004cde:	2002      	movs	r0, #2
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8004ce0:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 8004ce2:	f7fe ffad 	bl	8003c40 <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
 8004ce6:	e797      	b.n	8004c18 <tcp_close_shutdown+0x34>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
 8004ce8:	8b63      	ldrh	r3, [r4, #26]
 8004cea:	2b00      	cmp	r3, #0
 8004cec:	d034      	beq.n	8004d58 <tcp_close_shutdown+0x174>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8004cee:	4b2c      	ldr	r3, [pc, #176]	; (8004da0 <tcp_close_shutdown+0x1bc>)
 8004cf0:	681a      	ldr	r2, [r3, #0]
 8004cf2:	4294      	cmp	r4, r2
 8004cf4:	d02c      	beq.n	8004d50 <tcp_close_shutdown+0x16c>
 8004cf6:	4828      	ldr	r0, [pc, #160]	; (8004d98 <tcp_close_shutdown+0x1b4>)
 8004cf8:	6002      	str	r2, [r0, #0]
 8004cfa:	b35a      	cbz	r2, 8004d54 <tcp_close_shutdown+0x170>
 8004cfc:	68d3      	ldr	r3, [r2, #12]
 8004cfe:	429c      	cmp	r4, r3
 8004d00:	d040      	beq.n	8004d84 <tcp_close_shutdown+0x1a0>
 8004d02:	2b00      	cmp	r3, #0
 8004d04:	d042      	beq.n	8004d8c <tcp_close_shutdown+0x1a8>
 8004d06:	68da      	ldr	r2, [r3, #12]
 8004d08:	4294      	cmp	r4, r2
 8004d0a:	d041      	beq.n	8004d90 <tcp_close_shutdown+0x1ac>
 8004d0c:	4613      	mov	r3, r2
 8004d0e:	e7f8      	b.n	8004d02 <tcp_close_shutdown+0x11e>
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8004d10:	4621      	mov	r1, r4
 8004d12:	4824      	ldr	r0, [pc, #144]	; (8004da4 <tcp_close_shutdown+0x1c0>)
 8004d14:	f7ff ff00 	bl	8004b18 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8004d18:	4621      	mov	r1, r4
 8004d1a:	2003      	movs	r0, #3
 8004d1c:	f7fe ff90 	bl	8003c40 <memp_free>
    pcb = NULL;
    break;
 8004d20:	e77a      	b.n	8004c18 <tcp_close_shutdown+0x34>
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8004d22:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 8004d24:	f640 3268 	movw	r2, #2920	; 0xb68
 8004d28:	4291      	cmp	r1, r2
 8004d2a:	d183      	bne.n	8004c34 <tcp_close_shutdown+0x50>
 8004d2c:	e763      	b.n	8004bf6 <tcp_close_shutdown+0x12>
 8004d2e:	6003      	str	r3, [r0, #0]
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8004d30:	68e2      	ldr	r2, [r4, #12]
 8004d32:	60da      	str	r2, [r3, #12]
 8004d34:	4b19      	ldr	r3, [pc, #100]	; (8004d9c <tcp_close_shutdown+0x1b8>)
 8004d36:	2201      	movs	r2, #1
 8004d38:	2500      	movs	r5, #0
      if (pcb->state == ESTABLISHED) {
 8004d3a:	2904      	cmp	r1, #4
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8004d3c:	701a      	strb	r2, [r3, #0]
 8004d3e:	60e5      	str	r5, [r4, #12]
      if (pcb->state == ESTABLISHED) {
 8004d40:	d011      	beq.n	8004d66 <tcp_close_shutdown+0x182>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
 8004d42:	4621      	mov	r1, r4
 8004d44:	2002      	movs	r0, #2
 8004d46:	f7fe ff7b 	bl	8003c40 <memp_free>
      }
      return ERR_OK;
 8004d4a:	4628      	mov	r0, r5
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
  }
  return err;
}
 8004d4c:	b002      	add	sp, #8
 8004d4e:	bd70      	pop	{r4, r5, r6, pc}
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8004d50:	68e2      	ldr	r2, [r4, #12]
 8004d52:	601a      	str	r2, [r3, #0]
 8004d54:	2300      	movs	r3, #0
 8004d56:	60e3      	str	r3, [r4, #12]
    }
    memp_free(MEMP_TCP_PCB, pcb);
 8004d58:	4621      	mov	r1, r4
 8004d5a:	2002      	movs	r0, #2
 8004d5c:	f7fe ff70 	bl	8003c40 <memp_free>
    pcb = NULL;
    break;
 8004d60:	e75a      	b.n	8004c18 <tcp_close_shutdown+0x34>
 8004d62:	6003      	str	r3, [r0, #0]
 8004d64:	e7e6      	b.n	8004d34 <tcp_close_shutdown+0x150>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
 8004d66:	4b10      	ldr	r3, [pc, #64]	; (8004da8 <tcp_close_shutdown+0x1c4>)

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 8004d68:	220a      	movs	r2, #10
        TCP_REG(&tcp_tw_pcbs, pcb);
 8004d6a:	6819      	ldr	r1, [r3, #0]
 8004d6c:	60e1      	str	r1, [r4, #12]

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 8004d6e:	7622      	strb	r2, [r4, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 8004d70:	601c      	str	r4, [r3, #0]
 8004d72:	f002 f95d 	bl	8007030 <tcp_timer_needed>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
      }
      return ERR_OK;
 8004d76:	4628      	mov	r0, r5
 8004d78:	e74f      	b.n	8004c1a <tcp_close_shutdown+0x36>
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8004d7a:	68e2      	ldr	r2, [r4, #12]
 8004d7c:	601a      	str	r2, [r3, #0]
 8004d7e:	e7d9      	b.n	8004d34 <tcp_close_shutdown+0x150>
 8004d80:	4613      	mov	r3, r2
 8004d82:	e7d5      	b.n	8004d30 <tcp_close_shutdown+0x14c>
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8004d84:	4613      	mov	r3, r2
 8004d86:	68e2      	ldr	r2, [r4, #12]
 8004d88:	60da      	str	r2, [r3, #12]
 8004d8a:	e7e3      	b.n	8004d54 <tcp_close_shutdown+0x170>
 8004d8c:	6003      	str	r3, [r0, #0]
 8004d8e:	e7e1      	b.n	8004d54 <tcp_close_shutdown+0x170>
 8004d90:	6003      	str	r3, [r0, #0]
 8004d92:	e7f8      	b.n	8004d86 <tcp_close_shutdown+0x1a2>
 8004d94:	20005748 	.word	0x20005748
 8004d98:	20005754 	.word	0x20005754
 8004d9c:	20005744 	.word	0x20005744
 8004da0:	20005758 	.word	0x20005758
 8004da4:	20005750 	.word	0x20005750
 8004da8:	2000575c 	.word	0x2000575c

08004dac <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 8004dac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
 8004dae:	b372      	cbz	r2, 8004e0e <tcp_recv_null+0x62>
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8004db0:	8910      	ldrh	r0, [r2, #8]
 8004db2:	8d8b      	ldrh	r3, [r1, #44]	; 0x2c
 8004db4:	4403      	add	r3, r0
 8004db6:	b29b      	uxth	r3, r3
  if (pcb->rcv_wnd > TCP_WND) {
 8004db8:	f640 3068 	movw	r0, #2920	; 0xb68
 8004dbc:	4283      	cmp	r3, r0
 8004dbe:	d822      	bhi.n	8004e06 <tcp_recv_null+0x5a>
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8004dc0:	858b      	strh	r3, [r1, #44]	; 0x2c
 8004dc2:	461c      	mov	r4, r3
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8004dc4:	f8d1 e028 	ldr.w	lr, [r1, #40]	; 0x28

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8004dc8:	8ecd      	ldrh	r5, [r1, #54]	; 0x36
 8004dca:	4616      	mov	r6, r2
 8004dcc:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8004dce:	ebc2 070e 	rsb	r7, r2, lr
 8004dd2:	4608      	mov	r0, r1
 8004dd4:	19e1      	adds	r1, r4, r7
 8004dd6:	f240 54b4 	movw	r4, #1460	; 0x5b4
 8004dda:	42a5      	cmp	r5, r4
 8004ddc:	bf94      	ite	ls
 8004dde:	1b4c      	subls	r4, r1, r5
 8004de0:	1b0c      	subhi	r4, r1, r4
 8004de2:	2c00      	cmp	r4, #0
 8004de4:	db22      	blt.n	8004e2c <tcp_recv_null+0x80>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8004de6:	f240 22d9 	movw	r2, #729	; 0x2d9
 8004dea:	4291      	cmp	r1, r2
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 8004dec:	85c3      	strh	r3, [r0, #46]	; 0x2e

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8004dee:	dd05      	ble.n	8004dfc <tcp_recv_null+0x50>
    tcp_ack_now(pcb);
 8004df0:	7f83      	ldrb	r3, [r0, #30]
 8004df2:	f043 0302 	orr.w	r3, r3, #2
 8004df6:	7783      	strb	r3, [r0, #30]
    tcp_output(pcb);
 8004df8:	f001 fe44 	bl	8006a84 <tcp_output>
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
    pbuf_free(p);
 8004dfc:	4630      	mov	r0, r6
 8004dfe:	f7ff f9cb 	bl	8004198 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
}
 8004e02:	2000      	movs	r0, #0
 8004e04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
  if (pcb->rcv_wnd > TCP_WND) {
    pcb->rcv_wnd = TCP_WND;
 8004e06:	4604      	mov	r4, r0
 8004e08:	8588      	strh	r0, [r1, #44]	; 0x2c
 8004e0a:	4603      	mov	r3, r0
 8004e0c:	e7da      	b.n	8004dc4 <tcp_recv_null+0x18>
{
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
    pbuf_free(p);
  } else if (err == ERR_OK) {
 8004e0e:	2b00      	cmp	r3, #0
 8004e10:	d1f7      	bne.n	8004e02 <tcp_recv_null+0x56>
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
 8004e12:	7e0b      	ldrb	r3, [r1, #24]
 8004e14:	2b01      	cmp	r3, #1
 8004e16:	d003      	beq.n	8004e20 <tcp_recv_null+0x74>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 8004e18:	7f8b      	ldrb	r3, [r1, #30]
 8004e1a:	f043 0310 	orr.w	r3, r3, #16
 8004e1e:	778b      	strb	r3, [r1, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 8004e20:	4608      	mov	r0, r1
    pbuf_free(p);
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
}
 8004e22:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  if (pcb->state != LISTEN) {
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 8004e26:	2101      	movs	r1, #1
 8004e28:	f7ff bedc 	b.w	8004be4 <tcp_close_shutdown>
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    return new_right_edge - pcb->rcv_ann_right_edge;
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8004e2c:	2f00      	cmp	r7, #0
 8004e2e:	dd02      	ble.n	8004e36 <tcp_recv_null+0x8a>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 8004e30:	2200      	movs	r2, #0
 8004e32:	85c2      	strh	r2, [r0, #46]	; 0x2e
 8004e34:	e7e2      	b.n	8004dfc <tcp_recv_null+0x50>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 8004e36:	ebce 0202 	rsb	r2, lr, r2
 8004e3a:	b292      	uxth	r2, r2
 8004e3c:	e7f9      	b.n	8004e32 <tcp_recv_null+0x86>
 8004e3e:	bf00      	nop

08004e40 <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 8004e40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
 8004e44:	6f46      	ldr	r6, [r0, #116]	; 0x74
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8004e46:	6fc7      	ldr	r7, [r0, #124]	; 0x7c
/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
 8004e48:	f896 800d 	ldrb.w	r8, [r6, #13]
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
 8004e4c:	2500      	movs	r5, #0
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 8004e4e:	4604      	mov	r4, r0
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
 8004e50:	6745      	str	r5, [r0, #116]	; 0x74
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8004e52:	b15f      	cbz	r7, 8004e6c <tcp_process_refused_data+0x2c>
 8004e54:	4601      	mov	r1, r0
 8004e56:	462b      	mov	r3, r5
 8004e58:	4632      	mov	r2, r6
 8004e5a:	6900      	ldr	r0, [r0, #16]
 8004e5c:	47b8      	blx	r7
  if (err == ERR_OK) {
 8004e5e:	b360      	cbz	r0, 8004eba <tcp_process_refused_data+0x7a>
      TCP_EVENT_CLOSED(pcb, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
      }
    }
  } else if (err == ERR_ABRT) {
 8004e60:	300a      	adds	r0, #10
 8004e62:	d044      	beq.n	8004eee <tcp_process_refused_data+0xae>
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
 8004e64:	6766      	str	r6, [r4, #116]	; 0x74
  }
  return ERR_OK;
 8004e66:	4628      	mov	r0, r5
 8004e68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8004e6c:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
 8004e6e:	8933      	ldrh	r3, [r6, #8]
 8004e70:	4413      	add	r3, r2
 8004e72:	b29b      	uxth	r3, r3
  if (pcb->rcv_wnd > TCP_WND) {
 8004e74:	f640 3168 	movw	r1, #2920	; 0xb68
 8004e78:	428b      	cmp	r3, r1
 8004e7a:	d834      	bhi.n	8004ee6 <tcp_process_refused_data+0xa6>
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8004e7c:	8583      	strh	r3, [r0, #44]	; 0x2c
 8004e7e:	461a      	mov	r2, r3
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8004e80:	6aa7      	ldr	r7, [r4, #40]	; 0x28

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8004e82:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004e84:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
 8004e86:	f240 5eb4 	movw	lr, #1460	; 0x5b4
 8004e8a:	1a3d      	subs	r5, r7, r0
 8004e8c:	4571      	cmp	r1, lr
 8004e8e:	442a      	add	r2, r5
 8004e90:	bf94      	ite	ls
 8004e92:	1a51      	subls	r1, r2, r1
 8004e94:	ebce 0102 	rsbhi	r1, lr, r2
 8004e98:	2900      	cmp	r1, #0
 8004e9a:	db2c      	blt.n	8004ef6 <tcp_process_refused_data+0xb6>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8004e9c:	f240 21d9 	movw	r1, #729	; 0x2d9
 8004ea0:	428a      	cmp	r2, r1
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 8004ea2:	85e3      	strh	r3, [r4, #46]	; 0x2e

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8004ea4:	dd06      	ble.n	8004eb4 <tcp_process_refused_data+0x74>
    tcp_ack_now(pcb);
 8004ea6:	7fa3      	ldrb	r3, [r4, #30]
 8004ea8:	f043 0302 	orr.w	r3, r3, #2
 8004eac:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8004eae:	4620      	mov	r0, r4
 8004eb0:	f001 fde8 	bl	8006a84 <tcp_output>
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
    pbuf_free(p);
 8004eb4:	4630      	mov	r0, r6
 8004eb6:	f7ff f96f 	bl	8004198 <pbuf_free>
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
  if (err == ERR_OK) {
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
 8004eba:	f018 0f20 	tst.w	r8, #32
 8004ebe:	d00f      	beq.n	8004ee0 <tcp_process_refused_data+0xa0>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
 8004ec0:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
        pcb->rcv_wnd++;
      }
      TCP_EVENT_CLOSED(pcb, err);
 8004ec2:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
  if (err == ERR_OK) {
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
 8004ec4:	f640 3268 	movw	r2, #2920	; 0xb68
 8004ec8:	4293      	cmp	r3, r2
        pcb->rcv_wnd++;
 8004eca:	bf1c      	itt	ne
 8004ecc:	3301      	addne	r3, #1
 8004ece:	85a3      	strhne	r3, [r4, #44]	; 0x2c
      }
      TCP_EVENT_CLOSED(pcb, err);
 8004ed0:	b135      	cbz	r5, 8004ee0 <tcp_process_refused_data+0xa0>
 8004ed2:	2300      	movs	r3, #0
 8004ed4:	461a      	mov	r2, r3
 8004ed6:	4621      	mov	r1, r4
 8004ed8:	6920      	ldr	r0, [r4, #16]
 8004eda:	47a8      	blx	r5
      if (err == ERR_ABRT) {
 8004edc:	300a      	adds	r0, #10
 8004ede:	d006      	beq.n	8004eee <tcp_process_refused_data+0xae>
    return ERR_ABRT;
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
  }
  return ERR_OK;
 8004ee0:	2000      	movs	r0, #0
 8004ee2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
  if (pcb->rcv_wnd > TCP_WND) {
    pcb->rcv_wnd = TCP_WND;
 8004ee6:	460a      	mov	r2, r1
 8004ee8:	8581      	strh	r1, [r0, #44]	; 0x2c
 8004eea:	460b      	mov	r3, r1
 8004eec:	e7c8      	b.n	8004e80 <tcp_process_refused_data+0x40>
      if (pcb->rcv_wnd != TCP_WND) {
        pcb->rcv_wnd++;
      }
      TCP_EVENT_CLOSED(pcb, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
 8004eee:	f06f 0009 	mvn.w	r0, #9
 8004ef2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    return new_right_edge - pcb->rcv_ann_right_edge;
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8004ef6:	2d00      	cmp	r5, #0
 8004ef8:	dd02      	ble.n	8004f00 <tcp_process_refused_data+0xc0>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 8004efa:	2300      	movs	r3, #0
 8004efc:	85e3      	strh	r3, [r4, #46]	; 0x2e
 8004efe:	e7d9      	b.n	8004eb4 <tcp_process_refused_data+0x74>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 8004f00:	1bc3      	subs	r3, r0, r7
 8004f02:	b29b      	uxth	r3, r3
 8004f04:	e7fa      	b.n	8004efc <tcp_process_refused_data+0xbc>
 8004f06:	bf00      	nop

08004f08 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 8004f08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 8004f0c:	4d1c      	ldr	r5, [pc, #112]	; (8004f80 <tcp_tmr+0x78>)
 8004f0e:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8004f8c <tcp_tmr+0x84>
 8004f12:	782b      	ldrb	r3, [r5, #0]

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
 8004f14:	4e1b      	ldr	r6, [pc, #108]	; (8004f84 <tcp_tmr+0x7c>)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 8004f16:	3301      	adds	r3, #1
 8004f18:	702b      	strb	r3, [r5, #0]

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
 8004f1a:	2700      	movs	r7, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 8004f1c:	f8d8 4000 	ldr.w	r4, [r8]

  while(pcb != NULL) {
 8004f20:	b12c      	cbz	r4, 8004f2e <tcp_tmr+0x26>
    if (pcb->last_timer != tcp_timer_ctr) {
 8004f22:	782b      	ldrb	r3, [r5, #0]
 8004f24:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 8004f28:	429a      	cmp	r2, r3
 8004f2a:	d109      	bne.n	8004f40 <tcp_tmr+0x38>
 8004f2c:	e7fe      	b.n	8004f2c <tcp_tmr+0x24>
tcp_tmr(void)
{
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();

  if (++tcp_timer & 1) {
 8004f2e:	4a16      	ldr	r2, [pc, #88]	; (8004f88 <tcp_tmr+0x80>)
 8004f30:	7813      	ldrb	r3, [r2, #0]
 8004f32:	3301      	adds	r3, #1
 8004f34:	b2db      	uxtb	r3, r3
 8004f36:	7013      	strb	r3, [r2, #0]
 8004f38:	07db      	lsls	r3, r3, #31
 8004f3a:	d412      	bmi.n	8004f62 <tcp_tmr+0x5a>
 8004f3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while(pcb != NULL) {
    if (pcb->last_timer != tcp_timer_ctr) {
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 8004f40:	7fa2      	ldrb	r2, [r4, #30]
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
    if (pcb->last_timer != tcp_timer_ctr) {
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 8004f42:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 8004f46:	07d1      	lsls	r1, r2, #31
 8004f48:	d40f      	bmi.n	8004f6a <tcp_tmr+0x62>
      }

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 8004f4a:	6f63      	ldr	r3, [r4, #116]	; 0x74
        tcp_active_pcbs_changed = 0;
        tcp_process_refused_data(pcb);
 8004f4c:	4620      	mov	r0, r4
        tcp_ack_now(pcb);
        tcp_output(pcb);
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
      }

      next = pcb->next;
 8004f4e:	68e4      	ldr	r4, [r4, #12]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 8004f50:	2b00      	cmp	r3, #0
 8004f52:	d0e5      	beq.n	8004f20 <tcp_tmr+0x18>
        tcp_active_pcbs_changed = 0;
 8004f54:	7037      	strb	r7, [r6, #0]
        tcp_process_refused_data(pcb);
 8004f56:	f7ff ff73 	bl	8004e40 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 8004f5a:	7833      	ldrb	r3, [r6, #0]
 8004f5c:	2b00      	cmp	r3, #0
 8004f5e:	d0df      	beq.n	8004f20 <tcp_tmr+0x18>
 8004f60:	e7dc      	b.n	8004f1c <tcp_tmr+0x14>
  if (++tcp_timer & 1) {
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  }
}
 8004f62:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  tcp_fasttmr();

  if (++tcp_timer & 1) {
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 8004f66:	f7ff bb77 	b.w	8004658 <tcp_slowtmr>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 8004f6a:	f042 0202 	orr.w	r2, r2, #2
 8004f6e:	77a2      	strb	r2, [r4, #30]
        tcp_output(pcb);
 8004f70:	4620      	mov	r0, r4
 8004f72:	f001 fd87 	bl	8006a84 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8004f76:	7fa3      	ldrb	r3, [r4, #30]
 8004f78:	f023 0303 	bic.w	r3, r3, #3
 8004f7c:	77a3      	strb	r3, [r4, #30]
 8004f7e:	e7e4      	b.n	8004f4a <tcp_tmr+0x42>
 8004f80:	2000297d 	.word	0x2000297d
 8004f84:	20005744 	.word	0x20005744
 8004f88:	2000297c 	.word	0x2000297c
 8004f8c:	20005748 	.word	0x20005748

08004f90 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 8004f90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 8004f94:	7e03      	ldrb	r3, [r0, #24]
 8004f96:	2b0a      	cmp	r3, #10
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 8004f98:	b083      	sub	sp, #12
 8004f9a:	4605      	mov	r5, r0
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 8004f9c:	d050      	beq.n	8005040 <tcp_abandon+0xb0>
 8004f9e:	460f      	mov	r7, r1
    ackno = pcb->rcv_nxt;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8004fa0:	4601      	mov	r1, r0
 8004fa2:	482d      	ldr	r0, [pc, #180]	; (8005058 <tcp_abandon+0xc8>)
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
 8004fa4:	f8d5 9050 	ldr.w	r9, [r5, #80]	; 0x50
    ackno = pcb->rcv_nxt;
 8004fa8:	f8d5 a028 	ldr.w	sl, [r5, #40]	; 0x28
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 8004fac:	f8d5 6088 	ldr.w	r6, [r5, #136]	; 0x88
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 8004fb0:	f8d5 8010 	ldr.w	r8, [r5, #16]
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8004fb4:	f7ff fdb0 	bl	8004b18 <tcp_pcb_remove>
 8004fb8:	4b28      	ldr	r3, [pc, #160]	; (800505c <tcp_abandon+0xcc>)
    if (pcb->unacked != NULL) {
 8004fba:	6f2c      	ldr	r4, [r5, #112]	; 0x70
    ackno = pcb->rcv_nxt;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8004fbc:	2201      	movs	r2, #1
 8004fbe:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
 8004fc0:	b16c      	cbz	r4, 8004fde <tcp_abandon+0x4e>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004fc2:	6863      	ldr	r3, [r4, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004fc4:	f8d4 b000 	ldr.w	fp, [r4]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004fc8:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004fca:	b10b      	cbz	r3, 8004fd0 <tcp_abandon+0x40>
      pbuf_free(seg->p);
 8004fcc:	f7ff f8e4 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004fd0:	4621      	mov	r1, r4
 8004fd2:	2004      	movs	r0, #4
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004fd4:	465c      	mov	r4, fp
      pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004fd6:	f7fe fe33 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004fda:	2c00      	cmp	r4, #0
 8004fdc:	d1f1      	bne.n	8004fc2 <tcp_abandon+0x32>
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
    if (pcb->unacked != NULL) {
      tcp_segs_free(pcb->unacked);
    }
    if (pcb->unsent != NULL) {
 8004fde:	6eec      	ldr	r4, [r5, #108]	; 0x6c
 8004fe0:	b16c      	cbz	r4, 8004ffe <tcp_abandon+0x6e>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004fe2:	6863      	ldr	r3, [r4, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8004fe4:	f8d4 b000 	ldr.w	fp, [r4]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 8004fe8:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8004fea:	b10b      	cbz	r3, 8004ff0 <tcp_abandon+0x60>
      pbuf_free(seg->p);
 8004fec:	f7ff f8d4 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004ff0:	4621      	mov	r1, r4
 8004ff2:	2004      	movs	r0, #4
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004ff4:	465c      	mov	r4, fp
      pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8004ff6:	f7fe fe23 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8004ffa:	2c00      	cmp	r4, #0
 8004ffc:	d1f1      	bne.n	8004fe2 <tcp_abandon+0x52>
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
 8004ffe:	b967      	cbnz	r7, 800501a <tcp_abandon+0x8a>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
 8005000:	4629      	mov	r1, r5
 8005002:	2002      	movs	r0, #2
 8005004:	f7fe fe1c 	bl	8003c40 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 8005008:	b1be      	cbz	r6, 800503a <tcp_abandon+0xaa>
 800500a:	4640      	mov	r0, r8
 800500c:	f06f 0109 	mvn.w	r1, #9
 8005010:	4633      	mov	r3, r6
  }
}
 8005012:	b003      	add	sp, #12
 8005014:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 8005018:	4718      	bx	r3
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 800501a:	8baa      	ldrh	r2, [r5, #28]
 800501c:	8b6b      	ldrh	r3, [r5, #26]
 800501e:	9300      	str	r3, [sp, #0]
 8005020:	9201      	str	r2, [sp, #4]
 8005022:	4651      	mov	r1, sl
 8005024:	4648      	mov	r0, r9
 8005026:	1d2b      	adds	r3, r5, #4
 8005028:	462a      	mov	r2, r5
 800502a:	f001 fe79 	bl	8006d20 <tcp_rst>
    }
    memp_free(MEMP_TCP_PCB, pcb);
 800502e:	4629      	mov	r1, r5
 8005030:	2002      	movs	r0, #2
 8005032:	f7fe fe05 	bl	8003c40 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 8005036:	2e00      	cmp	r6, #0
 8005038:	d1e7      	bne.n	800500a <tcp_abandon+0x7a>
  }
}
 800503a:	b003      	add	sp, #12
 800503c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 8005040:	4601      	mov	r1, r0
 8005042:	4807      	ldr	r0, [pc, #28]	; (8005060 <tcp_abandon+0xd0>)
 8005044:	f7ff fd68 	bl	8004b18 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 8005048:	4629      	mov	r1, r5
 800504a:	2002      	movs	r0, #2
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  }
}
 800504c:	b003      	add	sp, #12
 800504e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
 8005052:	f7fe bdf5 	b.w	8003c40 <memp_free>
 8005056:	bf00      	nop
 8005058:	20005748 	.word	0x20005748
 800505c:	20005744 	.word	0x20005744
 8005060:	2000575c 	.word	0x2000575c

08005064 <tcp_abort>:
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 8005064:	2101      	movs	r1, #1
 8005066:	f7ff bf93 	b.w	8004f90 <tcp_abandon>
 800506a:	bf00      	nop

0800506c <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 800506c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800506e:	4605      	mov	r5, r0
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8005070:	2002      	movs	r0, #2
 8005072:	f7fe fdd3 	bl	8003c1c <memp_malloc>
  if (pcb == NULL) {
 8005076:	4604      	mov	r4, r0
 8005078:	2800      	cmp	r0, #0
 800507a:	d03e      	beq.n	80050fa <tcp_alloc+0x8e>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800507c:	2294      	movs	r2, #148	; 0x94
 800507e:	2100      	movs	r1, #0
 8005080:	4620      	mov	r0, r4
 8005082:	f006 fa53 	bl	800b52c <memset>
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 8005086:	493a      	ldr	r1, [pc, #232]	; (8005170 <tcp_alloc+0x104>)
 8005088:	4b3a      	ldr	r3, [pc, #232]	; (8005174 <tcp_alloc+0x108>)
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 800508a:	483b      	ldr	r0, [pc, #236]	; (8005178 <tcp_alloc+0x10c>)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800508c:	681a      	ldr	r2, [r3, #0]
 800508e:	680b      	ldr	r3, [r1, #0]
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 8005090:	7807      	ldrb	r7, [r0, #0]
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
 8005092:	7665      	strb	r5, [r4, #25]
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 8005094:	4413      	add	r3, r2
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
 8005096:	f241 65d0 	movw	r5, #5840	; 0x16d0
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
 800509a:	6262      	str	r2, [r4, #36]	; 0x24
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
 800509c:	2200      	movs	r2, #0
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800509e:	600b      	str	r3, [r1, #0]
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 80050a0:	4e36      	ldr	r6, [pc, #216]	; (800517c <tcp_alloc+0x110>)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 80050a2:	4837      	ldr	r0, [pc, #220]	; (8005180 <tcp_alloc+0x114>)
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
 80050a4:	65a3      	str	r3, [r4, #88]	; 0x58
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
 80050a6:	f640 3168 	movw	r1, #2920	; 0xb68
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
 80050aa:	6523      	str	r3, [r4, #80]	; 0x50
    pcb->lastack = iss;
 80050ac:	64a3      	str	r3, [r4, #72]	; 0x48
    pcb->snd_lbb = iss;   
 80050ae:	65e3      	str	r3, [r4, #92]	; 0x5c
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
 80050b0:	f04f 0eff 	mov.w	lr, #255	; 0xff
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 80050b4:	2306      	movs	r3, #6
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 80050b6:	f884 7021 	strb.w	r7, [r4, #33]	; 0x21
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
 80050ba:	f8a4 5066 	strh.w	r5, [r4, #102]	; 0x66
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 80050be:	f44f 7706 	mov.w	r7, #536	; 0x218
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
 80050c2:	f8a4 2068 	strh.w	r2, [r4, #104]	; 0x68
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
 80050c6:	7262      	strb	r2, [r4, #9]
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
 80050c8:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;
 80050cc:	77e2      	strb	r2, [r4, #31]
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
 80050ce:	f884 2092 	strb.w	r2, [r4, #146]	; 0x92
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
 80050d2:	f64f 75ff 	movw	r5, #65535	; 0xffff
    pcb->cwnd = 1;
 80050d6:	2201      	movs	r2, #1
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
 80050d8:	85a1      	strh	r1, [r4, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
 80050da:	85e1      	strh	r1, [r4, #46]	; 0x2e
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
 80050dc:	f884 e00a 	strb.w	lr, [r4, #10]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 80050e0:	86e7      	strh	r7, [r4, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 80050e2:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 80050e6:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
    pcb->rtime = -1;
 80050ea:	86a5      	strh	r5, [r4, #52]	; 0x34
    pcb->cwnd = 1;
 80050ec:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 80050f0:	67e6      	str	r6, [r4, #124]	; 0x7c
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 80050f2:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  }
  return pcb;
}
 80050f6:	4620      	mov	r0, r4
 80050f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80050fa:	4b22      	ldr	r3, [pc, #136]	; (8005184 <tcp_alloc+0x118>)
 80050fc:	6818      	ldr	r0, [r3, #0]
 80050fe:	b188      	cbz	r0, 8005124 <tcp_alloc+0xb8>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8005100:	4b1c      	ldr	r3, [pc, #112]	; (8005174 <tcp_alloc+0x108>)
 8005102:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8005104:	681c      	ldr	r4, [r3, #0]
 8005106:	4603      	mov	r3, r0
 8005108:	1a61      	subs	r1, r4, r1
 800510a:	e005      	b.n	8005118 <tcp_alloc+0xac>
 800510c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800510e:	1aa2      	subs	r2, r4, r2
 8005110:	428a      	cmp	r2, r1
 8005112:	bf24      	itt	cs
 8005114:	4611      	movcs	r1, r2
 8005116:	4618      	movcs	r0, r3
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8005118:	68db      	ldr	r3, [r3, #12]
 800511a:	2b00      	cmp	r3, #0
 800511c:	d1f6      	bne.n	800510c <tcp_alloc+0xa0>
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800511e:	2101      	movs	r1, #1
 8005120:	f7ff ff36 	bl	8004f90 <tcp_abandon>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8005124:	2002      	movs	r0, #2
 8005126:	f7fe fd79 	bl	8003c1c <memp_malloc>
    if (pcb == NULL) {
 800512a:	4604      	mov	r4, r0
 800512c:	2800      	cmp	r0, #0
 800512e:	d1a5      	bne.n	800507c <tcp_alloc+0x10>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8005130:	4b15      	ldr	r3, [pc, #84]	; (8005188 <tcp_alloc+0x11c>)
 8005132:	681b      	ldr	r3, [r3, #0]
 8005134:	b1ab      	cbz	r3, 8005162 <tcp_alloc+0xf6>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8005136:	4a0f      	ldr	r2, [pc, #60]	; (8005174 <tcp_alloc+0x108>)
 8005138:	6817      	ldr	r7, [r2, #0]
 800513a:	267f      	movs	r6, #127	; 0x7f
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
 800513c:	7e5a      	ldrb	r2, [r3, #25]
 800513e:	4295      	cmp	r5, r2
 8005140:	d308      	bcc.n	8005154 <tcp_alloc+0xe8>
 8005142:	42b2      	cmp	r2, r6
 8005144:	d806      	bhi.n	8005154 <tcp_alloc+0xe8>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8005146:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005148:	1a79      	subs	r1, r7, r1
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
 800514a:	42a1      	cmp	r1, r4
 800514c:	d302      	bcc.n	8005154 <tcp_alloc+0xe8>
 800514e:	4616      	mov	r6, r2
 8005150:	460c      	mov	r4, r1
 8005152:	4618      	mov	r0, r3
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8005154:	68db      	ldr	r3, [r3, #12]
 8005156:	2b00      	cmp	r3, #0
 8005158:	d1f0      	bne.n	800513c <tcp_alloc+0xd0>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
 800515a:	b110      	cbz	r0, 8005162 <tcp_alloc+0xf6>
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800515c:	2101      	movs	r1, #1
 800515e:	f7ff ff17 	bl	8004f90 <tcp_abandon>
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8005162:	2002      	movs	r0, #2
 8005164:	f7fe fd5a 	bl	8003c1c <memp_malloc>
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 8005168:	4604      	mov	r4, r0
 800516a:	2800      	cmp	r0, #0
 800516c:	d0c3      	beq.n	80050f6 <tcp_alloc+0x8a>
 800516e:	e785      	b.n	800507c <tcp_alloc+0x10>
 8005170:	20000004 	.word	0x20000004
 8005174:	2000574c 	.word	0x2000574c
 8005178:	2000297d 	.word	0x2000297d
 800517c:	08004dad 	.word	0x08004dad
 8005180:	006ddd00 	.word	0x006ddd00
 8005184:	2000575c 	.word	0x2000575c
 8005188:	20005748 	.word	0x20005748

0800518c <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 800518c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
tcp_alloc(u8_t prio)
{
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800518e:	2002      	movs	r0, #2
 8005190:	f7fe fd44 	bl	8003c1c <memp_malloc>
  if (pcb == NULL) {
 8005194:	4604      	mov	r4, r0
 8005196:	2800      	cmp	r0, #0
 8005198:	d040      	beq.n	800521c <tcp_new+0x90>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800519a:	2294      	movs	r2, #148	; 0x94
 800519c:	2100      	movs	r1, #0
 800519e:	4620      	mov	r0, r4
 80051a0:	f006 f9c4 	bl	800b52c <memset>
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 80051a4:	4a3b      	ldr	r2, [pc, #236]	; (8005294 <tcp_new+0x108>)
 80051a6:	4b3c      	ldr	r3, [pc, #240]	; (8005298 <tcp_new+0x10c>)
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 80051a8:	483c      	ldr	r0, [pc, #240]	; (800529c <tcp_new+0x110>)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 80051aa:	6819      	ldr	r1, [r3, #0]
 80051ac:	6813      	ldr	r3, [r2, #0]
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 80051ae:	f890 e000 	ldrb.w	lr, [r0]

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 80051b2:	4d3b      	ldr	r5, [pc, #236]	; (80052a0 <tcp_new+0x114>)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 80051b4:	483b      	ldr	r0, [pc, #236]	; (80052a4 <tcp_new+0x118>)
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
 80051b6:	6261      	str	r1, [r4, #36]	; 0x24
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 80051b8:	440b      	add	r3, r1
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
 80051ba:	2740      	movs	r7, #64	; 0x40
    pcb->snd_buf = TCP_SND_BUF;
 80051bc:	f241 66d0 	movw	r6, #5840	; 0x16d0
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 80051c0:	6013      	str	r3, [r2, #0]
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
 80051c2:	2200      	movs	r2, #0
    pcb->rcv_wnd = TCP_WND;
 80051c4:	f640 3168 	movw	r1, #2920	; 0xb68
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
 80051c8:	65a3      	str	r3, [r4, #88]	; 0x58
    pcb->snd_nxt = iss;
 80051ca:	6523      	str	r3, [r4, #80]	; 0x50
    pcb->lastack = iss;
 80051cc:	64a3      	str	r3, [r4, #72]	; 0x48
    pcb->snd_lbb = iss;   
 80051ce:	65e3      	str	r3, [r4, #92]	; 0x5c
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 80051d0:	f884 e021 	strb.w	lr, [r4, #33]	; 0x21
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 80051d4:	2306      	movs	r3, #6
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
 80051d6:	f04f 0eff 	mov.w	lr, #255	; 0xff
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
 80051da:	7667      	strb	r7, [r4, #25]
    pcb->snd_buf = TCP_SND_BUF;
 80051dc:	f8a4 6066 	strh.w	r6, [r4, #102]	; 0x66
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 80051e0:	f44f 7706 	mov.w	r7, #536	; 0x218
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
 80051e4:	f8a4 2068 	strh.w	r2, [r4, #104]	; 0x68
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
 80051e8:	7262      	strb	r2, [r4, #9]
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
 80051ea:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;
 80051ee:	77e2      	strb	r2, [r4, #31]
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
 80051f0:	f884 2092 	strb.w	r2, [r4, #146]	; 0x92
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
 80051f4:	f64f 76ff 	movw	r6, #65535	; 0xffff
    pcb->cwnd = 1;
 80051f8:	2201      	movs	r2, #1
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
 80051fa:	85a1      	strh	r1, [r4, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
 80051fc:	85e1      	strh	r1, [r4, #46]	; 0x2e
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
 80051fe:	f884 e00a 	strb.w	lr, [r4, #10]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8005202:	86e7      	strh	r7, [r4, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 8005204:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 8005208:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
    pcb->rtime = -1;
 800520c:	86a6      	strh	r6, [r4, #52]	; 0x34
    pcb->cwnd = 1;
 800520e:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 8005212:	67e5      	str	r5, [r4, #124]	; 0x7c
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 8005214:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
 */
struct tcp_pcb *
tcp_new(void)
{
  return tcp_alloc(TCP_PRIO_NORMAL);
}
 8005218:	4620      	mov	r0, r4
 800521a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800521c:	4b22      	ldr	r3, [pc, #136]	; (80052a8 <tcp_new+0x11c>)
 800521e:	6818      	ldr	r0, [r3, #0]
 8005220:	b188      	cbz	r0, 8005246 <tcp_new+0xba>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8005222:	4b1d      	ldr	r3, [pc, #116]	; (8005298 <tcp_new+0x10c>)
 8005224:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8005226:	681c      	ldr	r4, [r3, #0]
 8005228:	4603      	mov	r3, r0
 800522a:	1a61      	subs	r1, r4, r1
 800522c:	e005      	b.n	800523a <tcp_new+0xae>
 800522e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005230:	1aa2      	subs	r2, r4, r2
 8005232:	428a      	cmp	r2, r1
 8005234:	bf24      	itt	cs
 8005236:	4611      	movcs	r1, r2
 8005238:	4618      	movcs	r0, r3
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800523a:	68db      	ldr	r3, [r3, #12]
 800523c:	2b00      	cmp	r3, #0
 800523e:	d1f6      	bne.n	800522e <tcp_new+0xa2>
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 8005240:	2101      	movs	r1, #1
 8005242:	f7ff fea5 	bl	8004f90 <tcp_abandon>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8005246:	2002      	movs	r0, #2
 8005248:	f7fe fce8 	bl	8003c1c <memp_malloc>
    if (pcb == NULL) {
 800524c:	4604      	mov	r4, r0
 800524e:	2800      	cmp	r0, #0
 8005250:	d1a3      	bne.n	800519a <tcp_new+0xe>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8005252:	4b16      	ldr	r3, [pc, #88]	; (80052ac <tcp_new+0x120>)
 8005254:	681b      	ldr	r3, [r3, #0]
 8005256:	b1ab      	cbz	r3, 8005284 <tcp_new+0xf8>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8005258:	4a0f      	ldr	r2, [pc, #60]	; (8005298 <tcp_new+0x10c>)
 800525a:	6816      	ldr	r6, [r2, #0]
 800525c:	257f      	movs	r5, #127	; 0x7f
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
 800525e:	7e5a      	ldrb	r2, [r3, #25]
 8005260:	2a40      	cmp	r2, #64	; 0x40
 8005262:	d808      	bhi.n	8005276 <tcp_new+0xea>
 8005264:	42aa      	cmp	r2, r5
 8005266:	d806      	bhi.n	8005276 <tcp_new+0xea>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8005268:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800526a:	1a71      	subs	r1, r6, r1
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
 800526c:	42a1      	cmp	r1, r4
 800526e:	d302      	bcc.n	8005276 <tcp_new+0xea>
 8005270:	4615      	mov	r5, r2
 8005272:	460c      	mov	r4, r1
 8005274:	4618      	mov	r0, r3
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8005276:	68db      	ldr	r3, [r3, #12]
 8005278:	2b00      	cmp	r3, #0
 800527a:	d1f0      	bne.n	800525e <tcp_new+0xd2>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
 800527c:	b110      	cbz	r0, 8005284 <tcp_new+0xf8>
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800527e:	2101      	movs	r1, #1
 8005280:	f7ff fe86 	bl	8004f90 <tcp_abandon>
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8005284:	2002      	movs	r0, #2
 8005286:	f7fe fcc9 	bl	8003c1c <memp_malloc>
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 800528a:	4604      	mov	r4, r0
 800528c:	2800      	cmp	r0, #0
 800528e:	d0c3      	beq.n	8005218 <tcp_new+0x8c>
 8005290:	e783      	b.n	800519a <tcp_new+0xe>
 8005292:	bf00      	nop
 8005294:	20000004 	.word	0x20000004
 8005298:	2000574c 	.word	0x2000574c
 800529c:	2000297d 	.word	0x2000297d
 80052a0:	08004dad 	.word	0x08004dad
 80052a4:	006ddd00 	.word	0x006ddd00
 80052a8:	2000575c 	.word	0x2000575c
 80052ac:	20005748 	.word	0x20005748

080052b0 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 80052b0:	b570      	push	{r4, r5, r6, lr}
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
 80052b2:	7e03      	ldrb	r3, [r0, #24]
 80052b4:	2b01      	cmp	r3, #1
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 80052b6:	b082      	sub	sp, #8
 80052b8:	4604      	mov	r4, r0
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
 80052ba:	f000 80ad 	beq.w	8005418 <tcp_close+0x168>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 80052be:	7f82      	ldrb	r2, [r0, #30]
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 80052c0:	2b04      	cmp	r3, #4
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 80052c2:	f042 0210 	orr.w	r2, r2, #16
 80052c6:	7782      	strb	r2, [r0, #30]
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 80052c8:	d009      	beq.n	80052de <tcp_close+0x2e>
 80052ca:	2b07      	cmp	r3, #7
 80052cc:	d007      	beq.n	80052de <tcp_close+0x2e>
      }
      return ERR_OK;
    }
  }

  switch (pcb->state) {
 80052ce:	2b07      	cmp	r3, #7
 80052d0:	d86e      	bhi.n	80053b0 <tcp_close+0x100>
 80052d2:	e8df f003 	tbb	[pc, r3]
 80052d6:	6d84      	.short	0x6d84
 80052d8:	6d646470 	.word	0x6d646470
 80052dc:	7c6d      	.short	0x7c6d
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 80052de:	6f62      	ldr	r2, [r4, #116]	; 0x74
 80052e0:	2a00      	cmp	r2, #0
 80052e2:	f000 80a6 	beq.w	8005432 <tcp_close+0x182>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 80052e6:	8ba2      	ldrh	r2, [r4, #28]
 80052e8:	8b63      	ldrh	r3, [r4, #26]
 80052ea:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80052ec:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80052ee:	9201      	str	r2, [sp, #4]
 80052f0:	9300      	str	r3, [sp, #0]
 80052f2:	4622      	mov	r2, r4
 80052f4:	1d23      	adds	r3, r4, #4
 80052f6:	f001 fd13 	bl	8006d20 <tcp_rst>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 80052fa:	7e21      	ldrb	r1, [r4, #24]
 80052fc:	2901      	cmp	r1, #1
 80052fe:	d92e      	bls.n	800535e <tcp_close+0xae>
 8005300:	290a      	cmp	r1, #10
 8005302:	d02c      	beq.n	800535e <tcp_close+0xae>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8005304:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005306:	b118      	cbz	r0, 8005310 <tcp_close+0x60>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8005308:	f7fe ff46 	bl	8004198 <pbuf_free>
      pcb->refused_data = NULL;
 800530c:	2300      	movs	r3, #0
 800530e:	6763      	str	r3, [r4, #116]	; 0x74

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
 8005310:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8005312:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005316:	86a3      	strh	r3, [r4, #52]	; 0x34
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8005318:	b165      	cbz	r5, 8005334 <tcp_close+0x84>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 800531a:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800531c:	682e      	ldr	r6, [r5, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 800531e:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8005320:	b10b      	cbz	r3, 8005326 <tcp_close+0x76>
      pbuf_free(seg->p);
 8005322:	f7fe ff39 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8005326:	4629      	mov	r1, r5
 8005328:	2004      	movs	r0, #4
 800532a:	f7fe fc89 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800532e:	4635      	mov	r5, r6
 8005330:	2e00      	cmp	r6, #0
 8005332:	d1f2      	bne.n	800531a <tcp_close+0x6a>
    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
 8005334:	6f25      	ldr	r5, [r4, #112]	; 0x70
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8005336:	b165      	cbz	r5, 8005352 <tcp_close+0xa2>
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 8005338:	686b      	ldr	r3, [r5, #4]
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800533a:	682e      	ldr	r6, [r5, #0]
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
      pbuf_free(seg->p);
 800533c:	4618      	mov	r0, r3
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
    if (seg->p != NULL) {
 800533e:	b10b      	cbz	r3, 8005344 <tcp_close+0x94>
      pbuf_free(seg->p);
 8005340:	f7fe ff2a 	bl	8004198 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8005344:	4629      	mov	r1, r5
 8005346:	2004      	movs	r0, #4
 8005348:	f7fe fc7a 	bl	8003c40 <memp_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800534c:	4635      	mov	r5, r6
 800534e:	2e00      	cmp	r6, #0
 8005350:	d1f2      	bne.n	8005338 <tcp_close+0x88>
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 8005352:	2300      	movs	r3, #0
 8005354:	7e21      	ldrb	r1, [r4, #24]
 8005356:	66e3      	str	r3, [r4, #108]	; 0x6c
 8005358:	6723      	str	r3, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 800535a:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800535e:	4b44      	ldr	r3, [pc, #272]	; (8005470 <tcp_close+0x1c0>)
 8005360:	681a      	ldr	r2, [r3, #0]
 8005362:	4294      	cmp	r4, r2
 8005364:	d077      	beq.n	8005456 <tcp_close+0x1a6>
 8005366:	4843      	ldr	r0, [pc, #268]	; (8005474 <tcp_close+0x1c4>)
 8005368:	6002      	str	r2, [r0, #0]
 800536a:	b152      	cbz	r2, 8005382 <tcp_close+0xd2>
 800536c:	68d3      	ldr	r3, [r2, #12]
 800536e:	429c      	cmp	r4, r3
 8005370:	d074      	beq.n	800545c <tcp_close+0x1ac>
 8005372:	b12b      	cbz	r3, 8005380 <tcp_close+0xd0>
 8005374:	68da      	ldr	r2, [r3, #12]
 8005376:	4294      	cmp	r4, r2
 8005378:	d057      	beq.n	800542a <tcp_close+0x17a>
 800537a:	4613      	mov	r3, r2
 800537c:	2b00      	cmp	r3, #0
 800537e:	d1f9      	bne.n	8005374 <tcp_close+0xc4>
 8005380:	6003      	str	r3, [r0, #0]
 8005382:	4b3d      	ldr	r3, [pc, #244]	; (8005478 <tcp_close+0x1c8>)
 8005384:	2201      	movs	r2, #1
 8005386:	2500      	movs	r5, #0
      if (pcb->state == ESTABLISHED) {
 8005388:	2904      	cmp	r1, #4
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800538a:	701a      	strb	r2, [r3, #0]
 800538c:	60e5      	str	r5, [r4, #12]
      if (pcb->state == ESTABLISHED) {
 800538e:	d057      	beq.n	8005440 <tcp_close+0x190>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
 8005390:	4621      	mov	r1, r4
 8005392:	2002      	movs	r0, #2
 8005394:	f7fe fc54 	bl	8003c40 <memp_free>
      }
      return ERR_OK;
 8005398:	4628      	mov	r0, r5
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
}
 800539a:	b002      	add	sp, #8
 800539c:	bd70      	pop	{r4, r5, r6, pc}
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
 800539e:	4620      	mov	r0, r4
 80053a0:	f000 ff9e 	bl	80062e0 <tcp_send_fin>
    if (err == ERR_OK) {
 80053a4:	b928      	cbnz	r0, 80053b2 <tcp_close+0x102>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
 80053a6:	2305      	movs	r3, #5
 80053a8:	7623      	strb	r3, [r4, #24]
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
 80053aa:	4620      	mov	r0, r4
 80053ac:	f001 fb6a 	bl	8006a84 <tcp_output>
 80053b0:	2000      	movs	r0, #0
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
}
 80053b2:	b002      	add	sp, #8
 80053b4:	bd70      	pop	{r4, r5, r6, pc}
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 80053b6:	4621      	mov	r1, r4
 80053b8:	482d      	ldr	r0, [pc, #180]	; (8005470 <tcp_close+0x1c0>)
 80053ba:	f7ff fbad 	bl	8004b18 <tcp_pcb_remove>
 80053be:	4b2e      	ldr	r3, [pc, #184]	; (8005478 <tcp_close+0x1c8>)
 80053c0:	2201      	movs	r2, #1
    memp_free(MEMP_TCP_PCB, pcb);
 80053c2:	4621      	mov	r1, r4
 80053c4:	2002      	movs	r0, #2
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 80053c6:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 80053c8:	f7fe fc3a 	bl	8003c40 <memp_free>
 80053cc:	e7f0      	b.n	80053b0 <tcp_close+0x100>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
 80053ce:	4620      	mov	r0, r4
 80053d0:	f000 ff86 	bl	80062e0 <tcp_send_fin>
    if (err == ERR_OK) {
 80053d4:	2800      	cmp	r0, #0
 80053d6:	d1ec      	bne.n	80053b2 <tcp_close+0x102>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
 80053d8:	2309      	movs	r3, #9
 80053da:	7623      	strb	r3, [r4, #24]
 80053dc:	e7e5      	b.n	80053aa <tcp_close+0xfa>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
 80053de:	8b63      	ldrh	r3, [r4, #26]
 80053e0:	b1ab      	cbz	r3, 800540e <tcp_close+0x15e>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 80053e2:	4b26      	ldr	r3, [pc, #152]	; (800547c <tcp_close+0x1cc>)
 80053e4:	681a      	ldr	r2, [r3, #0]
 80053e6:	4294      	cmp	r4, r2
 80053e8:	d03e      	beq.n	8005468 <tcp_close+0x1b8>
 80053ea:	4822      	ldr	r0, [pc, #136]	; (8005474 <tcp_close+0x1c4>)
 80053ec:	6002      	str	r2, [r0, #0]
 80053ee:	b162      	cbz	r2, 800540a <tcp_close+0x15a>
 80053f0:	68d3      	ldr	r3, [r2, #12]
 80053f2:	429c      	cmp	r4, r3
 80053f4:	d006      	beq.n	8005404 <tcp_close+0x154>
 80053f6:	2b00      	cmp	r3, #0
 80053f8:	d032      	beq.n	8005460 <tcp_close+0x1b0>
 80053fa:	68da      	ldr	r2, [r3, #12]
 80053fc:	4294      	cmp	r4, r2
 80053fe:	d031      	beq.n	8005464 <tcp_close+0x1b4>
 8005400:	4613      	mov	r3, r2
 8005402:	e7f8      	b.n	80053f6 <tcp_close+0x146>
 8005404:	4613      	mov	r3, r2
 8005406:	68e2      	ldr	r2, [r4, #12]
 8005408:	60da      	str	r2, [r3, #12]
 800540a:	2300      	movs	r3, #0
 800540c:	60e3      	str	r3, [r4, #12]
    }
    memp_free(MEMP_TCP_PCB, pcb);
 800540e:	4621      	mov	r1, r4
 8005410:	2002      	movs	r0, #2
 8005412:	f7fe fc15 	bl	8003c40 <memp_free>
 8005416:	e7cb      	b.n	80053b0 <tcp_close+0x100>
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8005418:	4601      	mov	r1, r0
 800541a:	4819      	ldr	r0, [pc, #100]	; (8005480 <tcp_close+0x1d0>)
 800541c:	f7ff fb7c 	bl	8004b18 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8005420:	4621      	mov	r1, r4
 8005422:	2003      	movs	r0, #3
 8005424:	f7fe fc0c 	bl	8003c40 <memp_free>
 8005428:	e7c2      	b.n	80053b0 <tcp_close+0x100>
 800542a:	6003      	str	r3, [r0, #0]
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800542c:	68e2      	ldr	r2, [r4, #12]
 800542e:	60da      	str	r2, [r3, #12]
 8005430:	e7a7      	b.n	8005382 <tcp_close+0xd2>
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8005432:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 8005434:	f640 3268 	movw	r2, #2920	; 0xb68
 8005438:	4291      	cmp	r1, r2
 800543a:	f47f af54 	bne.w	80052e6 <tcp_close+0x36>
 800543e:	e746      	b.n	80052ce <tcp_close+0x1e>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
 8005440:	4b10      	ldr	r3, [pc, #64]	; (8005484 <tcp_close+0x1d4>)

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 8005442:	220a      	movs	r2, #10
        TCP_REG(&tcp_tw_pcbs, pcb);
 8005444:	6819      	ldr	r1, [r3, #0]
 8005446:	60e1      	str	r1, [r4, #12]

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 8005448:	7622      	strb	r2, [r4, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800544a:	601c      	str	r4, [r3, #0]
 800544c:	f001 fdf0 	bl	8007030 <tcp_timer_needed>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
      }
      return ERR_OK;
 8005450:	4628      	mov	r0, r5
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
}
 8005452:	b002      	add	sp, #8
 8005454:	bd70      	pop	{r4, r5, r6, pc}
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8005456:	68e2      	ldr	r2, [r4, #12]
 8005458:	601a      	str	r2, [r3, #0]
 800545a:	e792      	b.n	8005382 <tcp_close+0xd2>
 800545c:	4613      	mov	r3, r2
 800545e:	e7e5      	b.n	800542c <tcp_close+0x17c>
 8005460:	6003      	str	r3, [r0, #0]
 8005462:	e7d2      	b.n	800540a <tcp_close+0x15a>
 8005464:	6003      	str	r3, [r0, #0]
 8005466:	e7ce      	b.n	8005406 <tcp_close+0x156>
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8005468:	68e2      	ldr	r2, [r4, #12]
 800546a:	601a      	str	r2, [r3, #0]
 800546c:	e7cd      	b.n	800540a <tcp_close+0x15a>
 800546e:	bf00      	nop
 8005470:	20005748 	.word	0x20005748
 8005474:	20005754 	.word	0x20005754
 8005478:	20005744 	.word	0x20005744
 800547c:	20005758 	.word	0x20005758
 8005480:	20005750 	.word	0x20005750
 8005484:	2000575c 	.word	0x2000575c

08005488 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
 8005488:	b510      	push	{r4, lr}
 800548a:	4604      	mov	r4, r0
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 800548c:	4608      	mov	r0, r1
 800548e:	f7fb fd51 	bl	8000f34 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
 8005492:	b130      	cbz	r0, 80054a2 <tcp_eff_send_mss+0x1a>
 8005494:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 8005496:	b123      	cbz	r3, 80054a2 <tcp_eff_send_mss+0x1a>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 8005498:	3b28      	subs	r3, #40	; 0x28
 800549a:	b29b      	uxth	r3, r3
 800549c:	429c      	cmp	r4, r3
 800549e:	bf28      	it	cs
 80054a0:	461c      	movcs	r4, r3
  }
  return sendmss;
}
 80054a2:	4620      	mov	r0, r4
 80054a4:	bd10      	pop	{r4, pc}
 80054a6:	bf00      	nop

080054a8 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 80054a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
 80054ac:	4bbd      	ldr	r3, [pc, #756]	; (80057a4 <tcp_receive+0x2fc>)
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80054ae:	f8df 8304 	ldr.w	r8, [pc, #772]	; 80057b4 <tcp_receive+0x30c>
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
 80054b2:	781b      	ldrb	r3, [r3, #0]
 80054b4:	06dd      	lsls	r5, r3, #27
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 80054b6:	4604      	mov	r4, r0
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
 80054b8:	d41b      	bmi.n	80054f2 <tcp_receive+0x4a>
 80054ba:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 80057b8 <tcp_receive+0x310>

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 80054be:	f8b9 3000 	ldrh.w	r3, [r9]
 80054c2:	b113      	cbz	r3, 80054ca <tcp_receive+0x22>
 80054c4:	7e22      	ldrb	r2, [r4, #24]
 80054c6:	2a06      	cmp	r2, #6
 80054c8:	d97d      	bls.n	80055c6 <tcp_receive+0x11e>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 80054ca:	f8d8 3000 	ldr.w	r3, [r8]
 80054ce:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80054d0:	1a5a      	subs	r2, r3, r1
 80054d2:	2a00      	cmp	r2, #0
 80054d4:	db05      	blt.n	80054e2 <tcp_receive+0x3a>
 80054d6:	1c5a      	adds	r2, r3, #1
 80054d8:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 80054da:	1a53      	subs	r3, r2, r1
 80054dc:	1a1b      	subs	r3, r3, r0
 80054de:	2b00      	cmp	r3, #0
 80054e0:	dd05      	ble.n	80054ee <tcp_receive+0x46>
      tcp_ack_now(pcb);
 80054e2:	7fa3      	ldrb	r3, [r4, #30]
 80054e4:	f043 0302 	orr.w	r3, r3, #2
 80054e8:	77a3      	strb	r3, [r4, #30]
    }
  }
}
 80054ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80054ee:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80054f2:	6d43      	ldr	r3, [r0, #84]	; 0x54
 80054f4:	f8d8 2000 	ldr.w	r2, [r8]
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 80054f8:	f8b0 5060 	ldrh.w	r5, [r0, #96]	; 0x60
 80054fc:	6d80      	ldr	r0, [r0, #88]	; 0x58

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80054fe:	1a99      	subs	r1, r3, r2
 8005500:	2900      	cmp	r1, #0
 8005502:	f2c0 80aa 	blt.w	800565a <tcp_receive+0x1b2>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8005506:	4ea8      	ldr	r6, [pc, #672]	; (80057a8 <tcp_receive+0x300>)

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 8005508:	4293      	cmp	r3, r2
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800550a:	6833      	ldr	r3, [r6, #0]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800550c:	f000 815d 	beq.w	80057ca <tcp_receive+0x322>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8005510:	4298      	cmp	r0, r3
 8005512:	f000 8162 	beq.w	80057da <tcp_receive+0x332>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 8005516:	4629      	mov	r1, r5
 8005518:	4686      	mov	lr, r0
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800551a:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 800551c:	1bda      	subs	r2, r3, r7
 800551e:	2a00      	cmp	r2, #0
 8005520:	f340 812b 	ble.w	800577a <tcp_receive+0x2d2>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 8005524:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8005526:	1a59      	subs	r1, r3, r1
 8005528:	2900      	cmp	r1, #0
 800552a:	f340 80b4 	ble.w	8005696 <tcp_receive+0x1ee>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
 800552e:	2300      	movs	r3, #0
 8005530:	f8df 9284 	ldr.w	r9, [pc, #644]	; 80057b8 <tcp_receive+0x310>
 8005534:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 8005538:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800553a:	2b00      	cmp	r3, #0
 800553c:	d063      	beq.n	8005606 <tcp_receive+0x15e>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800553e:	4f9a      	ldr	r7, [pc, #616]	; (80057a8 <tcp_receive+0x300>)
 8005540:	e00d      	b.n	800555e <tcp_receive+0xb6>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
        pcb->acked--;
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
 8005542:	6868      	ldr	r0, [r5, #4]
 8005544:	f7fe fe56 	bl	80041f4 <pbuf_clen>
 8005548:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800554c:	1a18      	subs	r0, r3, r0
 800554e:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
      tcp_seg_free(next);
 8005552:	4628      	mov	r0, r5
 8005554:	f7ff fa88 	bl	8004a68 <tcp_seg_free>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 8005558:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800555a:	2b00      	cmp	r3, #0
 800555c:	d053      	beq.n	8005606 <tcp_receive+0x15e>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800555e:	68db      	ldr	r3, [r3, #12]
 8005560:	6835      	ldr	r5, [r6, #0]
 8005562:	6858      	ldr	r0, [r3, #4]
 8005564:	f7fc f98c 	bl	8001880 <lwip_ntohl>
 8005568:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800556a:	68da      	ldr	r2, [r3, #12]
 800556c:	f8b3 a008 	ldrh.w	sl, [r3, #8]
 8005570:	4683      	mov	fp, r0
 8005572:	8990      	ldrh	r0, [r2, #12]
 8005574:	f7fc f97e 	bl	8001874 <lwip_ntohs>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 8005578:	f010 0003 	ands.w	r0, r0, #3
 800557c:	bf18      	it	ne
 800557e:	2001      	movne	r0, #1
 8005580:	ebcb 0505 	rsb	r5, fp, r5
 8005584:	4482      	add	sl, r0
 8005586:	ebca 0505 	rsb	r5, sl, r5
 800558a:	2d00      	cmp	r5, #0
 800558c:	db3b      	blt.n	8005606 <tcp_receive+0x15e>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800558e:	683b      	ldr	r3, [r7, #0]
 8005590:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8005592:	1a9b      	subs	r3, r3, r2
 8005594:	2b00      	cmp	r3, #0
 8005596:	dc36      	bgt.n	8005606 <tcp_receive+0x15e>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
 8005598:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      pcb->unsent = pcb->unsent->next;
 800559a:	682b      	ldr	r3, [r5, #0]
 800559c:	66e3      	str	r3, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 800559e:	b37b      	cbz	r3, 8005600 <tcp_receive+0x158>
        pcb->unsent_oversize = 0;
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 80055a0:	6868      	ldr	r0, [r5, #4]
 80055a2:	f7fe fe27 	bl	80041f4 <pbuf_clen>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 80055a6:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 80055aa:	2b00      	cmp	r3, #0
 80055ac:	d0c9      	beq.n	8005542 <tcp_receive+0x9a>
 80055ae:	68eb      	ldr	r3, [r5, #12]
 80055b0:	8998      	ldrh	r0, [r3, #12]
 80055b2:	f7fc f95f 	bl	8001874 <lwip_ntohs>
 80055b6:	07c3      	lsls	r3, r0, #31
 80055b8:	d5c3      	bpl.n	8005542 <tcp_receive+0x9a>
        pcb->acked--;
 80055ba:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 80055be:	3b01      	subs	r3, #1
 80055c0:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 80055c4:	e7bd      	b.n	8005542 <tcp_receive+0x9a>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 80055c6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80055c8:	f8d8 1000 	ldr.w	r1, [r8]
 80055cc:	1a55      	subs	r5, r2, r1
 80055ce:	2d01      	cmp	r5, #1
 80055d0:	d405      	bmi.n	80055de <tcp_receive+0x136>
 80055d2:	1c50      	adds	r0, r2, #1
 80055d4:	1a40      	subs	r0, r0, r1
 80055d6:	1ac3      	subs	r3, r0, r3
 80055d8:	2b00      	cmp	r3, #0
 80055da:	f340 8116 	ble.w	800580a <tcp_receive+0x362>
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 80055de:	1a8b      	subs	r3, r1, r2
 80055e0:	2b00      	cmp	r3, #0
 80055e2:	f2c0 808c 	blt.w	80056fe <tcp_receive+0x256>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 80055e6:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 80055e8:	f1c3 0301 	rsb	r3, r3, #1
 80055ec:	440b      	add	r3, r1
 80055ee:	1a9b      	subs	r3, r3, r2
 80055f0:	2b00      	cmp	r3, #0
 80055f2:	f340 8104 	ble.w	80057fe <tcp_receive+0x356>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 80055f6:	4620      	mov	r0, r4
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
 80055f8:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 80055fc:	f001 b9fa 	b.w	80069f4 <tcp_send_empty_ack>

      next = pcb->unsent;
      pcb->unsent = pcb->unsent->next;
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
        pcb->unsent_oversize = 0;
 8005600:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
 8005604:	e7cc      	b.n	80055a0 <tcp_receive+0xf8>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 8005606:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005608:	2b00      	cmp	r3, #0
 800560a:	f43f af58 	beq.w	80054be <tcp_receive+0x16>
 800560e:	6831      	ldr	r1, [r6, #0]
 8005610:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8005612:	1a52      	subs	r2, r2, r1
 8005614:	2a00      	cmp	r2, #0
 8005616:	f6bf af52 	bge.w	80054be <tcp_receive+0x16>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800561a:	4964      	ldr	r1, [pc, #400]	; (80057ac <tcp_receive+0x304>)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 800561c:	f9b4 2040 	ldrsh.w	r2, [r4, #64]	; 0x40
 8005620:	6809      	ldr	r1, [r1, #0]
 8005622:	1ac9      	subs	r1, r1, r3
 8005624:	eba1 01e2 	sub.w	r1, r1, r2, asr #3
 8005628:	b289      	uxth	r1, r1
      pcb->sa += m;
 800562a:	188b      	adds	r3, r1, r2

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 800562c:	b20a      	sxth	r2, r1
      pcb->sa += m;
      if (m < 0) {
 800562e:	2a00      	cmp	r2, #0
        m = -m;
 8005630:	bfbc      	itt	lt
 8005632:	4249      	neglt	r1, r1
 8005634:	b20a      	sxthlt	r2, r1
      }
      m = m - (pcb->sv >> 2);
 8005636:	f9b4 1042 	ldrsh.w	r1, [r4, #66]	; 0x42
      pcb->sv += m;
 800563a:	eba1 01a1 	sub.w	r1, r1, r1, asr #2
 800563e:	440a      	add	r2, r1
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
 8005640:	b21b      	sxth	r3, r3
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
 8005642:	b292      	uxth	r2, r2
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
 8005644:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 8005648:	2100      	movs	r1, #0
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800564a:	eb02 03e3 	add.w	r3, r2, r3, asr #3
 800564e:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
      pcb->sa += m;
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
 8005652:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 8005656:	63a1      	str	r1, [r4, #56]	; 0x38
 8005658:	e731      	b.n	80054be <tcp_receive+0x16>
 800565a:	4b55      	ldr	r3, [pc, #340]	; (80057b0 <tcp_receive+0x308>)
 800565c:	4e52      	ldr	r6, [pc, #328]	; (80057a8 <tcp_receive+0x300>)
 800565e:	6819      	ldr	r1, [r3, #0]
 8005660:	6833      	ldr	r3, [r6, #0]
 8005662:	89c9      	ldrh	r1, [r1, #14]
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 8005664:	f8b4 7062 	ldrh.w	r7, [r4, #98]	; 0x62
        pcb->snd_wnd_max = tcphdr->wnd;
      }
      pcb->snd_wl1 = seqno;
 8005668:	6562      	str	r2, [r4, #84]	; 0x54
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 800566a:	428f      	cmp	r7, r1

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
 800566c:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
        pcb->snd_wnd_max = tcphdr->wnd;
 8005670:	bf38      	it	cc
 8005672:	f8a4 1062 	strhcc.w	r1, [r4, #98]	; 0x62
      }
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
 8005676:	65a3      	str	r3, [r4, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
        if (pcb->persist_backoff == 0) {
 8005678:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
      if (pcb->snd_wnd_max < tcphdr->wnd) {
        pcb->snd_wnd_max = tcphdr->wnd;
      }
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
      if (pcb->snd_wnd == 0) {
 800567c:	2900      	cmp	r1, #0
 800567e:	f040 809d 	bne.w	80057bc <tcp_receive+0x314>
        if (pcb->persist_backoff == 0) {
 8005682:	2a00      	cmp	r2, #0
 8005684:	f040 808b 	bne.w	800579e <tcp_receive+0x2f6>
          /* start persist timer */
          pcb->persist_cnt = 0;
          pcb->persist_backoff = 1;
 8005688:	2201      	movs	r2, #1
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
      if (pcb->snd_wnd == 0) {
        if (pcb->persist_backoff == 0) {
          /* start persist timer */
          pcb->persist_cnt = 0;
 800568a:	f884 1090 	strb.w	r1, [r4, #144]	; 0x90
          pcb->persist_backoff = 1;
 800568e:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
 8005692:	469e      	mov	lr, r3
 8005694:	e741      	b.n	800551a <tcp_receive+0x72>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 8005696:	7fa1      	ldrb	r1, [r4, #30]
 8005698:	0748      	lsls	r0, r1, #29
 800569a:	d506      	bpl.n	80056aa <tcp_receive+0x202>
        pcb->flags &= ~TF_INFR;
 800569c:	f021 0104 	bic.w	r1, r1, #4
        pcb->cwnd = pcb->ssthresh;
 80056a0:	f8b4 004e 	ldrh.w	r0, [r4, #78]	; 0x4e

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
        pcb->flags &= ~TF_INFR;
 80056a4:	77a1      	strb	r1, [r4, #30]
        pcb->cwnd = pcb->ssthresh;
 80056a6:	f8a4 004c 	strh.w	r0, [r4, #76]	; 0x4c
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
 80056aa:	f8b4 0066 	ldrh.w	r0, [r4, #102]	; 0x66

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80056ae:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
 80056b2:	f9b4 7040 	ldrsh.w	r7, [r4, #64]	; 0x40
      pcb->dupacks = 0;
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 80056b6:	7e25      	ldrb	r5, [r4, #24]

      pcb->snd_buf += pcb->acked;

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
      pcb->lastack = ackno;
 80056b8:	64a3      	str	r3, [r4, #72]	; 0x48

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 80056ba:	b292      	uxth	r2, r2

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80056bc:	eb01 03e7 	add.w	r3, r1, r7, asr #3

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 80056c0:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 80056c4:	2100      	movs	r1, #0
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
 80056c6:	4402      	add	r2, r0
      pcb->dupacks = 0;
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 80056c8:	2d03      	cmp	r5, #3
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
 80056ca:	f8a4 2066 	strh.w	r2, [r4, #102]	; 0x66

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80056ce:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 80056d2:	f884 1046 	strb.w	r1, [r4, #70]	; 0x46
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 80056d6:	f884 1047 	strb.w	r1, [r4, #71]	; 0x47
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 80056da:	d92b      	bls.n	8005734 <tcp_receive+0x28c>
        if (pcb->cwnd < pcb->ssthresh) {
 80056dc:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 80056e0:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 80056e4:	4293      	cmp	r3, r2
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 80056e6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 80056e8:	bf9c      	itt	ls
 80056ea:	435b      	mulls	r3, r3
 80056ec:	fb93 f3f2 	sdivls	r3, r3, r2
 80056f0:	4413      	add	r3, r2
 80056f2:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 80056f4:	429a      	cmp	r2, r3
 80056f6:	d21d      	bcs.n	8005734 <tcp_receive+0x28c>
            pcb->cwnd = new_cwnd;
 80056f8:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 80056fc:	e01a      	b.n	8005734 <tcp_receive+0x28c>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 80056fe:	7fa3      	ldrb	r3, [r4, #30]
 8005700:	f043 0302 	orr.w	r3, r3, #2
 8005704:	77a3      	strb	r3, [r4, #30]
 8005706:	e776      	b.n	80055f6 <tcp_receive+0x14e>
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 8005708:	68eb      	ldr	r3, [r5, #12]
 800570a:	8998      	ldrh	r0, [r3, #12]
 800570c:	f7fc f8b2 	bl	8001874 <lwip_ntohs>
 8005710:	07c2      	lsls	r2, r0, #31
 8005712:	d504      	bpl.n	800571e <tcp_receive+0x276>
          pcb->acked--;
 8005714:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8005718:	3b01      	subs	r3, #1
 800571a:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
 800571e:	6868      	ldr	r0, [r5, #4]
 8005720:	f7fe fd68 	bl	80041f4 <pbuf_clen>
 8005724:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8005728:	1a18      	subs	r0, r3, r0
 800572a:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
        tcp_seg_free(next);
 800572e:	4628      	mov	r0, r5
 8005730:	f7ff f99a 	bl	8004a68 <tcp_seg_free>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 8005734:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8005736:	2b00      	cmp	r3, #0
 8005738:	d057      	beq.n	80057ea <tcp_receive+0x342>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 800573a:	68db      	ldr	r3, [r3, #12]
 800573c:	6858      	ldr	r0, [r3, #4]
 800573e:	f7fc f89f 	bl	8001880 <lwip_ntohl>
 8005742:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8005744:	68da      	ldr	r2, [r3, #12]
 8005746:	891f      	ldrh	r7, [r3, #8]
 8005748:	4605      	mov	r5, r0
 800574a:	8990      	ldrh	r0, [r2, #12]
 800574c:	f7fc f892 	bl	8001874 <lwip_ntohs>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 8005750:	6833      	ldr	r3, [r6, #0]
 8005752:	f010 0003 	ands.w	r0, r0, #3
 8005756:	bf18      	it	ne
 8005758:	2001      	movne	r0, #1
 800575a:	4407      	add	r7, r0
 800575c:	1aed      	subs	r5, r5, r3
 800575e:	443d      	add	r5, r7
 8005760:	2d00      	cmp	r5, #0
 8005762:	dc41      	bgt.n	80057e8 <tcp_receive+0x340>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
 8005764:	6f25      	ldr	r5, [r4, #112]	; 0x70
        pcb->unacked = pcb->unacked->next;
 8005766:	682b      	ldr	r3, [r5, #0]
 8005768:	6723      	str	r3, [r4, #112]	; 0x70

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800576a:	6868      	ldr	r0, [r5, #4]
 800576c:	f7fe fd42 	bl	80041f4 <pbuf_clen>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 8005770:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8005774:	2b00      	cmp	r3, #0
 8005776:	d0d2      	beq.n	800571e <tcp_receive+0x276>
 8005778:	e7c6      	b.n	8005708 <tcp_receive+0x260>

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
      /* Clause 2 */
      if (tcplen == 0) {
 800577a:	f8df 903c 	ldr.w	r9, [pc, #60]	; 80057b8 <tcp_receive+0x310>
 800577e:	f8b9 2000 	ldrh.w	r2, [r9]
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
 8005782:	f04f 0c00 	mov.w	ip, #0
 8005786:	f8a4 c064 	strh.w	ip, [r4, #100]	; 0x64
      /* Clause 2 */
      if (tcplen == 0) {
 800578a:	b922      	cbnz	r2, 8005796 <tcp_receive+0x2ee>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 800578c:	4428      	add	r0, r5
 800578e:	4471      	add	r1, lr
 8005790:	4288      	cmp	r0, r1
 8005792:	f000 809d 	beq.w	80058d0 <tcp_receive+0x428>
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
 8005796:	2300      	movs	r3, #0
 8005798:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
 800579c:	e6cc      	b.n	8005538 <tcp_receive+0x90>
 800579e:	469e      	mov	lr, r3
 80057a0:	e6bb      	b.n	800551a <tcp_receive+0x72>
 80057a2:	bf00      	nop
 80057a4:	2000298c 	.word	0x2000298c
 80057a8:	20002988 	.word	0x20002988
 80057ac:	2000574c 	.word	0x2000574c
 80057b0:	20002990 	.word	0x20002990
 80057b4:	20002980 	.word	0x20002980
 80057b8:	20002984 	.word	0x20002984
        if (pcb->persist_backoff == 0) {
          /* start persist timer */
          pcb->persist_cnt = 0;
          pcb->persist_backoff = 1;
        }
      } else if (pcb->persist_backoff > 0) {
 80057bc:	2a00      	cmp	r2, #0
 80057be:	d0ee      	beq.n	800579e <tcp_receive+0x2f6>
        /* stop persist timer */
          pcb->persist_backoff = 0;
 80057c0:	2200      	movs	r2, #0
 80057c2:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
 80057c6:	469e      	mov	lr, r3
 80057c8:	e6a7      	b.n	800551a <tcp_receive+0x72>
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 80057ca:	1ac1      	subs	r1, r0, r3
 80057cc:	2900      	cmp	r1, #0
 80057ce:	f6bf ae9f 	bge.w	8005510 <tcp_receive+0x68>
 80057d2:	496d      	ldr	r1, [pc, #436]	; (8005988 <tcp_receive+0x4e0>)
 80057d4:	6809      	ldr	r1, [r1, #0]
 80057d6:	89c9      	ldrh	r1, [r1, #14]
 80057d8:	e744      	b.n	8005664 <tcp_receive+0x1bc>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 80057da:	4b6b      	ldr	r3, [pc, #428]	; (8005988 <tcp_receive+0x4e0>)
 80057dc:	681b      	ldr	r3, [r3, #0]
 80057de:	89d9      	ldrh	r1, [r3, #14]
 80057e0:	428d      	cmp	r5, r1
 80057e2:	d271      	bcs.n	80058c8 <tcp_receive+0x420>
 80057e4:	4603      	mov	r3, r0
 80057e6:	e73d      	b.n	8005664 <tcp_receive+0x1bc>
 80057e8:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80057ea:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 8005998 <tcp_receive+0x4f0>
 80057ee:	fab3 f383 	clz	r3, r3
 80057f2:	095b      	lsrs	r3, r3, #5
 80057f4:	425b      	negs	r3, r3
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
      else
        pcb->rtime = 0;

      pcb->polltmr = 0;
 80057f6:	2200      	movs	r2, #0
 80057f8:	86a3      	strh	r3, [r4, #52]	; 0x34
 80057fa:	77e2      	strb	r2, [r4, #31]
 80057fc:	e69c      	b.n	8005538 <tcp_receive+0x90>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 80057fe:	428a      	cmp	r2, r1
 8005800:	f47f aef9 	bne.w	80055f6 <tcp_receive+0x14e>
 8005804:	4e61      	ldr	r6, [pc, #388]	; (800598c <tcp_receive+0x4e4>)
 8005806:	68f3      	ldr	r3, [r6, #12]
 8005808:	e026      	b.n	8005858 <tcp_receive+0x3b0>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
 800580a:	4e60      	ldr	r6, [pc, #384]	; (800598c <tcp_receive+0x4e4>)
 800580c:	6870      	ldr	r0, [r6, #4]
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
 800580e:	8942      	ldrh	r2, [r0, #10]
 8005810:	4295      	cmp	r5, r2

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
 8005812:	462b      	mov	r3, r5
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
 8005814:	dd7a      	ble.n	800590c <tcp_receive+0x464>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 8005816:	8901      	ldrh	r1, [r0, #8]
 8005818:	1b49      	subs	r1, r1, r5
 800581a:	b289      	uxth	r1, r1
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
 800581c:	2500      	movs	r5, #0
 800581e:	8145      	strh	r5, [r0, #10]
        while (p->len < off) {
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
 8005820:	8101      	strh	r1, [r0, #8]
          p->len = 0;
          p = p->next;
 8005822:	6800      	ldr	r0, [r0, #0]
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
          off -= p->len;
 8005824:	1a9b      	subs	r3, r3, r2
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 8005826:	8942      	ldrh	r2, [r0, #10]
 8005828:	429a      	cmp	r2, r3
 800582a:	dbf8      	blt.n	800581e <tcp_receive+0x376>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
 800582c:	4259      	negs	r1, r3
 800582e:	b209      	sxth	r1, r1
 8005830:	f7fe fc7c 	bl	800412c <pbuf_header>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 8005834:	f8d8 1000 	ldr.w	r1, [r8]
 8005838:	8933      	ldrh	r3, [r6, #8]
 800583a:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800583c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800583e:	f8c8 0000 	str.w	r0, [r8]
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 8005842:	440b      	add	r3, r1
 8005844:	f1c2 0201 	rsb	r2, r2, #1
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8005848:	68f1      	ldr	r1, [r6, #12]
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800584a:	1a1b      	subs	r3, r3, r0
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800584c:	2a00      	cmp	r2, #0
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800584e:	8133      	strh	r3, [r6, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8005850:	6048      	str	r0, [r1, #4]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 8005852:	f73f aed0 	bgt.w	80055f6 <tcp_receive+0x14e>
 8005856:	460b      	mov	r3, r1
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 8005858:	8998      	ldrh	r0, [r3, #12]
 800585a:	8937      	ldrh	r7, [r6, #8]
 800585c:	4d4b      	ldr	r5, [pc, #300]	; (800598c <tcp_receive+0x4e4>)
 800585e:	f7fc f809 	bl	8001874 <lwip_ntohs>
 8005862:	f010 0003 	ands.w	r0, r0, #3
 8005866:	bf18      	it	ne
 8005868:	2001      	movne	r0, #1
 800586a:	183b      	adds	r3, r7, r0

        if (tcplen > pcb->rcv_wnd) {
 800586c:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800586e:	b29b      	uxth	r3, r3

        if (tcplen > pcb->rcv_wnd) {
 8005870:	4293      	cmp	r3, r2
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 8005872:	f8a9 3000 	strh.w	r3, [r9]

        if (tcplen > pcb->rcv_wnd) {
 8005876:	d84e      	bhi.n	8005916 <tcp_receive+0x46e>
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 8005878:	f8d8 1000 	ldr.w	r1, [r8]

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 800587c:	1ad2      	subs	r2, r2, r3
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800587e:	440b      	add	r3, r1
 8005880:	62a3      	str	r3, [r4, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 8005882:	85a2      	strh	r2, [r4, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
 8005884:	4620      	mov	r0, r4
 8005886:	f7fe fe95 	bl	80045b4 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 800588a:	6873      	ldr	r3, [r6, #4]
 800588c:	493f      	ldr	r1, [pc, #252]	; (800598c <tcp_receive+0x4e4>)
 800588e:	891a      	ldrh	r2, [r3, #8]
 8005890:	b11a      	cbz	r2, 800589a <tcp_receive+0x3f2>
          recv_data = inseg.p;
 8005892:	483f      	ldr	r0, [pc, #252]	; (8005990 <tcp_receive+0x4e8>)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 8005894:	2200      	movs	r2, #0

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
          recv_data = inseg.p;
 8005896:	6003      	str	r3, [r0, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 8005898:	604a      	str	r2, [r1, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800589a:	68f3      	ldr	r3, [r6, #12]
 800589c:	8998      	ldrh	r0, [r3, #12]
 800589e:	f7fb ffe9 	bl	8001874 <lwip_ntohs>
 80058a2:	07c1      	lsls	r1, r0, #31
 80058a4:	d504      	bpl.n	80058b0 <tcp_receive+0x408>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 80058a6:	4a3b      	ldr	r2, [pc, #236]	; (8005994 <tcp_receive+0x4ec>)
 80058a8:	7813      	ldrb	r3, [r2, #0]
 80058aa:	f043 0320 	orr.w	r3, r3, #32
 80058ae:	7013      	strb	r3, [r2, #0]
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 80058b0:	7fa3      	ldrb	r3, [r4, #30]
 80058b2:	07da      	lsls	r2, r3, #31
 80058b4:	bf46      	itte	mi
 80058b6:	f023 0301 	bicmi.w	r3, r3, #1
 80058ba:	f043 0302 	orrmi.w	r3, r3, #2
 80058be:	f043 0301 	orrpl.w	r3, r3, #1
 80058c2:	77a3      	strb	r3, [r4, #30]
 80058c4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80058c8:	4629      	mov	r1, r5
 80058ca:	4686      	mov	lr, r0
 80058cc:	4603      	mov	r3, r0
 80058ce:	e624      	b.n	800551a <tcp_receive+0x72>
      /* Clause 2 */
      if (tcplen == 0) {
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 80058d0:	f9b4 2034 	ldrsh.w	r2, [r4, #52]	; 0x34
 80058d4:	4562      	cmp	r2, ip
 80058d6:	f6ff af5e 	blt.w	8005796 <tcp_receive+0x2ee>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 80058da:	429f      	cmp	r7, r3
 80058dc:	f47f af5b 	bne.w	8005796 <tcp_receive+0x2ee>
              found_dupack = 1;
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 80058e0:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 80058e4:	1c53      	adds	r3, r2, #1
 80058e6:	b2db      	uxtb	r3, r3
 80058e8:	429a      	cmp	r2, r3
                ++pcb->dupacks;
 80058ea:	bf3c      	itt	cc
 80058ec:	461a      	movcc	r2, r3
 80058ee:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
              }
              if (pcb->dupacks > 3) {
 80058f2:	2a03      	cmp	r2, #3
 80058f4:	d942      	bls.n	800597c <tcp_receive+0x4d4>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 80058f6:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 80058fa:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80058fc:	4413      	add	r3, r2
 80058fe:	b29b      	uxth	r3, r3
 8005900:	429a      	cmp	r2, r3
 8005902:	f4bf ae19 	bcs.w	8005538 <tcp_receive+0x90>
                  pcb->cwnd += pcb->mss;
 8005906:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800590a:	e615      	b.n	8005538 <tcp_receive+0x90>
        if(pbuf_header(p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 800590c:	4269      	negs	r1, r5
 800590e:	b209      	sxth	r1, r1
 8005910:	f7fe fc0c 	bl	800412c <pbuf_header>
 8005914:	e78e      	b.n	8005834 <tcp_receive+0x38c>
        if (tcplen > pcb->rcv_wnd) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8005916:	68eb      	ldr	r3, [r5, #12]
 8005918:	8998      	ldrh	r0, [r3, #12]
 800591a:	f7fb ffab 	bl	8001874 <lwip_ntohs>
 800591e:	07c7      	lsls	r7, r0, #31
 8005920:	d41e      	bmi.n	8005960 <tcp_receive+0x4b8>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 8005922:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8005924:	68f3      	ldr	r3, [r6, #12]
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 8005926:	8132      	strh	r2, [r6, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8005928:	8998      	ldrh	r0, [r3, #12]
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 800592a:	4d18      	ldr	r5, [pc, #96]	; (800598c <tcp_receive+0x4e4>)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800592c:	f7fb ffa2 	bl	8001874 <lwip_ntohs>
 8005930:	0780      	lsls	r0, r0, #30
            inseg.len -= 1;
 8005932:	8929      	ldrh	r1, [r5, #8]
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8005934:	d502      	bpl.n	800593c <tcp_receive+0x494>
            inseg.len -= 1;
 8005936:	3901      	subs	r1, #1
 8005938:	b289      	uxth	r1, r1
 800593a:	8129      	strh	r1, [r5, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
 800593c:	6870      	ldr	r0, [r6, #4]
 800593e:	f7fe fbab 	bl	8004098 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8005942:	68f3      	ldr	r3, [r6, #12]
 8005944:	8935      	ldrh	r5, [r6, #8]
 8005946:	8998      	ldrh	r0, [r3, #12]
 8005948:	f7fb ff94 	bl	8001874 <lwip_ntohs>
 800594c:	f010 0003 	ands.w	r0, r0, #3
 8005950:	bf18      	it	ne
 8005952:	2001      	movne	r0, #1
 8005954:	182b      	adds	r3, r5, r0
 8005956:	b29b      	uxth	r3, r3
 8005958:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800595a:	f8a9 3000 	strh.w	r3, [r9]
 800595e:	e78b      	b.n	8005878 <tcp_receive+0x3d0>
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 8005960:	68ef      	ldr	r7, [r5, #12]
 8005962:	89bd      	ldrh	r5, [r7, #12]
 8005964:	4628      	mov	r0, r5
 8005966:	f7fb ff85 	bl	8001874 <lwip_ntohs>
 800596a:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 800596e:	f7fb ff7d 	bl	800186c <lwip_htons>
 8005972:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8005976:	4328      	orrs	r0, r5
 8005978:	81b8      	strh	r0, [r7, #12]
 800597a:	e7d2      	b.n	8005922 <tcp_receive+0x47a>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
                  pcb->cwnd += pcb->mss;
                }
              } else if (pcb->dupacks == 3) {
 800597c:	f47f addc 	bne.w	8005538 <tcp_receive+0x90>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
 8005980:	4620      	mov	r0, r4
 8005982:	f001 fa55 	bl	8006e30 <tcp_rexmit_fast>
 8005986:	e5d7      	b.n	8005538 <tcp_receive+0x90>
 8005988:	20002990 	.word	0x20002990
 800598c:	20002998 	.word	0x20002998
 8005990:	20002994 	.word	0x20002994
 8005994:	2000298d 	.word	0x2000298d
 8005998:	20002984 	.word	0x20002984

0800599c <tcp_parseopt.isra.0>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
 800599c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 800599e:	4c22      	ldr	r4, [pc, #136]	; (8005a28 <tcp_parseopt.isra.0+0x8c>)
 80059a0:	6825      	ldr	r5, [r4, #0]
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
 80059a2:	4606      	mov	r6, r0
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 80059a4:	89a8      	ldrh	r0, [r5, #12]
 80059a6:	f7fb ff65 	bl	8001874 <lwip_ntohs>
 80059aa:	f3c0 300f 	ubfx	r0, r0, #12, #16
 80059ae:	2805      	cmp	r0, #5
 80059b0:	d800      	bhi.n	80059b4 <tcp_parseopt.isra.0+0x18>
 80059b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 80059b4:	6823      	ldr	r3, [r4, #0]
 80059b6:	8998      	ldrh	r0, [r3, #12]
 80059b8:	f7fb ff5c 	bl	8001874 <lwip_ntohs>
 80059bc:	0b00      	lsrs	r0, r0, #12
 80059be:	3805      	subs	r0, #5
 80059c0:	0080      	lsls	r0, r0, #2
 80059c2:	b280      	uxth	r0, r0
    for (c = 0; c < max_c; ) {
 80059c4:	2800      	cmp	r0, #0
 80059c6:	d0f4      	beq.n	80059b2 <tcp_parseopt.isra.0+0x16>
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 80059c8:	f105 0214 	add.w	r2, r5, #20
 80059cc:	2300      	movs	r3, #0
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 80059ce:	f240 57b3 	movw	r7, #1459	; 0x5b3
  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
      opt = opts[c];
      switch (opt) {
 80059d2:	5cd1      	ldrb	r1, [r2, r3]
 80059d4:	2901      	cmp	r1, #1
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 80059d6:	f240 55b4 	movw	r5, #1460	; 0x5b4
  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
      opt = opts[c];
      switch (opt) {
 80059da:	d01b      	beq.n	8005a14 <tcp_parseopt.isra.0+0x78>
 80059dc:	d3e9      	bcc.n	80059b2 <tcp_parseopt.isra.0+0x16>
 80059de:	2902      	cmp	r1, #2
 80059e0:	d11b      	bne.n	8005a1a <tcp_parseopt.isra.0+0x7e>
        ++c;
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 80059e2:	18d4      	adds	r4, r2, r3
 80059e4:	7861      	ldrb	r1, [r4, #1]
 80059e6:	2904      	cmp	r1, #4
 80059e8:	d1e3      	bne.n	80059b2 <tcp_parseopt.isra.0+0x16>
 80059ea:	1cd9      	adds	r1, r3, #3
 80059ec:	4281      	cmp	r1, r0
 80059ee:	dae0      	bge.n	80059b2 <tcp_parseopt.isra.0+0x16>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
 80059f0:	f894 e002 	ldrb.w	lr, [r4, #2]
 80059f4:	78e1      	ldrb	r1, [r4, #3]
 80059f6:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 80059fa:	1e4c      	subs	r4, r1, #1
 80059fc:	b2a4      	uxth	r4, r4
        /* Advance to next option */
        c += 0x04;
 80059fe:	3304      	adds	r3, #4
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8005a00:	42bc      	cmp	r4, r7
 8005a02:	bf88      	it	hi
 8005a04:	4629      	movhi	r1, r5
        /* Advance to next option */
        c += 0x04;
 8005a06:	b29b      	uxth	r3, r3
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8005a08:	8031      	strh	r1, [r6, #0]
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
 8005a0a:	4298      	cmp	r0, r3
 8005a0c:	d9d1      	bls.n	80059b2 <tcp_parseopt.isra.0+0x16>
      opt = opts[c];
      switch (opt) {
 8005a0e:	5cd1      	ldrb	r1, [r2, r3]
 8005a10:	2901      	cmp	r1, #1
 8005a12:	d1e3      	bne.n	80059dc <tcp_parseopt.isra.0+0x40>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
 8005a14:	3301      	adds	r3, #1
 8005a16:	b29b      	uxth	r3, r3
 8005a18:	e7f7      	b.n	8005a0a <tcp_parseopt.isra.0+0x6e>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 8005a1a:	18d1      	adds	r1, r2, r3
 8005a1c:	7849      	ldrb	r1, [r1, #1]
 8005a1e:	2900      	cmp	r1, #0
 8005a20:	d0c7      	beq.n	80059b2 <tcp_parseopt.isra.0+0x16>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 8005a22:	440b      	add	r3, r1
 8005a24:	b29b      	uxth	r3, r3
 8005a26:	e7f0      	b.n	8005a0a <tcp_parseopt.isra.0+0x6e>
 8005a28:	20002990 	.word	0x20002990

08005a2c <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8005a2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
 8005a30:	6843      	ldr	r3, [r0, #4]
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8005a32:	4da7      	ldr	r5, [pc, #668]	; (8005cd0 <tcp_input+0x2a4>)
 8005a34:	781a      	ldrb	r2, [r3, #0]
 8005a36:	f002 020f 	and.w	r2, r2, #15
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8005a3a:	0096      	lsls	r6, r2, #2
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8005a3c:	b087      	sub	sp, #28
 8005a3e:	4688      	mov	r8, r1

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8005a40:	eb03 0382 	add.w	r3, r3, r2, lsl #2
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8005a44:	4271      	negs	r1, r6
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8005a46:	4604      	mov	r4, r0

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8005a48:	602b      	str	r3, [r5, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8005a4a:	f7fe fb6f 	bl	800412c <pbuf_header>
 8005a4e:	b910      	cbnz	r0, 8005a56 <tcp_input+0x2a>
 8005a50:	8923      	ldrh	r3, [r4, #8]
 8005a52:	2b13      	cmp	r3, #19
 8005a54:	d805      	bhi.n	8005a62 <tcp_input+0x36>
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
 8005a56:	4620      	mov	r0, r4
}
 8005a58:	b007      	add	sp, #28
 8005a5a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
 8005a5e:	f7fe bb9b 	b.w	8004198 <pbuf_free>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 8005a62:	4f9c      	ldr	r7, [pc, #624]	; (8005cd4 <tcp_input+0x2a8>)
 8005a64:	4641      	mov	r1, r8
 8005a66:	6838      	ldr	r0, [r7, #0]
 8005a68:	f7fb fbdc 	bl	8001224 <ip4_addr_isbroadcast>
 8005a6c:	2800      	cmp	r0, #0
 8005a6e:	d1f2      	bne.n	8005a56 <tcp_input+0x2a>
 8005a70:	683b      	ldr	r3, [r7, #0]
 8005a72:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8005a76:	2be0      	cmp	r3, #224	; 0xe0
 8005a78:	d0ed      	beq.n	8005a56 <tcp_input+0x2a>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
 8005a7a:	682b      	ldr	r3, [r5, #0]
 8005a7c:	8998      	ldrh	r0, [r3, #12]
 8005a7e:	f7fb fef9 	bl	8001874 <lwip_ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
 8005a82:	0b00      	lsrs	r0, r0, #12
 8005a84:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
 8005a88:	0081      	lsls	r1, r0, #2
 8005a8a:	b209      	sxth	r1, r1
 8005a8c:	4620      	mov	r0, r4
 8005a8e:	f7fe fb4d 	bl	800412c <pbuf_header>
 8005a92:	4606      	mov	r6, r0
 8005a94:	2800      	cmp	r0, #0
 8005a96:	d1de      	bne.n	8005a56 <tcp_input+0x2a>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 8005a98:	f8d5 9000 	ldr.w	r9, [r5]
 8005a9c:	f8b9 0000 	ldrh.w	r0, [r9]
 8005aa0:	f7fb fee8 	bl	8001874 <lwip_ntohs>
  tcphdr->dest = ntohs(tcphdr->dest);
 8005aa4:	f8d5 a000 	ldr.w	sl, [r5]
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 8005aa8:	f8a9 0000 	strh.w	r0, [r9]
  tcphdr->dest = ntohs(tcphdr->dest);
 8005aac:	f8ba 0002 	ldrh.w	r0, [sl, #2]
 8005ab0:	f7fb fee0 	bl	8001874 <lwip_ntohs>
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8005ab4:	f8d5 9000 	ldr.w	r9, [r5]
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
 8005ab8:	f8aa 0002 	strh.w	r0, [sl, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8005abc:	f8d9 0004 	ldr.w	r0, [r9, #4]
 8005ac0:	f7fb fede 	bl	8001880 <lwip_ntohl>
 8005ac4:	4b84      	ldr	r3, [pc, #528]	; (8005cd8 <tcp_input+0x2ac>)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8005ac6:	f8d5 a000 	ldr.w	sl, [r5]
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8005aca:	f8c9 0004 	str.w	r0, [r9, #4]
 8005ace:	6018      	str	r0, [r3, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8005ad0:	f8da 0008 	ldr.w	r0, [sl, #8]
 8005ad4:	f7fb fed4 	bl	8001880 <lwip_ntohl>
 8005ad8:	4b80      	ldr	r3, [pc, #512]	; (8005cdc <tcp_input+0x2b0>)
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8005ada:	f8d5 9000 	ldr.w	r9, [r5]

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8005ade:	6018      	str	r0, [r3, #0]
 8005ae0:	f8ca 0008 	str.w	r0, [sl, #8]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8005ae4:	f8b9 000e 	ldrh.w	r0, [r9, #14]
 8005ae8:	f7fb fec4 	bl	8001874 <lwip_ntohs>

  flags = TCPH_FLAGS(tcphdr);
 8005aec:	682b      	ldr	r3, [r5, #0]
  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8005aee:	f8a9 000e 	strh.w	r0, [r9, #14]

  flags = TCPH_FLAGS(tcphdr);
 8005af2:	8998      	ldrh	r0, [r3, #12]
 8005af4:	f7fb febe 	bl	8001874 <lwip_ntohs>
 8005af8:	fa5f fe80 	uxtb.w	lr, r0
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8005afc:	f01e 0303 	ands.w	r3, lr, #3
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8005b00:	4a77      	ldr	r2, [pc, #476]	; (8005ce0 <tcp_input+0x2b4>)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8005b02:	f8b4 8008 	ldrh.w	r8, [r4, #8]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8005b06:	f8d2 9000 	ldr.w	r9, [r2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8005b0a:	4a76      	ldr	r2, [pc, #472]	; (8005ce4 <tcp_input+0x2b8>)
 8005b0c:	bf18      	it	ne
 8005b0e:	2301      	movne	r3, #1
 8005b10:	4443      	add	r3, r8
 8005b12:	b29b      	uxth	r3, r3
 8005b14:	9304      	str	r3, [sp, #16]
 8005b16:	8013      	strh	r3, [r2, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
 8005b18:	4b73      	ldr	r3, [pc, #460]	; (8005ce8 <tcp_input+0x2bc>)
 8005b1a:	f00e 013f 	and.w	r1, lr, #63	; 0x3f
 8005b1e:	7019      	strb	r1, [r3, #0]
 8005b20:	682b      	ldr	r3, [r5, #0]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8005b22:	f1b9 0f00 	cmp.w	r9, #0
 8005b26:	d07e      	beq.n	8005c26 <tcp_input+0x1fa>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8005b28:	4a70      	ldr	r2, [pc, #448]	; (8005cec <tcp_input+0x2c0>)
 8005b2a:	f8b3 c000 	ldrh.w	ip, [r3]
 8005b2e:	f8d2 a000 	ldr.w	sl, [r2]
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 8005b32:	683a      	ldr	r2, [r7, #0]
 8005b34:	9203      	str	r2, [sp, #12]
 8005b36:	4630      	mov	r0, r6
 8005b38:	9105      	str	r1, [sp, #20]
 8005b3a:	464e      	mov	r6, r9
 8005b3c:	e004      	b.n	8005b48 <tcp_input+0x11c>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8005b3e:	68f2      	ldr	r2, [r6, #12]
 8005b40:	4630      	mov	r0, r6
 8005b42:	2a00      	cmp	r2, #0
 8005b44:	d06f      	beq.n	8005c26 <tcp_input+0x1fa>
 8005b46:	4616      	mov	r6, r2
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 8005b48:	8bb2      	ldrh	r2, [r6, #28]
 8005b4a:	4562      	cmp	r2, ip
 8005b4c:	d1f7      	bne.n	8005b3e <tcp_input+0x112>
 8005b4e:	f8b6 b01a 	ldrh.w	fp, [r6, #26]
 8005b52:	885a      	ldrh	r2, [r3, #2]
 8005b54:	4593      	cmp	fp, r2
 8005b56:	d1f2      	bne.n	8005b3e <tcp_input+0x112>
       pcb->local_port == tcphdr->dest &&
 8005b58:	6872      	ldr	r2, [r6, #4]
 8005b5a:	4552      	cmp	r2, sl
 8005b5c:	d1ef      	bne.n	8005b3e <tcp_input+0x112>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8005b5e:	6831      	ldr	r1, [r6, #0]
 8005b60:	9a03      	ldr	r2, [sp, #12]
 8005b62:	4291      	cmp	r1, r2
 8005b64:	d1eb      	bne.n	8005b3e <tcp_input+0x112>
 8005b66:	9905      	ldr	r1, [sp, #20]

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
 8005b68:	b128      	cbz	r0, 8005b76 <tcp_input+0x14a>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
 8005b6a:	4f5d      	ldr	r7, [pc, #372]	; (8005ce0 <tcp_input+0x2b4>)
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
        prev->next = pcb->next;
 8005b6c:	68f2      	ldr	r2, [r6, #12]
 8005b6e:	60c2      	str	r2, [r0, #12]
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
 8005b70:	603e      	str	r6, [r7, #0]
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
 8005b72:	f8c6 900c 	str.w	r9, [r6, #12]
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 8005b76:	4f5e      	ldr	r7, [pc, #376]	; (8005cf0 <tcp_input+0x2c4>)
    inseg.len = p->tot_len;
    inseg.p = p;
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
 8005b78:	f8df 9180 	ldr.w	r9, [pc, #384]	; 8005cfc <tcp_input+0x2d0>
    recv_flags = 0;
 8005b7c:	f8df a180 	ldr.w	sl, [pc, #384]	; 8005d00 <tcp_input+0x2d4>
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
 8005b80:	f8a7 8008 	strh.w	r8, [r7, #8]
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 8005b84:	2200      	movs	r2, #0
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
    recv_flags = 0;

    if (flags & TCP_PSH) {
 8005b86:	f01e 0f08 	tst.w	lr, #8
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
    inseg.p = p;
 8005b8a:	607c      	str	r4, [r7, #4]
    inseg.tcphdr = tcphdr;
 8005b8c:	60fb      	str	r3, [r7, #12]
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 8005b8e:	603a      	str	r2, [r7, #0]
    inseg.len = p->tot_len;
    inseg.p = p;
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
 8005b90:	f8c9 2000 	str.w	r2, [r9]
    recv_flags = 0;
 8005b94:	f88a 2000 	strb.w	r2, [sl]

    if (flags & TCP_PSH) {
 8005b98:	d003      	beq.n	8005ba2 <tcp_input+0x176>
      p->flags |= PBUF_FLAG_PUSH;
 8005b9a:	7b63      	ldrb	r3, [r4, #13]
 8005b9c:	f043 0301 	orr.w	r3, r3, #1
 8005ba0:	7363      	strb	r3, [r4, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 8005ba2:	6f73      	ldr	r3, [r6, #116]	; 0x74
 8005ba4:	b163      	cbz	r3, 8005bc0 <tcp_input+0x194>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 8005ba6:	4630      	mov	r0, r6
 8005ba8:	f7ff f94a 	bl	8004e40 <tcp_process_refused_data>
 8005bac:	300a      	adds	r0, #10
 8005bae:	d072      	beq.n	8005c96 <tcp_input+0x26a>
 8005bb0:	6f73      	ldr	r3, [r6, #116]	; 0x74
 8005bb2:	b11b      	cbz	r3, 8005bbc <tcp_input+0x190>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 8005bb4:	4b4b      	ldr	r3, [pc, #300]	; (8005ce4 <tcp_input+0x2b8>)
 8005bb6:	881b      	ldrh	r3, [r3, #0]
 8005bb8:	2b00      	cmp	r3, #0
 8005bba:	d16c      	bne.n	8005c96 <tcp_input+0x26a>
 8005bbc:	4b4a      	ldr	r3, [pc, #296]	; (8005ce8 <tcp_input+0x2bc>)
 8005bbe:	7819      	ldrb	r1, [r3, #0]
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
 8005bc0:	4c4c      	ldr	r4, [pc, #304]	; (8005cf4 <tcp_input+0x2c8>)
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 8005bc2:	0748      	lsls	r0, r1, #29
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
 8005bc4:	6026      	str	r6, [r4, #0]
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 8005bc6:	d568      	bpl.n	8005c9a <tcp_input+0x26e>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 8005bc8:	7e33      	ldrb	r3, [r6, #24]
 8005bca:	2b02      	cmp	r3, #2
 8005bcc:	f000 8271 	beq.w	80060b2 <tcp_input+0x686>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 8005bd0:	4b41      	ldr	r3, [pc, #260]	; (8005cd8 <tcp_input+0x2ac>)
 8005bd2:	6ab2      	ldr	r2, [r6, #40]	; 0x28
 8005bd4:	681b      	ldr	r3, [r3, #0]
 8005bd6:	1a9b      	subs	r3, r3, r2
 8005bd8:	d404      	bmi.n	8005be4 <tcp_input+0x1b8>
 8005bda:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8005bdc:	1a9b      	subs	r3, r3, r2
 8005bde:	2b00      	cmp	r3, #0
 8005be0:	f340 826d 	ble.w	80060be <tcp_input+0x692>
    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
 8005be4:	f89a 3000 	ldrb.w	r3, [sl]
 8005be8:	071d      	lsls	r5, r3, #28
 8005bea:	f140 8115 	bpl.w	8005e18 <tcp_input+0x3ec>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 8005bee:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 8005bf2:	b11b      	cbz	r3, 8005bfc <tcp_input+0x1d0>
 8005bf4:	f06f 010a 	mvn.w	r1, #10
 8005bf8:	6930      	ldr	r0, [r6, #16]
 8005bfa:	4798      	blx	r3
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8005bfc:	4631      	mov	r1, r6
 8005bfe:	4838      	ldr	r0, [pc, #224]	; (8005ce0 <tcp_input+0x2b4>)
 8005c00:	f7fe ff8a 	bl	8004b18 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 8005c04:	4631      	mov	r1, r6
 8005c06:	2002      	movs	r0, #2
 8005c08:	f7fe f81a 	bl	8003c40 <memp_free>
aborted:
    tcp_input_pcb = NULL;
    recv_data = NULL;

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 8005c0c:	6878      	ldr	r0, [r7, #4]
 8005c0e:	4e38      	ldr	r6, [pc, #224]	; (8005cf0 <tcp_input+0x2c4>)
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
 8005c10:	2500      	movs	r5, #0
 8005c12:	6025      	str	r5, [r4, #0]
    recv_data = NULL;
 8005c14:	f8c9 5000 	str.w	r5, [r9]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 8005c18:	b110      	cbz	r0, 8005c20 <tcp_input+0x1f4>
    {
      pbuf_free(inseg.p);
 8005c1a:	f7fe fabd 	bl	8004198 <pbuf_free>
      inseg.p = NULL;
 8005c1e:	6075      	str	r5, [r6, #4]
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
 8005c20:	b007      	add	sp, #28
 8005c22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8005c26:	4a34      	ldr	r2, [pc, #208]	; (8005cf8 <tcp_input+0x2cc>)
 8005c28:	6810      	ldr	r0, [r2, #0]
 8005c2a:	2800      	cmp	r0, #0
 8005c2c:	d042      	beq.n	8005cb4 <tcp_input+0x288>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8005c2e:	4a2f      	ldr	r2, [pc, #188]	; (8005cec <tcp_input+0x2c0>)
 8005c30:	881e      	ldrh	r6, [r3, #0]
 8005c32:	f8d2 8000 	ldr.w	r8, [r2]
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 8005c36:	f8d7 c000 	ldr.w	ip, [r7]
 8005c3a:	e002      	b.n	8005c42 <tcp_input+0x216>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8005c3c:	68c0      	ldr	r0, [r0, #12]
 8005c3e:	2800      	cmp	r0, #0
 8005c40:	d038      	beq.n	8005cb4 <tcp_input+0x288>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 8005c42:	8b82      	ldrh	r2, [r0, #28]
 8005c44:	42b2      	cmp	r2, r6
 8005c46:	d1f9      	bne.n	8005c3c <tcp_input+0x210>
         pcb->local_port == tcphdr->dest &&
 8005c48:	8b42      	ldrh	r2, [r0, #26]
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 8005c4a:	8859      	ldrh	r1, [r3, #2]
 8005c4c:	4291      	cmp	r1, r2
 8005c4e:	d1f5      	bne.n	8005c3c <tcp_input+0x210>
         pcb->local_port == tcphdr->dest &&
 8005c50:	6842      	ldr	r2, [r0, #4]
 8005c52:	4542      	cmp	r2, r8
 8005c54:	d1f2      	bne.n	8005c3c <tcp_input+0x210>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8005c56:	6802      	ldr	r2, [r0, #0]
 8005c58:	4562      	cmp	r2, ip
 8005c5a:	d1ef      	bne.n	8005c3c <tcp_input+0x210>
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
 8005c5c:	f01e 0f04 	tst.w	lr, #4
 8005c60:	f47f aef9 	bne.w	8005a56 <tcp_input+0x2a>
    return ERR_OK;
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 8005c64:	f01e 0f02 	tst.w	lr, #2
 8005c68:	f000 8318 	beq.w	800629c <tcp_input+0x870>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 8005c6c:	4b1a      	ldr	r3, [pc, #104]	; (8005cd8 <tcp_input+0x2ac>)
 8005c6e:	681a      	ldr	r2, [r3, #0]
 8005c70:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8005c72:	1ad3      	subs	r3, r2, r3
 8005c74:	d404      	bmi.n	8005c80 <tcp_input+0x254>
 8005c76:	8d85      	ldrh	r5, [r0, #44]	; 0x2c
 8005c78:	1b5b      	subs	r3, r3, r5
 8005c7a:	2b00      	cmp	r3, #0
 8005c7c:	f340 8316 	ble.w	80062ac <tcp_input+0x880>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
  }

  if ((tcplen > 0))  {
 8005c80:	9b04      	ldr	r3, [sp, #16]
 8005c82:	2b00      	cmp	r3, #0
 8005c84:	f43f aee7 	beq.w	8005a56 <tcp_input+0x2a>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
 8005c88:	7f83      	ldrb	r3, [r0, #30]
 8005c8a:	f043 0302 	orr.w	r3, r3, #2
 8005c8e:	7783      	strb	r3, [r0, #30]
    return tcp_output(pcb);
 8005c90:	f000 fef8 	bl	8006a84 <tcp_output>
 8005c94:	e6df      	b.n	8005a56 <tcp_input+0x2a>
 8005c96:	4c17      	ldr	r4, [pc, #92]	; (8005cf4 <tcp_input+0x2c8>)
 8005c98:	e7b8      	b.n	8005c0c <tcp_input+0x1e0>
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 8005c9a:	0789      	lsls	r1, r1, #30
 8005c9c:	f140 80cd 	bpl.w	8005e3a <tcp_input+0x40e>
 8005ca0:	7e33      	ldrb	r3, [r6, #24]
 8005ca2:	3b02      	subs	r3, #2
 8005ca4:	2b01      	cmp	r3, #1
 8005ca6:	f240 80c8 	bls.w	8005e3a <tcp_input+0x40e>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
 8005caa:	7fb3      	ldrb	r3, [r6, #30]
 8005cac:	f043 0302 	orr.w	r3, r3, #2
 8005cb0:	77b3      	strb	r3, [r6, #30]
 8005cb2:	e797      	b.n	8005be4 <tcp_input+0x1b8>
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8005cb4:	f8df c04c 	ldr.w	ip, [pc, #76]	; 8005d04 <tcp_input+0x2d8>
 8005cb8:	f8dc 9000 	ldr.w	r9, [ip]
 8005cbc:	f1b9 0f00 	cmp.w	r9, #0
 8005cc0:	f000 81e0 	beq.w	8006084 <tcp_input+0x658>
 8005cc4:	8858      	ldrh	r0, [r3, #2]
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 8005cc6:	683e      	ldr	r6, [r7, #0]
 8005cc8:	46c8      	mov	r8, r9
 8005cca:	2100      	movs	r1, #0
 8005ccc:	e023      	b.n	8005d16 <tcp_input+0x2ea>
 8005cce:	bf00      	nop
 8005cd0:	20002990 	.word	0x20002990
 8005cd4:	20002eec 	.word	0x20002eec
 8005cd8:	20002980 	.word	0x20002980
 8005cdc:	20002988 	.word	0x20002988
 8005ce0:	20005748 	.word	0x20005748
 8005ce4:	20002984 	.word	0x20002984
 8005ce8:	2000298c 	.word	0x2000298c
 8005cec:	20002ee4 	.word	0x20002ee4
 8005cf0:	20002998 	.word	0x20002998
 8005cf4:	20005760 	.word	0x20005760
 8005cf8:	2000575c 	.word	0x2000575c
 8005cfc:	20002994 	.word	0x20002994
 8005d00:	2000298d 	.word	0x2000298d
 8005d04:	20005750 	.word	0x20005750
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8005d08:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8005d0c:	4641      	mov	r1, r8
 8005d0e:	2a00      	cmp	r2, #0
 8005d10:	f000 81b8 	beq.w	8006084 <tcp_input+0x658>
 8005d14:	4690      	mov	r8, r2
      if (lpcb->local_port == tcphdr->dest) {
 8005d16:	f8b8 201a 	ldrh.w	r2, [r8, #26]
 8005d1a:	4282      	cmp	r2, r0
 8005d1c:	d1f4      	bne.n	8005d08 <tcp_input+0x2dc>
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 8005d1e:	f8d8 2000 	ldr.w	r2, [r8]
 8005d22:	42b2      	cmp	r2, r6
 8005d24:	d001      	beq.n	8005d2a <tcp_input+0x2fe>
            ip_addr_isany(&(lpcb->local_ip))) {
 8005d26:	2a00      	cmp	r2, #0
 8005d28:	d1ee      	bne.n	8005d08 <tcp_input+0x2dc>
#endif /* SO_REUSE */
    if (lpcb != NULL) {
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 8005d2a:	b131      	cbz	r1, 8005d3a <tcp_input+0x30e>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 8005d2c:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8005d30:	60ca      	str	r2, [r1, #12]
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 8005d32:	f8cc 8000 	str.w	r8, [ip]
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 8005d36:	f8c8 900c 	str.w	r9, [r8, #12]
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
 8005d3a:	f01e 0f04 	tst.w	lr, #4
 8005d3e:	f47f ae8a 	bne.w	8005a56 <tcp_input+0x2a>
    return ERR_OK;
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 8005d42:	f00e 0210 	and.w	r2, lr, #16
 8005d46:	f002 06ff 	and.w	r6, r2, #255	; 0xff
 8005d4a:	2a00      	cmp	r2, #0
 8005d4c:	f040 81c2 	bne.w	80060d4 <tcp_input+0x6a8>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
 8005d50:	f01e 0f02 	tst.w	lr, #2
 8005d54:	f43f ae7f 	beq.w	8005a56 <tcp_input+0x2a>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 8005d58:	f898 0019 	ldrb.w	r0, [r8, #25]
 8005d5c:	f7ff f986 	bl	800506c <tcp_alloc>
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 8005d60:	4681      	mov	r9, r0
 8005d62:	2800      	cmp	r0, #0
 8005d64:	f43f ae77 	beq.w	8005a56 <tcp_input+0x2a>
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 8005d68:	6828      	ldr	r0, [r5, #0]
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 8005d6a:	4ba1      	ldr	r3, [pc, #644]	; (8005ff0 <tcp_input+0x5c4>)
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 8005d6c:	f890 e001 	ldrb.w	lr, [r0, #1]
 8005d70:	7805      	ldrb	r5, [r0, #0]
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 8005d72:	4aa0      	ldr	r2, [pc, #640]	; (8005ff4 <tcp_input+0x5c8>)
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 8005d74:	681b      	ldr	r3, [r3, #0]
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 8005d76:	6839      	ldr	r1, [r7, #0]
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 8005d78:	6812      	ldr	r2, [r2, #0]
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 8005d7a:	f8c9 1000 	str.w	r1, [r9]
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 8005d7e:	ea45 210e 	orr.w	r1, r5, lr, lsl #8
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
 8005d82:	f8b8 501a 	ldrh.w	r5, [r8, #26]
 8005d86:	f8a9 501a 	strh.w	r5, [r9, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 8005d8a:	f8a9 101c 	strh.w	r1, [r9, #28]
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 8005d8e:	1c5d      	adds	r5, r3, #1
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
 8005d90:	2103      	movs	r1, #3
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 8005d92:	f8c9 2004 	str.w	r2, [r9, #4]
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
 8005d96:	f889 1018 	strb.w	r1, [r9, #24]
    npcb->rcv_nxt = seqno + 1;
 8005d9a:	f8c9 5028 	str.w	r5, [r9, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 8005d9e:	f8c9 5030 	str.w	r5, [r9, #48]	; 0x30
    npcb->snd_wnd = tcphdr->wnd;
 8005da2:	89c0      	ldrh	r0, [r0, #14]
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    npcb->callback_arg = pcb->callback_arg;
 8005da4:	f8d8 1010 	ldr.w	r1, [r8, #16]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 8005da8:	f8d8 2014 	ldr.w	r2, [r8, #20]
 8005dac:	f8c9 2014 	str.w	r2, [r9, #20]
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 8005db0:	3b01      	subs	r3, #1
    npcb->callback_arg = pcb->callback_arg;
 8005db2:	f8c9 1010 	str.w	r1, [r9, #16]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
 8005db6:	f8a9 0060 	strh.w	r0, [r9, #96]	; 0x60
    npcb->snd_wnd_max = tcphdr->wnd;
 8005dba:	f8a9 0062 	strh.w	r0, [r9, #98]	; 0x62
    npcb->ssthresh = npcb->snd_wnd;
 8005dbe:	f8a9 004e 	strh.w	r0, [r9, #78]	; 0x4e
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 8005dc2:	f8c9 3054 	str.w	r3, [r9, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8005dc6:	f898 3008 	ldrb.w	r3, [r8, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 8005dca:	4a8b      	ldr	r2, [pc, #556]	; (8005ff8 <tcp_input+0x5cc>)
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8005dcc:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 8005dd0:	6812      	ldr	r2, [r2, #0]
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8005dd2:	f889 3008 	strb.w	r3, [r9, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 8005dd6:	4b88      	ldr	r3, [pc, #544]	; (8005ff8 <tcp_input+0x5cc>)
 8005dd8:	f8c9 200c 	str.w	r2, [r9, #12]
 8005ddc:	f8c3 9000 	str.w	r9, [r3]
 8005de0:	f001 f926 	bl	8007030 <tcp_timer_needed>
 8005de4:	4b85      	ldr	r3, [pc, #532]	; (8005ffc <tcp_input+0x5d0>)
 8005de6:	2201      	movs	r2, #1

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 8005de8:	f109 0036 	add.w	r0, r9, #54	; 0x36
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 8005dec:	701a      	strb	r2, [r3, #0]

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 8005dee:	f7ff fdd5 	bl	800599c <tcp_parseopt.isra.0>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 8005df2:	f109 0104 	add.w	r1, r9, #4
 8005df6:	f8b9 0036 	ldrh.w	r0, [r9, #54]	; 0x36
 8005dfa:	f7ff fb45 	bl	8005488 <tcp_eff_send_mss>
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 8005dfe:	2112      	movs	r1, #18
    TCP_REG_ACTIVE(npcb);

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 8005e00:	f8a9 0036 	strh.w	r0, [r9, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 8005e04:	4648      	mov	r0, r9
 8005e06:	f000 fd4d 	bl	80068a4 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 8005e0a:	2800      	cmp	r0, #0
 8005e0c:	f040 8178 	bne.w	8006100 <tcp_input+0x6d4>
      tcp_abandon(npcb, 0);
      return rc;
    }
    return tcp_output(npcb);
 8005e10:	4648      	mov	r0, r9
 8005e12:	f000 fe37 	bl	8006a84 <tcp_output>
 8005e16:	e61e      	b.n	8005a56 <tcp_input+0x2a>
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else if (recv_flags & TF_CLOSED) {
 8005e18:	06d8      	lsls	r0, r3, #27
 8005e1a:	f140 80ff 	bpl.w	800601c <tcp_input+0x5f0>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
 8005e1e:	7fb3      	ldrb	r3, [r6, #30]
 8005e20:	06d9      	lsls	r1, r3, #27
 8005e22:	f53f aeeb 	bmi.w	8005bfc <tcp_input+0x1d0>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 8005e26:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 8005e2a:	2b00      	cmp	r3, #0
 8005e2c:	f43f aee6 	beq.w	8005bfc <tcp_input+0x1d0>
 8005e30:	f06f 010b 	mvn.w	r1, #11
 8005e34:	6930      	ldr	r0, [r6, #16]
 8005e36:	4798      	blx	r3
 8005e38:	e6e0      	b.n	8005bfc <tcp_input+0x1d0>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    return ERR_OK;
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 8005e3a:	7fb3      	ldrb	r3, [r6, #30]
 8005e3c:	06da      	lsls	r2, r3, #27
 8005e3e:	d402      	bmi.n	8005e46 <tcp_input+0x41a>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 8005e40:	4b6f      	ldr	r3, [pc, #444]	; (8006000 <tcp_input+0x5d4>)
 8005e42:	681b      	ldr	r3, [r3, #0]
 8005e44:	6273      	str	r3, [r6, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
 8005e46:	2300      	movs	r3, #0
 8005e48:	f886 3092 	strb.w	r3, [r6, #146]	; 0x92

  tcp_parseopt(pcb);
 8005e4c:	f106 0036 	add.w	r0, r6, #54	; 0x36
 8005e50:	f7ff fda4 	bl	800599c <tcp_parseopt.isra.0>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 8005e54:	7e33      	ldrb	r3, [r6, #24]
 8005e56:	3b02      	subs	r3, #2
 8005e58:	2b07      	cmp	r3, #7
 8005e5a:	f63f aec3 	bhi.w	8005be4 <tcp_input+0x1b8>
 8005e5e:	e8df f003 	tbb	[pc, r3]
 8005e62:	81a0      	.short	0x81a0
 8005e64:	b73867b7 	.word	0xb73867b7
 8005e68:	0419      	.short	0x0419
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
 8005e6a:	4630      	mov	r0, r6
 8005e6c:	f7ff fb1c 	bl	80054a8 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8005e70:	4b64      	ldr	r3, [pc, #400]	; (8006004 <tcp_input+0x5d8>)
 8005e72:	781b      	ldrb	r3, [r3, #0]
 8005e74:	06db      	lsls	r3, r3, #27
 8005e76:	f57f aeb5 	bpl.w	8005be4 <tcp_input+0x1b8>
 8005e7a:	4b63      	ldr	r3, [pc, #396]	; (8006008 <tcp_input+0x5dc>)
 8005e7c:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8005e7e:	681b      	ldr	r3, [r3, #0]
 8005e80:	429a      	cmp	r2, r3
 8005e82:	f47f aeaf 	bne.w	8005be4 <tcp_input+0x1b8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
 8005e86:	f89a 3000 	ldrb.w	r3, [sl]
 8005e8a:	f043 0310 	orr.w	r3, r3, #16
 8005e8e:	f88a 3000 	strb.w	r3, [sl]
 8005e92:	e6a7      	b.n	8005be4 <tcp_input+0x1b8>
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
 8005e94:	4630      	mov	r0, r6
 8005e96:	f7ff fb07 	bl	80054a8 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8005e9a:	4b5a      	ldr	r3, [pc, #360]	; (8006004 <tcp_input+0x5d8>)
 8005e9c:	781b      	ldrb	r3, [r3, #0]
 8005e9e:	06da      	lsls	r2, r3, #27
 8005ea0:	f57f aea0 	bpl.w	8005be4 <tcp_input+0x1b8>
 8005ea4:	4b58      	ldr	r3, [pc, #352]	; (8006008 <tcp_input+0x5dc>)
 8005ea6:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8005ea8:	681b      	ldr	r3, [r3, #0]
 8005eaa:	429a      	cmp	r2, r3
 8005eac:	f47f ae9a 	bne.w	8005be4 <tcp_input+0x1b8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
 8005eb0:	4630      	mov	r0, r6
 8005eb2:	f7fe fdfb 	bl	8004aac <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8005eb6:	4b50      	ldr	r3, [pc, #320]	; (8005ff8 <tcp_input+0x5cc>)
 8005eb8:	681a      	ldr	r2, [r3, #0]
 8005eba:	42b2      	cmp	r2, r6
 8005ebc:	f000 8157 	beq.w	800616e <tcp_input+0x742>
 8005ec0:	4b52      	ldr	r3, [pc, #328]	; (800600c <tcp_input+0x5e0>)
 8005ec2:	601a      	str	r2, [r3, #0]
 8005ec4:	b33a      	cbz	r2, 8005f16 <tcp_input+0x4ea>
 8005ec6:	68d1      	ldr	r1, [r2, #12]
 8005ec8:	42b1      	cmp	r1, r6
 8005eca:	f000 8191 	beq.w	80061f0 <tcp_input+0x7c4>
 8005ece:	460a      	mov	r2, r1
 8005ed0:	e7f8      	b.n	8005ec4 <tcp_input+0x498>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
 8005ed2:	4630      	mov	r0, r6
 8005ed4:	f7ff fae8 	bl	80054a8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8005ed8:	f89a 3000 	ldrb.w	r3, [sl]
 8005edc:	0699      	lsls	r1, r3, #26
 8005ede:	f57f ae81 	bpl.w	8005be4 <tcp_input+0x1b8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 8005ee2:	7fb3      	ldrb	r3, [r6, #30]
 8005ee4:	f043 0302 	orr.w	r3, r3, #2
 8005ee8:	77b3      	strb	r3, [r6, #30]
      tcp_pcb_purge(pcb);
 8005eea:	4630      	mov	r0, r6
 8005eec:	f7fe fdde 	bl	8004aac <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8005ef0:	4b41      	ldr	r3, [pc, #260]	; (8005ff8 <tcp_input+0x5cc>)
 8005ef2:	681a      	ldr	r2, [r3, #0]
 8005ef4:	42b2      	cmp	r2, r6
 8005ef6:	f000 813a 	beq.w	800616e <tcp_input+0x742>
 8005efa:	4b44      	ldr	r3, [pc, #272]	; (800600c <tcp_input+0x5e0>)
 8005efc:	601a      	str	r2, [r3, #0]
 8005efe:	b15a      	cbz	r2, 8005f18 <tcp_input+0x4ec>
 8005f00:	68d1      	ldr	r1, [r2, #12]
 8005f02:	42b1      	cmp	r1, r6
 8005f04:	d104      	bne.n	8005f10 <tcp_input+0x4e4>
 8005f06:	e158      	b.n	80061ba <tcp_input+0x78e>
 8005f08:	68d1      	ldr	r1, [r2, #12]
 8005f0a:	42b1      	cmp	r1, r6
 8005f0c:	f000 8154 	beq.w	80061b8 <tcp_input+0x78c>
 8005f10:	460a      	mov	r2, r1
 8005f12:	2900      	cmp	r1, #0
 8005f14:	d1f8      	bne.n	8005f08 <tcp_input+0x4dc>
 8005f16:	601a      	str	r2, [r3, #0]
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 8005f18:	4b3d      	ldr	r3, [pc, #244]	; (8006010 <tcp_input+0x5e4>)
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8005f1a:	4a38      	ldr	r2, [pc, #224]	; (8005ffc <tcp_input+0x5d0>)
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 8005f1c:	6819      	ldr	r1, [r3, #0]
 8005f1e:	60f1      	str	r1, [r6, #12]
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
 8005f20:	210a      	movs	r1, #10
 8005f22:	7631      	strb	r1, [r6, #24]
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8005f24:	2101      	movs	r1, #1
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 8005f26:	601e      	str	r6, [r3, #0]
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8005f28:	7011      	strb	r1, [r2, #0]
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 8005f2a:	f001 f881 	bl	8007030 <tcp_timer_needed>
 8005f2e:	e659      	b.n	8005be4 <tcp_input+0x1b8>
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
 8005f30:	4630      	mov	r0, r6
 8005f32:	f7ff fab9 	bl	80054a8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8005f36:	f89a 3000 	ldrb.w	r3, [sl]
 8005f3a:	f013 0f20 	tst.w	r3, #32
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8005f3e:	4b31      	ldr	r3, [pc, #196]	; (8006004 <tcp_input+0x5d8>)
 8005f40:	781b      	ldrb	r3, [r3, #0]
      pcb->state = CLOSE_WAIT;
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
 8005f42:	f000 80fa 	beq.w	800613a <tcp_input+0x70e>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8005f46:	06dd      	lsls	r5, r3, #27
 8005f48:	d505      	bpl.n	8005f56 <tcp_input+0x52a>
 8005f4a:	4b2f      	ldr	r3, [pc, #188]	; (8006008 <tcp_input+0x5dc>)
 8005f4c:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8005f4e:	681b      	ldr	r3, [r3, #0]
 8005f50:	429a      	cmp	r2, r3
 8005f52:	f000 810f 	beq.w	8006174 <tcp_input+0x748>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 8005f56:	7fb3      	ldrb	r3, [r6, #30]
        pcb->state = CLOSING;
 8005f58:	2208      	movs	r2, #8
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 8005f5a:	f043 0302 	orr.w	r3, r3, #2
 8005f5e:	77b3      	strb	r3, [r6, #30]
        pcb->state = CLOSING;
 8005f60:	7632      	strb	r2, [r6, #24]
 8005f62:	e63f      	b.n	8005be4 <tcp_input+0x1b8>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
 8005f64:	4b27      	ldr	r3, [pc, #156]	; (8006004 <tcp_input+0x5d8>)
 8005f66:	781b      	ldrb	r3, [r3, #0]
 8005f68:	06d8      	lsls	r0, r3, #27
 8005f6a:	f140 80f2 	bpl.w	8006152 <tcp_input+0x726>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8005f6e:	4a26      	ldr	r2, [pc, #152]	; (8006008 <tcp_input+0x5dc>)
 8005f70:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8005f72:	6810      	ldr	r0, [r2, #0]
 8005f74:	43db      	mvns	r3, r3
 8005f76:	42c3      	cmn	r3, r0
 8005f78:	d404      	bmi.n	8005f84 <tcp_input+0x558>
 8005f7a:	6d33      	ldr	r3, [r6, #80]	; 0x50
 8005f7c:	1ac3      	subs	r3, r0, r3
 8005f7e:	2b00      	cmp	r3, #0
 8005f80:	f340 810d 	ble.w	800619e <tcp_input+0x772>
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 8005f84:	4a23      	ldr	r2, [pc, #140]	; (8006014 <tcp_input+0x5e8>)
                tcphdr->dest, tcphdr->src);
 8005f86:	682b      	ldr	r3, [r5, #0]
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 8005f88:	8811      	ldrh	r1, [r2, #0]
 8005f8a:	4a19      	ldr	r2, [pc, #100]	; (8005ff0 <tcp_input+0x5c4>)
 8005f8c:	881d      	ldrh	r5, [r3, #0]
 8005f8e:	6812      	ldr	r2, [r2, #0]
 8005f90:	9501      	str	r5, [sp, #4]
 8005f92:	885b      	ldrh	r3, [r3, #2]
 8005f94:	9300      	str	r3, [sp, #0]
 8005f96:	4411      	add	r1, r2
 8005f98:	4b16      	ldr	r3, [pc, #88]	; (8005ff4 <tcp_input+0x5c8>)
 8005f9a:	4a1f      	ldr	r2, [pc, #124]	; (8006018 <tcp_input+0x5ec>)
 8005f9c:	f000 fec0 	bl	8006d20 <tcp_rst>
 8005fa0:	e620      	b.n	8005be4 <tcp_input+0x1b8>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 8005fa2:	4b18      	ldr	r3, [pc, #96]	; (8006004 <tcp_input+0x5d8>)
 8005fa4:	781b      	ldrb	r3, [r3, #0]
 8005fa6:	f003 0312 	and.w	r3, r3, #18
 8005faa:	2b12      	cmp	r3, #18
 8005fac:	f000 8124 	beq.w	80061f8 <tcp_input+0x7cc>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
 8005fb0:	4b14      	ldr	r3, [pc, #80]	; (8006004 <tcp_input+0x5d8>)
 8005fb2:	781b      	ldrb	r3, [r3, #0]
 8005fb4:	06db      	lsls	r3, r3, #27
 8005fb6:	f57f ae15 	bpl.w	8005be4 <tcp_input+0x1b8>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 8005fba:	4a16      	ldr	r2, [pc, #88]	; (8006014 <tcp_input+0x5e8>)
        tcphdr->dest, tcphdr->src);
 8005fbc:	682b      	ldr	r3, [r5, #0]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 8005fbe:	8811      	ldrh	r1, [r2, #0]
 8005fc0:	4a0b      	ldr	r2, [pc, #44]	; (8005ff0 <tcp_input+0x5c4>)
 8005fc2:	8818      	ldrh	r0, [r3, #0]
 8005fc4:	6812      	ldr	r2, [r2, #0]
 8005fc6:	9001      	str	r0, [sp, #4]
 8005fc8:	480f      	ldr	r0, [pc, #60]	; (8006008 <tcp_input+0x5dc>)
 8005fca:	885b      	ldrh	r3, [r3, #2]
 8005fcc:	6800      	ldr	r0, [r0, #0]
 8005fce:	e7e1      	b.n	8005f94 <tcp_input+0x568>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
 8005fd0:	4630      	mov	r0, r6
 8005fd2:	f7ff fa69 	bl	80054a8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 8005fd6:	f89a 3000 	ldrb.w	r3, [sl]
 8005fda:	069b      	lsls	r3, r3, #26
 8005fdc:	f57f ae02 	bpl.w	8005be4 <tcp_input+0x1b8>
      tcp_ack_now(pcb);
 8005fe0:	7fb3      	ldrb	r3, [r6, #30]
      pcb->state = CLOSE_WAIT;
 8005fe2:	2207      	movs	r2, #7
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
 8005fe4:	f043 0302 	orr.w	r3, r3, #2
 8005fe8:	77b3      	strb	r3, [r6, #30]
      pcb->state = CLOSE_WAIT;
 8005fea:	7632      	strb	r2, [r6, #24]
 8005fec:	e5fa      	b.n	8005be4 <tcp_input+0x1b8>
 8005fee:	bf00      	nop
 8005ff0:	20002980 	.word	0x20002980
 8005ff4:	20002ee4 	.word	0x20002ee4
 8005ff8:	20005748 	.word	0x20005748
 8005ffc:	20005744 	.word	0x20005744
 8006000:	2000574c 	.word	0x2000574c
 8006004:	2000298c 	.word	0x2000298c
 8006008:	20002988 	.word	0x20002988
 800600c:	20005754 	.word	0x20005754
 8006010:	2000575c 	.word	0x2000575c
 8006014:	20002984 	.word	0x20002984
 8006018:	20002eec 	.word	0x20002eec
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
 800601c:	f8b6 2064 	ldrh.w	r2, [r6, #100]	; 0x64
 8006020:	b13a      	cbz	r2, 8006032 <tcp_input+0x606>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 8006022:	6fb3      	ldr	r3, [r6, #120]	; 0x78
 8006024:	b12b      	cbz	r3, 8006032 <tcp_input+0x606>
 8006026:	4631      	mov	r1, r6
 8006028:	6930      	ldr	r0, [r6, #16]
 800602a:	4798      	blx	r3
          if (err == ERR_ABRT) {
 800602c:	300a      	adds	r0, #10
 800602e:	f43f aded 	beq.w	8005c0c <tcp_input+0x1e0>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
 8006032:	f8d9 2000 	ldr.w	r2, [r9]
 8006036:	b1a2      	cbz	r2, 8006062 <tcp_input+0x636>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
 8006038:	7fb1      	ldrb	r1, [r6, #30]
 800603a:	f001 0110 	and.w	r1, r1, #16
 800603e:	f001 03ff 	and.w	r3, r1, #255	; 0xff
 8006042:	2900      	cmp	r1, #0
 8006044:	d155      	bne.n	80060f2 <tcp_input+0x6c6>
            tcp_abort(pcb);
            goto aborted;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8006046:	6ff5      	ldr	r5, [r6, #124]	; 0x7c
 8006048:	2d00      	cmp	r5, #0
 800604a:	d05e      	beq.n	800610a <tcp_input+0x6de>
 800604c:	4631      	mov	r1, r6
 800604e:	6930      	ldr	r0, [r6, #16]
 8006050:	47a8      	blx	r5
          if (err == ERR_ABRT) {
 8006052:	f110 0f0a 	cmn.w	r0, #10
 8006056:	f43f add9 	beq.w	8005c0c <tcp_input+0x1e0>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 800605a:	b110      	cbz	r0, 8006062 <tcp_input+0x636>
            pcb->refused_data = recv_data;
 800605c:	f8d9 3000 	ldr.w	r3, [r9]
 8006060:	6773      	str	r3, [r6, #116]	; 0x74
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 8006062:	f89a 3000 	ldrb.w	r3, [sl]
 8006066:	069a      	lsls	r2, r3, #26
 8006068:	d506      	bpl.n	8006078 <tcp_input+0x64c>
          if (pcb->refused_data != NULL) {
 800606a:	6f73      	ldr	r3, [r6, #116]	; 0x74
 800606c:	2b00      	cmp	r3, #0
 800606e:	d052      	beq.n	8006116 <tcp_input+0x6ea>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 8006070:	7b5a      	ldrb	r2, [r3, #13]
 8006072:	f042 0220 	orr.w	r2, r2, #32
 8006076:	735a      	strb	r2, [r3, #13]
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 8006078:	2300      	movs	r3, #0
        /* Try to send something out. */
        tcp_output(pcb);
 800607a:	4630      	mov	r0, r6
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 800607c:	6023      	str	r3, [r4, #0]
        /* Try to send something out. */
        tcp_output(pcb);
 800607e:	f000 fd01 	bl	8006a84 <tcp_output>
 8006082:	e5c3      	b.n	8005c0c <tcp_input+0x1e0>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 8006084:	8998      	ldrh	r0, [r3, #12]
 8006086:	f7fb fbf5 	bl	8001874 <lwip_ntohs>
 800608a:	0743      	lsls	r3, r0, #29
 800608c:	f53f ace3 	bmi.w	8005a56 <tcp_input+0x2a>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 8006090:	4a8b      	ldr	r2, [pc, #556]	; (80062c0 <tcp_input+0x894>)
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
 8006092:	682b      	ldr	r3, [r5, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 8006094:	8811      	ldrh	r1, [r2, #0]
 8006096:	4a8b      	ldr	r2, [pc, #556]	; (80062c4 <tcp_input+0x898>)
 8006098:	8818      	ldrh	r0, [r3, #0]
 800609a:	6812      	ldr	r2, [r2, #0]
 800609c:	9001      	str	r0, [sp, #4]
 800609e:	488a      	ldr	r0, [pc, #552]	; (80062c8 <tcp_input+0x89c>)
 80060a0:	885b      	ldrh	r3, [r3, #2]
 80060a2:	6800      	ldr	r0, [r0, #0]
 80060a4:	9300      	str	r3, [sp, #0]
 80060a6:	4411      	add	r1, r2
 80060a8:	4b88      	ldr	r3, [pc, #544]	; (80062cc <tcp_input+0x8a0>)
 80060aa:	4a89      	ldr	r2, [pc, #548]	; (80062d0 <tcp_input+0x8a4>)
 80060ac:	f000 fe38 	bl	8006d20 <tcp_rst>
 80060b0:	e4d1      	b.n	8005a56 <tcp_input+0x2a>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
 80060b2:	4b85      	ldr	r3, [pc, #532]	; (80062c8 <tcp_input+0x89c>)
 80060b4:	6d32      	ldr	r2, [r6, #80]	; 0x50
 80060b6:	681b      	ldr	r3, [r3, #0]
 80060b8:	429a      	cmp	r2, r3
 80060ba:	f47f ad93 	bne.w	8005be4 <tcp_input+0x1b8>
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 80060be:	f89a 2000 	ldrb.w	r2, [sl]
      pcb->flags &= ~TF_ACK_DELAY;
 80060c2:	7fb3      	ldrb	r3, [r6, #30]
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 80060c4:	f042 0208 	orr.w	r2, r2, #8
      pcb->flags &= ~TF_ACK_DELAY;
 80060c8:	f023 0301 	bic.w	r3, r3, #1
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 80060cc:	f88a 2000 	strb.w	r2, [sl]
      pcb->flags &= ~TF_ACK_DELAY;
 80060d0:	77b3      	strb	r3, [r6, #30]
 80060d2:	e587      	b.n	8005be4 <tcp_input+0x1b8>
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 80060d4:	4a7b      	ldr	r2, [pc, #492]	; (80062c4 <tcp_input+0x898>)
 80060d6:	881b      	ldrh	r3, [r3, #0]
 80060d8:	6811      	ldr	r1, [r2, #0]
 80060da:	9301      	str	r3, [sp, #4]
 80060dc:	9b04      	ldr	r3, [sp, #16]
 80060de:	9000      	str	r0, [sp, #0]
 80060e0:	440b      	add	r3, r1
 80060e2:	4619      	mov	r1, r3
 80060e4:	4b78      	ldr	r3, [pc, #480]	; (80062c8 <tcp_input+0x89c>)
 80060e6:	4a7a      	ldr	r2, [pc, #488]	; (80062d0 <tcp_input+0x8a4>)
 80060e8:	6818      	ldr	r0, [r3, #0]
 80060ea:	4b78      	ldr	r3, [pc, #480]	; (80062cc <tcp_input+0x8a0>)
 80060ec:	f000 fe18 	bl	8006d20 <tcp_rst>
 80060f0:	e4b1      	b.n	8005a56 <tcp_input+0x2a>
        if (recv_data != NULL) {
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 80060f2:	4610      	mov	r0, r2
 80060f4:	f7fe f850 	bl	8004198 <pbuf_free>
            tcp_abort(pcb);
 80060f8:	4630      	mov	r0, r6
 80060fa:	f7fe ffb3 	bl	8005064 <tcp_abort>
            goto aborted;
 80060fe:	e585      	b.n	8005c0c <tcp_input+0x1e0>
    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    if (rc != ERR_OK) {
      tcp_abandon(npcb, 0);
 8006100:	4631      	mov	r1, r6
 8006102:	4648      	mov	r0, r9
 8006104:	f7fe ff44 	bl	8004f90 <tcp_abandon>
 8006108:	e4a5      	b.n	8005a56 <tcp_input+0x2a>
            tcp_abort(pcb);
            goto aborted;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800610a:	462b      	mov	r3, r5
 800610c:	4628      	mov	r0, r5
 800610e:	4631      	mov	r1, r6
 8006110:	f7fe fe4c 	bl	8004dac <tcp_recv_null>
 8006114:	e79d      	b.n	8006052 <tcp_input+0x626>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
 8006116:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
 8006118:	6ff5      	ldr	r5, [r6, #124]	; 0x7c
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
 800611a:	f640 3268 	movw	r2, #2920	; 0xb68
 800611e:	4293      	cmp	r3, r2
              pcb->rcv_wnd++;
 8006120:	bf1c      	itt	ne
 8006122:	3301      	addne	r3, #1
 8006124:	85b3      	strhne	r3, [r6, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
 8006126:	2d00      	cmp	r5, #0
 8006128:	d0a6      	beq.n	8006078 <tcp_input+0x64c>
 800612a:	2300      	movs	r3, #0
 800612c:	461a      	mov	r2, r3
 800612e:	4631      	mov	r1, r6
 8006130:	6930      	ldr	r0, [r6, #16]
 8006132:	47a8      	blx	r5
            if (err == ERR_ABRT) {
 8006134:	300a      	adds	r0, #10
 8006136:	d19f      	bne.n	8006078 <tcp_input+0x64c>
 8006138:	e568      	b.n	8005c0c <tcp_input+0x1e0>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 800613a:	06d8      	lsls	r0, r3, #27
 800613c:	f57f ad52 	bpl.w	8005be4 <tcp_input+0x1b8>
 8006140:	4b61      	ldr	r3, [pc, #388]	; (80062c8 <tcp_input+0x89c>)
 8006142:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8006144:	681b      	ldr	r3, [r3, #0]
 8006146:	429a      	cmp	r2, r3
 8006148:	f47f ad4c 	bne.w	8005be4 <tcp_input+0x1b8>
      pcb->state = FIN_WAIT_2;
 800614c:	2306      	movs	r3, #6
 800614e:	7633      	strb	r3, [r6, #24]
 8006150:	e548      	b.n	8005be4 <tcp_input+0x1b8>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 8006152:	079a      	lsls	r2, r3, #30
 8006154:	f57f ad46 	bpl.w	8005be4 <tcp_input+0x1b8>
 8006158:	4a5a      	ldr	r2, [pc, #360]	; (80062c4 <tcp_input+0x898>)
 800615a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800615c:	6812      	ldr	r2, [r2, #0]
 800615e:	3b01      	subs	r3, #1
 8006160:	4293      	cmp	r3, r2
 8006162:	f47f ad3f 	bne.w	8005be4 <tcp_input+0x1b8>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
 8006166:	4630      	mov	r0, r6
 8006168:	f000 fe38 	bl	8006ddc <tcp_rexmit>
 800616c:	e53a      	b.n	8005be4 <tcp_input+0x1b8>
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800616e:	68f2      	ldr	r2, [r6, #12]
 8006170:	601a      	str	r2, [r3, #0]
 8006172:	e6d1      	b.n	8005f18 <tcp_input+0x4ec>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 8006174:	7fb3      	ldrb	r3, [r6, #30]
 8006176:	f043 0302 	orr.w	r3, r3, #2
 800617a:	77b3      	strb	r3, [r6, #30]
        tcp_pcb_purge(pcb);
 800617c:	4630      	mov	r0, r6
 800617e:	f7fe fc95 	bl	8004aac <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 8006182:	4b54      	ldr	r3, [pc, #336]	; (80062d4 <tcp_input+0x8a8>)
 8006184:	681a      	ldr	r2, [r3, #0]
 8006186:	42b2      	cmp	r2, r6
 8006188:	d0f1      	beq.n	800616e <tcp_input+0x742>
 800618a:	4b53      	ldr	r3, [pc, #332]	; (80062d8 <tcp_input+0x8ac>)
 800618c:	601a      	str	r2, [r3, #0]
 800618e:	2a00      	cmp	r2, #0
 8006190:	f43f aec1 	beq.w	8005f16 <tcp_input+0x4ea>
 8006194:	68d1      	ldr	r1, [r2, #12]
 8006196:	42b1      	cmp	r1, r6
 8006198:	d02a      	beq.n	80061f0 <tcp_input+0x7c4>
 800619a:	460a      	mov	r2, r1
 800619c:	e7f7      	b.n	800618e <tcp_input+0x762>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 800619e:	6973      	ldr	r3, [r6, #20]
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
 80061a0:	2204      	movs	r2, #4
 80061a2:	7632      	strb	r2, [r6, #24]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 80061a4:	2b00      	cmp	r3, #0
 80061a6:	d0a7      	beq.n	80060f8 <tcp_input+0x6cc>
 80061a8:	2200      	movs	r2, #0
 80061aa:	4631      	mov	r1, r6
 80061ac:	6930      	ldr	r0, [r6, #16]
 80061ae:	4798      	blx	r3
        if (err != ERR_OK) {
 80061b0:	b130      	cbz	r0, 80061c0 <tcp_input+0x794>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
 80061b2:	300a      	adds	r0, #10
 80061b4:	d1a0      	bne.n	80060f8 <tcp_input+0x6cc>
 80061b6:	e529      	b.n	8005c0c <tcp_input+0x1e0>
 80061b8:	601a      	str	r2, [r3, #0]
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 80061ba:	68f3      	ldr	r3, [r6, #12]
 80061bc:	60d3      	str	r3, [r2, #12]
 80061be:	e6ab      	b.n	8005f18 <tcp_input+0x4ec>
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 80061c0:	4630      	mov	r0, r6
          if (err != ERR_ABRT) {
            tcp_abort(pcb);
          }
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
 80061c2:	f8b6 504c 	ldrh.w	r5, [r6, #76]	; 0x4c
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 80061c6:	f7ff f96f 	bl	80054a8 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
 80061ca:	f8b6 3064 	ldrh.w	r3, [r6, #100]	; 0x64
 80061ce:	b113      	cbz	r3, 80061d6 <tcp_input+0x7aa>
          pcb->acked--;
 80061d0:	3b01      	subs	r3, #1
 80061d2:	f8a6 3064 	strh.w	r3, [r6, #100]	; 0x64
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80061d6:	8ef3      	ldrh	r3, [r6, #54]	; 0x36

        if (recv_flags & TF_GOT_FIN) {
 80061d8:	f89a 2000 	ldrb.w	r2, [sl]
        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
          pcb->acked--;
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80061dc:	2d01      	cmp	r5, #1
 80061de:	bf04      	itt	eq
 80061e0:	005b      	lsleq	r3, r3, #1
 80061e2:	b29b      	uxtheq	r3, r3

        if (recv_flags & TF_GOT_FIN) {
 80061e4:	0691      	lsls	r1, r2, #26
        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
          pcb->acked--;
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80061e6:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c

        if (recv_flags & TF_GOT_FIN) {
 80061ea:	f57f acfb 	bpl.w	8005be4 <tcp_input+0x1b8>
 80061ee:	e6f7      	b.n	8005fe0 <tcp_input+0x5b4>
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 80061f0:	68f1      	ldr	r1, [r6, #12]
 80061f2:	601a      	str	r2, [r3, #0]
 80061f4:	60d1      	str	r1, [r2, #12]
 80061f6:	e68f      	b.n	8005f18 <tcp_input+0x4ec>
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 80061f8:	6f33      	ldr	r3, [r6, #112]	; 0x70
 80061fa:	68db      	ldr	r3, [r3, #12]
 80061fc:	6858      	ldr	r0, [r3, #4]
 80061fe:	f7fb fb3f 	bl	8001880 <lwip_ntohl>
 8006202:	4b31      	ldr	r3, [pc, #196]	; (80062c8 <tcp_input+0x89c>)
 8006204:	681b      	ldr	r3, [r3, #0]
 8006206:	3001      	adds	r0, #1
 8006208:	4298      	cmp	r0, r3
 800620a:	f47f aed1 	bne.w	8005fb0 <tcp_input+0x584>
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
 800620e:	4b2d      	ldr	r3, [pc, #180]	; (80062c4 <tcp_input+0x898>)
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 8006210:	f8b6 2066 	ldrh.w	r2, [r6, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
 8006214:	681b      	ldr	r3, [r3, #0]
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
 8006216:	682d      	ldr	r5, [r5, #0]
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
 8006218:	64b0      	str	r0, [r6, #72]	; 0x48
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
 800621a:	1c59      	adds	r1, r3, #1
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 800621c:	3201      	adds	r2, #1
      pcb->rcv_nxt = seqno + 1;
 800621e:	62b1      	str	r1, [r6, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8006220:	6331      	str	r1, [r6, #48]	; 0x30
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 8006222:	f8a6 2066 	strh.w	r2, [r6, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
 8006226:	89ea      	ldrh	r2, [r5, #14]
 8006228:	f8a6 2060 	strh.w	r2, [r6, #96]	; 0x60
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800622c:	3b01      	subs	r3, #1
      pcb->state = ESTABLISHED;
 800622e:	2104      	movs	r1, #4
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 8006230:	6573      	str	r3, [r6, #84]	; 0x54
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
      pcb->snd_wnd_max = tcphdr->wnd;
 8006232:	f8a6 2062 	strh.w	r2, [r6, #98]	; 0x62
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;
 8006236:	7631      	strb	r1, [r6, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 8006238:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
 800623a:	1871      	adds	r1, r6, r1
 800623c:	f7ff f924 	bl	8005488 <tcp_eff_send_mss>

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 8006240:	f8b6 104c 	ldrh.w	r1, [r6, #76]	; 0x4c
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 8006244:	86f0      	strh	r0, [r6, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 8006246:	eb00 0280 	add.w	r2, r0, r0, lsl #2

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800624a:	2901      	cmp	r1, #1
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 800624c:	ea4f 0242 	mov.w	r2, r2, lsl #1
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 8006250:	4603      	mov	r3, r0
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 8006252:	f8a6 204e 	strh.w	r2, [r6, #78]	; 0x4e

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 8006256:	bf08      	it	eq
 8006258:	0043      	lsleq	r3, r0, #1
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 800625a:	f8b6 2068 	ldrh.w	r2, [r6, #104]	; 0x68
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
 800625e:	6f30      	ldr	r0, [r6, #112]	; 0x70

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 8006260:	bf08      	it	eq
 8006262:	b29b      	uxtheq	r3, r3
 8006264:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 8006268:	1e53      	subs	r3, r2, #1
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
      pcb->unacked = rseg->next;
 800626a:	6802      	ldr	r2, [r0, #0]
 800626c:	6732      	str	r2, [r6, #112]	; 0x70
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 800626e:	f8a6 3068 	strh.w	r3, [r6, #104]	; 0x68
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
      pcb->unacked = rseg->next;
      tcp_seg_free(rseg);
 8006272:	f7fe fbf9 	bl	8004a68 <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 8006276:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8006278:	b1f3      	cbz	r3, 80062b8 <tcp_input+0x88c>
        pcb->rtime = -1;
      else {
        pcb->rtime = 0;
        pcb->nrtx = 0;
 800627a:	2300      	movs	r3, #0
 800627c:	f886 3046 	strb.w	r3, [r6, #70]	; 0x46
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 8006280:	f8d6 5080 	ldr.w	r5, [r6, #128]	; 0x80
 8006284:	86b3      	strh	r3, [r6, #52]	; 0x34
 8006286:	2d00      	cmp	r5, #0
 8006288:	f43f ad0f 	beq.w	8005caa <tcp_input+0x27e>
 800628c:	2200      	movs	r2, #0
 800628e:	4631      	mov	r1, r6
 8006290:	6930      	ldr	r0, [r6, #16]
 8006292:	47a8      	blx	r5
      if (err == ERR_ABRT) {
 8006294:	300a      	adds	r0, #10
 8006296:	f47f ad08 	bne.w	8005caa <tcp_input+0x27e>
 800629a:	e4b7      	b.n	8005c0c <tcp_input+0x1e0>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
    }
  } else if (flags & TCP_FIN) {
 800629c:	f01e 0f01 	tst.w	lr, #1
 80062a0:	f43f acee 	beq.w	8005c80 <tcp_input+0x254>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 80062a4:	4b0d      	ldr	r3, [pc, #52]	; (80062dc <tcp_input+0x8b0>)
 80062a6:	681b      	ldr	r3, [r3, #0]
 80062a8:	6243      	str	r3, [r0, #36]	; 0x24
 80062aa:	e4e9      	b.n	8005c80 <tcp_input+0x254>
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 80062ac:	9b04      	ldr	r3, [sp, #16]
 80062ae:	4413      	add	r3, r2
 80062b0:	e88d 0042 	stmia.w	sp, {r1, r6}
 80062b4:	4619      	mov	r1, r3
 80062b6:	e715      	b.n	80060e4 <tcp_input+0x6b8>
      tcp_seg_free(rseg);

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
 80062b8:	f04f 33ff 	mov.w	r3, #4294967295
 80062bc:	e7e0      	b.n	8006280 <tcp_input+0x854>
 80062be:	bf00      	nop
 80062c0:	20002984 	.word	0x20002984
 80062c4:	20002980 	.word	0x20002980
 80062c8:	20002988 	.word	0x20002988
 80062cc:	20002ee4 	.word	0x20002ee4
 80062d0:	20002eec 	.word	0x20002eec
 80062d4:	20005748 	.word	0x20005748
 80062d8:	20005754 	.word	0x20005754
 80062dc:	2000574c 	.word	0x2000574c

080062e0 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 80062e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 80062e4:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 80062e6:	4605      	mov	r5, r0
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 80062e8:	b90c      	cbnz	r4, 80062ee <tcp_send_fin+0xe>
 80062ea:	e00a      	b.n	8006302 <tcp_send_fin+0x22>
 80062ec:	461c      	mov	r4, r3
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80062ee:	6823      	ldr	r3, [r4, #0]
 80062f0:	2b00      	cmp	r3, #0
 80062f2:	d1fb      	bne.n	80062ec <tcp_send_fin+0xc>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 80062f4:	68e3      	ldr	r3, [r4, #12]
 80062f6:	8998      	ldrh	r0, [r3, #12]
 80062f8:	f7fb fabc 	bl	8001874 <lwip_ntohs>
 80062fc:	f010 0607 	ands.w	r6, r0, #7
 8006300:	d06b      	beq.n	80063da <tcp_send_fin+0xfa>

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8006302:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
 8006306:	2b07      	cmp	r3, #7
 8006308:	d85f      	bhi.n	80063ca <tcp_send_fin+0xea>

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 800630a:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
 800630e:	2b00      	cmp	r3, #0
 8006310:	d05f      	beq.n	80063d2 <tcp_send_fin+0xf2>
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8006312:	2200      	movs	r2, #0
 8006314:	4611      	mov	r1, r2
 8006316:	4610      	mov	r0, r2
 8006318:	f7fd fde6 	bl	8003ee8 <pbuf_alloc>
 800631c:	4606      	mov	r6, r0
 800631e:	2800      	cmp	r0, #0
 8006320:	d053      	beq.n	80063ca <tcp_send_fin+0xea>
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8006322:	2004      	movs	r0, #4
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 8006324:	f8d5 805c 	ldr.w	r8, [r5, #92]	; 0x5c
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8006328:	f7fd fc78 	bl	8003c1c <memp_malloc>
 800632c:	4604      	mov	r4, r0
 800632e:	2800      	cmp	r0, #0
 8006330:	d048      	beq.n	80063c4 <tcp_send_fin+0xe4>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
 8006332:	2300      	movs	r3, #0
 8006334:	7283      	strb	r3, [r0, #10]
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;
 8006336:	8932      	ldrh	r2, [r6, #8]
 8006338:	8102      	strh	r2, [r0, #8]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
 800633a:	e880 0048 	stmia.w	r0, {r3, r6}
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 800633e:	2114      	movs	r1, #20
 8006340:	4630      	mov	r0, r6
 8006342:	f7fd fef3 	bl	800412c <pbuf_header>
 8006346:	4606      	mov	r6, r0
 8006348:	2800      	cmp	r0, #0
 800634a:	d156      	bne.n	80063fa <tcp_send_fin+0x11a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800634c:	6863      	ldr	r3, [r4, #4]
  seg->tcphdr->src = htons(pcb->local_port);
 800634e:	8b68      	ldrh	r0, [r5, #26]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8006350:	685f      	ldr	r7, [r3, #4]
 8006352:	60e7      	str	r7, [r4, #12]
  seg->tcphdr->src = htons(pcb->local_port);
 8006354:	f7fb fa8a 	bl	800186c <lwip_htons>
 8006358:	8038      	strh	r0, [r7, #0]
  seg->tcphdr->dest = htons(pcb->remote_port);
 800635a:	8ba8      	ldrh	r0, [r5, #28]
 800635c:	68e7      	ldr	r7, [r4, #12]
 800635e:	f7fb fa85 	bl	800186c <lwip_htons>
 8006362:	8078      	strh	r0, [r7, #2]
  seg->tcphdr->seqno = htonl(seqno);
 8006364:	4640      	mov	r0, r8
 8006366:	68e7      	ldr	r7, [r4, #12]
 8006368:	f7fb fa88 	bl	800187c <lwip_htonl>
 800636c:	6078      	str	r0, [r7, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800636e:	f245 0001 	movw	r0, #20481	; 0x5001
 8006372:	68e7      	ldr	r7, [r4, #12]
 8006374:	f7fb fa7a 	bl	800186c <lwip_htons>
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 8006378:	68e3      	ldr	r3, [r4, #12]
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 800637a:	6eea      	ldr	r2, [r5, #108]	; 0x6c
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800637c:	81b8      	strh	r0, [r7, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800637e:	749e      	strb	r6, [r3, #18]
 8006380:	74de      	strb	r6, [r3, #19]
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 8006382:	b90a      	cbnz	r2, 8006388 <tcp_send_fin+0xa8>
 8006384:	e037      	b.n	80063f6 <tcp_send_fin+0x116>
    pcb->unsent = seg;
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8006386:	461a      	mov	r2, r3
 8006388:	6813      	ldr	r3, [r2, #0]
 800638a:	2b00      	cmp	r3, #0
 800638c:	d1fb      	bne.n	8006386 <tcp_send_fin+0xa6>
    useg->next = seg;
 800638e:	6014      	str	r4, [r2, #0]
    pcb->snd_lbb++;
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
  }
  if (flags & TCP_FIN) {
    pcb->flags |= TF_FIN;
 8006390:	7fa9      	ldrb	r1, [r5, #30]
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 8006392:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 8006394:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
    pcb->flags |= TF_FIN;
 8006398:	f041 0120 	orr.w	r1, r1, #32
 800639c:	77a9      	strb	r1, [r5, #30]
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 800639e:	3201      	adds	r2, #1
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 80063a0:	3b01      	subs	r3, #1
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    useg->next = seg;
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 80063a2:	2600      	movs	r6, #0
  if (flags & TCP_FIN) {
    pcb->flags |= TF_FIN;
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 80063a4:	6860      	ldr	r0, [r4, #4]

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 80063a6:	f8a5 3066 	strh.w	r3, [r5, #102]	; 0x66
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 80063aa:	65ea      	str	r2, [r5, #92]	; 0x5c
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    useg->next = seg;
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 80063ac:	f8a5 606a 	strh.w	r6, [r5, #106]	; 0x6a
  if (flags & TCP_FIN) {
    pcb->flags |= TF_FIN;
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 80063b0:	f7fd ff20 	bl	80041f4 <pbuf_clen>
 80063b4:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
 80063b8:	4403      	add	r3, r0
 80063ba:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 80063be:	4630      	mov	r0, r6
 80063c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 80063c4:	4630      	mov	r0, r6
 80063c6:	f7fd fee7 	bl	8004198 <pbuf_free>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
 80063ca:	7fab      	ldrb	r3, [r5, #30]
 80063cc:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80063d0:	77ab      	strb	r3, [r5, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 80063d2:	f04f 30ff 	mov.w	r0, #4294967295
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
}
 80063d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 80063da:	68e7      	ldr	r7, [r4, #12]
 80063dc:	2001      	movs	r0, #1
 80063de:	89bc      	ldrh	r4, [r7, #12]
 80063e0:	f7fb fa44 	bl	800186c <lwip_htons>
 80063e4:	4320      	orrs	r0, r4
 80063e6:	81b8      	strh	r0, [r7, #12]
      pcb->flags |= TF_FIN;
 80063e8:	7fab      	ldrb	r3, [r5, #30]
 80063ea:	f043 0320 	orr.w	r3, r3, #32
 80063ee:	77ab      	strb	r3, [r5, #30]
      return ERR_OK;
 80063f0:	4630      	mov	r0, r6
 80063f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
    pcb->unsent = seg;
 80063f6:	66ec      	str	r4, [r5, #108]	; 0x6c
 80063f8:	e7ca      	b.n	8006390 <tcp_send_fin+0xb0>

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 80063fa:	4620      	mov	r0, r4
 80063fc:	f7fe fb34 	bl	8004a68 <tcp_seg_free>
 8006400:	e7e3      	b.n	80063ca <tcp_send_fin+0xea>
 8006402:	bf00      	nop

08006404 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 8006404:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 8006408:	f8b0 4062 	ldrh.w	r4, [r0, #98]	; 0x62
 800640c:	8ec5      	ldrh	r5, [r0, #54]	; 0x36
 800640e:	0864      	lsrs	r4, r4, #1
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 8006410:	b08d      	sub	sp, #52	; 0x34
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 8006412:	42ac      	cmp	r4, r5
 8006414:	bf28      	it	cs
 8006416:	462c      	movcs	r4, r5
 8006418:	9403      	str	r4, [sp, #12]
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 800641a:	2900      	cmp	r1, #0
 800641c:	f000 821f 	beq.w	800685e <tcp_write+0x45a>
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 8006420:	7e04      	ldrb	r4, [r0, #24]
 8006422:	2c07      	cmp	r4, #7
 8006424:	d007      	beq.n	8006436 <tcp_write+0x32>
      (pcb->state != CLOSE_WAIT) &&
 8006426:	3c02      	subs	r4, #2
 8006428:	2c02      	cmp	r4, #2
 800642a:	d904      	bls.n	8006436 <tcp_write+0x32>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 800642c:	f06f 000c 	mvn.w	r0, #12
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
 8006430:	b00d      	add	sp, #52	; 0x34
 8006432:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006436:	9105      	str	r1, [sp, #20]
 8006438:	9309      	str	r3, [sp, #36]	; 0x24
 800643a:	9200      	str	r2, [sp, #0]
 800643c:	4680      	mov	r8, r0
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
 800643e:	2a00      	cmp	r2, #0
 8006440:	f000 808b 	beq.w	800655a <tcp_write+0x156>
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 8006444:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
 8006448:	4293      	cmp	r3, r2
 800644a:	f0c0 81f5 	bcc.w	8006838 <tcp_write+0x434>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800644e:	f8b0 7068 	ldrh.w	r7, [r0, #104]	; 0x68
 8006452:	2f07      	cmp	r7, #7
 8006454:	f200 81f0 	bhi.w	8006838 <tcp_write+0x434>
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 8006458:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800645a:	9307      	str	r3, [sp, #28]
 800645c:	2b00      	cmp	r3, #0
 800645e:	f000 8089 	beq.w	8006574 <tcp_write+0x170>
 8006462:	461a      	mov	r2, r3
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8006464:	681b      	ldr	r3, [r3, #0]
 8006466:	2b00      	cmp	r3, #0
 8006468:	d1fb      	bne.n	8006462 <tcp_write+0x5e>
 800646a:	4611      	mov	r1, r2
 800646c:	4699      	mov	r9, r3
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 800646e:	f8b8 306a 	ldrh.w	r3, [r8, #106]	; 0x6a
 8006472:	9207      	str	r2, [sp, #28]
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 8006474:	7a92      	ldrb	r2, [r2, #10]
    space = mss_local - (last_unsent->len + unsent_optlen);
 8006476:	8909      	ldrh	r1, [r1, #8]
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 8006478:	9306      	str	r3, [sp, #24]
 800647a:	461c      	mov	r4, r3
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    space = mss_local - (last_unsent->len + unsent_optlen);
 800647c:	9b03      	ldr	r3, [sp, #12]
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800647e:	f012 0f01 	tst.w	r2, #1
 8006482:	bf0c      	ite	eq
 8006484:	2000      	moveq	r0, #0
 8006486:	2004      	movne	r0, #4
    space = mss_local - (last_unsent->len + unsent_optlen);
 8006488:	1a5b      	subs	r3, r3, r1
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800648a:	f012 0f02 	tst.w	r2, #2
 800648e:	bf0c      	ite	eq
 8006490:	2200      	moveq	r2, #0
 8006492:	220c      	movne	r2, #12
    space = mss_local - (last_unsent->len + unsent_optlen);
 8006494:	1a1b      	subs	r3, r3, r0
 8006496:	1a9b      	subs	r3, r3, r2
 8006498:	b29b      	uxth	r3, r3
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
 800649a:	4622      	mov	r2, r4
 800649c:	b1fc      	cbz	r4, 80064de <tcp_write+0xda>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
 800649e:	9c00      	ldr	r4, [sp, #0]
 80064a0:	4294      	cmp	r4, r2
 80064a2:	4625      	mov	r5, r4
 80064a4:	bf28      	it	cs
 80064a6:	4615      	movcs	r5, r2
      pos += oversize_used;
      oversize -= oversize_used;
 80064a8:	1b52      	subs	r2, r2, r5
      space -= oversize_used;
 80064aa:	1b5b      	subs	r3, r3, r5
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
      pos += oversize_used;
      oversize -= oversize_used;
 80064ac:	b292      	uxth	r2, r2
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 80064ae:	42ac      	cmp	r4, r5
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
      pos += oversize_used;
      oversize -= oversize_used;
 80064b0:	9206      	str	r2, [sp, #24]
      space -= oversize_used;
 80064b2:	b29b      	uxth	r3, r3
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 80064b4:	d818      	bhi.n	80064e8 <tcp_write+0xe4>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 80064b6:	9c07      	ldr	r4, [sp, #28]
 80064b8:	2d00      	cmp	r5, #0
 80064ba:	f000 812f 	beq.w	800671c <tcp_write+0x318>
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
 80064be:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 80064c2:	4623      	mov	r3, r4
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 80064c4:	685e      	ldr	r6, [r3, #4]
 80064c6:	2e00      	cmp	r6, #0
 80064c8:	f000 8182 	beq.w	80067d0 <tcp_write+0x3cc>
      p->tot_len += oversize_used;
 80064cc:	8933      	ldrh	r3, [r6, #8]
      if (p->next == NULL) {
 80064ce:	6832      	ldr	r2, [r6, #0]
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
 80064d0:	442b      	add	r3, r5
 80064d2:	8133      	strh	r3, [r6, #8]
      if (p->next == NULL) {
 80064d4:	2a00      	cmp	r2, #0
 80064d6:	f000 816d 	beq.w	80067b4 <tcp_write+0x3b0>
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
 80064da:	4616      	mov	r6, r2
 80064dc:	e7f6      	b.n	80064cc <tcp_write+0xc8>
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 80064de:	9a00      	ldr	r2, [sp, #0]
 80064e0:	2a00      	cmp	r2, #0
 80064e2:	f000 811a 	beq.w	800671a <tcp_write+0x316>
 80064e6:	4625      	mov	r5, r4
 80064e8:	2b00      	cmp	r3, #0
 80064ea:	f000 8113 	beq.w	8006714 <tcp_write+0x310>
 80064ee:	2900      	cmp	r1, #0
 80064f0:	f000 818b 	beq.w	800680a <tcp_write+0x406>
      u16_t seglen = space < len - pos ? space : len - pos;
 80064f4:	9a00      	ldr	r2, [sp, #0]
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 80064f6:	9909      	ldr	r1, [sp, #36]	; 0x24
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
 80064f8:	1b54      	subs	r4, r2, r5
 80064fa:	429c      	cmp	r4, r3
 80064fc:	bfa8      	it	ge
 80064fe:	461c      	movge	r4, r3
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 8006500:	07c8      	lsls	r0, r1, #31
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
 8006502:	b2a4      	uxth	r4, r4
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 8006504:	460a      	mov	r2, r1
 8006506:	f140 8183 	bpl.w	8006810 <tcp_write+0x40c>
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800650a:	429c      	cmp	r4, r3
 800650c:	f080 81a5 	bcs.w	800685a <tcp_write+0x456>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 8006510:	0791      	lsls	r1, r2, #30
 8006512:	d404      	bmi.n	800651e <tcp_write+0x11a>
 8006514:	f898 201e 	ldrb.w	r2, [r8, #30]
 8006518:	0652      	lsls	r2, r2, #25
 800651a:	f100 819e 	bmi.w	800685a <tcp_write+0x456>
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
 800651e:	f204 51b7 	addw	r1, r4, #1463	; 0x5b7
 8006522:	f021 0103 	bic.w	r1, r1, #3
 8006526:	428b      	cmp	r3, r1
 8006528:	bfa8      	it	ge
 800652a:	460b      	movge	r3, r1
 800652c:	b299      	uxth	r1, r3
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800652e:	2200      	movs	r2, #0
 8006530:	2003      	movs	r0, #3
 8006532:	f7fd fcd9 	bl	8003ee8 <pbuf_alloc>
  if (p == NULL) {
 8006536:	900a      	str	r0, [sp, #40]	; 0x28
 8006538:	2800      	cmp	r0, #0
 800653a:	f000 8193 	beq.w	8006864 <tcp_write+0x460>
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 800653e:	8943      	ldrh	r3, [r0, #10]
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 8006540:	9905      	ldr	r1, [sp, #20]
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 8006542:	8104      	strh	r4, [r0, #8]
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  if (p == NULL) {
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 8006544:	1b1b      	subs	r3, r3, r4
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 8006546:	8144      	strh	r4, [r0, #10]
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  if (p == NULL) {
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 8006548:	b29b      	uxth	r3, r3
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 800654a:	4622      	mov	r2, r4
 800654c:	4429      	add	r1, r5
 800654e:	6840      	ldr	r0, [r0, #4]
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  if (p == NULL) {
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 8006550:	9306      	str	r3, [sp, #24]
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 8006552:	f004 ffe0 	bl	800b516 <memcpy>
 8006556:	980a      	ldr	r0, [sp, #40]	; 0x28
 8006558:	e164      	b.n	8006824 <tcp_write+0x420>
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 800655a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800655c:	9307      	str	r3, [sp, #28]

  err = tcp_write_checks(pcb, len);
  if (err != ERR_OK) {
    return err;
  }
  queuelen = pcb->snd_queuelen;
 800655e:	f8b0 7068 	ldrh.w	r7, [r0, #104]	; 0x68
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 8006562:	2b00      	cmp	r3, #0
 8006564:	f47f af7d 	bne.w	8006462 <tcp_write+0x5e>
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 8006568:	f8dd 9000 	ldr.w	r9, [sp]
 800656c:	f8a8 906a 	strh.w	r9, [r8, #106]	; 0x6a
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8006570:	464c      	mov	r4, r9
 8006572:	e18f      	b.n	8006894 <tcp_write+0x490>
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
 8006574:	9306      	str	r3, [sp, #24]
  u16_t oversize_used = 0;
 8006576:	930b      	str	r3, [sp, #44]	; 0x2c
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0; /* position in 'arg' data */
 8006578:	461d      	mov	r5, r3
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
 800657a:	930a      	str	r3, [sp, #40]	; 0x28
 800657c:	4613      	mov	r3, r2
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800657e:	42ab      	cmp	r3, r5
 8006580:	f240 817b 	bls.w	800687a <tcp_write+0x476>
 8006584:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006586:	f002 0302 	and.w	r3, r2, #2
 800658a:	f04f 0900 	mov.w	r9, #0
 800658e:	b2db      	uxtb	r3, r3
 8006590:	f002 0b01 	and.w	fp, r2, #1
 8006594:	9308      	str	r3, [sp, #32]
 8006596:	f8cd 9008 	str.w	r9, [sp, #8]
 800659a:	f8cd 9010 	str.w	r9, [sp, #16]
 800659e:	465c      	mov	r4, fp
 80065a0:	9b00      	ldr	r3, [sp, #0]
 80065a2:	e08a      	b.n	80066ba <tcp_write+0x2b6>
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 80065a4:	42b2      	cmp	r2, r6
 80065a6:	f240 80e2 	bls.w	800676e <tcp_write+0x36a>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 80065aa:	9b08      	ldr	r3, [sp, #32]
 80065ac:	b95b      	cbnz	r3, 80065c6 <tcp_write+0x1c2>
 80065ae:	f898 301e 	ldrb.w	r3, [r8, #30]
 80065b2:	065b      	lsls	r3, r3, #25
 80065b4:	f100 80db 	bmi.w	800676e <tcp_write+0x36a>
        (!(pcb->flags & TF_NODELAY) &&
 80065b8:	9b04      	ldr	r3, [sp, #16]
 80065ba:	b923      	cbnz	r3, 80065c6 <tcp_write+0x1c2>
         (!first_seg ||
 80065bc:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
 80065c0:	2b00      	cmp	r3, #0
 80065c2:	f000 80cf 	beq.w	8006764 <tcp_write+0x360>
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
 80065c6:	9b03      	ldr	r3, [sp, #12]
 80065c8:	f206 51b7 	addw	r1, r6, #1463	; 0x5b7
 80065cc:	f021 0103 	bic.w	r1, r1, #3
 80065d0:	4299      	cmp	r1, r3
 80065d2:	bfa8      	it	ge
 80065d4:	4619      	movge	r1, r3
 80065d6:	b289      	uxth	r1, r1
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 80065d8:	2200      	movs	r2, #0
 80065da:	4610      	mov	r0, r2
 80065dc:	f7fd fc84 	bl	8003ee8 <pbuf_alloc>
  if (p == NULL) {
 80065e0:	4683      	mov	fp, r0
 80065e2:	2800      	cmp	r0, #0
 80065e4:	f000 80e3 	beq.w	80067ae <tcp_write+0x3aa>
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 80065e8:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 80065ec:	9b05      	ldr	r3, [sp, #20]
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 80065ee:	8106      	strh	r6, [r0, #8]
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  if (p == NULL) {
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 80065f0:	ebc6 0e0e 	rsb	lr, r6, lr
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 80065f4:	1959      	adds	r1, r3, r5
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 80065f6:	8146      	strh	r6, [r0, #10]
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  if (p == NULL) {
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 80065f8:	fa1f f38e 	uxth.w	r3, lr
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 80065fc:	4632      	mov	r2, r6
 80065fe:	6840      	ldr	r0, [r0, #4]
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  if (p == NULL) {
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 8006600:	9306      	str	r3, [sp, #24]
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 8006602:	f004 ff88 	bl	800b516 <memcpy>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
    }

    queuelen += pbuf_clen(p);
 8006606:	4658      	mov	r0, fp
 8006608:	f7fd fdf4 	bl	80041f4 <pbuf_clen>
 800660c:	4438      	add	r0, r7
 800660e:	b287      	uxth	r7, r0

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8006610:	2f08      	cmp	r7, #8
 8006612:	d879      	bhi.n	8006708 <tcp_write+0x304>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 8006614:	f8d8 205c 	ldr.w	r2, [r8, #92]	; 0x5c
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8006618:	2004      	movs	r0, #4
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 800661a:	eb05 0902 	add.w	r9, r5, r2
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800661e:	f7fd fafd 	bl	8003c1c <memp_malloc>
 8006622:	4682      	mov	sl, r0
 8006624:	2800      	cmp	r0, #0
 8006626:	d06f      	beq.n	8006708 <tcp_write+0x304>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
 8006628:	f04f 0300 	mov.w	r3, #0
 800662c:	7283      	strb	r3, [r0, #10]
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;
 800662e:	f8bb 1008 	ldrh.w	r1, [fp, #8]
 8006632:	8101      	strh	r1, [r0, #8]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
 8006634:	2300      	movs	r3, #0
  seg->p = p;
 8006636:	e880 0808 	stmia.w	r0, {r3, fp}
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 800663a:	2114      	movs	r1, #20
 800663c:	4658      	mov	r0, fp
 800663e:	f7fd fd75 	bl	800412c <pbuf_header>
 8006642:	4683      	mov	fp, r0
 8006644:	2800      	cmp	r0, #0
 8006646:	f040 8097 	bne.w	8006778 <tcp_write+0x374>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800664a:	f8da 1004 	ldr.w	r1, [sl, #4]
  seg->tcphdr->src = htons(pcb->local_port);
 800664e:	f8b8 001a 	ldrh.w	r0, [r8, #26]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8006652:	6849      	ldr	r1, [r1, #4]
 8006654:	f8ca 100c 	str.w	r1, [sl, #12]
 8006658:	9101      	str	r1, [sp, #4]
  seg->tcphdr->src = htons(pcb->local_port);
 800665a:	f7fb f907 	bl	800186c <lwip_htons>
 800665e:	9901      	ldr	r1, [sp, #4]
 8006660:	8008      	strh	r0, [r1, #0]
  seg->tcphdr->dest = htons(pcb->remote_port);
 8006662:	f8b8 001c 	ldrh.w	r0, [r8, #28]
 8006666:	f8da 100c 	ldr.w	r1, [sl, #12]
 800666a:	9101      	str	r1, [sp, #4]
 800666c:	f7fb f8fe 	bl	800186c <lwip_htons>
 8006670:	9901      	ldr	r1, [sp, #4]
 8006672:	8048      	strh	r0, [r1, #2]
  seg->tcphdr->seqno = htonl(seqno);
 8006674:	4648      	mov	r0, r9
 8006676:	f8da 900c 	ldr.w	r9, [sl, #12]
 800667a:	f7fb f8ff 	bl	800187c <lwip_htonl>
 800667e:	f8c9 0004 	str.w	r0, [r9, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8006682:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
 8006686:	f8da 900c 	ldr.w	r9, [sl, #12]
 800668a:	f7fb f8ef 	bl	800186c <lwip_htons>
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800668e:	f8da 100c 	ldr.w	r1, [sl, #12]
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 8006692:	9b04      	ldr	r3, [sp, #16]
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8006694:	f8a9 000c 	strh.w	r0, [r9, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 8006698:	f881 b012 	strb.w	fp, [r1, #18]
 800669c:	f881 b013 	strb.w	fp, [r1, #19]
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 80066a0:	2b00      	cmp	r3, #0
 80066a2:	d066      	beq.n	8006772 <tcp_write+0x36e>
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
 80066a4:	9b02      	ldr	r3, [sp, #8]
 80066a6:	f8c3 a000 	str.w	sl, [r3]

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 80066aa:	4435      	add	r5, r6
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 80066ac:	9b00      	ldr	r3, [sp, #0]

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 80066ae:	b2ad      	uxth	r5, r5
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 80066b0:	42ab      	cmp	r3, r5
 80066b2:	f240 80f2 	bls.w	800689a <tcp_write+0x496>
 80066b6:	f8cd a008 	str.w	sl, [sp, #8]
    struct pbuf *p;
    u16_t left = len - pos;
    u16_t max_len = mss_local - optlen;
    u16_t seglen = left > max_len ? max_len : left;
 80066ba:	9a03      	ldr	r2, [sp, #12]
 80066bc:	1b5e      	subs	r6, r3, r5
 80066be:	b2b6      	uxth	r6, r6
 80066c0:	4296      	cmp	r6, r2
 80066c2:	bf28      	it	cs
 80066c4:	4616      	movcs	r6, r2
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 80066c6:	2c00      	cmp	r4, #0
 80066c8:	f47f af6c 	bne.w	80065a4 <tcp_write+0x1a0>
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 80066cc:	2201      	movs	r2, #1
 80066ce:	4631      	mov	r1, r6
 80066d0:	4620      	mov	r0, r4
 80066d2:	f7fd fc09 	bl	8003ee8 <pbuf_alloc>
 80066d6:	4681      	mov	r9, r0
 80066d8:	2800      	cmp	r0, #0
 80066da:	d068      	beq.n	80067ae <tcp_write+0x3aa>
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 80066dc:	9b05      	ldr	r3, [sp, #20]
 80066de:	442b      	add	r3, r5
 80066e0:	6043      	str	r3, [r0, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 80066e2:	4622      	mov	r2, r4
 80066e4:	4621      	mov	r1, r4
 80066e6:	4620      	mov	r0, r4
 80066e8:	f7fd fbfe 	bl	8003ee8 <pbuf_alloc>
 80066ec:	4683      	mov	fp, r0
 80066ee:	2800      	cmp	r0, #0
 80066f0:	f000 8084 	beq.w	80067fc <tcp_write+0x3f8>
        pbuf_free(p2);
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 80066f4:	4649      	mov	r1, r9
 80066f6:	f7fd fd8d 	bl	8004214 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 80066fa:	4658      	mov	r0, fp
 80066fc:	f7fd fd7a 	bl	80041f4 <pbuf_clen>
 8006700:	4438      	add	r0, r7
 8006702:	b287      	uxth	r7, r0

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8006704:	2f08      	cmp	r7, #8
 8006706:	d985      	bls.n	8006614 <tcp_write+0x210>
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 8006708:	4658      	mov	r0, fp
 800670a:	f8dd 9010 	ldr.w	r9, [sp, #16]
 800670e:	f7fd fd43 	bl	8004198 <pbuf_free>
 8006712:	e036      	b.n	8006782 <tcp_write+0x37e>
 8006714:	930a      	str	r3, [sp, #40]	; 0x28
 8006716:	950b      	str	r5, [sp, #44]	; 0x2c
 8006718:	e734      	b.n	8006584 <tcp_write+0x180>
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800671a:	4614      	mov	r4, r2
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800671c:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 8006720:	f8a8 306a 	strh.w	r3, [r8, #106]	; 0x6a
 8006724:	9b07      	ldr	r3, [sp, #28]
   * is harmless
   */
  if (last_unsent == NULL) {
    pcb->unsent = queue;
  } else {
    last_unsent->next = queue;
 8006726:	f8c3 9000 	str.w	r9, [r3]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800672a:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
  pcb->snd_buf -= len;
 800672e:	f8b8 2066 	ldrh.w	r2, [r8, #102]	; 0x66
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 8006732:	9800      	ldr	r0, [sp, #0]
  pcb->snd_buf -= len;
  pcb->snd_queuelen = queuelen;
 8006734:	f8a8 7068 	strh.w	r7, [r8, #104]	; 0x68
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 8006738:	4403      	add	r3, r0
  pcb->snd_buf -= len;
 800673a:	1a12      	subs	r2, r2, r0
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800673c:	f8c8 305c 	str.w	r3, [r8, #92]	; 0x5c
  pcb->snd_buf -= len;
 8006740:	f8a8 2066 	strh.w	r2, [r8, #102]	; 0x66
    LWIP_ASSERT("tcp_write: valid queue length",
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 8006744:	2c00      	cmp	r4, #0
 8006746:	f000 8094 	beq.w	8006872 <tcp_write+0x46e>
 800674a:	68e5      	ldr	r5, [r4, #12]
 800674c:	2d00      	cmp	r5, #0
 800674e:	f000 8092 	beq.w	8006876 <tcp_write+0x472>
 8006752:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006754:	f003 0302 	and.w	r3, r3, #2
 8006758:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 800675c:	2b00      	cmp	r3, #0
 800675e:	d074      	beq.n	800684a <tcp_write+0x446>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
 8006760:	2000      	movs	r0, #0
 8006762:	e665      	b.n	8006430 <tcp_write+0x2c>
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
 8006764:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
 8006768:	2b00      	cmp	r3, #0
 800676a:	f47f af2c 	bne.w	80065c6 <tcp_write+0x1c2>
 800676e:	4631      	mov	r1, r6
 8006770:	e732      	b.n	80065d8 <tcp_write+0x1d4>
 8006772:	f8cd a010 	str.w	sl, [sp, #16]
 8006776:	e798      	b.n	80066aa <tcp_write+0x2a6>

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 8006778:	4650      	mov	r0, sl
 800677a:	f8dd 9010 	ldr.w	r9, [sp, #16]
 800677e:	f7fe f973 	bl	8004a68 <tcp_seg_free>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 8006782:	f898 301e 	ldrb.w	r3, [r8, #30]
 8006786:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800678a:	f888 301e 	strb.w	r3, [r8, #30]
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
 800678e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006790:	b113      	cbz	r3, 8006798 <tcp_write+0x394>
    pbuf_free(concat_p);
 8006792:	4618      	mov	r0, r3
 8006794:	f7fd fd00 	bl	8004198 <pbuf_free>
  }
  if (queue != NULL) {
 8006798:	f1b9 0f00 	cmp.w	r9, #0
 800679c:	d002      	beq.n	80067a4 <tcp_write+0x3a0>
    tcp_segs_free(queue);
 800679e:	4648      	mov	r0, r9
 80067a0:	f7fe f950 	bl	8004a44 <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 80067a4:	f04f 30ff 	mov.w	r0, #4294967295
}
 80067a8:	b00d      	add	sp, #52	; 0x34
 80067aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80067ae:	f8dd 9010 	ldr.w	r9, [sp, #16]
 80067b2:	e7e6      	b.n	8006782 <tcp_write+0x37e>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 80067b4:	8973      	ldrh	r3, [r6, #10]
 80067b6:	6870      	ldr	r0, [r6, #4]
 80067b8:	9905      	ldr	r1, [sp, #20]
 80067ba:	462a      	mov	r2, r5
 80067bc:	4418      	add	r0, r3
 80067be:	f004 feaa 	bl	800b516 <memcpy>
        p->len += oversize_used;
 80067c2:	8973      	ldrh	r3, [r6, #10]
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 80067c4:	6832      	ldr	r2, [r6, #0]
      p->tot_len += oversize_used;
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
 80067c6:	442b      	add	r3, r5
 80067c8:	8173      	strh	r3, [r6, #10]
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 80067ca:	2a00      	cmp	r2, #0
 80067cc:	f47f ae85 	bne.w	80064da <tcp_write+0xd6>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 80067d0:	9a07      	ldr	r2, [sp, #28]
 80067d2:	8913      	ldrh	r3, [r2, #8]
 80067d4:	441d      	add	r5, r3
 80067d6:	8115      	strh	r5, [r2, #8]
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 80067d8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 80067da:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 80067de:	f8a8 306a 	strh.w	r3, [r8, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 80067e2:	2e00      	cmp	r6, #0
 80067e4:	d052      	beq.n	800688c <tcp_write+0x488>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 80067e6:	9d07      	ldr	r5, [sp, #28]
 80067e8:	4631      	mov	r1, r6
 80067ea:	6868      	ldr	r0, [r5, #4]
 80067ec:	f7fd fd12 	bl	8004214 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 80067f0:	8933      	ldrh	r3, [r6, #8]
 80067f2:	892a      	ldrh	r2, [r5, #8]
 80067f4:	4413      	add	r3, r2
 80067f6:	812b      	strh	r3, [r5, #8]
 80067f8:	9b07      	ldr	r3, [sp, #28]
 80067fa:	e794      	b.n	8006726 <tcp_write+0x322>
 80067fc:	464c      	mov	r4, r9

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 80067fe:	4620      	mov	r0, r4
 8006800:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8006804:	f7fd fcc8 	bl	8004198 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 8006808:	e7bb      	b.n	8006782 <tcp_write+0x37e>
 800680a:	910a      	str	r1, [sp, #40]	; 0x28
 800680c:	950b      	str	r5, [sp, #44]	; 0x2c
 800680e:	e6b9      	b.n	8006584 <tcp_write+0x180>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 8006810:	2201      	movs	r2, #1
 8006812:	4621      	mov	r1, r4
 8006814:	2003      	movs	r0, #3
 8006816:	f7fd fb67 	bl	8003ee8 <pbuf_alloc>
 800681a:	900a      	str	r0, [sp, #40]	; 0x28
 800681c:	b310      	cbz	r0, 8006864 <tcp_write+0x460>
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
 800681e:	9b05      	ldr	r3, [sp, #20]
 8006820:	442b      	add	r3, r5
 8006822:	6043      	str	r3, [r0, #4]
      }

      pos += seglen;
      queuelen += pbuf_clen(concat_p);
 8006824:	f7fd fce6 	bl	80041f4 <pbuf_clen>
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 8006828:	442c      	add	r4, r5
 800682a:	b2a4      	uxth	r4, r4
      queuelen += pbuf_clen(concat_p);
 800682c:	4438      	add	r0, r7
 800682e:	950b      	str	r5, [sp, #44]	; 0x2c
 8006830:	b287      	uxth	r7, r0
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 8006832:	4625      	mov	r5, r4
 8006834:	9b00      	ldr	r3, [sp, #0]
 8006836:	e6a2      	b.n	800657e <tcp_write+0x17a>

  /* fail on too much data */
  if (len > pcb->snd_buf) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
 8006838:	f898 301e 	ldrb.w	r3, [r8, #30]
 800683c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8006840:	f888 301e 	strb.w	r3, [r8, #30]
    return ERR_MEM;
 8006844:	f04f 30ff 	mov.w	r0, #4294967295
 8006848:	e5f2      	b.n	8006430 <tcp_write+0x2c>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 800684a:	2008      	movs	r0, #8
 800684c:	89ae      	ldrh	r6, [r5, #12]
 800684e:	f7fb f80d 	bl	800186c <lwip_htons>
 8006852:	4330      	orrs	r0, r6
 8006854:	81a8      	strh	r0, [r5, #12]
  }

  return ERR_OK;
 8006856:	4620      	mov	r0, r4
 8006858:	e5ea      	b.n	8006430 <tcp_write+0x2c>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800685a:	4621      	mov	r1, r4
 800685c:	e667      	b.n	800652e <tcp_write+0x12a>
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 800685e:	f06f 000d 	mvn.w	r0, #13
 8006862:	e5e5      	b.n	8006430 <tcp_write+0x2c>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 8006864:	f898 301e 	ldrb.w	r3, [r8, #30]
 8006868:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800686c:	f888 301e 	strb.w	r3, [r8, #30]
 8006870:	e798      	b.n	80067a4 <tcp_write+0x3a0>
  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
 8006872:	4620      	mov	r0, r4
 8006874:	e5dc      	b.n	8006430 <tcp_write+0x2c>
 8006876:	4628      	mov	r0, r5
 8006878:	e5da      	b.n	8006430 <tcp_write+0x2c>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800687a:	9c07      	ldr	r4, [sp, #28]
 800687c:	f04f 0900 	mov.w	r9, #0
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 8006880:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8006882:	2b00      	cmp	r3, #0
 8006884:	d0a8      	beq.n	80067d8 <tcp_write+0x3d4>
 8006886:	461d      	mov	r5, r3
 8006888:	9b07      	ldr	r3, [sp, #28]
 800688a:	e61b      	b.n	80064c4 <tcp_write+0xc0>

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 800688c:	9b07      	ldr	r3, [sp, #28]
 800688e:	2b00      	cmp	r3, #0
 8006890:	f47f af49 	bne.w	8006726 <tcp_write+0x322>
    pcb->unsent = queue;
 8006894:	f8c8 906c 	str.w	r9, [r8, #108]	; 0x6c
 8006898:	e747      	b.n	800672a <tcp_write+0x326>
 800689a:	f8dd 9010 	ldr.w	r9, [sp, #16]
 800689e:	4654      	mov	r4, sl
 80068a0:	e7ee      	b.n	8006880 <tcp_write+0x47c>
 80068a2:	bf00      	nop

080068a4 <tcp_enqueue_flags>:

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 80068a4:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
 80068a8:	2b07      	cmp	r3, #7
 80068aa:	f200 809c 	bhi.w	80069e6 <tcp_enqueue_flags+0x142>
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 80068ae:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 80068b2:	f001 0302 	and.w	r3, r1, #2
 80068b6:	460e      	mov	r6, r1
 80068b8:	f001 0803 	and.w	r8, r1, #3
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 80068bc:	b083      	sub	sp, #12
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 80068be:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80068c2:	2b00      	cmp	r3, #0
 80068c4:	d17a      	bne.n	80069bc <tcp_enqueue_flags+0x118>
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 80068c6:	460f      	mov	r7, r1

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 80068c8:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
 80068cc:	2b00      	cmp	r3, #0
 80068ce:	d07f      	beq.n	80069d0 <tcp_enqueue_flags+0x12c>
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 80068d0:	2200      	movs	r2, #0
 80068d2:	4604      	mov	r4, r0
 80068d4:	4610      	mov	r0, r2
 80068d6:	f7fd fb07 	bl	8003ee8 <pbuf_alloc>
 80068da:	2800      	cmp	r0, #0
 80068dc:	d074      	beq.n	80069c8 <tcp_enqueue_flags+0x124>
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 80068de:	2f00      	cmp	r7, #0
 80068e0:	9001      	str	r0, [sp, #4]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 80068e2:	f04f 0004 	mov.w	r0, #4
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 80068e6:	bf0b      	itete	eq
 80068e8:	f44f 49a0 	moveq.w	r9, #20480	; 0x5000
 80068ec:	f44f 49c0 	movne.w	r9, #24576	; 0x6000
 80068f0:	f04f 0b00 	moveq.w	fp, #0
 80068f4:	4683      	movne	fp, r0
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 80068f6:	f8d4 a05c 	ldr.w	sl, [r4, #92]	; 0x5c
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 80068fa:	f7fd f98f 	bl	8003c1c <memp_malloc>
 80068fe:	9b01      	ldr	r3, [sp, #4]
 8006900:	4605      	mov	r5, r0
 8006902:	2800      	cmp	r0, #0
 8006904:	d05d      	beq.n	80069c2 <tcp_enqueue_flags+0x11e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
 8006906:	7287      	strb	r7, [r0, #10]
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;
 8006908:	891a      	ldrh	r2, [r3, #8]
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
  seg->p = p;
 800690a:	6043      	str	r3, [r0, #4]
  seg->len = p->tot_len - optlen;
 800690c:	ebcb 0b02 	rsb	fp, fp, r2
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
 8006910:	2200      	movs	r2, #0
  seg->p = p;
  seg->len = p->tot_len - optlen;
 8006912:	f8a0 b008 	strh.w	fp, [r0, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 8006916:	2114      	movs	r1, #20
 8006918:	4618      	mov	r0, r3
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
 800691a:	602a      	str	r2, [r5, #0]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 800691c:	f7fd fc06 	bl	800412c <pbuf_header>
 8006920:	4607      	mov	r7, r0
 8006922:	2800      	cmp	r0, #0
 8006924:	d15b      	bne.n	80069de <tcp_enqueue_flags+0x13a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8006926:	686b      	ldr	r3, [r5, #4]
  seg->tcphdr->src = htons(pcb->local_port);
 8006928:	8b60      	ldrh	r0, [r4, #26]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800692a:	f8d3 b004 	ldr.w	fp, [r3, #4]
 800692e:	f8c5 b00c 	str.w	fp, [r5, #12]
  seg->tcphdr->src = htons(pcb->local_port);
 8006932:	f7fa ff9b 	bl	800186c <lwip_htons>
 8006936:	f8ab 0000 	strh.w	r0, [fp]
  seg->tcphdr->dest = htons(pcb->remote_port);
 800693a:	8ba0      	ldrh	r0, [r4, #28]
 800693c:	f8d5 b00c 	ldr.w	fp, [r5, #12]
 8006940:	f7fa ff94 	bl	800186c <lwip_htons>
 8006944:	f8ab 0002 	strh.w	r0, [fp, #2]
  seg->tcphdr->seqno = htonl(seqno);
 8006948:	4650      	mov	r0, sl
 800694a:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 800694e:	f7fa ff95 	bl	800187c <lwip_htonl>
 8006952:	f8ca 0004 	str.w	r0, [sl, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8006956:	ea49 0006 	orr.w	r0, r9, r6
 800695a:	f8d5 900c 	ldr.w	r9, [r5, #12]
 800695e:	f7fa ff85 	bl	800186c <lwip_htons>
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 8006962:	68eb      	ldr	r3, [r5, #12]
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 8006964:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8006966:	f8a9 000c 	strh.w	r0, [r9, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800696a:	749f      	strb	r7, [r3, #18]
 800696c:	74df      	strb	r7, [r3, #19]
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 800696e:	b90a      	cbnz	r2, 8006974 <tcp_enqueue_flags+0xd0>
 8006970:	e033      	b.n	80069da <tcp_enqueue_flags+0x136>
 8006972:	461a      	mov	r2, r3
    pcb->unsent = seg;
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8006974:	6813      	ldr	r3, [r2, #0]
 8006976:	2b00      	cmp	r3, #0
 8006978:	d1fb      	bne.n	8006972 <tcp_enqueue_flags+0xce>
    useg->next = seg;
 800697a:	6015      	str	r5, [r2, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 800697c:	2300      	movs	r3, #0
 800697e:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 8006982:	f1b8 0f00 	cmp.w	r8, #0
 8006986:	d007      	beq.n	8006998 <tcp_enqueue_flags+0xf4>
    pcb->snd_lbb++;
 8006988:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 800698a:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 800698e:	3201      	adds	r2, #1
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 8006990:	3b01      	subs	r3, #1
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 8006992:	65e2      	str	r2, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 8006994:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
 8006998:	07f3      	lsls	r3, r6, #31
 800699a:	d503      	bpl.n	80069a4 <tcp_enqueue_flags+0x100>
    pcb->flags |= TF_FIN;
 800699c:	7fa3      	ldrb	r3, [r4, #30]
 800699e:	f043 0320 	orr.w	r3, r3, #32
 80069a2:	77a3      	strb	r3, [r4, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 80069a4:	6868      	ldr	r0, [r5, #4]
 80069a6:	f7fd fc25 	bl	80041f4 <pbuf_clen>
 80069aa:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 80069ae:	4418      	add	r0, r3
 80069b0:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 80069b4:	2000      	movs	r0, #0
}
 80069b6:	b003      	add	sp, #12
 80069b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 80069bc:	2104      	movs	r1, #4
    optflags = TF_SEG_OPTS_MSS;
 80069be:	2701      	movs	r7, #1
 80069c0:	e782      	b.n	80068c8 <tcp_enqueue_flags+0x24>
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 80069c2:	4618      	mov	r0, r3
 80069c4:	f7fd fbe8 	bl	8004198 <pbuf_free>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
 80069c8:	7fa3      	ldrb	r3, [r4, #30]
 80069ca:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80069ce:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 80069d0:	f04f 30ff 	mov.w	r0, #4294967295
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
}
 80069d4:	b003      	add	sp, #12
 80069d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
    pcb->unsent = seg;
 80069da:	66e5      	str	r5, [r4, #108]	; 0x6c
 80069dc:	e7ce      	b.n	800697c <tcp_enqueue_flags+0xd8>

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 80069de:	4628      	mov	r0, r5
 80069e0:	f7fe f842 	bl	8004a68 <tcp_seg_free>
 80069e4:	e7f0      	b.n	80069c8 <tcp_enqueue_flags+0x124>
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
 80069e6:	7f83      	ldrb	r3, [r0, #30]
 80069e8:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80069ec:	7783      	strb	r3, [r0, #30]
    return ERR_MEM;
 80069ee:	f04f 30ff 	mov.w	r0, #4294967295
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
}
 80069f2:	4770      	bx	lr

080069f4 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 80069f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80069f6:	4604      	mov	r4, r0
 80069f8:	b083      	sub	sp, #12
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 80069fa:	6d00      	ldr	r0, [r0, #80]	; 0x50
 80069fc:	f7fa ff3e 	bl	800187c <lwip_htonl>
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8006a00:	2200      	movs	r2, #0
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 8006a02:	4606      	mov	r6, r0
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8006a04:	2114      	movs	r1, #20
 8006a06:	2001      	movs	r0, #1
 8006a08:	f7fd fa6e 	bl	8003ee8 <pbuf_alloc>
  if (p != NULL) {
 8006a0c:	2800      	cmp	r0, #0
 8006a0e:	d034      	beq.n	8006a7a <tcp_send_empty_ack+0x86>
 8006a10:	4607      	mov	r7, r0
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
 8006a12:	8b60      	ldrh	r0, [r4, #26]
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 8006a14:	687d      	ldr	r5, [r7, #4]
    tcphdr->src = htons(pcb->local_port);
 8006a16:	f7fa ff29 	bl	800186c <lwip_htons>
 8006a1a:	8028      	strh	r0, [r5, #0]
    tcphdr->dest = htons(pcb->remote_port);
 8006a1c:	8ba0      	ldrh	r0, [r4, #28]
 8006a1e:	f7fa ff25 	bl	800186c <lwip_htons>
    tcphdr->seqno = seqno_be;
 8006a22:	606e      	str	r6, [r5, #4]
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
 8006a24:	8068      	strh	r0, [r5, #2]
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 8006a26:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8006a28:	f7fa ff28 	bl	800187c <lwip_htonl>
 8006a2c:	60a8      	str	r0, [r5, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 8006a2e:	f245 0010 	movw	r0, #20496	; 0x5010
 8006a32:	f7fa ff1b 	bl	800186c <lwip_htons>
 8006a36:	81a8      	strh	r0, [r5, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8006a38:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 8006a3a:	f7fa ff17 	bl	800186c <lwip_htons>
    tcphdr->chksum = 0;
 8006a3e:	2600      	movs	r6, #0
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8006a40:	81e8      	strh	r0, [r5, #14]
    tcphdr->chksum = 0;
 8006a42:	742e      	strb	r6, [r5, #16]
 8006a44:	746e      	strb	r6, [r5, #17]
    tcphdr->urgp = 0;
 8006a46:	74ae      	strb	r6, [r5, #18]
 8006a48:	74ee      	strb	r6, [r5, #19]
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8006a4a:	7fa1      	ldrb	r1, [r4, #30]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006a4c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8006a4e:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8006a50:	7a65      	ldrb	r5, [r4, #9]
 8006a52:	7aa3      	ldrb	r3, [r4, #10]
 8006a54:	9500      	str	r5, [sp, #0]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006a56:	4402      	add	r2, r0
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8006a58:	f021 0103 	bic.w	r1, r1, #3
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8006a5c:	2006      	movs	r0, #6
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8006a5e:	77a1      	strb	r1, [r4, #30]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006a60:	6322      	str	r2, [r4, #48]	; 0x30
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8006a62:	4621      	mov	r1, r4
 8006a64:	9001      	str	r0, [sp, #4]
 8006a66:	1d22      	adds	r2, r4, #4
 8006a68:	4638      	mov	r0, r7
 8006a6a:	f7fa fbad 	bl	80011c8 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 8006a6e:	4638      	mov	r0, r7
 8006a70:	f7fd fb92 	bl	8004198 <pbuf_free>

  return ERR_OK;
 8006a74:	4630      	mov	r0, r6
}
 8006a76:	b003      	add	sp, #12
 8006a78:	bdf0      	pop	{r4, r5, r6, r7, pc}
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 8006a7a:	f06f 0001 	mvn.w	r0, #1
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);

  return ERR_OK;
}
 8006a7e:	b003      	add	sp, #12
 8006a80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006a82:	bf00      	nop

08006a84 <tcp_output>:

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8006a84:	4ba4      	ldr	r3, [pc, #656]	; (8006d18 <tcp_output+0x294>)
 8006a86:	681b      	ldr	r3, [r3, #0]
 8006a88:	4298      	cmp	r0, r3
 8006a8a:	f000 8143 	beq.w	8006d14 <tcp_output+0x290>
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 8006a8e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8006a92:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 8006a96:	f8b0 804c 	ldrh.w	r8, [r0, #76]	; 0x4c
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 8006a9a:	7f83      	ldrb	r3, [r0, #30]
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);

  seg = pcb->unsent;
 8006a9c:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8006a9e:	4590      	cmp	r8, r2
 8006aa0:	bf28      	it	cs
 8006aa2:	4690      	movcs	r8, r2
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 8006aa4:	079a      	lsls	r2, r3, #30
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 8006aa6:	b082      	sub	sp, #8
 8006aa8:	4604      	mov	r4, r0
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 8006aaa:	f140 80d5 	bpl.w	8006c58 <tcp_output+0x1d4>
 8006aae:	2d00      	cmp	r5, #0
 8006ab0:	f000 812a 	beq.w	8006d08 <tcp_output+0x284>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 8006ab4:	68eb      	ldr	r3, [r5, #12]
 8006ab6:	6858      	ldr	r0, [r3, #4]
 8006ab8:	f7fa fee2 	bl	8001880 <lwip_ntohl>
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
 8006abc:	892b      	ldrh	r3, [r5, #8]
 8006abe:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8006ac0:	1a9b      	subs	r3, r3, r2
 8006ac2:	4418      	add	r0, r3
 8006ac4:	4580      	cmp	r8, r0
 8006ac6:	f0c0 811f 	bcc.w	8006d08 <tcp_output+0x284>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 8006aca:	6f27      	ldr	r7, [r4, #112]	; 0x70
  if (useg != NULL) {
 8006acc:	b137      	cbz	r7, 8006adc <tcp_output+0x58>
    for (; useg->next != NULL; useg = useg->next);
 8006ace:	683b      	ldr	r3, [r7, #0]
 8006ad0:	2b00      	cmp	r3, #0
 8006ad2:	f040 80c4 	bne.w	8006c5e <tcp_output+0x1da>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8006ad6:	2d00      	cmp	r5, #0
 8006ad8:	f000 8113 	beq.w	8006d02 <tcp_output+0x27e>
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
 8006adc:	f8df 923c 	ldr.w	r9, [pc, #572]	; 8006d1c <tcp_output+0x298>
 8006ae0:	e063      	b.n	8006baa <tcp_output+0x126>
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 8006ae2:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
 8006ae6:	3301      	adds	r3, #1
 8006ae8:	f000 80b3 	beq.w	8006c52 <tcp_output+0x1ce>
    pcb->rtime = 0;
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
 8006aec:	6823      	ldr	r3, [r4, #0]
 8006aee:	b92b      	cbnz	r3, 8006afc <tcp_output+0x78>
    netif = ip_route(&(pcb->remote_ip));
 8006af0:	4630      	mov	r0, r6
 8006af2:	f7fa fa1f 	bl	8000f34 <ip_route>
    if (netif == NULL) {
 8006af6:	b300      	cbz	r0, 8006b3a <tcp_output+0xb6>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 8006af8:	6843      	ldr	r3, [r0, #4]
 8006afa:	6023      	str	r3, [r4, #0]
  }

  if (pcb->rttest == 0) {
 8006afc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006afe:	2b00      	cmp	r3, #0
 8006b00:	f000 80b2 	beq.w	8006c68 <tcp_output+0x1e4>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8006b04:	6868      	ldr	r0, [r5, #4]
 8006b06:	68ea      	ldr	r2, [r5, #12]
 8006b08:	6843      	ldr	r3, [r0, #4]

  seg->p->len -= len;
  seg->p->tot_len -= len;
 8006b0a:	8901      	ldrh	r1, [r0, #8]
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
 8006b0c:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;
 8006b10:	6042      	str	r2, [r0, #4]
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8006b12:	1ad3      	subs	r3, r2, r3
 8006b14:	b29b      	uxth	r3, r3

  seg->p->len -= len;
 8006b16:	ebc3 0e0e 	rsb	lr, r3, lr
  seg->p->tot_len -= len;
 8006b1a:	1acb      	subs	r3, r1, r3

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
 8006b1c:	2100      	movs	r1, #0
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
 8006b1e:	f8a0 e00a 	strh.w	lr, [r0, #10]
  seg->p->tot_len -= len;
 8006b22:	8103      	strh	r3, [r0, #8]

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
 8006b24:	7411      	strb	r1, [r2, #16]
 8006b26:	7451      	strb	r1, [r2, #17]

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8006b28:	7a62      	ldrb	r2, [r4, #9]
 8006b2a:	7aa3      	ldrb	r3, [r4, #10]
 8006b2c:	9200      	str	r2, [sp, #0]
 8006b2e:	2106      	movs	r1, #6
 8006b30:	9101      	str	r1, [sp, #4]
 8006b32:	4632      	mov	r2, r6
 8006b34:	4621      	mov	r1, r4
 8006b36:	f7fa fb47 	bl	80011c8 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8006b3a:	68eb      	ldr	r3, [r5, #12]
 8006b3c:	6858      	ldr	r0, [r3, #4]
 8006b3e:	f7fa fe9f 	bl	8001880 <lwip_ntohl>
 8006b42:	68eb      	ldr	r3, [r5, #12]
 8006b44:	f8b5 a008 	ldrh.w	sl, [r5, #8]
 8006b48:	4606      	mov	r6, r0
 8006b4a:	8998      	ldrh	r0, [r3, #12]
 8006b4c:	f7fa fe92 	bl	8001874 <lwip_ntohs>
 8006b50:	f010 0003 	ands.w	r0, r0, #3
 8006b54:	bf18      	it	ne
 8006b56:	2001      	movne	r0, #1
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8006b58:	6d23      	ldr	r3, [r4, #80]	; 0x50
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8006b5a:	4450      	add	r0, sl
 8006b5c:	4430      	add	r0, r6
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8006b5e:	1a1b      	subs	r3, r3, r0
 8006b60:	2b00      	cmp	r3, #0
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 8006b62:	68eb      	ldr	r3, [r5, #12]
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
 8006b64:	bfb8      	it	lt
 8006b66:	6520      	strlt	r0, [r4, #80]	; 0x50
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 8006b68:	8998      	ldrh	r0, [r3, #12]
 8006b6a:	892e      	ldrh	r6, [r5, #8]
 8006b6c:	f7fa fe82 	bl	8001874 <lwip_ntohs>
 8006b70:	f010 0003 	ands.w	r0, r0, #3
 8006b74:	bf18      	it	ne
 8006b76:	2001      	movne	r0, #1
 8006b78:	42f0      	cmn	r0, r6
 8006b7a:	f000 80a4 	beq.w	8006cc6 <tcp_output+0x242>
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 8006b7e:	6f23      	ldr	r3, [r4, #112]	; 0x70
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
 8006b80:	2200      	movs	r2, #0
 8006b82:	602a      	str	r2, [r5, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 8006b84:	2b00      	cmp	r3, #0
 8006b86:	d078      	beq.n	8006c7a <tcp_output+0x1f6>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 8006b88:	68eb      	ldr	r3, [r5, #12]
 8006b8a:	6858      	ldr	r0, [r3, #4]
 8006b8c:	f7fa fe78 	bl	8001880 <lwip_ntohl>
 8006b90:	68fb      	ldr	r3, [r7, #12]
 8006b92:	4606      	mov	r6, r0
 8006b94:	6858      	ldr	r0, [r3, #4]
 8006b96:	f7fa fe73 	bl	8001880 <lwip_ntohl>
 8006b9a:	1a30      	subs	r0, r6, r0
 8006b9c:	2800      	cmp	r0, #0
 8006b9e:	db76      	blt.n	8006c8e <tcp_output+0x20a>
          }
          seg->next = (*cur_seg);
          (*cur_seg) = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 8006ba0:	603d      	str	r5, [r7, #0]
 8006ba2:	462f      	mov	r7, r5
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
 8006ba4:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8006ba6:	2d00      	cmp	r5, #0
 8006ba8:	d06c      	beq.n	8006c84 <tcp_output+0x200>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 8006baa:	68eb      	ldr	r3, [r5, #12]
 8006bac:	6858      	ldr	r0, [r3, #4]
 8006bae:	f7fa fe67 	bl	8001880 <lwip_ntohl>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8006bb2:	892b      	ldrh	r3, [r5, #8]
 8006bb4:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8006bb6:	1a9b      	subs	r3, r3, r2
 8006bb8:	4418      	add	r0, r3
 8006bba:	4580      	cmp	r8, r0
 8006bbc:	f0c0 80a1 	bcc.w	8006d02 <tcp_output+0x27e>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
 8006bc0:	68eb      	ldr	r3, [r5, #12]
 8006bc2:	8998      	ldrh	r0, [r3, #12]
 8006bc4:	f7fa fe56 	bl	8001874 <lwip_ntohs>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 8006bc8:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006bca:	b14b      	cbz	r3, 8006be0 <tcp_output+0x15c>
 8006bcc:	7fa3      	ldrb	r3, [r4, #30]
 8006bce:	f013 0f44 	tst.w	r3, #68	; 0x44
 8006bd2:	d105      	bne.n	8006be0 <tcp_output+0x15c>
 8006bd4:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8006bd6:	2a00      	cmp	r2, #0
 8006bd8:	d07d      	beq.n	8006cd6 <tcp_output+0x252>
 8006bda:	6811      	ldr	r1, [r2, #0]
 8006bdc:	2900      	cmp	r1, #0
 8006bde:	d076      	beq.n	8006cce <tcp_output+0x24a>
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
 8006be0:	7e23      	ldrb	r3, [r4, #24]
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
 8006be2:	682a      	ldr	r2, [r5, #0]
 8006be4:	66e2      	str	r2, [r4, #108]	; 0x6c

    if (pcb->state != SYN_SENT) {
 8006be6:	2b02      	cmp	r3, #2
 8006be8:	d00d      	beq.n	8006c06 <tcp_output+0x182>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8006bea:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 8006bee:	2010      	movs	r0, #16
 8006bf0:	f8ba 600c 	ldrh.w	r6, [sl, #12]
 8006bf4:	f7fa fe3a 	bl	800186c <lwip_htons>
 8006bf8:	4330      	orrs	r0, r6
 8006bfa:	f8aa 000c 	strh.w	r0, [sl, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8006bfe:	7fa3      	ldrb	r3, [r4, #30]
 8006c00:	f023 0303 	bic.w	r3, r3, #3
 8006c04:	77a3      	strb	r3, [r4, #30]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 8006c06:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8006c08:	68ee      	ldr	r6, [r5, #12]
 8006c0a:	f7fa fe37 	bl	800187c <lwip_htonl>
 8006c0e:	60b0      	str	r0, [r6, #8]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8006c10:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 8006c12:	68ee      	ldr	r6, [r5, #12]
 8006c14:	f7fa fe2a 	bl	800186c <lwip_htons>

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006c18:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8006c1a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8006c1c:	81f0      	strh	r0, [r6, #14]

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006c1e:	4413      	add	r3, r2
 8006c20:	6323      	str	r3, [r4, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8006c22:	7aab      	ldrb	r3, [r5, #10]
 8006c24:	07db      	lsls	r3, r3, #31
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 8006c26:	f104 0604 	add.w	r6, r4, #4
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8006c2a:	f57f af5a 	bpl.w	8006ae2 <tcp_output+0x5e>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 8006c2e:	4631      	mov	r1, r6
 8006c30:	f240 50b4 	movw	r0, #1460	; 0x5b4

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 8006c34:	f8d5 a00c 	ldr.w	sl, [r5, #12]
  if (seg->flags & TF_SEG_OPTS_MSS) {
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 8006c38:	f7fe fc26 	bl	8005488 <tcp_eff_send_mss>
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 8006c3c:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 8006c40:	f7fa fe1c 	bl	800187c <lwip_htonl>
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 8006c44:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 8006c48:	f8ca 0014 	str.w	r0, [sl, #20]
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 8006c4c:	3301      	adds	r3, #1
 8006c4e:	f47f af4d 	bne.w	8006aec <tcp_output+0x68>
    pcb->rtime = 0;
 8006c52:	2300      	movs	r3, #0
 8006c54:	86a3      	strh	r3, [r4, #52]	; 0x34
 8006c56:	e749      	b.n	8006aec <tcp_output+0x68>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 8006c58:	6f07      	ldr	r7, [r0, #112]	; 0x70
  if (useg != NULL) {
 8006c5a:	b90f      	cbnz	r7, 8006c60 <tcp_output+0x1dc>
 8006c5c:	e73b      	b.n	8006ad6 <tcp_output+0x52>
 8006c5e:	461f      	mov	r7, r3
    for (; useg->next != NULL; useg = useg->next);
 8006c60:	683b      	ldr	r3, [r7, #0]
 8006c62:	2b00      	cmp	r3, #0
 8006c64:	d1fb      	bne.n	8006c5e <tcp_output+0x1da>
 8006c66:	e736      	b.n	8006ad6 <tcp_output+0x52>
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 8006c68:	68eb      	ldr	r3, [r5, #12]
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
 8006c6a:	f8d9 2000 	ldr.w	r2, [r9]
 8006c6e:	63a2      	str	r2, [r4, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 8006c70:	6858      	ldr	r0, [r3, #4]
 8006c72:	f7fa fe05 	bl	8001880 <lwip_ntohl>
 8006c76:	63e0      	str	r0, [r4, #60]	; 0x3c
 8006c78:	e744      	b.n	8006b04 <tcp_output+0x80>
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
        pcb->unacked = seg;
 8006c7a:	6725      	str	r5, [r4, #112]	; 0x70
 8006c7c:	462f      	mov	r7, r5
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
 8006c7e:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8006c80:	2d00      	cmp	r5, #0
 8006c82:	d192      	bne.n	8006baa <tcp_output+0x126>
 8006c84:	7fa3      	ldrb	r3, [r4, #30]
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8006c86:	2200      	movs	r2, #0
 8006c88:	f8a4 206a 	strh.w	r2, [r4, #106]	; 0x6a
 8006c8c:	e032      	b.n	8006cf4 <tcp_output+0x270>
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 8006c8e:	6f23      	ldr	r3, [r4, #112]	; 0x70
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8006c90:	f104 0a70 	add.w	sl, r4, #112	; 0x70
          while (*cur_seg &&
 8006c94:	b92b      	cbnz	r3, 8006ca2 <tcp_output+0x21e>
 8006c96:	e012      	b.n	8006cbe <tcp_output+0x23a>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
 8006c98:	f8da a000 	ldr.w	sl, [sl]
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 8006c9c:	f8da 3000 	ldr.w	r3, [sl]
 8006ca0:	b16b      	cbz	r3, 8006cbe <tcp_output+0x23a>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8006ca2:	68db      	ldr	r3, [r3, #12]
 8006ca4:	6858      	ldr	r0, [r3, #4]
 8006ca6:	f7fa fdeb 	bl	8001880 <lwip_ntohl>
 8006caa:	68eb      	ldr	r3, [r5, #12]
 8006cac:	4606      	mov	r6, r0
 8006cae:	6858      	ldr	r0, [r3, #4]
 8006cb0:	f7fa fde6 	bl	8001880 <lwip_ntohl>
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 8006cb4:	1a30      	subs	r0, r6, r0
 8006cb6:	2800      	cmp	r0, #0
 8006cb8:	dbee      	blt.n	8006c98 <tcp_output+0x214>
 8006cba:	f8da 3000 	ldr.w	r3, [sl]
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
 8006cbe:	602b      	str	r3, [r5, #0]
          (*cur_seg) = seg;
 8006cc0:	f8ca 5000 	str.w	r5, [sl]
 8006cc4:	e76e      	b.n	8006ba4 <tcp_output+0x120>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 8006cc6:	4628      	mov	r0, r5
 8006cc8:	f7fd fece 	bl	8004a68 <tcp_seg_free>
 8006ccc:	e76a      	b.n	8006ba4 <tcp_output+0x120>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 8006cce:	8910      	ldrh	r0, [r2, #8]
 8006cd0:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
 8006cd2:	4288      	cmp	r0, r1
 8006cd4:	d284      	bcs.n	8006be0 <tcp_output+0x15c>
 8006cd6:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
 8006cda:	2900      	cmp	r1, #0
 8006cdc:	d080      	beq.n	8006be0 <tcp_output+0x15c>
 8006cde:	f8b4 1068 	ldrh.w	r1, [r4, #104]	; 0x68
 8006ce2:	2907      	cmp	r1, #7
 8006ce4:	f63f af7c 	bhi.w	8006be0 <tcp_output+0x15c>
 8006ce8:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 8006cec:	f47f af78 	bne.w	8006be0 <tcp_output+0x15c>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 8006cf0:	2a00      	cmp	r2, #0
 8006cf2:	d0c8      	beq.n	8006c86 <tcp_output+0x202>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 8006cf4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  return ERR_OK;
}
 8006cf8:	2000      	movs	r0, #0
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 8006cfa:	77a3      	strb	r3, [r4, #30]
  return ERR_OK;
}
 8006cfc:	b002      	add	sp, #8
 8006cfe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006d02:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8006d04:	7fa3      	ldrb	r3, [r4, #30]
 8006d06:	e7f3      	b.n	8006cf0 <tcp_output+0x26c>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 8006d08:	4620      	mov	r0, r4
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
 8006d0a:	b002      	add	sp, #8
 8006d0c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 8006d10:	f7ff be70 	b.w	80069f4 <tcp_send_empty_ack>
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
 8006d14:	2000      	movs	r0, #0
 8006d16:	4770      	bx	lr
 8006d18:	20005760 	.word	0x20005760
 8006d1c:	2000574c 	.word	0x2000574c

08006d20 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 8006d20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006d24:	b082      	sub	sp, #8
 8006d26:	4681      	mov	r9, r0
 8006d28:	460d      	mov	r5, r1
 8006d2a:	4617      	mov	r7, r2
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 8006d2c:	2114      	movs	r1, #20
 8006d2e:	2200      	movs	r2, #0
 8006d30:	2001      	movs	r0, #1
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 8006d32:	4698      	mov	r8, r3
 8006d34:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
 8006d38:	f8bd a02c 	ldrh.w	sl, [sp, #44]	; 0x2c
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 8006d3c:	f7fd f8d4 	bl	8003ee8 <pbuf_alloc>
  if (p == NULL) {
 8006d40:	b388      	cbz	r0, 8006da6 <tcp_rst+0x86>
 8006d42:	4606      	mov	r6, r0
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
 8006d44:	4620      	mov	r0, r4
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 8006d46:	6874      	ldr	r4, [r6, #4]
  tcphdr->src = htons(local_port);
 8006d48:	f7fa fd90 	bl	800186c <lwip_htons>
 8006d4c:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = htons(remote_port);
 8006d4e:	4650      	mov	r0, sl
 8006d50:	f7fa fd8c 	bl	800186c <lwip_htons>
 8006d54:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = htonl(seqno);
 8006d56:	4648      	mov	r0, r9
 8006d58:	f7fa fd90 	bl	800187c <lwip_htonl>
 8006d5c:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = htonl(ackno);
 8006d5e:	4628      	mov	r0, r5
 8006d60:	f7fa fd8c 	bl	800187c <lwip_htonl>
 8006d64:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 8006d66:	f245 0014 	movw	r0, #20500	; 0x5014
 8006d6a:	f7fa fd7f 	bl	800186c <lwip_htons>
  tcphdr->wnd = PP_HTONS(TCP_WND);
 8006d6e:	2500      	movs	r5, #0
 8006d70:	f04f 0c0b 	mov.w	ip, #11
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 8006d74:	f04f 0e06 	mov.w	lr, #6
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  tcphdr->wnd = PP_HTONS(TCP_WND);
 8006d78:	2368      	movs	r3, #104	; 0x68
  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 8006d7a:	81a0      	strh	r0, [r4, #12]
  tcphdr->wnd = PP_HTONS(TCP_WND);
 8006d7c:	73e3      	strb	r3, [r4, #15]
 8006d7e:	f884 c00e 	strb.w	ip, [r4, #14]
  tcphdr->chksum = 0;
 8006d82:	7425      	strb	r5, [r4, #16]
 8006d84:	7465      	strb	r5, [r4, #17]
  tcphdr->urgp = 0;
 8006d86:	74a5      	strb	r5, [r4, #18]
 8006d88:	74e5      	strb	r5, [r4, #19]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 8006d8a:	4642      	mov	r2, r8
 8006d8c:	4639      	mov	r1, r7
 8006d8e:	23ff      	movs	r3, #255	; 0xff
 8006d90:	e88d 4020 	stmia.w	sp, {r5, lr}
 8006d94:	4630      	mov	r0, r6
 8006d96:	f7fa fa17 	bl	80011c8 <ip_output>
  pbuf_free(p);
 8006d9a:	4630      	mov	r0, r6
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8006d9c:	b002      	add	sp, #8
 8006d9e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
 8006da2:	f7fd b9f9 	b.w	8004198 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8006da6:	b002      	add	sp, #8
 8006da8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08006dac <tcp_rexmit_rto>:
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 8006dac:	6f01      	ldr	r1, [r0, #112]	; 0x70
 8006dae:	b1a1      	cbz	r1, 8006dda <tcp_rexmit_rto+0x2e>
 8006db0:	460a      	mov	r2, r1
 8006db2:	e000      	b.n	8006db6 <tcp_rexmit_rto+0xa>
 8006db4:	461a      	mov	r2, r3
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 8006db6:	6813      	ldr	r3, [r2, #0]
 8006db8:	2b00      	cmp	r3, #0
 8006dba:	d1fb      	bne.n	8006db4 <tcp_rexmit_rto+0x8>
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 8006dbc:	b410      	push	{r4}
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8006dbe:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 8006dc0:	6014      	str	r4, [r2, #0]
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 8006dc2:	f890 2046 	ldrb.w	r2, [r0, #70]	; 0x46
  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8006dc6:	66c1      	str	r1, [r0, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 8006dc8:	3201      	adds	r2, #1
 8006dca:	f880 2046 	strb.w	r2, [r0, #70]	; 0x46
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 8006dce:	6703      	str	r3, [r0, #112]	; 0x70

  /* increment number of retransmissions */
  ++pcb->nrtx;

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8006dd0:	6383      	str	r3, [r0, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
}
 8006dd2:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
 8006dd6:	f7ff be55 	b.w	8006a84 <tcp_output>
 8006dda:	4770      	bx	lr

08006ddc <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 8006ddc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 8006dde:	6f06      	ldr	r6, [r0, #112]	; 0x70
 8006de0:	b316      	cbz	r6, 8006e28 <tcp_rexmit+0x4c>
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 8006de2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 8006de4:	6832      	ldr	r2, [r6, #0]
 8006de6:	6702      	str	r2, [r0, #112]	; 0x70
 8006de8:	4607      	mov	r7, r0

  cur_seg = &(pcb->unsent);
 8006dea:	f100 056c 	add.w	r5, r0, #108	; 0x6c
  while (*cur_seg &&
 8006dee:	b91b      	cbnz	r3, 8006df8 <tcp_rexmit+0x1c>
 8006df0:	e00f      	b.n	8006e12 <tcp_rexmit+0x36>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
 8006df2:	682d      	ldr	r5, [r5, #0]
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 8006df4:	682b      	ldr	r3, [r5, #0]
 8006df6:	b163      	cbz	r3, 8006e12 <tcp_rexmit+0x36>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8006df8:	68db      	ldr	r3, [r3, #12]
 8006dfa:	6858      	ldr	r0, [r3, #4]
 8006dfc:	f7fa fd40 	bl	8001880 <lwip_ntohl>
 8006e00:	68f3      	ldr	r3, [r6, #12]
 8006e02:	4604      	mov	r4, r0
 8006e04:	6858      	ldr	r0, [r3, #4]
 8006e06:	f7fa fd3b 	bl	8001880 <lwip_ntohl>
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 8006e0a:	1a20      	subs	r0, r4, r0
 8006e0c:	2800      	cmp	r0, #0
 8006e0e:	dbf0      	blt.n	8006df2 <tcp_rexmit+0x16>
 8006e10:	682b      	ldr	r3, [r5, #0]
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 8006e12:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 8006e14:	602e      	str	r6, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8006e16:	6833      	ldr	r3, [r6, #0]
 8006e18:	b13b      	cbz	r3, 8006e2a <tcp_rexmit+0x4e>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 8006e1a:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8006e1e:	2200      	movs	r2, #0
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 8006e20:	3301      	adds	r3, #1
 8006e22:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8006e26:	63ba      	str	r2, [r7, #56]	; 0x38
 8006e28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  seg->next = *cur_seg;
  *cur_seg = seg;
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8006e2a:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 8006e2e:	e7f4      	b.n	8006e1a <tcp_rexmit+0x3e>

08006e30 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 8006e30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 8006e32:	6f07      	ldr	r7, [r0, #112]	; 0x70
 8006e34:	b117      	cbz	r7, 8006e3c <tcp_rexmit_fast+0xc>
 8006e36:	7f83      	ldrb	r3, [r0, #30]
 8006e38:	075b      	lsls	r3, r3, #29
 8006e3a:	d500      	bpl.n	8006e3e <tcp_rexmit_fast+0xe>
 8006e3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 8006e3e:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 8006e40:	683a      	ldr	r2, [r7, #0]
 8006e42:	6702      	str	r2, [r0, #112]	; 0x70
 8006e44:	4606      	mov	r6, r0

  cur_seg = &(pcb->unsent);
 8006e46:	f100 056c 	add.w	r5, r0, #108	; 0x6c
  while (*cur_seg &&
 8006e4a:	b91b      	cbnz	r3, 8006e54 <tcp_rexmit_fast+0x24>
 8006e4c:	e00f      	b.n	8006e6e <tcp_rexmit_fast+0x3e>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
 8006e4e:	682d      	ldr	r5, [r5, #0]
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 8006e50:	682b      	ldr	r3, [r5, #0]
 8006e52:	b163      	cbz	r3, 8006e6e <tcp_rexmit_fast+0x3e>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8006e54:	68db      	ldr	r3, [r3, #12]
 8006e56:	6858      	ldr	r0, [r3, #4]
 8006e58:	f7fa fd12 	bl	8001880 <lwip_ntohl>
 8006e5c:	68fb      	ldr	r3, [r7, #12]
 8006e5e:	4604      	mov	r4, r0
 8006e60:	6858      	ldr	r0, [r3, #4]
 8006e62:	f7fa fd0d 	bl	8001880 <lwip_ntohl>
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 8006e66:	1a20      	subs	r0, r4, r0
 8006e68:	2800      	cmp	r0, #0
 8006e6a:	dbf0      	blt.n	8006e4e <tcp_rexmit_fast+0x1e>
 8006e6c:	682b      	ldr	r3, [r5, #0]
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 8006e6e:	603b      	str	r3, [r7, #0]
  *cur_seg = seg;
 8006e70:	602f      	str	r7, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8006e72:	683b      	ldr	r3, [r7, #0]
 8006e74:	b313      	cbz	r3, 8006ebc <tcp_rexmit_fast+0x8c>
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 8006e76:	f8b6 304c 	ldrh.w	r3, [r6, #76]	; 0x4c
 8006e7a:	f8b6 1060 	ldrh.w	r1, [r6, #96]	; 0x60
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 8006e7e:	f896 2046 	ldrb.w	r2, [r6, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8006e82:	2000      	movs	r0, #0
 8006e84:	63b0      	str	r0, [r6, #56]	; 0x38
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 8006e86:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 8006e88:	428b      	cmp	r3, r1
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 8006e8a:	f102 0201 	add.w	r2, r2, #1
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
      pcb->ssthresh = pcb->snd_wnd / 2;
 8006e8e:	bf8c      	ite	hi
 8006e90:	084b      	lsrhi	r3, r1, #1
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 8006e92:	085b      	lsrls	r3, r3, #1
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 8006e94:	f886 2046 	strb.w	r2, [r6, #70]	; 0x46
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 8006e98:	0042      	lsls	r2, r0, #1
 8006e9a:	4293      	cmp	r3, r2
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    pcb->flags |= TF_INFR;
 8006e9c:	7fb1      	ldrb	r1, [r6, #30]
 8006e9e:	f8a6 304e 	strh.w	r3, [r6, #78]	; 0x4e
    if (pcb->ssthresh < 2*pcb->mss) {
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 8006ea2:	bfb8      	it	lt
 8006ea4:	b293      	uxthlt	r3, r2
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8006ea6:	4402      	add	r2, r0
    if (pcb->ssthresh < 2*pcb->mss) {
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 8006ea8:	bfb8      	it	lt
 8006eaa:	f8a6 304e 	strhlt.w	r3, [r6, #78]	; 0x4e
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8006eae:	4413      	add	r3, r2
    pcb->flags |= TF_INFR;
 8006eb0:	f041 0204 	orr.w	r2, r1, #4
 8006eb4:	77b2      	strb	r2, [r6, #30]
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8006eb6:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
 8006eba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  seg->next = *cur_seg;
  *cur_seg = seg;
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8006ebc:	f8a6 306a 	strh.w	r3, [r6, #106]	; 0x6a
 8006ec0:	e7d9      	b.n	8006e76 <tcp_rexmit_fast+0x46>
 8006ec2:	bf00      	nop

08006ec4 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 8006ec4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006ec6:	4604      	mov	r4, r0
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 8006ec8:	6d00      	ldr	r0, [r0, #80]	; 0x50
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 8006eca:	b083      	sub	sp, #12
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 8006ecc:	3801      	subs	r0, #1
 8006ece:	f7fa fcd5 	bl	800187c <lwip_htonl>
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8006ed2:	2200      	movs	r2, #0
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 8006ed4:	4607      	mov	r7, r0
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8006ed6:	2114      	movs	r1, #20
 8006ed8:	2001      	movs	r0, #1
 8006eda:	f7fd f805 	bl	8003ee8 <pbuf_alloc>
  if (p != NULL) {
 8006ede:	b378      	cbz	r0, 8006f40 <tcp_keepalive+0x7c>
 8006ee0:	4606      	mov	r6, r0
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
 8006ee2:	8b60      	ldrh	r0, [r4, #26]
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 8006ee4:	6875      	ldr	r5, [r6, #4]
    tcphdr->src = htons(pcb->local_port);
 8006ee6:	f7fa fcc1 	bl	800186c <lwip_htons>
 8006eea:	8028      	strh	r0, [r5, #0]
    tcphdr->dest = htons(pcb->remote_port);
 8006eec:	8ba0      	ldrh	r0, [r4, #28]
 8006eee:	f7fa fcbd 	bl	800186c <lwip_htons>
    tcphdr->seqno = seqno_be;
 8006ef2:	606f      	str	r7, [r5, #4]
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
 8006ef4:	8068      	strh	r0, [r5, #2]
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 8006ef6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8006ef8:	f7fa fcc0 	bl	800187c <lwip_htonl>
 8006efc:	60a8      	str	r0, [r5, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 8006efe:	f245 0010 	movw	r0, #20496	; 0x5010
 8006f02:	f7fa fcb3 	bl	800186c <lwip_htons>
 8006f06:	81a8      	strh	r0, [r5, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8006f08:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 8006f0a:	f7fa fcaf 	bl	800186c <lwip_htons>
    tcphdr->chksum = 0;
 8006f0e:	2200      	movs	r2, #0
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8006f10:	81e8      	strh	r0, [r5, #14]
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006f12:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
 8006f14:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
 8006f16:	742a      	strb	r2, [r5, #16]
 8006f18:	746a      	strb	r2, [r5, #17]
    tcphdr->urgp = 0;
 8006f1a:	74aa      	strb	r2, [r5, #18]
 8006f1c:	74ea      	strb	r2, [r5, #19]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8006f1e:	7aa3      	ldrb	r3, [r4, #10]
 8006f20:	9200      	str	r2, [sp, #0]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006f22:	1842      	adds	r2, r0, r1
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8006f24:	2106      	movs	r1, #6
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006f26:	6322      	str	r2, [r4, #48]	; 0x30
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8006f28:	4630      	mov	r0, r6
 8006f2a:	9101      	str	r1, [sp, #4]
 8006f2c:	1d22      	adds	r2, r4, #4
 8006f2e:	4621      	mov	r1, r4
 8006f30:	f7fa f94a 	bl	80011c8 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 8006f34:	4630      	mov	r0, r6

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8006f36:	b003      	add	sp, #12
 8006f38:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 8006f3c:	f7fd b92c 	b.w	8004198 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8006f40:	b003      	add	sp, #12
 8006f42:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006f44 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8006f44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 8006f48:	6f06      	ldr	r6, [r0, #112]	; 0x70
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8006f4a:	b083      	sub	sp, #12
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
 8006f4c:	2e00      	cmp	r6, #0
 8006f4e:	d068      	beq.n	8007022 <tcp_zero_window_probe+0xde>
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8006f50:	68f3      	ldr	r3, [r6, #12]
 8006f52:	4604      	mov	r4, r0
 8006f54:	8998      	ldrh	r0, [r3, #12]
 8006f56:	f7fa fc8d 	bl	8001874 <lwip_ntohs>
 8006f5a:	f010 0001 	ands.w	r0, r0, #1
 8006f5e:	d14b      	bne.n	8006ff8 <tcp_zero_window_probe+0xb4>
 8006f60:	4680      	mov	r8, r0
 8006f62:	2115      	movs	r1, #21
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8006f64:	68f3      	ldr	r3, [r6, #12]
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8006f66:	2200      	movs	r2, #0
 8006f68:	2001      	movs	r0, #1

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8006f6a:	f8d3 9004 	ldr.w	r9, [r3, #4]
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8006f6e:	f7fc ffbb 	bl	8003ee8 <pbuf_alloc>
  if (p != NULL) {
 8006f72:	4607      	mov	r7, r0
 8006f74:	2800      	cmp	r0, #0
 8006f76:	d057      	beq.n	8007028 <tcp_zero_window_probe+0xe4>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
 8006f78:	8b60      	ldrh	r0, [r4, #26]
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 8006f7a:	687d      	ldr	r5, [r7, #4]
    tcphdr->src = htons(pcb->local_port);
 8006f7c:	f7fa fc76 	bl	800186c <lwip_htons>
 8006f80:	8028      	strh	r0, [r5, #0]
    tcphdr->dest = htons(pcb->remote_port);
 8006f82:	8ba0      	ldrh	r0, [r4, #28]
 8006f84:	f7fa fc72 	bl	800186c <lwip_htons>
    tcphdr->seqno = seqno_be;
 8006f88:	f8c5 9004 	str.w	r9, [r5, #4]
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
 8006f8c:	8068      	strh	r0, [r5, #2]
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 8006f8e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8006f90:	f7fa fc74 	bl	800187c <lwip_htonl>
 8006f94:	60a8      	str	r0, [r5, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 8006f96:	f245 0010 	movw	r0, #20496	; 0x5010
 8006f9a:	f7fa fc67 	bl	800186c <lwip_htons>
 8006f9e:	81a8      	strh	r0, [r5, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8006fa0:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 8006fa2:	f7fa fc63 	bl	800186c <lwip_htons>
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006fa6:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
 8006fa8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8006faa:	f8d7 9004 	ldr.w	r9, [r7, #4]
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8006fae:	81e8      	strh	r0, [r5, #14]
    tcphdr->chksum = 0;
 8006fb0:	2300      	movs	r3, #0
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006fb2:	440a      	add	r2, r1
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
 8006fb4:	742b      	strb	r3, [r5, #16]
 8006fb6:	746b      	strb	r3, [r5, #17]
    tcphdr->urgp = 0;
 8006fb8:	74ab      	strb	r3, [r5, #18]
 8006fba:	74eb      	strb	r3, [r5, #19]

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8006fbc:	6322      	str	r2, [r4, #48]	; 0x30
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

  if (is_fin) {
 8006fbe:	f1b8 0f00 	cmp.w	r8, #0
 8006fc2:	d023      	beq.n	800700c <tcp_zero_window_probe+0xc8>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8006fc4:	2011      	movs	r0, #17
 8006fc6:	f9b9 500c 	ldrsh.w	r5, [r9, #12]
 8006fca:	f7fa fc4f 	bl	800186c <lwip_htons>
 8006fce:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8006fd2:	4328      	orrs	r0, r5
 8006fd4:	f8a9 000c 	strh.w	r0, [r9, #12]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8006fd8:	2100      	movs	r1, #0
 8006fda:	2206      	movs	r2, #6
 8006fdc:	7aa3      	ldrb	r3, [r4, #10]
 8006fde:	4638      	mov	r0, r7
 8006fe0:	e88d 0006 	stmia.w	sp, {r1, r2}
 8006fe4:	1d22      	adds	r2, r4, #4
 8006fe6:	4621      	mov	r1, r4
 8006fe8:	f7fa f8ee 	bl	80011c8 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 8006fec:	4638      	mov	r0, r7

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8006fee:	b003      	add	sp, #12
 8006ff0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 8006ff4:	f7fd b8d0 	b.w	8004198 <pbuf_free>
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8006ff8:	8933      	ldrh	r3, [r6, #8]
 8006ffa:	2b00      	cmp	r3, #0
 8006ffc:	bf15      	itete	ne
 8006ffe:	2115      	movne	r1, #21
 8007000:	2114      	moveq	r1, #20
 8007002:	f04f 0800 	movne.w	r8, #0
 8007006:	f04f 0801 	moveq.w	r8, #1
 800700a:	e7ab      	b.n	8006f64 <tcp_zero_window_probe+0x20>
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 800700c:	6870      	ldr	r0, [r6, #4]
 800700e:	8932      	ldrh	r2, [r6, #8]
 8007010:	8903      	ldrh	r3, [r0, #8]
 8007012:	1a9b      	subs	r3, r3, r2
 8007014:	f109 0114 	add.w	r1, r9, #20
 8007018:	b29b      	uxth	r3, r3
 800701a:	2201      	movs	r2, #1
 800701c:	f7fd f992 	bl	8004344 <pbuf_copy_partial>
 8007020:	e7da      	b.n	8006fd8 <tcp_zero_window_probe+0x94>
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
    seg = pcb->unsent;
 8007022:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  }
  if(seg == NULL) {
 8007024:	2e00      	cmp	r6, #0
 8007026:	d193      	bne.n	8006f50 <tcp_zero_window_probe+0xc>
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8007028:	b003      	add	sp, #12
 800702a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800702e:	bf00      	nop

08007030 <tcp_timer_needed>:

#else /* LWIP_TIMERS */
/* Satisfy the TCP code which calls this function */
void
tcp_timer_needed(void)
{
 8007030:	4770      	bx	lr
 8007032:	bf00      	nop

08007034 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8007034:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = (struct ip_hdr *)p->payload;
 8007038:	6847      	ldr	r7, [r0, #4]

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 800703a:	8903      	ldrh	r3, [r0, #8]
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 800703c:	4688      	mov	r8, r1
 800703e:	7839      	ldrb	r1, [r7, #0]
 8007040:	f001 010f 	and.w	r1, r1, #15

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 8007044:	1c8a      	adds	r2, r1, #2
 8007046:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 800704a:	b085      	sub	sp, #20
 800704c:	4604      	mov	r4, r0

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 800704e:	db05      	blt.n	800705c <udp_input+0x28>
 8007050:	0089      	lsls	r1, r1, #2
 8007052:	4249      	negs	r1, r1
 8007054:	f7fd f86a 	bl	800412c <pbuf_header>
 8007058:	4605      	mov	r5, r0
 800705a:	b128      	cbz	r0, 8007068 <udp_input+0x34>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
 800705c:	4620      	mov	r0, r4
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 800705e:	b005      	add	sp, #20
 8007060:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
 8007064:	f7fd b898 	b.w	8004198 <pbuf_free>
  }

  udphdr = (struct udp_hdr *)p->payload;

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 8007068:	f8df 917c 	ldr.w	r9, [pc, #380]	; 80071e8 <udp_input+0x1b4>
    snmp_inc_udpinerrors();
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
 800706c:	f8d4 b004 	ldr.w	fp, [r4, #4]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 8007070:	f8d9 0000 	ldr.w	r0, [r9]
 8007074:	4641      	mov	r1, r8
 8007076:	f7fa f8d5 	bl	8001224 <ip4_addr_isbroadcast>
 800707a:	4682      	mov	sl, r0

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 800707c:	f8bb 0000 	ldrh.w	r0, [fp]
 8007080:	f7fa fbf8 	bl	8001874 <lwip_ntohs>
 8007084:	4606      	mov	r6, r0
  dest = ntohs(udphdr->dest);
 8007086:	f8bb 0002 	ldrh.w	r0, [fp, #2]
 800708a:	f7fa fbf3 	bl	8001874 <lwip_ntohs>

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
 800708e:	2844      	cmp	r0, #68	; 0x44
 8007090:	d035      	beq.n	80070fe <udp_input+0xca>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8007092:	4b53      	ldr	r3, [pc, #332]	; (80071e0 <udp_input+0x1ac>)
 8007094:	681b      	ldr	r3, [r3, #0]
 8007096:	9303      	str	r3, [sp, #12]
 8007098:	461a      	mov	r2, r3
 800709a:	2b00      	cmp	r3, #0
 800709c:	d031      	beq.n	8007102 <udp_input+0xce>
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 800709e:	4b51      	ldr	r3, [pc, #324]	; (80071e4 <udp_input+0x1b0>)

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 80070a0:	f8d9 c000 	ldr.w	ip, [r9]
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 80070a4:	f8d3 e000 	ldr.w	lr, [r3]
 80070a8:	f1ba 0f00 	cmp.w	sl, #0
 80070ac:	d062      	beq.n	8007174 <udp_input+0x140>
 80070ae:	4629      	mov	r1, r5
 80070b0:	4613      	mov	r3, r2
 80070b2:	e004      	b.n	80070be <udp_input+0x8a>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80070b4:	68da      	ldr	r2, [r3, #12]
 80070b6:	4619      	mov	r1, r3
 80070b8:	2a00      	cmp	r2, #0
 80070ba:	d045      	beq.n	8007148 <udp_input+0x114>
 80070bc:	4613      	mov	r3, r2
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
 80070be:	8a5a      	ldrh	r2, [r3, #18]
 80070c0:	4282      	cmp	r2, r0
 80070c2:	d1f7      	bne.n	80070b4 <udp_input+0x80>
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 80070c4:	681a      	ldr	r2, [r3, #0]
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 80070c6:	4562      	cmp	r2, ip
 80070c8:	d007      	beq.n	80070da <udp_input+0xa6>
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
 80070ca:	b132      	cbz	r2, 80070da <udp_input+0xa6>
 80070cc:	ea82 0b0c 	eor.w	fp, r2, ip
 80070d0:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80070d4:	ea1b 0f02 	tst.w	fp, r2
 80070d8:	d1ec      	bne.n	80070b4 <udp_input+0x80>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 80070da:	2d00      	cmp	r5, #0
 80070dc:	d064      	beq.n	80071a8 <udp_input+0x174>
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 80070de:	8a9a      	ldrh	r2, [r3, #20]
 80070e0:	42b2      	cmp	r2, r6
 80070e2:	d1e7      	bne.n	80070b4 <udp_input+0x80>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 80070e4:	685a      	ldr	r2, [r3, #4]
 80070e6:	b10a      	cbz	r2, 80070ec <udp_input+0xb8>
 80070e8:	4572      	cmp	r2, lr
 80070ea:	d1e3      	bne.n	80070b4 <udp_input+0x80>
 80070ec:	461d      	mov	r5, r3
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
 80070ee:	b369      	cbz	r1, 800714c <udp_input+0x118>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 80070f0:	68da      	ldr	r2, [r3, #12]
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
 80070f2:	483b      	ldr	r0, [pc, #236]	; (80071e0 <udp_input+0x1ac>)
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 80070f4:	60ca      	str	r2, [r1, #12]
          pcb->next = udp_pcbs;
 80070f6:	9a03      	ldr	r2, [sp, #12]
          udp_pcbs = pcb;
 80070f8:	6003      	str	r3, [r0, #0]
        /* the first fully matching PCB */
        if (prev != NULL) {
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
 80070fa:	60da      	str	r2, [r3, #12]
 80070fc:	e026      	b.n	800714c <udp_input+0x118>
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
 80070fe:	2e43      	cmp	r6, #67	; 0x43
 8007100:	d05e      	beq.n	80071c0 <udp_input+0x18c>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 8007102:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8007106:	f8d9 3000 	ldr.w	r3, [r9]
 800710a:	4d37      	ldr	r5, [pc, #220]	; (80071e8 <udp_input+0x1b4>)
 800710c:	429a      	cmp	r2, r3
 800710e:	d1a5      	bne.n	800705c <udp_input+0x28>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 8007110:	f06f 0107 	mvn.w	r1, #7
 8007114:	4620      	mov	r0, r4
 8007116:	f7fd f809 	bl	800412c <pbuf_header>
 800711a:	2800      	cmp	r0, #0
 800711c:	d19e      	bne.n	800705c <udp_input+0x28>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 800711e:	f1ba 0f00 	cmp.w	sl, #0
 8007122:	d19b      	bne.n	800705c <udp_input+0x28>
 8007124:	682b      	ldr	r3, [r5, #0]
 8007126:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800712a:	2be0      	cmp	r3, #224	; 0xe0
 800712c:	d096      	beq.n	800705c <udp_input+0x28>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 800712e:	7839      	ldrb	r1, [r7, #0]
 8007130:	f001 010f 	and.w	r1, r1, #15
 8007134:	3102      	adds	r1, #2
 8007136:	0089      	lsls	r1, r1, #2
 8007138:	4620      	mov	r0, r4
 800713a:	f7fc fff7 	bl	800412c <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 800713e:	2103      	movs	r1, #3
 8007140:	4620      	mov	r0, r4
 8007142:	f7f9 fdab 	bl	8000c9c <icmp_dest_unreach>
 8007146:	e789      	b.n	800705c <udp_input+0x28>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 8007148:	2d00      	cmp	r5, #0
 800714a:	d0da      	beq.n	8007102 <udp_input+0xce>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 800714c:	f06f 0107 	mvn.w	r1, #7
 8007150:	4620      	mov	r0, r4
 8007152:	f7fc ffeb 	bl	800412c <pbuf_header>
 8007156:	2800      	cmp	r0, #0
 8007158:	d180      	bne.n	800705c <udp_input+0x28>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 800715a:	69af      	ldr	r7, [r5, #24]
 800715c:	2f00      	cmp	r7, #0
 800715e:	f43f af7d 	beq.w	800705c <udp_input+0x28>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8007162:	69e8      	ldr	r0, [r5, #28]
 8007164:	4b1f      	ldr	r3, [pc, #124]	; (80071e4 <udp_input+0x1b0>)
 8007166:	9600      	str	r6, [sp, #0]
 8007168:	4622      	mov	r2, r4
 800716a:	4629      	mov	r1, r5
 800716c:	47b8      	blx	r7
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 800716e:	b005      	add	sp, #20
 8007170:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007174:	4613      	mov	r3, r2
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 8007176:	4655      	mov	r5, sl
 8007178:	4651      	mov	r1, sl
 800717a:	e004      	b.n	8007186 <udp_input+0x152>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800717c:	68da      	ldr	r2, [r3, #12]
 800717e:	4619      	mov	r1, r3
 8007180:	2a00      	cmp	r2, #0
 8007182:	d0e1      	beq.n	8007148 <udp_input+0x114>
 8007184:	4613      	mov	r3, r2
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
 8007186:	8a5a      	ldrh	r2, [r3, #18]
 8007188:	4282      	cmp	r2, r0
 800718a:	d1f7      	bne.n	800717c <udp_input+0x148>
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 800718c:	681a      	ldr	r2, [r3, #0]
 800718e:	b10a      	cbz	r2, 8007194 <udp_input+0x160>
 8007190:	4562      	cmp	r2, ip
 8007192:	d1f3      	bne.n	800717c <udp_input+0x148>
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 8007194:	b175      	cbz	r5, 80071b4 <udp_input+0x180>
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 8007196:	8a9a      	ldrh	r2, [r3, #20]
 8007198:	42b2      	cmp	r2, r6
 800719a:	d1ef      	bne.n	800717c <udp_input+0x148>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 800719c:	685a      	ldr	r2, [r3, #4]
 800719e:	2a00      	cmp	r2, #0
 80071a0:	d0a4      	beq.n	80070ec <udp_input+0xb8>
 80071a2:	4572      	cmp	r2, lr
 80071a4:	d1ea      	bne.n	800717c <udp_input+0x148>
 80071a6:	e7a1      	b.n	80070ec <udp_input+0xb8>
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 80071a8:	7c1a      	ldrb	r2, [r3, #16]
 80071aa:	f012 0f04 	tst.w	r2, #4
 80071ae:	bf08      	it	eq
 80071b0:	461d      	moveq	r5, r3
 80071b2:	e794      	b.n	80070de <udp_input+0xaa>
 80071b4:	7c1a      	ldrb	r2, [r3, #16]
 80071b6:	f012 0f04 	tst.w	r2, #4
 80071ba:	bf08      	it	eq
 80071bc:	461d      	moveq	r5, r3
 80071be:	e7ea      	b.n	8007196 <udp_input+0x162>
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
 80071c0:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80071c4:	2b00      	cmp	r3, #0
 80071c6:	d09c      	beq.n	8007102 <udp_input+0xce>
 80071c8:	685d      	ldr	r5, [r3, #4]
 80071ca:	2d00      	cmp	r5, #0
 80071cc:	d099      	beq.n	8007102 <udp_input+0xce>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 80071ce:	686b      	ldr	r3, [r5, #4]
 80071d0:	2b00      	cmp	r3, #0
 80071d2:	d0bb      	beq.n	800714c <udp_input+0x118>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
 80071d4:	4a03      	ldr	r2, [pc, #12]	; (80071e4 <udp_input+0x1b0>)
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 80071d6:	6812      	ldr	r2, [r2, #0]
 80071d8:	4293      	cmp	r3, r2
 80071da:	d192      	bne.n	8007102 <udp_input+0xce>
 80071dc:	e7b6      	b.n	800714c <udp_input+0x118>
 80071de:	bf00      	nop
 80071e0:	20005764 	.word	0x20005764
 80071e4:	20002ee4 	.word	0x20002ee4
 80071e8:	20002eec 	.word	0x20002eec

080071ec <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 80071ec:	b5f0      	push	{r4, r5, r6, r7, lr}
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80071ee:	f8df e0c4 	ldr.w	lr, [pc, #196]	; 80072b4 <udp_bind+0xc8>
 80071f2:	f8de 7000 	ldr.w	r7, [lr]
 80071f6:	2f00      	cmp	r7, #0
 80071f8:	d045      	beq.n	8007286 <udp_bind+0x9a>
 80071fa:	2900      	cmp	r1, #0
 80071fc:	d048      	beq.n	8007290 <udp_bind+0xa4>
 80071fe:	463b      	mov	r3, r7
 8007200:	2600      	movs	r6, #0
 8007202:	e001      	b.n	8007208 <udp_bind+0x1c>
 8007204:	68db      	ldr	r3, [r3, #12]
 8007206:	b18b      	cbz	r3, 800722c <udp_bind+0x40>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 8007208:	4298      	cmp	r0, r3
 800720a:	d00b      	beq.n	8007224 <udp_bind+0x38>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 800720c:	8a5c      	ldrh	r4, [r3, #18]
 800720e:	4294      	cmp	r4, r2
 8007210:	d1f8      	bne.n	8007204 <udp_bind+0x18>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 8007212:	681c      	ldr	r4, [r3, #0]
 8007214:	b11c      	cbz	r4, 800721e <udp_bind+0x32>
           ip_addr_isany(ipaddr) ||
 8007216:	680d      	ldr	r5, [r1, #0]
 8007218:	b10d      	cbz	r5, 800721e <udp_bind+0x32>
 800721a:	42a5      	cmp	r5, r4
 800721c:	d1f2      	bne.n	8007204 <udp_bind+0x18>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 800721e:	f06f 0007 	mvn.w	r0, #7
 8007222:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8007224:	68db      	ldr	r3, [r3, #12]
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 8007226:	2601      	movs	r6, #1
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8007228:	2b00      	cmp	r3, #0
 800722a:	d1ed      	bne.n	8007208 <udp_bind+0x1c>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 800722c:	680b      	ldr	r3, [r1, #0]
 800722e:	6003      	str	r3, [r0, #0]

  /* no port specified? */
  if (port == 0) {
 8007230:	b142      	cbz	r2, 8007244 <udp_bind+0x58>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
 8007232:	8242      	strh	r2, [r0, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 8007234:	b926      	cbnz	r6, 8007240 <udp_bind+0x54>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8007236:	60c7      	str	r7, [r0, #12]
    udp_pcbs = pcb;
 8007238:	f8ce 0000 	str.w	r0, [lr]
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 800723c:	4630      	mov	r0, r6
 800723e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007240:	2000      	movs	r0, #0
}
 8007242:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007244:	4d1a      	ldr	r5, [pc, #104]	; (80072b0 <udp_bind+0xc4>)
 8007246:	882b      	ldrh	r3, [r5, #0]
  }

  ip_addr_set(&pcb->local_ip, ipaddr);

  /* no port specified? */
  if (port == 0) {
 8007248:	f44f 4480 	mov.w	r4, #16384	; 0x4000
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 800724c:	f64f 7cff 	movw	ip, #65535	; 0xffff
 8007250:	4563      	cmp	r3, ip
 8007252:	bf1a      	itte	ne
 8007254:	3301      	addne	r3, #1
 8007256:	b29a      	uxthne	r2, r3
 8007258:	f44f 4240 	moveq.w	r2, #49152	; 0xc000
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800725c:	b157      	cbz	r7, 8007274 <udp_bind+0x88>
    if (pcb->local_port == udp_port) {
 800725e:	8a7b      	ldrh	r3, [r7, #18]
 8007260:	4293      	cmp	r3, r2
 8007262:	d009      	beq.n	8007278 <udp_bind+0x8c>
 8007264:	463b      	mov	r3, r7
 8007266:	e002      	b.n	800726e <udp_bind+0x82>
 8007268:	8a59      	ldrh	r1, [r3, #18]
 800726a:	4291      	cmp	r1, r2
 800726c:	d004      	beq.n	8007278 <udp_bind+0x8c>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800726e:	68db      	ldr	r3, [r3, #12]
 8007270:	2b00      	cmp	r3, #0
 8007272:	d1f9      	bne.n	8007268 <udp_bind+0x7c>
 8007274:	802a      	strh	r2, [r5, #0]
 8007276:	e7dc      	b.n	8007232 <udp_bind+0x46>
 8007278:	3c01      	subs	r4, #1
 800727a:	b2a4      	uxth	r4, r4
 800727c:	4613      	mov	r3, r2
    if (pcb->local_port == udp_port) {
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 800727e:	2c00      	cmp	r4, #0
 8007280:	d1e6      	bne.n	8007250 <udp_bind+0x64>
 8007282:	802a      	strh	r2, [r5, #0]
 8007284:	e7cb      	b.n	800721e <udp_bind+0x32>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 8007286:	463e      	mov	r6, r7
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 8007288:	463b      	mov	r3, r7
 800728a:	2900      	cmp	r1, #0
 800728c:	d0cf      	beq.n	800722e <udp_bind+0x42>
 800728e:	e7cd      	b.n	800722c <udp_bind+0x40>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8007290:	460e      	mov	r6, r1
 8007292:	463b      	mov	r3, r7
 8007294:	e002      	b.n	800729c <udp_bind+0xb0>
 8007296:	68db      	ldr	r3, [r3, #12]
 8007298:	2b00      	cmp	r3, #0
 800729a:	d0c8      	beq.n	800722e <udp_bind+0x42>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 800729c:	4298      	cmp	r0, r3
 800729e:	d005      	beq.n	80072ac <udp_bind+0xc0>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 80072a0:	8a59      	ldrh	r1, [r3, #18]
 80072a2:	4291      	cmp	r1, r2
 80072a4:	d1f7      	bne.n	8007296 <udp_bind+0xaa>
           ip_addr_isany(ipaddr) ||
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 80072a6:	f06f 0007 	mvn.w	r0, #7
 80072aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 80072ac:	2601      	movs	r6, #1
 80072ae:	e7f2      	b.n	8007296 <udp_bind+0xaa>
 80072b0:	2000000a 	.word	0x2000000a
 80072b4:	20005764 	.word	0x20005764

080072b8 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 80072b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80072bc:	460f      	mov	r7, r1
 80072be:	b084      	sub	sp, #16
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 80072c0:	8a41      	ldrh	r1, [r0, #18]
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 80072c2:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 80072c6:	4604      	mov	r4, r0
 80072c8:	4692      	mov	sl, r2
 80072ca:	4699      	mov	r9, r3
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 80072cc:	b921      	cbnz	r1, 80072d8 <udp_sendto_if+0x20>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 80072ce:	460a      	mov	r2, r1
 80072d0:	4601      	mov	r1, r0
 80072d2:	f7ff ff8b 	bl	80071ec <udp_bind>
    if (err != ERR_OK) {
 80072d6:	b9f0      	cbnz	r0, 8007316 <udp_sendto_if+0x5e>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
 80072d8:	2108      	movs	r1, #8
 80072da:	4638      	mov	r0, r7
 80072dc:	f7fc ff26 	bl	800412c <pbuf_header>
 80072e0:	b9e0      	cbnz	r0, 800731c <udp_sendto_if+0x64>
 80072e2:	463e      	mov	r6, r7
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
 80072e4:	8a60      	ldrh	r0, [r4, #18]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 80072e6:	6875      	ldr	r5, [r6, #4]
  udphdr->src = htons(pcb->local_port);
 80072e8:	f7fa fac0 	bl	800186c <lwip_htons>
 80072ec:	8028      	strh	r0, [r5, #0]
  udphdr->dest = htons(dst_port);
 80072ee:	4648      	mov	r0, r9
 80072f0:	f7fa fabc 	bl	800186c <lwip_htons>
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 80072f4:	6822      	ldr	r2, [r4, #0]
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
  udphdr->dest = htons(dst_port);
 80072f6:	8068      	strh	r0, [r5, #2]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 80072f8:	2300      	movs	r3, #0
 80072fa:	71ab      	strb	r3, [r5, #6]
 80072fc:	71eb      	strb	r3, [r5, #7]
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 80072fe:	b1da      	cbz	r2, 8007338 <udp_sendto_if+0x80>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 8007300:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8007304:	429a      	cmp	r2, r3
 8007306:	d036      	beq.n	8007376 <udp_sendto_if+0xbe>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
 8007308:	42be      	cmp	r6, r7
 800730a:	d031      	beq.n	8007370 <udp_sendto_if+0xb8>
        /* free the header pbuf */
        pbuf_free(q);
 800730c:	4630      	mov	r0, r6
 800730e:	f7fc ff43 	bl	8004198 <pbuf_free>
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 8007312:	f06f 0005 	mvn.w	r0, #5
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
 8007316:	b004      	add	sp, #16
 8007318:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 800731c:	2200      	movs	r2, #0
 800731e:	2108      	movs	r1, #8
 8007320:	2001      	movs	r0, #1
 8007322:	f7fc fde1 	bl	8003ee8 <pbuf_alloc>
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 8007326:	4606      	mov	r6, r0
 8007328:	b338      	cbz	r0, 800737a <udp_sendto_if+0xc2>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    if (p->tot_len != 0) {
 800732a:	893b      	ldrh	r3, [r7, #8]
 800732c:	2b00      	cmp	r3, #0
 800732e:	d0d9      	beq.n	80072e4 <udp_sendto_if+0x2c>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 8007330:	4639      	mov	r1, r7
 8007332:	f7fc ff87 	bl	8004244 <pbuf_chain>
 8007336:	e7d5      	b.n	80072e4 <udp_sendto_if+0x2c>


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 8007338:	f108 0904 	add.w	r9, r8, #4
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
 800733c:	8930      	ldrh	r0, [r6, #8]
 800733e:	f7fa fa95 	bl	800186c <lwip_htons>
 8007342:	80a8      	strh	r0, [r5, #4]
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 8007344:	7aa3      	ldrb	r3, [r4, #10]
 8007346:	7a64      	ldrb	r4, [r4, #9]
 8007348:	9400      	str	r4, [sp, #0]
 800734a:	2011      	movs	r0, #17
 800734c:	9001      	str	r0, [sp, #4]
 800734e:	f8cd 8008 	str.w	r8, [sp, #8]
 8007352:	4652      	mov	r2, sl
 8007354:	4649      	mov	r1, r9
 8007356:	4630      	mov	r0, r6
 8007358:	f7f9 fed4 	bl	8001104 <ip_output_if>
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 800735c:	42be      	cmp	r6, r7
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 800735e:	4604      	mov	r4, r0
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 8007360:	d0d9      	beq.n	8007316 <udp_sendto_if+0x5e>
    /* free the header pbuf */
    pbuf_free(q);
 8007362:	4630      	mov	r0, r6
 8007364:	f7fc ff18 	bl	8004198 <pbuf_free>
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 8007368:	4620      	mov	r0, r4
}
 800736a:	b004      	add	sp, #16
 800736c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 8007370:	f06f 0005 	mvn.w	r0, #5
 8007374:	e7cf      	b.n	8007316 <udp_sendto_if+0x5e>
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 8007376:	46a1      	mov	r9, r4
 8007378:	e7e0      	b.n	800733c <udp_sendto_if+0x84>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 800737a:	f04f 30ff 	mov.w	r0, #4294967295
 800737e:	e7ca      	b.n	8007316 <udp_sendto_if+0x5e>

08007380 <udp_connect>:
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 8007380:	8a43      	ldrh	r3, [r0, #18]
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 8007382:	b570      	push	{r4, r5, r6, lr}
 8007384:	4604      	mov	r4, r0
 8007386:	460d      	mov	r5, r1
 8007388:	4616      	mov	r6, r2
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 800738a:	b1bb      	cbz	r3, 80073bc <udp_connect+0x3c>
    if (err != ERR_OK) {
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 800738c:	b105      	cbz	r5, 8007390 <udp_connect+0x10>
 800738e:	682d      	ldr	r5, [r5, #0]
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8007390:	490f      	ldr	r1, [pc, #60]	; (80073d0 <udp_connect+0x50>)
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
 8007392:	7c23      	ldrb	r3, [r4, #16]
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8007394:	680a      	ldr	r2, [r1, #0]
    if (err != ERR_OK) {
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 8007396:	6065      	str	r5, [r4, #4]
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
 8007398:	f043 0304 	orr.w	r3, r3, #4
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  pcb->remote_port = port;
 800739c:	82a6      	strh	r6, [r4, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 800739e:	7423      	strb	r3, [r4, #16]
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80073a0:	b142      	cbz	r2, 80073b4 <udp_connect+0x34>
    if (pcb == ipcb) {
 80073a2:	4294      	cmp	r4, r2
 80073a4:	d011      	beq.n	80073ca <udp_connect+0x4a>
 80073a6:	4613      	mov	r3, r2
 80073a8:	e001      	b.n	80073ae <udp_connect+0x2e>
 80073aa:	429c      	cmp	r4, r3
 80073ac:	d00d      	beq.n	80073ca <udp_connect+0x4a>
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80073ae:	68db      	ldr	r3, [r3, #12]
 80073b0:	2b00      	cmp	r3, #0
 80073b2:	d1fa      	bne.n	80073aa <udp_connect+0x2a>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 80073b4:	60e2      	str	r2, [r4, #12]
  udp_pcbs = pcb;
 80073b6:	600c      	str	r4, [r1, #0]
  return ERR_OK;
 80073b8:	2000      	movs	r0, #0
 80073ba:	bd70      	pop	{r4, r5, r6, pc}
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 80073bc:	461a      	mov	r2, r3
 80073be:	4601      	mov	r1, r0
 80073c0:	f7ff ff14 	bl	80071ec <udp_bind>
    if (err != ERR_OK) {
 80073c4:	2800      	cmp	r0, #0
 80073c6:	d0e1      	beq.n	800738c <udp_connect+0xc>
 80073c8:	bd70      	pop	{r4, r5, r6, pc}

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
 80073ca:	2000      	movs	r0, #0
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
 80073cc:	bd70      	pop	{r4, r5, r6, pc}
 80073ce:	bf00      	nop
 80073d0:	20005764 	.word	0x20005764

080073d4 <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 80073d4:	6181      	str	r1, [r0, #24]
  pcb->recv_arg = recv_arg;
 80073d6:	61c2      	str	r2, [r0, #28]
 80073d8:	4770      	bx	lr
 80073da:	bf00      	nop

080073dc <udp_remove>:
{
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 80073dc:	4b0d      	ldr	r3, [pc, #52]	; (8007414 <udp_remove+0x38>)
 80073de:	681a      	ldr	r2, [r3, #0]
 80073e0:	4282      	cmp	r2, r0
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 80073e2:	4601      	mov	r1, r0
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 80073e4:	d011      	beq.n	800740a <udp_remove+0x2e>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 80073e6:	b13a      	cbz	r2, 80073f8 <udp_remove+0x1c>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 80073e8:	68d3      	ldr	r3, [r2, #12]
 80073ea:	b12b      	cbz	r3, 80073f8 <udp_remove+0x1c>
 80073ec:	4299      	cmp	r1, r3
 80073ee:	d006      	beq.n	80073fe <udp_remove+0x22>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 80073f0:	461a      	mov	r2, r3
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 80073f2:	68d3      	ldr	r3, [r2, #12]
 80073f4:	2b00      	cmp	r3, #0
 80073f6:	d1f9      	bne.n	80073ec <udp_remove+0x10>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 80073f8:	2001      	movs	r0, #1
 80073fa:	f7fc bc21 	b.w	8003c40 <memp_free>
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
 80073fe:	68cb      	ldr	r3, [r1, #12]
 8007400:	60d3      	str	r3, [r2, #12]
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8007402:	2b00      	cmp	r3, #0
 8007404:	d0f8      	beq.n	80073f8 <udp_remove+0x1c>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8007406:	461a      	mov	r2, r3
 8007408:	e7f3      	b.n	80073f2 <udp_remove+0x16>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 800740a:	68c2      	ldr	r2, [r0, #12]
 800740c:	601a      	str	r2, [r3, #0]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 800740e:	2001      	movs	r0, #1
 8007410:	f7fc bc16 	b.w	8003c40 <memp_free>
 8007414:	20005764 	.word	0x20005764

08007418 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8007418:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 800741a:	2001      	movs	r0, #1
 800741c:	f7fc fbfe 	bl	8003c1c <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 8007420:	4604      	mov	r4, r0
 8007422:	b128      	cbz	r0, 8007430 <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 8007424:	2220      	movs	r2, #32
 8007426:	2100      	movs	r1, #0
 8007428:	f004 f880 	bl	800b52c <memset>
    pcb->ttl = UDP_TTL;
 800742c:	23ff      	movs	r3, #255	; 0xff
 800742e:	72a3      	strb	r3, [r4, #10]
  }
  return pcb;
}
 8007430:	4620      	mov	r0, r4
 8007432:	bd10      	pop	{r4, pc}

08007434 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 8007434:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007438:	b083      	sub	sp, #12
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800743a:	4cca      	ldr	r4, [pc, #808]	; (8007764 <etharp_find_entry+0x330>)
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 800743c:	9101      	str	r1, [sp, #4]
 800743e:	2800      	cmp	r0, #0
 8007440:	f000 81fd 	beq.w	800783e <etharp_find_entry+0x40a>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007444:	7ca5      	ldrb	r5, [r4, #18]
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007446:	2d00      	cmp	r5, #0
 8007448:	d056      	beq.n	80074f8 <etharp_find_entry+0xc4>
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 800744a:	6806      	ldr	r6, [r0, #0]
 800744c:	6863      	ldr	r3, [r4, #4]
 800744e:	429e      	cmp	r6, r3
 8007450:	f000 8380 	beq.w	8007b54 <etharp_find_entry+0x720>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007454:	2d01      	cmp	r5, #1
 8007456:	f000 816b 	beq.w	8007730 <etharp_find_entry+0x2fc>
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 800745a:	2500      	movs	r5, #0
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 800745c:	220a      	movs	r2, #10
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 800745e:	f894 e013 	ldrb.w	lr, [r4, #19]
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007462:	46ab      	mov	fp, r5
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
            old_stable = i;
 8007464:	46ac      	mov	ip, r5
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007466:	4690      	mov	r8, r2
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007468:	f894 7026 	ldrb.w	r7, [r4, #38]	; 0x26
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800746c:	2f00      	cmp	r7, #0
 800746e:	f040 81e4 	bne.w	800783a <etharp_find_entry+0x406>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007472:	f894 703a 	ldrb.w	r7, [r4, #58]	; 0x3a
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007476:	2301      	movs	r3, #1
    } else if (state != ETHARP_STATE_EMPTY) {
 8007478:	2f00      	cmp	r7, #0
 800747a:	d14b      	bne.n	8007514 <etharp_find_entry+0xe0>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800747c:	f894 704e 	ldrb.w	r7, [r4, #78]	; 0x4e
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 8007480:	2f00      	cmp	r7, #0
 8007482:	d17f      	bne.n	8007584 <etharp_find_entry+0x150>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007484:	f894 7062 	ldrb.w	r7, [r4, #98]	; 0x62
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 8007488:	2f00      	cmp	r7, #0
 800748a:	f040 80b4 	bne.w	80075f6 <etharp_find_entry+0x1c2>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800748e:	f894 7076 	ldrb.w	r7, [r4, #118]	; 0x76
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 8007492:	2f00      	cmp	r7, #0
 8007494:	f040 80c8 	bne.w	8007628 <etharp_find_entry+0x1f4>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007498:	f894 708a 	ldrb.w	r7, [r4, #138]	; 0x8a
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 800749c:	2f00      	cmp	r7, #0
 800749e:	f040 80dc 	bne.w	800765a <etharp_find_entry+0x226>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80074a2:	f894 709e 	ldrb.w	r7, [r4, #158]	; 0x9e
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80074a6:	2f00      	cmp	r7, #0
 80074a8:	f040 80f0 	bne.w	800768c <etharp_find_entry+0x258>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80074ac:	f894 70b2 	ldrb.w	r7, [r4, #178]	; 0xb2
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80074b0:	2f00      	cmp	r7, #0
 80074b2:	f040 8105 	bne.w	80076c0 <etharp_find_entry+0x28c>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80074b6:	f894 70c6 	ldrb.w	r7, [r4, #198]	; 0xc6
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80074ba:	2f00      	cmp	r7, #0
 80074bc:	f040 811a 	bne.w	80076f4 <etharp_find_entry+0x2c0>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 80074c0:	9901      	ldr	r1, [sp, #4]
 80074c2:	460d      	mov	r5, r1
 80074c4:	07ad      	lsls	r5, r5, #30
 80074c6:	f100 82f8 	bmi.w	8007aba <etharp_find_entry+0x686>
 80074ca:	2b0a      	cmp	r3, #10
 80074cc:	4607      	mov	r7, r0
 80074ce:	d072      	beq.n	80075b6 <etharp_find_entry+0x182>
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
 80074d0:	fa5f f883 	uxtb.w	r8, r3
 80074d4:	461d      	mov	r5, r3
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 80074d6:	00ab      	lsls	r3, r5, #2
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 80074d8:	b127      	cbz	r7, 80074e4 <etharp_find_entry+0xb0>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 80074da:	195a      	adds	r2, r3, r5
 80074dc:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80074e0:	6839      	ldr	r1, [r7, #0]
 80074e2:	6051      	str	r1, [r2, #4]
  }
  arp_table[i].ctime = 0;
 80074e4:	442b      	add	r3, r5
 80074e6:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 80074ea:	2300      	movs	r3, #0
  return (err_t)i;
 80074ec:	fa4f f088 	sxtb.w	r0, r8
  /* IP address given? */
  if (ipaddr != NULL) {
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
  }
  arp_table[i].ctime = 0;
 80074f0:	74e3      	strb	r3, [r4, #19]
  return (err_t)i;
}
 80074f2:	b003      	add	sp, #12
 80074f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80074f8:	f894 7026 	ldrb.w	r7, [r4, #38]	; 0x26
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80074fc:	bb17      	cbnz	r7, 8007544 <etharp_find_entry+0x110>
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 80074fe:	463d      	mov	r5, r7
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007500:	46be      	mov	lr, r7
 8007502:	46bb      	mov	fp, r7
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007504:	463b      	mov	r3, r7
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007506:	f894 703a 	ldrb.w	r7, [r4, #58]	; 0x3a
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 800750a:	220a      	movs	r2, #10
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 800750c:	4694      	mov	ip, r2
 800750e:	4690      	mov	r8, r2
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 8007510:	2f00      	cmp	r7, #0
 8007512:	d0b3      	beq.n	800747c <etharp_find_entry+0x48>
 8007514:	6806      	ldr	r6, [r0, #0]
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 8007516:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8007518:	f8df 9248 	ldr.w	r9, [pc, #584]	; 8007764 <etharp_find_entry+0x330>
 800751c:	428e      	cmp	r6, r1
 800751e:	f000 831b 	beq.w	8007b58 <etharp_find_entry+0x724>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007522:	2f01      	cmp	r7, #1
 8007524:	f000 8120 	beq.w	8007768 <etharp_find_entry+0x334>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007528:	f899 703b 	ldrb.w	r7, [r9, #59]	; 0x3b
 800752c:	4577      	cmp	r7, lr
 800752e:	d302      	bcc.n	8007536 <etharp_find_entry+0x102>
 8007530:	46be      	mov	lr, r7
            old_stable = i;
 8007532:	f04f 0c02 	mov.w	ip, #2
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007536:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007538:	f894 704e 	ldrb.w	r7, [r4, #78]	; 0x4e
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800753c:	d1a0      	bne.n	8007480 <etharp_find_entry+0x4c>
 800753e:	bb17      	cbnz	r7, 8007586 <etharp_find_entry+0x152>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007540:	2303      	movs	r3, #3
 8007542:	e79f      	b.n	8007484 <etharp_find_entry+0x50>
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 8007544:	220a      	movs	r2, #10
 8007546:	6806      	ldr	r6, [r0, #0]
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007548:	46ae      	mov	lr, r5
 800754a:	46ab      	mov	fp, r5
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800754c:	462b      	mov	r3, r5
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 800754e:	4694      	mov	ip, r2
 8007550:	4690      	mov	r8, r2
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 8007552:	69a1      	ldr	r1, [r4, #24]
 8007554:	f8df a20c 	ldr.w	sl, [pc, #524]	; 8007764 <etharp_find_entry+0x330>
 8007558:	428e      	cmp	r6, r1
 800755a:	f000 82f7 	beq.w	8007b4c <etharp_find_entry+0x718>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 800755e:	2f01      	cmp	r7, #1
 8007560:	f000 80f2 	beq.w	8007748 <etharp_find_entry+0x314>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007564:	f89a 7027 	ldrb.w	r7, [sl, #39]	; 0x27
 8007568:	4577      	cmp	r7, lr
 800756a:	d302      	bcc.n	8007572 <etharp_find_entry+0x13e>
 800756c:	46be      	mov	lr, r7
            old_stable = i;
 800756e:	f04f 0c01 	mov.w	ip, #1
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007572:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007574:	f894 703a 	ldrb.w	r7, [r4, #58]	; 0x3a
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007578:	f47f af7e 	bne.w	8007478 <etharp_find_entry+0x44>
 800757c:	2f00      	cmp	r7, #0
 800757e:	d1ca      	bne.n	8007516 <etharp_find_entry+0xe2>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007580:	2302      	movs	r3, #2
 8007582:	e77b      	b.n	800747c <etharp_find_entry+0x48>
 8007584:	6806      	ldr	r6, [r0, #0]
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 8007586:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8007588:	f8df 91d8 	ldr.w	r9, [pc, #472]	; 8007764 <etharp_find_entry+0x330>
 800758c:	428e      	cmp	r6, r1
 800758e:	f000 830d 	beq.w	8007bac <etharp_find_entry+0x778>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007592:	2f01      	cmp	r7, #1
 8007594:	f000 80f5 	beq.w	8007782 <etharp_find_entry+0x34e>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007598:	f899 704f 	ldrb.w	r7, [r9, #79]	; 0x4f
 800759c:	4577      	cmp	r7, lr
 800759e:	d302      	bcc.n	80075a6 <etharp_find_entry+0x172>
 80075a0:	46be      	mov	lr, r7
            old_stable = i;
 80075a2:	f04f 0c03 	mov.w	ip, #3
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80075a6:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80075a8:	f894 7062 	ldrb.w	r7, [r4, #98]	; 0x62
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80075ac:	f47f af6c 	bne.w	8007488 <etharp_find_entry+0x54>
 80075b0:	bb17      	cbnz	r7, 80075f8 <etharp_find_entry+0x1c4>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 80075b2:	2304      	movs	r3, #4
 80075b4:	e76b      	b.n	800748e <etharp_find_entry+0x5a>
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 80075b6:	07cb      	lsls	r3, r1, #31
 80075b8:	f140 827f 	bpl.w	8007aba <etharp_find_entry+0x686>
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
 80075bc:	f1bc 0f0a 	cmp.w	ip, #10
 80075c0:	f000 80ac 	beq.w	800771c <etharp_find_entry+0x2e8>
      /* recycle oldest stable*/
      i = old_stable;
 80075c4:	fa5f f88c 	uxtb.w	r8, ip
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 80075c8:	ea4f 0688 	mov.w	r6, r8, lsl #2
 80075cc:	eb06 0908 	add.w	r9, r6, r8
 80075d0:	ea4f 0989 	mov.w	r9, r9, lsl #2
      return (s8_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
 80075d4:	4645      	mov	r5, r8
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 80075d6:	f854 0009 	ldr.w	r0, [r4, r9]
 80075da:	f8df a188 	ldr.w	sl, [pc, #392]	; 8007764 <etharp_find_entry+0x330>
 80075de:	b120      	cbz	r0, 80075ea <etharp_find_entry+0x1b6>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 80075e0:	f7fc fdda 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 80075e4:	2300      	movs	r3, #0
 80075e6:	f84a 3009 	str.w	r3, [sl, r9]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 80075ea:	4446      	add	r6, r8
 80075ec:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 80075f0:	2300      	movs	r3, #0
 80075f2:	74b3      	strb	r3, [r6, #18]
 80075f4:	e76f      	b.n	80074d6 <etharp_find_entry+0xa2>
 80075f6:	6806      	ldr	r6, [r0, #0]
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 80075f8:	6d61      	ldr	r1, [r4, #84]	; 0x54
 80075fa:	f8df 9168 	ldr.w	r9, [pc, #360]	; 8007764 <etharp_find_entry+0x330>
 80075fe:	428e      	cmp	r6, r1
 8007600:	f000 82d0 	beq.w	8007ba4 <etharp_find_entry+0x770>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007604:	2f01      	cmp	r7, #1
 8007606:	f000 80c9 	beq.w	800779c <etharp_find_entry+0x368>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 800760a:	f899 7063 	ldrb.w	r7, [r9, #99]	; 0x63
 800760e:	4577      	cmp	r7, lr
 8007610:	d302      	bcc.n	8007618 <etharp_find_entry+0x1e4>
 8007612:	46be      	mov	lr, r7
            old_stable = i;
 8007614:	f04f 0c04 	mov.w	ip, #4
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007618:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800761a:	f894 7076 	ldrb.w	r7, [r4, #118]	; 0x76
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800761e:	f47f af38 	bne.w	8007492 <etharp_find_entry+0x5e>
 8007622:	b917      	cbnz	r7, 800762a <etharp_find_entry+0x1f6>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007624:	2305      	movs	r3, #5
 8007626:	e737      	b.n	8007498 <etharp_find_entry+0x64>
 8007628:	6806      	ldr	r6, [r0, #0]
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 800762a:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 800762c:	f8df 9134 	ldr.w	r9, [pc, #308]	; 8007764 <etharp_find_entry+0x330>
 8007630:	428e      	cmp	r6, r1
 8007632:	f000 82b9 	beq.w	8007ba8 <etharp_find_entry+0x774>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007636:	2f01      	cmp	r7, #1
 8007638:	f000 80bd 	beq.w	80077b6 <etharp_find_entry+0x382>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 800763c:	f899 7077 	ldrb.w	r7, [r9, #119]	; 0x77
 8007640:	4577      	cmp	r7, lr
 8007642:	d302      	bcc.n	800764a <etharp_find_entry+0x216>
 8007644:	46be      	mov	lr, r7
            old_stable = i;
 8007646:	f04f 0c05 	mov.w	ip, #5
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800764a:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800764c:	f894 708a 	ldrb.w	r7, [r4, #138]	; 0x8a
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007650:	f47f af24 	bne.w	800749c <etharp_find_entry+0x68>
 8007654:	b917      	cbnz	r7, 800765c <etharp_find_entry+0x228>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007656:	2306      	movs	r3, #6
 8007658:	e723      	b.n	80074a2 <etharp_find_entry+0x6e>
 800765a:	6806      	ldr	r6, [r0, #0]
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 800765c:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800765e:	f8df 9104 	ldr.w	r9, [pc, #260]	; 8007764 <etharp_find_entry+0x330>
 8007662:	428e      	cmp	r6, r1
 8007664:	f000 82ab 	beq.w	8007bbe <etharp_find_entry+0x78a>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007668:	2f01      	cmp	r7, #1
 800766a:	f000 80b1 	beq.w	80077d0 <etharp_find_entry+0x39c>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 800766e:	f899 708b 	ldrb.w	r7, [r9, #139]	; 0x8b
 8007672:	4577      	cmp	r7, lr
 8007674:	d302      	bcc.n	800767c <etharp_find_entry+0x248>
 8007676:	46be      	mov	lr, r7
            old_stable = i;
 8007678:	f04f 0c06 	mov.w	ip, #6
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800767c:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800767e:	f894 709e 	ldrb.w	r7, [r4, #158]	; 0x9e
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007682:	f47f af10 	bne.w	80074a6 <etharp_find_entry+0x72>
 8007686:	b917      	cbnz	r7, 800768e <etharp_find_entry+0x25a>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007688:	2307      	movs	r3, #7
 800768a:	e70f      	b.n	80074ac <etharp_find_entry+0x78>
 800768c:	6806      	ldr	r6, [r0, #0]
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 800768e:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 8007692:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8007764 <etharp_find_entry+0x330>
 8007696:	428e      	cmp	r6, r1
 8007698:	f000 8293 	beq.w	8007bc2 <etharp_find_entry+0x78e>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 800769c:	2f01      	cmp	r7, #1
 800769e:	f000 80a4 	beq.w	80077ea <etharp_find_entry+0x3b6>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 80076a2:	f899 709f 	ldrb.w	r7, [r9, #159]	; 0x9f
 80076a6:	4577      	cmp	r7, lr
 80076a8:	d302      	bcc.n	80076b0 <etharp_find_entry+0x27c>
 80076aa:	46be      	mov	lr, r7
            old_stable = i;
 80076ac:	f04f 0c07 	mov.w	ip, #7
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80076b0:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80076b2:	f894 70b2 	ldrb.w	r7, [r4, #178]	; 0xb2
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80076b6:	f47f aefb 	bne.w	80074b0 <etharp_find_entry+0x7c>
 80076ba:	b917      	cbnz	r7, 80076c2 <etharp_find_entry+0x28e>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 80076bc:	2308      	movs	r3, #8
 80076be:	e6fa      	b.n	80074b6 <etharp_find_entry+0x82>
 80076c0:	6806      	ldr	r6, [r0, #0]
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 80076c2:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
 80076c6:	f8df 909c 	ldr.w	r9, [pc, #156]	; 8007764 <etharp_find_entry+0x330>
 80076ca:	428e      	cmp	r6, r1
 80076cc:	f000 80df 	beq.w	800788e <etharp_find_entry+0x45a>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 80076d0:	2f01      	cmp	r7, #1
 80076d2:	f000 8097 	beq.w	8007804 <etharp_find_entry+0x3d0>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 80076d6:	f899 70b3 	ldrb.w	r7, [r9, #179]	; 0xb3
 80076da:	4577      	cmp	r7, lr
 80076dc:	d302      	bcc.n	80076e4 <etharp_find_entry+0x2b0>
 80076de:	46be      	mov	lr, r7
            old_stable = i;
 80076e0:	f04f 0c08 	mov.w	ip, #8
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80076e4:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80076e6:	f894 70c6 	ldrb.w	r7, [r4, #198]	; 0xc6
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80076ea:	f47f aee6 	bne.w	80074ba <etharp_find_entry+0x86>
 80076ee:	b917      	cbnz	r7, 80076f6 <etharp_find_entry+0x2c2>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 80076f0:	2309      	movs	r3, #9
 80076f2:	e6e5      	b.n	80074c0 <etharp_find_entry+0x8c>
 80076f4:	6806      	ldr	r6, [r0, #0]
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 80076f6:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
 80076fa:	f8df 9068 	ldr.w	r9, [pc, #104]	; 8007764 <etharp_find_entry+0x330>
 80076fe:	428e      	cmp	r6, r1
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007700:	bf08      	it	eq
 8007702:	2009      	moveq	r0, #9
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 8007704:	f000 80c4 	beq.w	8007890 <etharp_find_entry+0x45c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007708:	2f01      	cmp	r7, #1
 800770a:	f000 8088 	beq.w	800781e <etharp_find_entry+0x3ea>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 800770e:	f899 50c7 	ldrb.w	r5, [r9, #199]	; 0xc7
            old_stable = i;
 8007712:	4575      	cmp	r5, lr
 8007714:	bf28      	it	cs
 8007716:	f04f 0c09 	movcs.w	ip, #9
 800771a:	e6d1      	b.n	80074c0 <etharp_find_entry+0x8c>
      i = old_stable;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
 800771c:	f1b8 0f0a 	cmp.w	r8, #10
 8007720:	f040 8088 	bne.w	8007834 <etharp_find_entry+0x400>
      /* recycle oldest pending */
      i = old_pending;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
 8007724:	2a0a      	cmp	r2, #10
 8007726:	f000 81c8 	beq.w	8007aba <etharp_find_entry+0x686>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
 800772a:	fa5f f882 	uxtb.w	r8, r2
 800772e:	e74b      	b.n	80075c8 <etharp_find_entry+0x194>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007730:	6825      	ldr	r5, [r4, #0]
 8007732:	2d00      	cmp	r5, #0
 8007734:	f000 81e2 	beq.w	8007afc <etharp_find_entry+0x6c8>
          if (arp_table[i].ctime >= age_queue) {
            old_queue = i;
 8007738:	2200      	movs	r2, #0
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 800773a:	f04f 0c0a 	mov.w	ip, #10
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 800773e:	4696      	mov	lr, r2
 8007740:	4693      	mov	fp, r2
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007742:	46e0      	mov	r8, ip
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
          if (arp_table[i].ctime >= age_queue) {
 8007744:	7ce5      	ldrb	r5, [r4, #19]
 8007746:	e68f      	b.n	8007468 <etharp_find_entry+0x34>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007748:	f8da 1014 	ldr.w	r1, [sl, #20]
          if (arp_table[i].ctime >= age_queue) {
 800774c:	f89a 9027 	ldrb.w	r9, [sl, #39]	; 0x27
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007750:	2900      	cmp	r1, #0
 8007752:	f000 81da 	beq.w	8007b0a <etharp_find_entry+0x6d6>
          if (arp_table[i].ctime >= age_queue) {
 8007756:	45a9      	cmp	r9, r5
 8007758:	f4ff af0b 	bcc.w	8007572 <etharp_find_entry+0x13e>
 800775c:	464d      	mov	r5, r9
            old_queue = i;
 800775e:	463a      	mov	r2, r7
 8007760:	e707      	b.n	8007572 <etharp_find_entry+0x13e>
 8007762:	bf00      	nop
 8007764:	200029ac 	.word	0x200029ac
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007768:	f8d9 7028 	ldr.w	r7, [r9, #40]	; 0x28
 800776c:	2f00      	cmp	r7, #0
 800776e:	f000 81d2 	beq.w	8007b16 <etharp_find_entry+0x6e2>
          if (arp_table[i].ctime >= age_queue) {
 8007772:	f899 703b 	ldrb.w	r7, [r9, #59]	; 0x3b
 8007776:	42af      	cmp	r7, r5
 8007778:	f4ff aedd 	bcc.w	8007536 <etharp_find_entry+0x102>
 800777c:	463d      	mov	r5, r7
            old_queue = i;
 800777e:	2202      	movs	r2, #2
 8007780:	e6d9      	b.n	8007536 <etharp_find_entry+0x102>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007782:	f8d9 703c 	ldr.w	r7, [r9, #60]	; 0x3c
 8007786:	2f00      	cmp	r7, #0
 8007788:	f000 81ce 	beq.w	8007b28 <etharp_find_entry+0x6f4>
          if (arp_table[i].ctime >= age_queue) {
 800778c:	f899 704f 	ldrb.w	r7, [r9, #79]	; 0x4f
 8007790:	42af      	cmp	r7, r5
 8007792:	f4ff af08 	bcc.w	80075a6 <etharp_find_entry+0x172>
 8007796:	463d      	mov	r5, r7
            old_queue = i;
 8007798:	2203      	movs	r2, #3
 800779a:	e704      	b.n	80075a6 <etharp_find_entry+0x172>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 800779c:	f8d9 7050 	ldr.w	r7, [r9, #80]	; 0x50
 80077a0:	2f00      	cmp	r7, #0
 80077a2:	f000 81ca 	beq.w	8007b3a <etharp_find_entry+0x706>
          if (arp_table[i].ctime >= age_queue) {
 80077a6:	f899 7063 	ldrb.w	r7, [r9, #99]	; 0x63
 80077aa:	42af      	cmp	r7, r5
 80077ac:	f4ff af34 	bcc.w	8007618 <etharp_find_entry+0x1e4>
 80077b0:	463d      	mov	r5, r7
            old_queue = i;
 80077b2:	2204      	movs	r2, #4
 80077b4:	e730      	b.n	8007618 <etharp_find_entry+0x1e4>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 80077b6:	f8d9 7064 	ldr.w	r7, [r9, #100]	; 0x64
 80077ba:	2f00      	cmp	r7, #0
 80077bc:	f000 81ce 	beq.w	8007b5c <etharp_find_entry+0x728>
          if (arp_table[i].ctime >= age_queue) {
 80077c0:	f899 7077 	ldrb.w	r7, [r9, #119]	; 0x77
 80077c4:	42af      	cmp	r7, r5
 80077c6:	f4ff af40 	bcc.w	800764a <etharp_find_entry+0x216>
 80077ca:	463d      	mov	r5, r7
            old_queue = i;
 80077cc:	2205      	movs	r2, #5
 80077ce:	e73c      	b.n	800764a <etharp_find_entry+0x216>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 80077d0:	f8d9 7078 	ldr.w	r7, [r9, #120]	; 0x78
 80077d4:	2f00      	cmp	r7, #0
 80077d6:	f000 81ca 	beq.w	8007b6e <etharp_find_entry+0x73a>
          if (arp_table[i].ctime >= age_queue) {
 80077da:	f899 708b 	ldrb.w	r7, [r9, #139]	; 0x8b
 80077de:	42af      	cmp	r7, r5
 80077e0:	f4ff af4c 	bcc.w	800767c <etharp_find_entry+0x248>
 80077e4:	463d      	mov	r5, r7
            old_queue = i;
 80077e6:	2206      	movs	r2, #6
 80077e8:	e748      	b.n	800767c <etharp_find_entry+0x248>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 80077ea:	f8d9 708c 	ldr.w	r7, [r9, #140]	; 0x8c
 80077ee:	2f00      	cmp	r7, #0
 80077f0:	f000 81c6 	beq.w	8007b80 <etharp_find_entry+0x74c>
          if (arp_table[i].ctime >= age_queue) {
 80077f4:	f899 709f 	ldrb.w	r7, [r9, #159]	; 0x9f
 80077f8:	42af      	cmp	r7, r5
 80077fa:	f4ff af59 	bcc.w	80076b0 <etharp_find_entry+0x27c>
 80077fe:	463d      	mov	r5, r7
            old_queue = i;
 8007800:	2207      	movs	r2, #7
 8007802:	e755      	b.n	80076b0 <etharp_find_entry+0x27c>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007804:	f8d9 70a0 	ldr.w	r7, [r9, #160]	; 0xa0
 8007808:	2f00      	cmp	r7, #0
 800780a:	f000 81c2 	beq.w	8007b92 <etharp_find_entry+0x75e>
          if (arp_table[i].ctime >= age_queue) {
 800780e:	f899 70b3 	ldrb.w	r7, [r9, #179]	; 0xb3
 8007812:	42af      	cmp	r7, r5
 8007814:	f4ff af66 	bcc.w	80076e4 <etharp_find_entry+0x2b0>
 8007818:	463d      	mov	r5, r7
            old_queue = i;
 800781a:	2208      	movs	r2, #8
 800781c:	e762      	b.n	80076e4 <etharp_find_entry+0x2b0>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 800781e:	f8d9 60b4 	ldr.w	r6, [r9, #180]	; 0xb4
 8007822:	2e00      	cmp	r6, #0
 8007824:	f000 81c4 	beq.w	8007bb0 <etharp_find_entry+0x77c>
          if (arp_table[i].ctime >= age_queue) {
 8007828:	f899 60c7 	ldrb.w	r6, [r9, #199]	; 0xc7
            old_queue = i;
 800782c:	42ae      	cmp	r6, r5
 800782e:	bf28      	it	cs
 8007830:	2209      	movcs	r2, #9
 8007832:	e645      	b.n	80074c0 <etharp_find_entry+0x8c>
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
      /* recycle oldest pending */
      i = old_pending;
 8007834:	fa5f f888 	uxtb.w	r8, r8
 8007838:	e6c6      	b.n	80075c8 <etharp_find_entry+0x194>
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800783a:	230a      	movs	r3, #10
 800783c:	e689      	b.n	8007552 <etharp_find_entry+0x11e>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800783e:	7ca3      	ldrb	r3, [r4, #18]
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007840:	b353      	cbz	r3, 8007898 <etharp_find_entry+0x464>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007842:	2b01      	cmp	r3, #1
 8007844:	f040 8130 	bne.w	8007aa8 <etharp_find_entry+0x674>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007848:	6823      	ldr	r3, [r4, #0]
 800784a:	2b00      	cmp	r3, #0
 800784c:	f000 81c4 	beq.w	8007bd8 <etharp_find_entry+0x7a4>
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007850:	f04f 0c0a 	mov.w	ip, #10
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
          if (arp_table[i].ctime >= age_queue) {
 8007854:	7ce7      	ldrb	r7, [r4, #19]
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007856:	46e0      	mov	r8, ip
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
          if (arp_table[i].ctime >= age_queue) {
            old_queue = i;
 8007858:	4602      	mov	r2, r0
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 800785a:	4606      	mov	r6, r0
 800785c:	4686      	mov	lr, r0
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800785e:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8007862:	4dbb      	ldr	r5, [pc, #748]	; (8007b50 <etharp_find_entry+0x71c>)
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007864:	2b00      	cmp	r3, #0
 8007866:	f000 8126 	beq.w	8007ab6 <etharp_find_entry+0x682>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 800786a:	2b01      	cmp	r3, #1
 800786c:	f000 81f7 	beq.w	8007c5e <etharp_find_entry+0x82a>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007870:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
 8007874:	42b3      	cmp	r3, r6
 8007876:	bf38      	it	cc
 8007878:	230a      	movcc	r3, #10
 800787a:	f080 81f3 	bcs.w	8007c64 <etharp_find_entry+0x830>
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800787e:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007880:	f894 503a 	ldrb.w	r5, [r4, #58]	; 0x3a
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007884:	d116      	bne.n	80078b4 <etharp_find_entry+0x480>
 8007886:	2d00      	cmp	r5, #0
 8007888:	d13b      	bne.n	8007902 <etharp_find_entry+0x4ce>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800788a:	2302      	movs	r3, #2
 800788c:	e013      	b.n	80078b6 <etharp_find_entry+0x482>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800788e:	2008      	movs	r0, #8
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
 8007890:	b240      	sxtb	r0, r0
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
  }
  arp_table[i].ctime = 0;
  return (err_t)i;
}
 8007892:	b003      	add	sp, #12
 8007894:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007898:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 800789c:	2b00      	cmp	r3, #0
 800789e:	f040 810f 	bne.w	8007ac0 <etharp_find_entry+0x68c>
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 80078a2:	220a      	movs	r2, #10
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 80078a4:	4694      	mov	ip, r2
 80078a6:	4690      	mov	r8, r2
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 80078a8:	4607      	mov	r7, r0
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 80078aa:	4606      	mov	r6, r0
 80078ac:	4686      	mov	lr, r0
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 80078ae:	4603      	mov	r3, r0
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80078b0:	f894 503a 	ldrb.w	r5, [r4, #58]	; 0x3a
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80078b4:	bb2d      	cbnz	r5, 8007902 <etharp_find_entry+0x4ce>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80078b6:	f894 504e 	ldrb.w	r5, [r4, #78]	; 0x4e
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80078ba:	bb95      	cbnz	r5, 8007922 <etharp_find_entry+0x4ee>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80078bc:	f894 5062 	ldrb.w	r5, [r4, #98]	; 0x62
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80078c0:	2d00      	cmp	r5, #0
 80078c2:	d13e      	bne.n	8007942 <etharp_find_entry+0x50e>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80078c4:	f894 5076 	ldrb.w	r5, [r4, #118]	; 0x76
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80078c8:	2d00      	cmp	r5, #0
 80078ca:	d14a      	bne.n	8007962 <etharp_find_entry+0x52e>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80078cc:	f894 508a 	ldrb.w	r5, [r4, #138]	; 0x8a
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80078d0:	2d00      	cmp	r5, #0
 80078d2:	d166      	bne.n	80079a2 <etharp_find_entry+0x56e>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80078d4:	f894 509e 	ldrb.w	r5, [r4, #158]	; 0x9e
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80078d8:	2d00      	cmp	r5, #0
 80078da:	d152      	bne.n	8007982 <etharp_find_entry+0x54e>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80078dc:	f894 50b2 	ldrb.w	r5, [r4, #178]	; 0xb2
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80078e0:	2d00      	cmp	r5, #0
 80078e2:	d16f      	bne.n	80079c4 <etharp_find_entry+0x590>
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80078e4:	f894 50c6 	ldrb.w	r5, [r4, #198]	; 0xc6
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 80078e8:	2d00      	cmp	r5, #0
 80078ea:	f43f ade9 	beq.w	80074c0 <etharp_find_entry+0x8c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 80078ee:	2d01      	cmp	r5, #1
 80078f0:	f000 80ce 	beq.w	8007a90 <etharp_find_entry+0x65c>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 80078f4:	f894 50c7 	ldrb.w	r5, [r4, #199]	; 0xc7
            old_stable = i;
 80078f8:	42b5      	cmp	r5, r6
 80078fa:	bf28      	it	cs
 80078fc:	f04f 0c09 	movcs.w	ip, #9
 8007900:	e5de      	b.n	80074c0 <etharp_find_entry+0x8c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007902:	2d01      	cmp	r5, #1
 8007904:	d06e      	beq.n	80079e4 <etharp_find_entry+0x5b0>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007906:	f894 503b 	ldrb.w	r5, [r4, #59]	; 0x3b
 800790a:	42b5      	cmp	r5, r6
 800790c:	d302      	bcc.n	8007914 <etharp_find_entry+0x4e0>
 800790e:	462e      	mov	r6, r5
            old_stable = i;
 8007910:	f04f 0c02 	mov.w	ip, #2
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007914:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007916:	f894 504e 	ldrb.w	r5, [r4, #78]	; 0x4e
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800791a:	d1ce      	bne.n	80078ba <etharp_find_entry+0x486>
 800791c:	b90d      	cbnz	r5, 8007922 <etharp_find_entry+0x4ee>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800791e:	2303      	movs	r3, #3
 8007920:	e7cc      	b.n	80078bc <etharp_find_entry+0x488>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007922:	2d01      	cmp	r5, #1
 8007924:	d06a      	beq.n	80079fc <etharp_find_entry+0x5c8>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007926:	f894 504f 	ldrb.w	r5, [r4, #79]	; 0x4f
 800792a:	42b5      	cmp	r5, r6
 800792c:	d302      	bcc.n	8007934 <etharp_find_entry+0x500>
 800792e:	462e      	mov	r6, r5
            old_stable = i;
 8007930:	f04f 0c03 	mov.w	ip, #3
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007934:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007936:	f894 5062 	ldrb.w	r5, [r4, #98]	; 0x62
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800793a:	d1c1      	bne.n	80078c0 <etharp_find_entry+0x48c>
 800793c:	b90d      	cbnz	r5, 8007942 <etharp_find_entry+0x50e>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800793e:	2304      	movs	r3, #4
 8007940:	e7c0      	b.n	80078c4 <etharp_find_entry+0x490>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007942:	2d01      	cmp	r5, #1
 8007944:	d066      	beq.n	8007a14 <etharp_find_entry+0x5e0>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007946:	f894 5063 	ldrb.w	r5, [r4, #99]	; 0x63
 800794a:	42b5      	cmp	r5, r6
 800794c:	d302      	bcc.n	8007954 <etharp_find_entry+0x520>
 800794e:	462e      	mov	r6, r5
            old_stable = i;
 8007950:	f04f 0c04 	mov.w	ip, #4
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007954:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007956:	f894 5076 	ldrb.w	r5, [r4, #118]	; 0x76
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800795a:	d1b5      	bne.n	80078c8 <etharp_find_entry+0x494>
 800795c:	b90d      	cbnz	r5, 8007962 <etharp_find_entry+0x52e>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800795e:	2305      	movs	r3, #5
 8007960:	e7b4      	b.n	80078cc <etharp_find_entry+0x498>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007962:	2d01      	cmp	r5, #1
 8007964:	d062      	beq.n	8007a2c <etharp_find_entry+0x5f8>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007966:	f894 5077 	ldrb.w	r5, [r4, #119]	; 0x77
 800796a:	42b5      	cmp	r5, r6
 800796c:	d302      	bcc.n	8007974 <etharp_find_entry+0x540>
 800796e:	462e      	mov	r6, r5
            old_stable = i;
 8007970:	f04f 0c05 	mov.w	ip, #5
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007974:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007976:	f894 508a 	ldrb.w	r5, [r4, #138]	; 0x8a
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800797a:	d1a9      	bne.n	80078d0 <etharp_find_entry+0x49c>
 800797c:	b98d      	cbnz	r5, 80079a2 <etharp_find_entry+0x56e>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800797e:	2306      	movs	r3, #6
 8007980:	e7a8      	b.n	80078d4 <etharp_find_entry+0x4a0>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007982:	2d01      	cmp	r5, #1
 8007984:	d077      	beq.n	8007a76 <etharp_find_entry+0x642>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007986:	f894 509f 	ldrb.w	r5, [r4, #159]	; 0x9f
 800798a:	42b5      	cmp	r5, r6
 800798c:	d302      	bcc.n	8007994 <etharp_find_entry+0x560>
 800798e:	462e      	mov	r6, r5
            old_stable = i;
 8007990:	f04f 0c07 	mov.w	ip, #7
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007994:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007996:	f894 50b2 	ldrb.w	r5, [r4, #178]	; 0xb2
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800799a:	d1a1      	bne.n	80078e0 <etharp_find_entry+0x4ac>
 800799c:	b995      	cbnz	r5, 80079c4 <etharp_find_entry+0x590>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800799e:	2308      	movs	r3, #8
 80079a0:	e7a0      	b.n	80078e4 <etharp_find_entry+0x4b0>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 80079a2:	2d01      	cmp	r5, #1
 80079a4:	d04e      	beq.n	8007a44 <etharp_find_entry+0x610>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 80079a6:	f894 508b 	ldrb.w	r5, [r4, #139]	; 0x8b
 80079aa:	42b5      	cmp	r5, r6
 80079ac:	d302      	bcc.n	80079b4 <etharp_find_entry+0x580>
 80079ae:	462e      	mov	r6, r5
            old_stable = i;
 80079b0:	f04f 0c06 	mov.w	ip, #6
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80079b4:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80079b6:	f894 509e 	ldrb.w	r5, [r4, #158]	; 0x9e
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80079ba:	d18d      	bne.n	80078d8 <etharp_find_entry+0x4a4>
 80079bc:	2d00      	cmp	r5, #0
 80079be:	d1e0      	bne.n	8007982 <etharp_find_entry+0x54e>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 80079c0:	2307      	movs	r3, #7
 80079c2:	e78b      	b.n	80078dc <etharp_find_entry+0x4a8>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 80079c4:	2d01      	cmp	r5, #1
 80079c6:	d049      	beq.n	8007a5c <etharp_find_entry+0x628>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 80079c8:	f894 50b3 	ldrb.w	r5, [r4, #179]	; 0xb3
 80079cc:	42b5      	cmp	r5, r6
 80079ce:	d302      	bcc.n	80079d6 <etharp_find_entry+0x5a2>
 80079d0:	462e      	mov	r6, r5
            old_stable = i;
 80079d2:	f04f 0c08 	mov.w	ip, #8
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80079d6:	2b0a      	cmp	r3, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 80079d8:	f894 50c6 	ldrb.w	r5, [r4, #198]	; 0xc6
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80079dc:	d184      	bne.n	80078e8 <etharp_find_entry+0x4b4>
 80079de:	2d00      	cmp	r5, #0
 80079e0:	d185      	bne.n	80078ee <etharp_find_entry+0x4ba>
 80079e2:	e685      	b.n	80076f0 <etharp_find_entry+0x2bc>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 80079e4:	4d5a      	ldr	r5, [pc, #360]	; (8007b50 <etharp_find_entry+0x71c>)
 80079e6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
          if (arp_table[i].ctime >= age_queue) {
 80079e8:	f895 503b 	ldrb.w	r5, [r5, #59]	; 0x3b
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 80079ec:	2900      	cmp	r1, #0
 80079ee:	f000 8113 	beq.w	8007c18 <etharp_find_entry+0x7e4>
          if (arp_table[i].ctime >= age_queue) {
 80079f2:	42bd      	cmp	r5, r7
 80079f4:	d38e      	bcc.n	8007914 <etharp_find_entry+0x4e0>
 80079f6:	462f      	mov	r7, r5
            old_queue = i;
 80079f8:	2202      	movs	r2, #2
 80079fa:	e78b      	b.n	8007914 <etharp_find_entry+0x4e0>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 80079fc:	4d54      	ldr	r5, [pc, #336]	; (8007b50 <etharp_find_entry+0x71c>)
 80079fe:	6be1      	ldr	r1, [r4, #60]	; 0x3c
          if (arp_table[i].ctime >= age_queue) {
 8007a00:	f895 504f 	ldrb.w	r5, [r5, #79]	; 0x4f
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a04:	2900      	cmp	r1, #0
 8007a06:	f000 8100 	beq.w	8007c0a <etharp_find_entry+0x7d6>
          if (arp_table[i].ctime >= age_queue) {
 8007a0a:	42bd      	cmp	r5, r7
 8007a0c:	d392      	bcc.n	8007934 <etharp_find_entry+0x500>
 8007a0e:	462f      	mov	r7, r5
            old_queue = i;
 8007a10:	2203      	movs	r2, #3
 8007a12:	e78f      	b.n	8007934 <etharp_find_entry+0x500>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a14:	4d4e      	ldr	r5, [pc, #312]	; (8007b50 <etharp_find_entry+0x71c>)
 8007a16:	6d21      	ldr	r1, [r4, #80]	; 0x50
          if (arp_table[i].ctime >= age_queue) {
 8007a18:	f895 5063 	ldrb.w	r5, [r5, #99]	; 0x63
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a1c:	2900      	cmp	r1, #0
 8007a1e:	f000 80d4 	beq.w	8007bca <etharp_find_entry+0x796>
          if (arp_table[i].ctime >= age_queue) {
 8007a22:	42bd      	cmp	r5, r7
 8007a24:	d396      	bcc.n	8007954 <etharp_find_entry+0x520>
 8007a26:	462f      	mov	r7, r5
            old_queue = i;
 8007a28:	2204      	movs	r2, #4
 8007a2a:	e793      	b.n	8007954 <etharp_find_entry+0x520>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a2c:	4d48      	ldr	r5, [pc, #288]	; (8007b50 <etharp_find_entry+0x71c>)
 8007a2e:	6e61      	ldr	r1, [r4, #100]	; 0x64
          if (arp_table[i].ctime >= age_queue) {
 8007a30:	f895 5077 	ldrb.w	r5, [r5, #119]	; 0x77
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a34:	2900      	cmp	r1, #0
 8007a36:	f000 80e1 	beq.w	8007bfc <etharp_find_entry+0x7c8>
          if (arp_table[i].ctime >= age_queue) {
 8007a3a:	42bd      	cmp	r5, r7
 8007a3c:	d39a      	bcc.n	8007974 <etharp_find_entry+0x540>
 8007a3e:	462f      	mov	r7, r5
            old_queue = i;
 8007a40:	2205      	movs	r2, #5
 8007a42:	e797      	b.n	8007974 <etharp_find_entry+0x540>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a44:	4d42      	ldr	r5, [pc, #264]	; (8007b50 <etharp_find_entry+0x71c>)
 8007a46:	6fa1      	ldr	r1, [r4, #120]	; 0x78
          if (arp_table[i].ctime >= age_queue) {
 8007a48:	f895 508b 	ldrb.w	r5, [r5, #139]	; 0x8b
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a4c:	2900      	cmp	r1, #0
 8007a4e:	f000 80ea 	beq.w	8007c26 <etharp_find_entry+0x7f2>
          if (arp_table[i].ctime >= age_queue) {
 8007a52:	42bd      	cmp	r5, r7
 8007a54:	d3ae      	bcc.n	80079b4 <etharp_find_entry+0x580>
 8007a56:	462f      	mov	r7, r5
            old_queue = i;
 8007a58:	2206      	movs	r2, #6
 8007a5a:	e7ab      	b.n	80079b4 <etharp_find_entry+0x580>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a5c:	4d3c      	ldr	r5, [pc, #240]	; (8007b50 <etharp_find_entry+0x71c>)
 8007a5e:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
          if (arp_table[i].ctime >= age_queue) {
 8007a62:	f895 50b3 	ldrb.w	r5, [r5, #179]	; 0xb3
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a66:	2900      	cmp	r1, #0
 8007a68:	f000 80f2 	beq.w	8007c50 <etharp_find_entry+0x81c>
          if (arp_table[i].ctime >= age_queue) {
 8007a6c:	42bd      	cmp	r5, r7
 8007a6e:	d3b2      	bcc.n	80079d6 <etharp_find_entry+0x5a2>
 8007a70:	462f      	mov	r7, r5
            old_queue = i;
 8007a72:	2208      	movs	r2, #8
 8007a74:	e7af      	b.n	80079d6 <etharp_find_entry+0x5a2>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a76:	4d36      	ldr	r5, [pc, #216]	; (8007b50 <etharp_find_entry+0x71c>)
 8007a78:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
          if (arp_table[i].ctime >= age_queue) {
 8007a7c:	f895 509f 	ldrb.w	r5, [r5, #159]	; 0x9f
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a80:	2900      	cmp	r1, #0
 8007a82:	f000 80d7 	beq.w	8007c34 <etharp_find_entry+0x800>
          if (arp_table[i].ctime >= age_queue) {
 8007a86:	42bd      	cmp	r5, r7
 8007a88:	d384      	bcc.n	8007994 <etharp_find_entry+0x560>
 8007a8a:	462f      	mov	r7, r5
            old_queue = i;
 8007a8c:	2207      	movs	r2, #7
 8007a8e:	e781      	b.n	8007994 <etharp_find_entry+0x560>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007a90:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 8007a94:	4e2e      	ldr	r6, [pc, #184]	; (8007b50 <etharp_find_entry+0x71c>)
 8007a96:	2d00      	cmp	r5, #0
 8007a98:	f000 80d3 	beq.w	8007c42 <etharp_find_entry+0x80e>
          if (arp_table[i].ctime >= age_queue) {
 8007a9c:	f896 50c7 	ldrb.w	r5, [r6, #199]	; 0xc7
            old_queue = i;
 8007aa0:	42bd      	cmp	r5, r7
 8007aa2:	bf28      	it	cs
 8007aa4:	2209      	movcs	r2, #9
 8007aa6:	e50b      	b.n	80074c0 <etharp_find_entry+0x8c>
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 8007aa8:	220a      	movs	r2, #10
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007aaa:	4690      	mov	r8, r2
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007aac:	7ce6      	ldrb	r6, [r4, #19]
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 8007aae:	4607      	mov	r7, r0
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007ab0:	4686      	mov	lr, r0
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
            old_stable = i;
 8007ab2:	4684      	mov	ip, r0
 8007ab4:	e6d3      	b.n	800785e <etharp_find_entry+0x42a>
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007ab6:	2301      	movs	r3, #1
 8007ab8:	e6fa      	b.n	80078b0 <etharp_find_entry+0x47c>
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
 8007aba:	f04f 30ff 	mov.w	r0, #4294967295
 8007abe:	e518      	b.n	80074f2 <etharp_find_entry+0xbe>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007ac0:	2b01      	cmp	r3, #1
 8007ac2:	d111      	bne.n	8007ae8 <etharp_find_entry+0x6b4>
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 8007ac4:	220a      	movs	r2, #10
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007ac6:	4694      	mov	ip, r2
 8007ac8:	4690      	mov	r8, r2
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 8007aca:	4681      	mov	r9, r0
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007acc:	4606      	mov	r6, r0
 8007ace:	4686      	mov	lr, r0
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007ad0:	4603      	mov	r3, r0
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007ad2:	6965      	ldr	r5, [r4, #20]
 8007ad4:	4f1e      	ldr	r7, [pc, #120]	; (8007b50 <etharp_find_entry+0x71c>)
 8007ad6:	2d00      	cmp	r5, #0
 8007ad8:	f000 8086 	beq.w	8007be8 <etharp_find_entry+0x7b4>
          if (arp_table[i].ctime >= age_queue) {
 8007adc:	f897 7027 	ldrb.w	r7, [r7, #39]	; 0x27
 8007ae0:	454f      	cmp	r7, r9
 8007ae2:	d270      	bcs.n	8007bc6 <etharp_find_entry+0x792>
 8007ae4:	464f      	mov	r7, r9
 8007ae6:	e6ca      	b.n	800787e <etharp_find_entry+0x44a>
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 8007ae8:	220a      	movs	r2, #10
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007aea:	f894 6027 	ldrb.w	r6, [r4, #39]	; 0x27
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007aee:	4690      	mov	r8, r2
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 8007af0:	4607      	mov	r7, r0
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007af2:	4686      	mov	lr, r0
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007af4:	4603      	mov	r3, r0
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
            old_stable = i;
 8007af6:	f04f 0c01 	mov.w	ip, #1
 8007afa:	e6c0      	b.n	800787e <etharp_find_entry+0x44a>
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 8007afc:	220a      	movs	r2, #10
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007afe:	46ae      	mov	lr, r5
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
            old_pending = i;
 8007b00:	46a8      	mov	r8, r5
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007b02:	4694      	mov	ip, r2
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007b04:	f894 b013 	ldrb.w	fp, [r4, #19]
 8007b08:	e4ae      	b.n	8007468 <etharp_find_entry+0x34>
 8007b0a:	45d9      	cmp	r9, fp
 8007b0c:	f4ff ad31 	bcc.w	8007572 <etharp_find_entry+0x13e>
 8007b10:	46cb      	mov	fp, r9
            old_pending = i;
 8007b12:	46b8      	mov	r8, r7
 8007b14:	e52d      	b.n	8007572 <etharp_find_entry+0x13e>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007b16:	f899 703b 	ldrb.w	r7, [r9, #59]	; 0x3b
 8007b1a:	455f      	cmp	r7, fp
 8007b1c:	f4ff ad0b 	bcc.w	8007536 <etharp_find_entry+0x102>
 8007b20:	46bb      	mov	fp, r7
            old_pending = i;
 8007b22:	f04f 0802 	mov.w	r8, #2
 8007b26:	e506      	b.n	8007536 <etharp_find_entry+0x102>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007b28:	f899 704f 	ldrb.w	r7, [r9, #79]	; 0x4f
 8007b2c:	455f      	cmp	r7, fp
 8007b2e:	f4ff ad3a 	bcc.w	80075a6 <etharp_find_entry+0x172>
 8007b32:	46bb      	mov	fp, r7
            old_pending = i;
 8007b34:	f04f 0803 	mov.w	r8, #3
 8007b38:	e535      	b.n	80075a6 <etharp_find_entry+0x172>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007b3a:	f899 7063 	ldrb.w	r7, [r9, #99]	; 0x63
 8007b3e:	455f      	cmp	r7, fp
 8007b40:	f4ff ad6a 	bcc.w	8007618 <etharp_find_entry+0x1e4>
 8007b44:	46bb      	mov	fp, r7
            old_pending = i;
 8007b46:	f04f 0804 	mov.w	r8, #4
 8007b4a:	e565      	b.n	8007618 <etharp_find_entry+0x1e4>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007b4c:	2001      	movs	r0, #1
 8007b4e:	e69f      	b.n	8007890 <etharp_find_entry+0x45c>
 8007b50:	200029ac 	.word	0x200029ac
 8007b54:	2000      	movs	r0, #0
 8007b56:	e69b      	b.n	8007890 <etharp_find_entry+0x45c>
 8007b58:	2002      	movs	r0, #2
 8007b5a:	e699      	b.n	8007890 <etharp_find_entry+0x45c>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007b5c:	f899 7077 	ldrb.w	r7, [r9, #119]	; 0x77
 8007b60:	455f      	cmp	r7, fp
 8007b62:	f4ff ad72 	bcc.w	800764a <etharp_find_entry+0x216>
 8007b66:	46bb      	mov	fp, r7
            old_pending = i;
 8007b68:	f04f 0805 	mov.w	r8, #5
 8007b6c:	e56d      	b.n	800764a <etharp_find_entry+0x216>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007b6e:	f899 708b 	ldrb.w	r7, [r9, #139]	; 0x8b
 8007b72:	455f      	cmp	r7, fp
 8007b74:	f4ff ad82 	bcc.w	800767c <etharp_find_entry+0x248>
 8007b78:	46bb      	mov	fp, r7
            old_pending = i;
 8007b7a:	f04f 0806 	mov.w	r8, #6
 8007b7e:	e57d      	b.n	800767c <etharp_find_entry+0x248>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007b80:	f899 709f 	ldrb.w	r7, [r9, #159]	; 0x9f
 8007b84:	455f      	cmp	r7, fp
 8007b86:	f4ff ad93 	bcc.w	80076b0 <etharp_find_entry+0x27c>
 8007b8a:	46bb      	mov	fp, r7
            old_pending = i;
 8007b8c:	f04f 0807 	mov.w	r8, #7
 8007b90:	e58e      	b.n	80076b0 <etharp_find_entry+0x27c>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007b92:	f899 70b3 	ldrb.w	r7, [r9, #179]	; 0xb3
 8007b96:	455f      	cmp	r7, fp
 8007b98:	f4ff ada4 	bcc.w	80076e4 <etharp_find_entry+0x2b0>
 8007b9c:	46bb      	mov	fp, r7
            old_pending = i;
 8007b9e:	f04f 0808 	mov.w	r8, #8
 8007ba2:	e59f      	b.n	80076e4 <etharp_find_entry+0x2b0>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007ba4:	2004      	movs	r0, #4
 8007ba6:	e673      	b.n	8007890 <etharp_find_entry+0x45c>
 8007ba8:	2005      	movs	r0, #5
 8007baa:	e671      	b.n	8007890 <etharp_find_entry+0x45c>
 8007bac:	2003      	movs	r0, #3
 8007bae:	e66f      	b.n	8007890 <etharp_find_entry+0x45c>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007bb0:	f899 50c7 	ldrb.w	r5, [r9, #199]	; 0xc7
            old_pending = i;
 8007bb4:	455d      	cmp	r5, fp
 8007bb6:	bf28      	it	cs
 8007bb8:	f04f 0809 	movcs.w	r8, #9
 8007bbc:	e480      	b.n	80074c0 <etharp_find_entry+0x8c>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007bbe:	2006      	movs	r0, #6
 8007bc0:	e666      	b.n	8007890 <etharp_find_entry+0x45c>
 8007bc2:	2007      	movs	r0, #7
 8007bc4:	e664      	b.n	8007890 <etharp_find_entry+0x45c>
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
          if (arp_table[i].ctime >= age_queue) {
            old_queue = i;
 8007bc6:	2201      	movs	r2, #1
 8007bc8:	e659      	b.n	800787e <etharp_find_entry+0x44a>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007bca:	4575      	cmp	r5, lr
 8007bcc:	f4ff aec2 	bcc.w	8007954 <etharp_find_entry+0x520>
 8007bd0:	46ae      	mov	lr, r5
            old_pending = i;
 8007bd2:	f04f 0804 	mov.w	r8, #4
 8007bd6:	e6bd      	b.n	8007954 <etharp_find_entry+0x520>
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 8007bd8:	220a      	movs	r2, #10
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007bda:	4694      	mov	ip, r2
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007bdc:	f894 e013 	ldrb.w	lr, [r4, #19]
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 8007be0:	4607      	mov	r7, r0
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007be2:	4606      	mov	r6, r0
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
            old_pending = i;
 8007be4:	4680      	mov	r8, r0
 8007be6:	e63a      	b.n	800785e <etharp_find_entry+0x42a>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007be8:	f897 5027 	ldrb.w	r5, [r7, #39]	; 0x27
 8007bec:	45ae      	cmp	lr, r5
 8007bee:	464f      	mov	r7, r9
 8007bf0:	f63f ae45 	bhi.w	800787e <etharp_find_entry+0x44a>
 8007bf4:	46ae      	mov	lr, r5
            old_pending = i;
 8007bf6:	f04f 0801 	mov.w	r8, #1
 8007bfa:	e640      	b.n	800787e <etharp_find_entry+0x44a>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007bfc:	4575      	cmp	r5, lr
 8007bfe:	f4ff aeb9 	bcc.w	8007974 <etharp_find_entry+0x540>
 8007c02:	46ae      	mov	lr, r5
            old_pending = i;
 8007c04:	f04f 0805 	mov.w	r8, #5
 8007c08:	e6b4      	b.n	8007974 <etharp_find_entry+0x540>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007c0a:	4575      	cmp	r5, lr
 8007c0c:	f4ff ae92 	bcc.w	8007934 <etharp_find_entry+0x500>
 8007c10:	46ae      	mov	lr, r5
            old_pending = i;
 8007c12:	f04f 0803 	mov.w	r8, #3
 8007c16:	e68d      	b.n	8007934 <etharp_find_entry+0x500>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007c18:	4575      	cmp	r5, lr
 8007c1a:	f4ff ae7b 	bcc.w	8007914 <etharp_find_entry+0x4e0>
 8007c1e:	46ae      	mov	lr, r5
            old_pending = i;
 8007c20:	f04f 0802 	mov.w	r8, #2
 8007c24:	e676      	b.n	8007914 <etharp_find_entry+0x4e0>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007c26:	4575      	cmp	r5, lr
 8007c28:	f4ff aec4 	bcc.w	80079b4 <etharp_find_entry+0x580>
 8007c2c:	46ae      	mov	lr, r5
            old_pending = i;
 8007c2e:	f04f 0806 	mov.w	r8, #6
 8007c32:	e6bf      	b.n	80079b4 <etharp_find_entry+0x580>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007c34:	4575      	cmp	r5, lr
 8007c36:	f4ff aead 	bcc.w	8007994 <etharp_find_entry+0x560>
 8007c3a:	46ae      	mov	lr, r5
            old_pending = i;
 8007c3c:	f04f 0807 	mov.w	r8, #7
 8007c40:	e6a8      	b.n	8007994 <etharp_find_entry+0x560>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007c42:	f896 50c7 	ldrb.w	r5, [r6, #199]	; 0xc7
            old_pending = i;
 8007c46:	4575      	cmp	r5, lr
 8007c48:	bf28      	it	cs
 8007c4a:	f04f 0809 	movcs.w	r8, #9
 8007c4e:	e437      	b.n	80074c0 <etharp_find_entry+0x8c>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007c50:	4575      	cmp	r5, lr
 8007c52:	f4ff aec0 	bcc.w	80079d6 <etharp_find_entry+0x5a2>
 8007c56:	46ae      	mov	lr, r5
            old_pending = i;
 8007c58:	f04f 0808 	mov.w	r8, #8
 8007c5c:	e6bb      	b.n	80079d6 <etharp_find_entry+0x5a2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007c5e:	46b9      	mov	r9, r7
 8007c60:	230a      	movs	r3, #10
 8007c62:	e736      	b.n	8007ad2 <etharp_find_entry+0x69e>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007c64:	461e      	mov	r6, r3
 8007c66:	230a      	movs	r3, #10
 8007c68:	e745      	b.n	8007af6 <etharp_find_entry+0x6c2>
 8007c6a:	bf00      	nop

08007c6c <etharp_raw.constprop.0>:
 */
#if !LWIP_AUTOIP
static
#endif /* LWIP_AUTOIP */
err_t
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
 8007c6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007c70:	4606      	mov	r6, r0
 8007c72:	460f      	mov	r7, r1
 8007c74:	4690      	mov	r8, r2
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 8007c76:	212a      	movs	r1, #42	; 0x2a
 8007c78:	2200      	movs	r2, #0
 8007c7a:	2003      	movs	r0, #3
 */
#if !LWIP_AUTOIP
static
#endif /* LWIP_AUTOIP */
err_t
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
 8007c7c:	4699      	mov	r9, r3
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 8007c7e:	f7fc f933 	bl	8003ee8 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 8007c82:	2800      	cmp	r0, #0
 8007c84:	d03a      	beq.n	8007cfc <etharp_raw.constprop.0+0x90>
 8007c86:	4605      	mov	r5, r0
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 8007c88:	2001      	movs	r0, #1
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
 8007c8a:	686c      	ldr	r4, [r5, #4]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 8007c8c:	f7f9 fdee 	bl	800186c <lwip_htons>
 8007c90:	82a0      	strh	r0, [r4, #20]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8007c92:	f8d8 3000 	ldr.w	r3, [r8]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8007c96:	4a1b      	ldr	r2, [pc, #108]	; (8007d04 <etharp_raw.constprop.0+0x98>)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8007c98:	f8c4 3016 	str.w	r3, [r4, #22]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 8007c9c:	4b1a      	ldr	r3, [pc, #104]	; (8007d08 <etharp_raw.constprop.0+0x9c>)
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8007c9e:	6810      	ldr	r0, [r2, #0]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8007ca0:	f8b8 1004 	ldrh.w	r1, [r8, #4]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8007ca4:	8892      	ldrh	r2, [r2, #4]
 8007ca6:	6220      	str	r0, [r4, #32]
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 8007ca8:	6818      	ldr	r0, [r3, #0]
 8007caa:	889b      	ldrh	r3, [r3, #4]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8007cac:	8361      	strh	r1, [r4, #26]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8007cae:	84a2      	strh	r2, [r4, #36]	; 0x24
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 8007cb0:	6020      	str	r0, [r4, #0]
 8007cb2:	80a3      	strh	r3, [r4, #4]
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 8007cb4:	683b      	ldr	r3, [r7, #0]
 8007cb6:	f8c4 3006 	str.w	r3, [r4, #6]
 8007cba:	88bb      	ldrh	r3, [r7, #4]
 8007cbc:	8163      	strh	r3, [r4, #10]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 8007cbe:	f8d9 3000 	ldr.w	r3, [r9]
 8007cc2:	61e3      	str	r3, [r4, #28]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 8007cc4:	9b08      	ldr	r3, [sp, #32]
 8007cc6:	681b      	ldr	r3, [r3, #0]
 8007cc8:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 8007ccc:	2106      	movs	r1, #6
  hdr->protolen = sizeof(ip_addr_t);
 8007cce:	2304      	movs	r3, #4
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8007cd0:	2200      	movs	r2, #0
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);
 8007cd2:	74e3      	strb	r3, [r4, #19]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 8007cd4:	74a1      	strb	r1, [r4, #18]
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8007cd6:	2308      	movs	r3, #8
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8007cd8:	2001      	movs	r0, #1
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 8007cda:	69b7      	ldr	r7, [r6, #24]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8007cdc:	73e0      	strb	r0, [r4, #15]
 8007cde:	73a2      	strb	r2, [r4, #14]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8007ce0:	7462      	strb	r2, [r4, #17]
 8007ce2:	7423      	strb	r3, [r4, #16]
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 8007ce4:	7323      	strb	r3, [r4, #12]
 8007ce6:	7361      	strb	r1, [r4, #13]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 8007ce8:	4630      	mov	r0, r6
 8007cea:	4629      	mov	r1, r5
 8007cec:	47b8      	blx	r7
 8007cee:	4604      	mov	r4, r0
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 8007cf0:	4628      	mov	r0, r5
 8007cf2:	f7fc fa51 	bl	8004198 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 8007cf6:	4620      	mov	r0, r4
 8007cf8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
 8007cfc:	f04f 30ff 	mov.w	r0, #4294967295
  pbuf_free(p);
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
}
 8007d00:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8007d04:	0800ca3c 	.word	0x0800ca3c
 8007d08:	0800ca34 	.word	0x0800ca34

08007d0c <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 8007d0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007d10:	4d17      	ldr	r5, [pc, #92]	; (8007d70 <etharp_tmr+0x64>)
 8007d12:	f1a5 0412 	sub.w	r4, r5, #18
 8007d16:	f104 06c8 	add.w	r6, r4, #200	; 0xc8
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007d1a:	f04f 0800 	mov.w	r8, #0
        etharp_free_entry(i);
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 8007d1e:	2702      	movs	r7, #2
 8007d20:	e009      	b.n	8007d36 <etharp_tmr+0x2a>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8007d22:	2a01      	cmp	r2, #1
 8007d24:	d020      	beq.n	8007d68 <etharp_tmr+0x5c>
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 8007d26:	2a03      	cmp	r2, #3
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 8007d28:	bf08      	it	eq
 8007d2a:	74a7      	strbeq	r7, [r4, #18]
 8007d2c:	3414      	adds	r4, #20
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007d2e:	42b4      	cmp	r4, r6
 8007d30:	f105 0514 	add.w	r5, r5, #20
 8007d34:	d016      	beq.n	8007d64 <etharp_tmr+0x58>
    u8_t state = arp_table[i].state;
 8007d36:	7ca2      	ldrb	r2, [r4, #18]
    if (state != ETHARP_STATE_EMPTY
 8007d38:	2a00      	cmp	r2, #0
 8007d3a:	d0f7      	beq.n	8007d2c <etharp_tmr+0x20>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
 8007d3c:	7ce3      	ldrb	r3, [r4, #19]
 8007d3e:	3301      	adds	r3, #1
 8007d40:	b2db      	uxtb	r3, r3
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8007d42:	2bef      	cmp	r3, #239	; 0xef
    if (state != ETHARP_STATE_EMPTY
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
 8007d44:	74e3      	strb	r3, [r4, #19]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8007d46:	d9ec      	bls.n	8007d22 <etharp_tmr+0x16>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007d48:	f855 0c12 	ldr.w	r0, [r5, #-18]
 8007d4c:	b118      	cbz	r0, 8007d56 <etharp_tmr+0x4a>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007d4e:	f7fc fa23 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007d52:	f845 8c12 	str.w	r8, [r5, #-18]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007d56:	f884 8012 	strb.w	r8, [r4, #18]
 8007d5a:	3414      	adds	r4, #20
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007d5c:	42b4      	cmp	r4, r6
 8007d5e:	f105 0514 	add.w	r5, r5, #20
 8007d62:	d1e8      	bne.n	8007d36 <etharp_tmr+0x2a>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
 8007d64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 8007d68:	2b01      	cmp	r3, #1
 8007d6a:	d8ed      	bhi.n	8007d48 <etharp_tmr+0x3c>
 8007d6c:	e7de      	b.n	8007d2c <etharp_tmr+0x20>
 8007d6e:	bf00      	nop
 8007d70:	200029be 	.word	0x200029be

08007d74 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
 8007d74:	b570      	push	{r4, r5, r6, lr}
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007d76:	4c5a      	ldr	r4, [pc, #360]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007d78:	7ca3      	ldrb	r3, [r4, #18]
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
 8007d7a:	4605      	mov	r5, r0
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007d7c:	b113      	cbz	r3, 8007d84 <etharp_cleanup_netif+0x10>
 8007d7e:	68a3      	ldr	r3, [r4, #8]
 8007d80:	4298      	cmp	r0, r3
 8007d82:	d04f      	beq.n	8007e24 <etharp_cleanup_netif+0xb0>
 8007d84:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007d88:	4e55      	ldr	r6, [pc, #340]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007d8a:	b113      	cbz	r3, 8007d92 <etharp_cleanup_netif+0x1e>
 8007d8c:	69f3      	ldr	r3, [r6, #28]
 8007d8e:	429d      	cmp	r5, r3
 8007d90:	d051      	beq.n	8007e36 <etharp_cleanup_netif+0xc2>
 8007d92:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007d96:	4e52      	ldr	r6, [pc, #328]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007d98:	b113      	cbz	r3, 8007da0 <etharp_cleanup_netif+0x2c>
 8007d9a:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8007d9c:	429d      	cmp	r5, r3
 8007d9e:	d054      	beq.n	8007e4a <etharp_cleanup_netif+0xd6>
 8007da0:	f894 304e 	ldrb.w	r3, [r4, #78]	; 0x4e
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007da4:	4e4e      	ldr	r6, [pc, #312]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007da6:	b113      	cbz	r3, 8007dae <etharp_cleanup_netif+0x3a>
 8007da8:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8007daa:	429d      	cmp	r5, r3
 8007dac:	d057      	beq.n	8007e5e <etharp_cleanup_netif+0xea>
 8007dae:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007db2:	4e4b      	ldr	r6, [pc, #300]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007db4:	b113      	cbz	r3, 8007dbc <etharp_cleanup_netif+0x48>
 8007db6:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8007db8:	429d      	cmp	r5, r3
 8007dba:	d05a      	beq.n	8007e72 <etharp_cleanup_netif+0xfe>
 8007dbc:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007dc0:	4e47      	ldr	r6, [pc, #284]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007dc2:	b113      	cbz	r3, 8007dca <etharp_cleanup_netif+0x56>
 8007dc4:	6ef3      	ldr	r3, [r6, #108]	; 0x6c
 8007dc6:	429d      	cmp	r5, r3
 8007dc8:	d05d      	beq.n	8007e86 <etharp_cleanup_netif+0x112>
 8007dca:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007dce:	4e44      	ldr	r6, [pc, #272]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007dd0:	b11b      	cbz	r3, 8007dda <etharp_cleanup_netif+0x66>
 8007dd2:	f8d6 3080 	ldr.w	r3, [r6, #128]	; 0x80
 8007dd6:	429d      	cmp	r5, r3
 8007dd8:	d05f      	beq.n	8007e9a <etharp_cleanup_netif+0x126>
 8007dda:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007dde:	4e40      	ldr	r6, [pc, #256]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007de0:	b11b      	cbz	r3, 8007dea <etharp_cleanup_netif+0x76>
 8007de2:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8007de6:	429d      	cmp	r5, r3
 8007de8:	d061      	beq.n	8007eae <etharp_cleanup_netif+0x13a>
 8007dea:	f894 30b2 	ldrb.w	r3, [r4, #178]	; 0xb2
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007dee:	4e3c      	ldr	r6, [pc, #240]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007df0:	b11b      	cbz	r3, 8007dfa <etharp_cleanup_netif+0x86>
 8007df2:	f8d6 30a8 	ldr.w	r3, [r6, #168]	; 0xa8
 8007df6:	429d      	cmp	r5, r3
 8007df8:	d065      	beq.n	8007ec6 <etharp_cleanup_netif+0x152>
 8007dfa:	f894 30c6 	ldrb.w	r3, [r4, #198]	; 0xc6
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007dfe:	4e38      	ldr	r6, [pc, #224]	; (8007ee0 <etharp_cleanup_netif+0x16c>)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8007e00:	b11b      	cbz	r3, 8007e0a <etharp_cleanup_netif+0x96>
 8007e02:	f8d6 30bc 	ldr.w	r3, [r6, #188]	; 0xbc
 8007e06:	42ab      	cmp	r3, r5
 8007e08:	d000      	beq.n	8007e0c <etharp_cleanup_netif+0x98>
 8007e0a:	bd70      	pop	{r4, r5, r6, pc}
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007e0c:	f8d6 00b4 	ldr.w	r0, [r6, #180]	; 0xb4
 8007e10:	b120      	cbz	r0, 8007e1c <etharp_cleanup_netif+0xa8>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007e12:	f7fc f9c1 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007e16:	2300      	movs	r3, #0
 8007e18:	f8c6 30b4 	str.w	r3, [r6, #180]	; 0xb4
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007e1c:	2300      	movs	r3, #0
 8007e1e:	f884 30c6 	strb.w	r3, [r4, #198]	; 0xc6
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
 8007e22:	e7f2      	b.n	8007e0a <etharp_cleanup_netif+0x96>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007e24:	6820      	ldr	r0, [r4, #0]
 8007e26:	b118      	cbz	r0, 8007e30 <etharp_cleanup_netif+0xbc>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007e28:	f7fc f9b6 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007e2c:	2300      	movs	r3, #0
 8007e2e:	6023      	str	r3, [r4, #0]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007e30:	2300      	movs	r3, #0
 8007e32:	74a3      	strb	r3, [r4, #18]
 8007e34:	e7a6      	b.n	8007d84 <etharp_cleanup_netif+0x10>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007e36:	6970      	ldr	r0, [r6, #20]
 8007e38:	b118      	cbz	r0, 8007e42 <etharp_cleanup_netif+0xce>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007e3a:	f7fc f9ad 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007e3e:	2300      	movs	r3, #0
 8007e40:	6173      	str	r3, [r6, #20]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007e42:	2300      	movs	r3, #0
 8007e44:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
 8007e48:	e7a3      	b.n	8007d92 <etharp_cleanup_netif+0x1e>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007e4a:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 8007e4c:	b118      	cbz	r0, 8007e56 <etharp_cleanup_netif+0xe2>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007e4e:	f7fc f9a3 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007e52:	2300      	movs	r3, #0
 8007e54:	62b3      	str	r3, [r6, #40]	; 0x28
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007e56:	2300      	movs	r3, #0
 8007e58:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
 8007e5c:	e7a0      	b.n	8007da0 <etharp_cleanup_netif+0x2c>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007e5e:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8007e60:	b118      	cbz	r0, 8007e6a <etharp_cleanup_netif+0xf6>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007e62:	f7fc f999 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007e66:	2300      	movs	r3, #0
 8007e68:	63f3      	str	r3, [r6, #60]	; 0x3c
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007e6a:	2300      	movs	r3, #0
 8007e6c:	f884 304e 	strb.w	r3, [r4, #78]	; 0x4e
 8007e70:	e79d      	b.n	8007dae <etharp_cleanup_netif+0x3a>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007e72:	6d30      	ldr	r0, [r6, #80]	; 0x50
 8007e74:	b118      	cbz	r0, 8007e7e <etharp_cleanup_netif+0x10a>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007e76:	f7fc f98f 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007e7a:	2300      	movs	r3, #0
 8007e7c:	6533      	str	r3, [r6, #80]	; 0x50
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007e7e:	2300      	movs	r3, #0
 8007e80:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
 8007e84:	e79a      	b.n	8007dbc <etharp_cleanup_netif+0x48>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007e86:	6e70      	ldr	r0, [r6, #100]	; 0x64
 8007e88:	b118      	cbz	r0, 8007e92 <etharp_cleanup_netif+0x11e>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007e8a:	f7fc f985 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007e8e:	2300      	movs	r3, #0
 8007e90:	6673      	str	r3, [r6, #100]	; 0x64
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007e92:	2300      	movs	r3, #0
 8007e94:	f884 3076 	strb.w	r3, [r4, #118]	; 0x76
 8007e98:	e797      	b.n	8007dca <etharp_cleanup_netif+0x56>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007e9a:	6fb0      	ldr	r0, [r6, #120]	; 0x78
 8007e9c:	b118      	cbz	r0, 8007ea6 <etharp_cleanup_netif+0x132>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007e9e:	f7fc f97b 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007ea2:	2300      	movs	r3, #0
 8007ea4:	67b3      	str	r3, [r6, #120]	; 0x78
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007ea6:	2300      	movs	r3, #0
 8007ea8:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
 8007eac:	e795      	b.n	8007dda <etharp_cleanup_netif+0x66>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007eae:	f8d6 008c 	ldr.w	r0, [r6, #140]	; 0x8c
 8007eb2:	b120      	cbz	r0, 8007ebe <etharp_cleanup_netif+0x14a>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007eb4:	f7fc f970 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007eb8:	2300      	movs	r3, #0
 8007eba:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007ebe:	2300      	movs	r3, #0
 8007ec0:	f884 309e 	strb.w	r3, [r4, #158]	; 0x9e
 8007ec4:	e791      	b.n	8007dea <etharp_cleanup_netif+0x76>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007ec6:	f8d6 00a0 	ldr.w	r0, [r6, #160]	; 0xa0
 8007eca:	b120      	cbz	r0, 8007ed6 <etharp_cleanup_netif+0x162>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007ecc:	f7fc f964 	bl	8004198 <pbuf_free>
    arp_table[i].q = NULL;
 8007ed0:	2300      	movs	r3, #0
 8007ed2:	f8c6 30a0 	str.w	r3, [r6, #160]	; 0xa0
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007ed6:	2300      	movs	r3, #0
 8007ed8:	f884 30b2 	strb.w	r3, [r4, #178]	; 0xb2
 8007edc:	e78d      	b.n	8007dfa <etharp_cleanup_netif+0x86>
 8007ede:	bf00      	nop
 8007ee0:	200029ac 	.word	0x200029ac

08007ee4 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
 8007ee4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007ee8:	460e      	mov	r6, r1
 8007eea:	b082      	sub	sp, #8
 8007eec:	4607      	mov	r7, r0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 8007eee:	4601      	mov	r1, r0
 8007ef0:	6830      	ldr	r0, [r6, #0]
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
 8007ef2:	4691      	mov	r9, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 8007ef4:	f7f9 f996 	bl	8001224 <ip4_addr_isbroadcast>
 8007ef8:	2800      	cmp	r0, #0
 8007efa:	d170      	bne.n	8007fde <etharp_query+0xfa>
      ip_addr_ismulticast(ipaddr) ||
 8007efc:	6833      	ldr	r3, [r6, #0]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 8007efe:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8007f02:	2ae0      	cmp	r2, #224	; 0xe0
 8007f04:	d06b      	beq.n	8007fde <etharp_query+0xfa>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
 8007f06:	2b00      	cmp	r3, #0
 8007f08:	d069      	beq.n	8007fde <etharp_query+0xfa>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 8007f0a:	2101      	movs	r1, #1
 8007f0c:	4630      	mov	r0, r6
 8007f0e:	f7ff fa91 	bl	8007434 <etharp_find_entry>

  /* could not find or create entry? */
  if (i < 0) {
 8007f12:	1e04      	subs	r4, r0, #0
 8007f14:	db5f      	blt.n	8007fd6 <etharp_query+0xf2>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 8007f16:	00a5      	lsls	r5, r4, #2
 8007f18:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8008024 <etharp_query+0x140>
 8007f1c:	192b      	adds	r3, r5, r4
 8007f1e:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 8007f22:	f107 0a2b 	add.w	sl, r7, #43	; 0x2b
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 8007f26:	7c9a      	ldrb	r2, [r3, #18]
 8007f28:	b32a      	cbz	r2, 8007f76 <etharp_query+0x92>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 8007f2a:	2a01      	cmp	r2, #1
 8007f2c:	d025      	beq.n	8007f7a <etharp_query+0x96>
 8007f2e:	f1b9 0f00 	cmp.w	r9, #0
 8007f32:	d059      	beq.n	8007fe8 <etharp_query+0x104>
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 8007f34:	4425      	add	r5, r4
 8007f36:	eb08 0885 	add.w	r8, r8, r5, lsl #2
 8007f3a:	f108 0808 	add.w	r8, r8, #8
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 8007f3e:	f8d9 3004 	ldr.w	r3, [r9, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 8007f42:	f858 0f04 	ldr.w	r0, [r8, #4]!
 8007f46:	6018      	str	r0, [r3, #0]
 8007f48:	f8b8 2004 	ldrh.w	r2, [r8, #4]
 8007f4c:	809a      	strh	r2, [r3, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 8007f4e:	f8da 2000 	ldr.w	r2, [sl]
 8007f52:	f8c3 2006 	str.w	r2, [r3, #6]
 8007f56:	f8ba 2004 	ldrh.w	r2, [sl, #4]
 8007f5a:	815a      	strh	r2, [r3, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 8007f5c:	2108      	movs	r1, #8
 8007f5e:	2000      	movs	r0, #0
 8007f60:	7319      	strb	r1, [r3, #12]
 8007f62:	7358      	strb	r0, [r3, #13]
  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
 8007f64:	4a2e      	ldr	r2, [pc, #184]	; (8008020 <etharp_query+0x13c>)
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8007f66:	69bb      	ldr	r3, [r7, #24]
  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
 8007f68:	7014      	strb	r4, [r2, #0]
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8007f6a:	4649      	mov	r1, r9
 8007f6c:	4638      	mov	r0, r7
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 8007f6e:	b002      	add	sp, #8
 8007f70:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8007f74:	4718      	bx	r3
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    arp_table[i].state = ETHARP_STATE_PENDING;
 8007f76:	2201      	movs	r2, #1
 8007f78:	749a      	strb	r2, [r3, #18]
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 8007f7a:	9600      	str	r6, [sp, #0]
 8007f7c:	1d3b      	adds	r3, r7, #4
 8007f7e:	4652      	mov	r2, sl
 8007f80:	4651      	mov	r1, sl
 8007f82:	4638      	mov	r0, r7
 8007f84:	f7ff fe72 	bl	8007c6c <etharp_raw.constprop.0>
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
 8007f88:	f1b9 0f00 	cmp.w	r9, #0
 8007f8c:	d020      	beq.n	8007fd0 <etharp_query+0xec>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 8007f8e:	192b      	adds	r3, r5, r4
 8007f90:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8007f94:	7c9b      	ldrb	r3, [r3, #18]
 8007f96:	2b01      	cmp	r3, #1
 8007f98:	d8cc      	bhi.n	8007f34 <etharp_query+0x50>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 8007f9a:	d119      	bne.n	8007fd0 <etharp_query+0xec>
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
 8007f9c:	f899 300c 	ldrb.w	r3, [r9, #12]
 8007fa0:	2b01      	cmp	r3, #1
 8007fa2:	464b      	mov	r3, r9
 8007fa4:	d003      	beq.n	8007fae <etharp_query+0xca>
 8007fa6:	e027      	b.n	8007ff8 <etharp_query+0x114>
 8007fa8:	7b1a      	ldrb	r2, [r3, #12]
 8007faa:	2a01      	cmp	r2, #1
 8007fac:	d124      	bne.n	8007ff8 <etharp_query+0x114>
        copy_needed = 1;
        break;
      }
      p = p->next;
 8007fae:	681b      	ldr	r3, [r3, #0]
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
 8007fb0:	2b00      	cmp	r3, #0
 8007fb2:	d1f9      	bne.n	8007fa8 <etharp_query+0xc4>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
      pbuf_ref(p);
 8007fb4:	4648      	mov	r0, r9
 8007fb6:	f7fc f927 	bl	8004208 <pbuf_ref>
 8007fba:	464e      	mov	r6, r9
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
      }
#else /* ARP_QUEUEING */
      /* always queue one packet per ARP request only, freeing a previously queued packet */
      if (arp_table[i].q != NULL) {
 8007fbc:	192b      	adds	r3, r5, r4
 8007fbe:	f858 0023 	ldr.w	r0, [r8, r3, lsl #2]
 8007fc2:	b108      	cbz	r0, 8007fc8 <etharp_query+0xe4>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        pbuf_free(arp_table[i].q);
 8007fc4:	f7fc f8e8 	bl	8004198 <pbuf_free>
      }
      arp_table[i].q = p;
 8007fc8:	442c      	add	r4, r5
      result = ERR_OK;
 8007fca:	2000      	movs	r0, #0
      /* always queue one packet per ARP request only, freeing a previously queued packet */
      if (arp_table[i].q != NULL) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        pbuf_free(arp_table[i].q);
      }
      arp_table[i].q = p;
 8007fcc:	f848 6024 	str.w	r6, [r8, r4, lsl #2]
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 8007fd0:	b002      	add	sp, #8
 8007fd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007fd6:	4620      	mov	r0, r4
 8007fd8:	b002      	add	sp, #8
 8007fda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 8007fde:	f06f 000d 	mvn.w	r0, #13
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 8007fe2:	b002      	add	sp, #8
 8007fe4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 8007fe8:	9600      	str	r6, [sp, #0]
 8007fea:	1d3b      	adds	r3, r7, #4
 8007fec:	4638      	mov	r0, r7
 8007fee:	4652      	mov	r2, sl
 8007ff0:	4651      	mov	r1, sl
 8007ff2:	f7ff fe3b 	bl	8007c6c <etharp_raw.constprop.0>
 8007ff6:	e7eb      	b.n	8007fd0 <etharp_query+0xec>
      }
      p = p->next;
    }
    if(copy_needed) {
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8007ff8:	8919      	ldrh	r1, [r3, #8]
 8007ffa:	2200      	movs	r2, #0
 8007ffc:	2003      	movs	r0, #3
 8007ffe:	f7fb ff73 	bl	8003ee8 <pbuf_alloc>
      if(p != NULL) {
 8008002:	4606      	mov	r6, r0
 8008004:	b138      	cbz	r0, 8008016 <etharp_query+0x132>
        if (pbuf_copy(p, q) != ERR_OK) {
 8008006:	4649      	mov	r1, r9
 8008008:	f7fc f93e 	bl	8004288 <pbuf_copy>
 800800c:	2800      	cmp	r0, #0
 800800e:	d0d5      	beq.n	8007fbc <etharp_query+0xd8>
          pbuf_free(p);
 8008010:	4630      	mov	r0, r6
 8008012:	f7fc f8c1 	bl	8004198 <pbuf_free>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
 8008016:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }
  return result;
}
 800801a:	b002      	add	sp, #8
 800801c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008020:	200029a8 	.word	0x200029a8
 8008024:	200029ac 	.word	0x200029ac

08008028 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
 8008028:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800802c:	460f      	mov	r7, r1
 800802e:	b084      	sub	sp, #16
 8008030:	4605      	mov	r5, r0
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 8008032:	210e      	movs	r1, #14
 8008034:	4638      	mov	r0, r7
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
 8008036:	4616      	mov	r6, r2
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 8008038:	f7fc f878 	bl	800412c <pbuf_header>
 800803c:	2800      	cmp	r0, #0
 800803e:	f040 80c3 	bne.w	80081c8 <etharp_output+0x1a0>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 8008042:	4629      	mov	r1, r5
 8008044:	6830      	ldr	r0, [r6, #0]
 8008046:	f7f9 f8ed 	bl	8001224 <ip4_addr_isbroadcast>
 800804a:	2800      	cmp	r0, #0
 800804c:	f040 808f 	bne.w	800816e <etharp_output+0x146>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
 8008050:	6832      	ldr	r2, [r6, #0]
 8008052:	f002 03f0 	and.w	r3, r2, #240	; 0xf0
 8008056:	2be0      	cmp	r3, #224	; 0xe0
 8008058:	f000 80a1 	beq.w	800819e <etharp_output+0x176>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 800805c:	686b      	ldr	r3, [r5, #4]
 800805e:	68a9      	ldr	r1, [r5, #8]
 8008060:	4053      	eors	r3, r2
 8008062:	420b      	tst	r3, r1
 8008064:	d00a      	beq.n	800807c <etharp_output+0x54>
 8008066:	b291      	uxth	r1, r2
 8008068:	f64f 63a9 	movw	r3, #65193	; 0xfea9
 800806c:	4299      	cmp	r1, r3
 800806e:	d005      	beq.n	800807c <etharp_output+0x54>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
 8008070:	68ea      	ldr	r2, [r5, #12]
 8008072:	f105 060c 	add.w	r6, r5, #12
 8008076:	2a00      	cmp	r2, #0
 8008078:	f000 80ab 	beq.w	80081d2 <etharp_output+0x1aa>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 800807c:	499a      	ldr	r1, [pc, #616]	; (80082e8 <etharp_output+0x2c0>)
 800807e:	4c9b      	ldr	r4, [pc, #620]	; (80082ec <etharp_output+0x2c4>)
 8008080:	f891 9000 	ldrb.w	r9, [r1]
 8008084:	ea4f 0a89 	mov.w	sl, r9, lsl #2
 8008088:	eb0a 0809 	add.w	r8, sl, r9
 800808c:	eb04 0888 	add.w	r8, r4, r8, lsl #2
 8008090:	f898 3012 	ldrb.w	r3, [r8, #18]
 8008094:	2b01      	cmp	r3, #1
 8008096:	d906      	bls.n	80080a6 <etharp_output+0x7e>
 8008098:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800809c:	4290      	cmp	r0, r2
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 800809e:	f108 0e04 	add.w	lr, r8, #4
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 80080a2:	f000 8099 	beq.w	80081d8 <etharp_output+0x1b0>
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 80080a6:	7ca3      	ldrb	r3, [r4, #18]
 80080a8:	4890      	ldr	r0, [pc, #576]	; (80082ec <etharp_output+0x2c4>)
 80080aa:	2b01      	cmp	r3, #1
 80080ac:	d903      	bls.n	80080b6 <etharp_output+0x8e>
 80080ae:	6840      	ldr	r0, [r0, #4]
 80080b0:	4290      	cmp	r0, r2
 80080b2:	f000 80ab 	beq.w	800820c <etharp_output+0x1e4>
 80080b6:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 80080ba:	488c      	ldr	r0, [pc, #560]	; (80082ec <etharp_output+0x2c4>)
 80080bc:	2b01      	cmp	r3, #1
 80080be:	d903      	bls.n	80080c8 <etharp_output+0xa0>
 80080c0:	6980      	ldr	r0, [r0, #24]
 80080c2:	4282      	cmp	r2, r0
 80080c4:	f000 80d8 	beq.w	8008278 <etharp_output+0x250>
 80080c8:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
 80080cc:	4887      	ldr	r0, [pc, #540]	; (80082ec <etharp_output+0x2c4>)
 80080ce:	2b01      	cmp	r3, #1
 80080d0:	d903      	bls.n	80080da <etharp_output+0xb2>
 80080d2:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80080d4:	4282      	cmp	r2, r0
 80080d6:	f000 80d3 	beq.w	8008280 <etharp_output+0x258>
 80080da:	f894 304e 	ldrb.w	r3, [r4, #78]	; 0x4e
 80080de:	4883      	ldr	r0, [pc, #524]	; (80082ec <etharp_output+0x2c4>)
 80080e0:	2b01      	cmp	r3, #1
 80080e2:	d903      	bls.n	80080ec <etharp_output+0xc4>
 80080e4:	6c00      	ldr	r0, [r0, #64]	; 0x40
 80080e6:	4282      	cmp	r2, r0
 80080e8:	f000 80ce 	beq.w	8008288 <etharp_output+0x260>
 80080ec:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 80080f0:	487e      	ldr	r0, [pc, #504]	; (80082ec <etharp_output+0x2c4>)
 80080f2:	2b01      	cmp	r3, #1
 80080f4:	d903      	bls.n	80080fe <etharp_output+0xd6>
 80080f6:	6d40      	ldr	r0, [r0, #84]	; 0x54
 80080f8:	4282      	cmp	r2, r0
 80080fa:	f000 80c9 	beq.w	8008290 <etharp_output+0x268>
 80080fe:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8008102:	487a      	ldr	r0, [pc, #488]	; (80082ec <etharp_output+0x2c4>)
 8008104:	2b01      	cmp	r3, #1
 8008106:	d903      	bls.n	8008110 <etharp_output+0xe8>
 8008108:	6e80      	ldr	r0, [r0, #104]	; 0x68
 800810a:	4282      	cmp	r2, r0
 800810c:	f000 80c4 	beq.w	8008298 <etharp_output+0x270>
 8008110:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
 8008114:	4875      	ldr	r0, [pc, #468]	; (80082ec <etharp_output+0x2c4>)
 8008116:	2b01      	cmp	r3, #1
 8008118:	d903      	bls.n	8008122 <etharp_output+0xfa>
 800811a:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 800811c:	4282      	cmp	r2, r0
 800811e:	f000 80bf 	beq.w	80082a0 <etharp_output+0x278>
 8008122:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
 8008126:	4871      	ldr	r0, [pc, #452]	; (80082ec <etharp_output+0x2c4>)
 8008128:	2b01      	cmp	r3, #1
 800812a:	d904      	bls.n	8008136 <etharp_output+0x10e>
 800812c:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
 8008130:	4282      	cmp	r2, r0
 8008132:	f000 80cd 	beq.w	80082d0 <etharp_output+0x2a8>
 8008136:	f894 30b2 	ldrb.w	r3, [r4, #178]	; 0xb2
 800813a:	486c      	ldr	r0, [pc, #432]	; (80082ec <etharp_output+0x2c4>)
 800813c:	2b01      	cmp	r3, #1
 800813e:	d904      	bls.n	800814a <etharp_output+0x122>
 8008140:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8008144:	4282      	cmp	r2, r0
 8008146:	f000 80c7 	beq.w	80082d8 <etharp_output+0x2b0>
 800814a:	f894 30c6 	ldrb.w	r3, [r4, #198]	; 0xc6
 800814e:	4867      	ldr	r0, [pc, #412]	; (80082ec <etharp_output+0x2c4>)
 8008150:	2b01      	cmp	r3, #1
 8008152:	d904      	bls.n	800815e <etharp_output+0x136>
 8008154:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 8008158:	4290      	cmp	r0, r2
 800815a:	f000 80c1 	beq.w	80082e0 <etharp_output+0x2b8>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
 800815e:	463a      	mov	r2, r7
 8008160:	4631      	mov	r1, r6
 8008162:	4628      	mov	r0, r5

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
 8008164:	b004      	add	sp, #16
 8008166:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
 800816a:	f7ff bebb 	b.w	8007ee4 <etharp_query>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
 800816e:	4a60      	ldr	r2, [pc, #384]	; (80082f0 <etharp_output+0x2c8>)
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 8008170:	687b      	ldr	r3, [r7, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 8008172:	6810      	ldr	r0, [r2, #0]
 8008174:	6018      	str	r0, [r3, #0]
 8008176:	8892      	ldrh	r2, [r2, #4]
 8008178:	809a      	strh	r2, [r3, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 800817a:	462a      	mov	r2, r5
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 800817c:	2008      	movs	r0, #8
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
 800817e:	f852 1f2b 	ldr.w	r1, [r2, #43]!
 8008182:	f8c3 1006 	str.w	r1, [r3, #6]
 8008186:	8892      	ldrh	r2, [r2, #4]
 8008188:	815a      	strh	r2, [r3, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 800818a:	2200      	movs	r2, #0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 800818c:	4639      	mov	r1, r7

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 800818e:	7318      	strb	r0, [r3, #12]
 8008190:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8008192:	69ab      	ldr	r3, [r5, #24]
 8008194:	4628      	mov	r0, r5

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
 8008196:	b004      	add	sp, #16
 8008198:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 800819c:	4718      	bx	r3
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 800819e:	7873      	ldrb	r3, [r6, #1]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 80081a0:	78f2      	ldrb	r2, [r6, #3]
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 80081a2:	78b1      	ldrb	r1, [r6, #2]
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 80081a4:	f88d 0009 	strb.w	r0, [sp, #9]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 80081a8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 80081ac:	2401      	movs	r4, #1
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 80081ae:	205e      	movs	r0, #94	; 0x5e
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 80081b0:	f88d 200d 	strb.w	r2, [sp, #13]
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 80081b4:	f88d 300b 	strb.w	r3, [sp, #11]
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 80081b8:	f88d 4008 	strb.w	r4, [sp, #8]
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 80081bc:	f88d 000a 	strb.w	r0, [sp, #10]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 80081c0:	f88d 100c 	strb.w	r1, [sp, #12]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 80081c4:	aa02      	add	r2, sp, #8
 80081c6:	e7d3      	b.n	8008170 <etharp_output+0x148>
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
 80081c8:	f06f 0001 	mvn.w	r0, #1

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
 80081cc:	b004      	add	sp, #16
 80081ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
 80081d2:	f06f 0003 	mvn.w	r0, #3
 80081d6:	e7f9      	b.n	80081cc <etharp_output+0x1a4>
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 80081d8:	2b02      	cmp	r3, #2
 80081da:	d065      	beq.n	80082a8 <etharp_output+0x280>
 80081dc:	f105 062b 	add.w	r6, r5, #43	; 0x2b
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 80081e0:	eb0a 0309 	add.w	r3, sl, r9
 80081e4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80081e8:	3308      	adds	r3, #8
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 80081ea:	687a      	ldr	r2, [r7, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 80081ec:	f853 0f04 	ldr.w	r0, [r3, #4]!
 80081f0:	6010      	str	r0, [r2, #0]
 80081f2:	889b      	ldrh	r3, [r3, #4]
 80081f4:	8093      	strh	r3, [r2, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 80081f6:	6833      	ldr	r3, [r6, #0]
 80081f8:	f8c2 3006 	str.w	r3, [r2, #6]
 80081fc:	88b3      	ldrh	r3, [r6, #4]
 80081fe:	8153      	strh	r3, [r2, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 8008200:	2008      	movs	r0, #8
 8008202:	2300      	movs	r3, #0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8008204:	4639      	mov	r1, r7

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 8008206:	7310      	strb	r0, [r2, #12]
 8008208:	7353      	strb	r3, [r2, #13]
 800820a:	e7c2      	b.n	8008192 <etharp_output+0x16a>
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 800820c:	f04f 0800 	mov.w	r8, #0
 8008210:	4642      	mov	r2, r8
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 8008212:	2b02      	cmp	r3, #2
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
 8008214:	700a      	strb	r2, [r1, #0]
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 8008216:	d014      	beq.n	8008242 <etharp_output+0x21a>
 8008218:	f105 062b 	add.w	r6, r5, #43	; 0x2b
 800821c:	ea4f 0988 	mov.w	r9, r8, lsl #2
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 8008220:	44c8      	add	r8, r9
 8008222:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 8008226:	3408      	adds	r4, #8
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 8008228:	687b      	ldr	r3, [r7, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 800822a:	f854 0f04 	ldr.w	r0, [r4, #4]!
 800822e:	6018      	str	r0, [r3, #0]
 8008230:	88a2      	ldrh	r2, [r4, #4]
 8008232:	809a      	strh	r2, [r3, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 8008234:	6832      	ldr	r2, [r6, #0]
 8008236:	f8c3 2006 	str.w	r2, [r3, #6]
 800823a:	88b2      	ldrh	r2, [r6, #4]
 800823c:	815a      	strh	r2, [r3, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 800823e:	2008      	movs	r0, #8
 8008240:	e7a3      	b.n	800818a <etharp_output+0x162>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 8008242:	ea4f 0988 	mov.w	r9, r8, lsl #2
 8008246:	eb09 0a08 	add.w	sl, r9, r8
 800824a:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 800824e:	f105 062b 	add.w	r6, r5, #43	; 0x2b
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 8008252:	f89a 3013 	ldrb.w	r3, [sl, #19]
 8008256:	2be3      	cmp	r3, #227	; 0xe3
 8008258:	d9e2      	bls.n	8008220 <etharp_output+0x1f8>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 800825a:	f10a 0304 	add.w	r3, sl, #4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 800825e:	9300      	str	r3, [sp, #0]
 8008260:	4632      	mov	r2, r6
 8008262:	4631      	mov	r1, r6
 8008264:	1d2b      	adds	r3, r5, #4
 8008266:	4628      	mov	r0, r5
 8008268:	f7ff fd00 	bl	8007c6c <etharp_raw.constprop.0>
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 800826c:	2800      	cmp	r0, #0
 800826e:	d1d7      	bne.n	8008220 <etharp_output+0x1f8>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 8008270:	2303      	movs	r3, #3
 8008272:	f88a 3012 	strb.w	r3, [sl, #18]
 8008276:	e7d3      	b.n	8008220 <etharp_output+0x1f8>
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008278:	f04f 0801 	mov.w	r8, #1
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 800827c:	4642      	mov	r2, r8
 800827e:	e7c8      	b.n	8008212 <etharp_output+0x1ea>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008280:	f04f 0802 	mov.w	r8, #2
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8008284:	4642      	mov	r2, r8
 8008286:	e7c4      	b.n	8008212 <etharp_output+0x1ea>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008288:	f04f 0803 	mov.w	r8, #3
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 800828c:	4642      	mov	r2, r8
 800828e:	e7c0      	b.n	8008212 <etharp_output+0x1ea>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008290:	f04f 0804 	mov.w	r8, #4
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8008294:	4642      	mov	r2, r8
 8008296:	e7bc      	b.n	8008212 <etharp_output+0x1ea>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008298:	f04f 0805 	mov.w	r8, #5
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 800829c:	4642      	mov	r2, r8
 800829e:	e7b8      	b.n	8008212 <etharp_output+0x1ea>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 80082a0:	f04f 0806 	mov.w	r8, #6
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 80082a4:	4642      	mov	r2, r8
 80082a6:	e7b4      	b.n	8008212 <etharp_output+0x1ea>
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 80082a8:	f898 3013 	ldrb.w	r3, [r8, #19]
 80082ac:	2be3      	cmp	r3, #227	; 0xe3
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 80082ae:	f105 062b 	add.w	r6, r5, #43	; 0x2b
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 80082b2:	d995      	bls.n	80081e0 <etharp_output+0x1b8>
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 80082b4:	f8cd e000 	str.w	lr, [sp]
 80082b8:	4632      	mov	r2, r6
 80082ba:	4631      	mov	r1, r6
 80082bc:	1d2b      	adds	r3, r5, #4
 80082be:	4628      	mov	r0, r5
 80082c0:	f7ff fcd4 	bl	8007c6c <etharp_raw.constprop.0>
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 80082c4:	2800      	cmp	r0, #0
 80082c6:	d18b      	bne.n	80081e0 <etharp_output+0x1b8>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 80082c8:	2303      	movs	r3, #3
 80082ca:	f888 3012 	strb.w	r3, [r8, #18]
 80082ce:	e787      	b.n	80081e0 <etharp_output+0x1b8>
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 80082d0:	f04f 0807 	mov.w	r8, #7
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 80082d4:	4642      	mov	r2, r8
 80082d6:	e79c      	b.n	8008212 <etharp_output+0x1ea>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 80082d8:	f04f 0808 	mov.w	r8, #8
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 80082dc:	4642      	mov	r2, r8
 80082de:	e798      	b.n	8008212 <etharp_output+0x1ea>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 80082e0:	f04f 0809 	mov.w	r8, #9
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 80082e4:	4642      	mov	r2, r8
 80082e6:	e794      	b.n	8008212 <etharp_output+0x1ea>
 80082e8:	200029a8 	.word	0x200029a8
 80082ec:	200029ac 	.word	0x200029ac
 80082f0:	0800ca34 	.word	0x0800ca34

080082f4 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 80082f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 80082f8:	2200      	movs	r2, #0
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 80082fa:	4605      	mov	r5, r0
 80082fc:	4688      	mov	r8, r1
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 80082fe:	2003      	movs	r0, #3
 8008300:	212a      	movs	r1, #42	; 0x2a
 8008302:	f7fb fdf1 	bl	8003ee8 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 8008306:	2800      	cmp	r0, #0
 8008308:	d03b      	beq.n	8008382 <etharp_request+0x8e>
 800830a:	4606      	mov	r6, r0
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 800830c:	2001      	movs	r0, #1
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
 800830e:	6874      	ldr	r4, [r6, #4]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 8008310:	f7f9 faac 	bl	800186c <lwip_htons>
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8008314:	4a1d      	ldr	r2, [pc, #116]	; (800838c <etharp_request+0x98>)
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 8008316:	82a0      	strh	r0, [r4, #20]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8008318:	f8d5 102b 	ldr.w	r1, [r5, #43]	; 0x2b
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 800831c:	4b1c      	ldr	r3, [pc, #112]	; (8008390 <etharp_request+0x9c>)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 800831e:	f8c4 1016 	str.w	r1, [r4, #22]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8008322:	6810      	ldr	r0, [r2, #0]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8008324:	f8b5 102f 	ldrh.w	r1, [r5, #47]	; 0x2f
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8008328:	8892      	ldrh	r2, [r2, #4]
 800832a:	6220      	str	r0, [r4, #32]
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 800832c:	6818      	ldr	r0, [r3, #0]
 800832e:	889b      	ldrh	r3, [r3, #4]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8008330:	8361      	strh	r1, [r4, #26]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8008332:	84a2      	strh	r2, [r4, #36]	; 0x24
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 8008334:	6020      	str	r0, [r4, #0]
 8008336:	80a3      	strh	r3, [r4, #4]
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 8008338:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
 800833c:	f8c4 3006 	str.w	r3, [r4, #6]
 8008340:	f8b5 302f 	ldrh.w	r3, [r5, #47]	; 0x2f
 8008344:	8163      	strh	r3, [r4, #10]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 8008346:	686b      	ldr	r3, [r5, #4]
 8008348:	61e3      	str	r3, [r4, #28]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 800834a:	f8d8 3000 	ldr.w	r3, [r8]
 800834e:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 8008352:	2106      	movs	r1, #6
  hdr->protolen = sizeof(ip_addr_t);
 8008354:	2304      	movs	r3, #4
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008356:	2200      	movs	r2, #0
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);
 8008358:	74e3      	strb	r3, [r4, #19]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 800835a:	74a1      	strb	r1, [r4, #18]
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 800835c:	2308      	movs	r3, #8
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800835e:	2001      	movs	r0, #1
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 8008360:	69af      	ldr	r7, [r5, #24]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008362:	73e0      	strb	r0, [r4, #15]
 8008364:	73a2      	strb	r2, [r4, #14]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8008366:	7462      	strb	r2, [r4, #17]
 8008368:	7423      	strb	r3, [r4, #16]
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 800836a:	7323      	strb	r3, [r4, #12]
 800836c:	7361      	strb	r1, [r4, #13]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 800836e:	4628      	mov	r0, r5
 8008370:	4631      	mov	r1, r6
 8008372:	47b8      	blx	r7
 8008374:	4604      	mov	r4, r0
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 8008376:	4630      	mov	r0, r6
 8008378:	f7fb ff0e 	bl	8004198 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 800837c:	4620      	mov	r0, r4
 800837e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
 8008382:	f04f 30ff 	mov.w	r0, #4294967295
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 8008386:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800838a:	bf00      	nop
 800838c:	0800ca3c 	.word	0x0800ca3c
 8008390:	0800ca34 	.word	0x0800ca34

08008394 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8008394:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 8008398:	8946      	ldrh	r6, [r0, #10]
 800839a:	2e0e      	cmp	r6, #14
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 800839c:	b085      	sub	sp, #20
 800839e:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 80083a0:	d91a      	bls.n	80083d8 <ethernet_input+0x44>
    ETHARP_STATS_INC(etharp.drop);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 80083a2:	6845      	ldr	r5, [r0, #4]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 80083a4:	782b      	ldrb	r3, [r5, #0]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
 80083a6:	89af      	ldrh	r7, [r5, #12]
 80083a8:	4688      	mov	r8, r1

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 80083aa:	07d9      	lsls	r1, r3, #31
 80083ac:	d50b      	bpl.n	80083c6 <ethernet_input+0x32>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 80083ae:	2b01      	cmp	r3, #1
 80083b0:	d029      	beq.n	8008406 <ethernet_input+0x72>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 80083b2:	2206      	movs	r2, #6
 80083b4:	496f      	ldr	r1, [pc, #444]	; (8008574 <ethernet_input+0x1e0>)
 80083b6:	4628      	mov	r0, r5
 80083b8:	f003 f89e 	bl	800b4f8 <memcmp>
 80083bc:	b918      	cbnz	r0, 80083c6 <ethernet_input+0x32>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 80083be:	7b63      	ldrb	r3, [r4, #13]
 80083c0:	f043 0308 	orr.w	r3, r3, #8
 80083c4:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
 80083c6:	2f08      	cmp	r7, #8
 80083c8:	d00d      	beq.n	80083e6 <ethernet_input+0x52>
 80083ca:	f5b7 6fc1 	cmp.w	r7, #1544	; 0x608
 80083ce:	d103      	bne.n	80083d8 <ethernet_input+0x44>
        ip_input(p, netif);
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 80083d0:	f898 3031 	ldrb.w	r3, [r8, #49]	; 0x31
 80083d4:	069b      	lsls	r3, r3, #26
 80083d6:	d421      	bmi.n	800841c <ethernet_input+0x88>
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 80083d8:	4620      	mov	r0, r4
 80083da:	f7fb fedd 	bl	8004198 <pbuf_free>
  return ERR_OK;
}
 80083de:	2000      	movs	r0, #0
 80083e0:	b005      	add	sp, #20
 80083e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 80083e6:	f898 3031 	ldrb.w	r3, [r8, #49]	; 0x31
 80083ea:	069a      	lsls	r2, r3, #26
 80083ec:	d5f4      	bpl.n	80083d8 <ethernet_input+0x44>
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
 80083ee:	f06f 010d 	mvn.w	r1, #13
 80083f2:	4620      	mov	r0, r4
 80083f4:	f7fb fe9a 	bl	800412c <pbuf_header>
 80083f8:	2800      	cmp	r0, #0
 80083fa:	d1ed      	bne.n	80083d8 <ethernet_input+0x44>
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
 80083fc:	4641      	mov	r1, r8
 80083fe:	4620      	mov	r0, r4
 8008400:	f7f8 fdba 	bl	8000f78 <ip_input>
      }
      break;
 8008404:	e7eb      	b.n	80083de <ethernet_input+0x4a>
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 8008406:	786b      	ldrb	r3, [r5, #1]
 8008408:	2b00      	cmp	r3, #0
 800840a:	d1dc      	bne.n	80083c6 <ethernet_input+0x32>
 800840c:	78ab      	ldrb	r3, [r5, #2]
 800840e:	2b5e      	cmp	r3, #94	; 0x5e
 8008410:	d1d9      	bne.n	80083c6 <ethernet_input+0x32>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 8008412:	7b43      	ldrb	r3, [r0, #13]
 8008414:	f043 0310 	orr.w	r3, r3, #16
 8008418:	7343      	strb	r3, [r0, #13]
 800841a:	e7d4      	b.n	80083c6 <ethernet_input+0x32>

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
 800841c:	2e29      	cmp	r6, #41	; 0x29
 800841e:	d9db      	bls.n	80083d8 <ethernet_input+0x44>
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8008420:	89eb      	ldrh	r3, [r5, #14]
 8008422:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008426:	d1d7      	bne.n	80083d8 <ethernet_input+0x44>
 8008428:	7cab      	ldrb	r3, [r5, #18]
 800842a:	2b06      	cmp	r3, #6
 800842c:	d1d4      	bne.n	80083d8 <ethernet_input+0x44>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 800842e:	7ceb      	ldrb	r3, [r5, #19]
 8008430:	2b04      	cmp	r3, #4
 8008432:	d1d1      	bne.n	80083d8 <ethernet_input+0x44>
      (hdr->protolen != sizeof(ip_addr_t)) ||
 8008434:	8a2b      	ldrh	r3, [r5, #16]
 8008436:	2b08      	cmp	r3, #8
 8008438:	d1ce      	bne.n	80083d8 <ethernet_input+0x44>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 800843a:	46aa      	mov	sl, r5
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
 800843c:	f8d8 7004 	ldr.w	r7, [r8, #4]
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 8008440:	f85a 0f1c 	ldr.w	r0, [sl, #28]!
 8008444:	9002      	str	r0, [sp, #8]
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 8008446:	f8d5 0026 	ldr.w	r0, [r5, #38]	; 0x26
 800844a:	9003      	str	r0, [sp, #12]

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
 800844c:	2f00      	cmp	r7, #0
 800844e:	d062      	beq.n	8008516 <ethernet_input+0x182>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
 8008450:	9b03      	ldr	r3, [sp, #12]
 8008452:	429f      	cmp	r7, r3
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008454:	bf13      	iteet	ne
 8008456:	f04f 0b02 	movne.w	fp, #2
 800845a:	f04f 0b01 	moveq.w	fp, #1
 800845e:	2701      	moveq	r7, #1
 8008460:	2700      	movne	r7, #0
 8008462:	f105 0616 	add.w	r6, r5, #22
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 8008466:	9802      	ldr	r0, [sp, #8]
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 8008468:	f108 092b 	add.w	r9, r8, #43	; 0x2b
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 800846c:	2800      	cmp	r0, #0
 800846e:	d045      	beq.n	80084fc <ethernet_input+0x168>
      ip_addr_isbroadcast(ipaddr, netif) ||
 8008470:	4641      	mov	r1, r8
 8008472:	f7f8 fed7 	bl	8001224 <ip4_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 8008476:	9001      	str	r0, [sp, #4]
 8008478:	2800      	cmp	r0, #0
 800847a:	d13f      	bne.n	80084fc <ethernet_input+0x168>
      ip_addr_isbroadcast(ipaddr, netif) ||
 800847c:	9b02      	ldr	r3, [sp, #8]
 800847e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008482:	2be0      	cmp	r3, #224	; 0xe0
 8008484:	d03a      	beq.n	80084fc <ethernet_input+0x168>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
 8008486:	4659      	mov	r1, fp
 8008488:	a802      	add	r0, sp, #8
 800848a:	f7fe ffd3 	bl	8007434 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 800848e:	2800      	cmp	r0, #0
 8008490:	db34      	blt.n	80084fc <ethernet_input+0x168>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 8008492:	4939      	ldr	r1, [pc, #228]	; (8008578 <ethernet_input+0x1e4>)

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8008494:	9a01      	ldr	r2, [sp, #4]
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 8008496:	2314      	movs	r3, #20
 8008498:	fb03 f300 	mul.w	r3, r3, r0
 800849c:	eb01 0c03 	add.w	ip, r1, r3
 80084a0:	2002      	movs	r0, #2
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 80084a2:	f103 0e08 	add.w	lr, r3, #8
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
  }

  /* record network interface */
  arp_table[i].netif = netif;
 80084a6:	f8cc 8008 	str.w	r8, [ip, #8]
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 80084aa:	f88c 0012 	strb.w	r0, [ip, #18]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 80084ae:	448e      	add	lr, r1
 80084b0:	6830      	ldr	r0, [r6, #0]
 80084b2:	f8ce 0004 	str.w	r0, [lr, #4]
 80084b6:	88b0      	ldrh	r0, [r6, #4]
 80084b8:	f8ae 0008 	strh.w	r0, [lr, #8]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 80084bc:	f851 b003 	ldr.w	fp, [r1, r3]

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
 80084c0:	f88c 2013 	strb.w	r2, [ip, #19]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 80084c4:	f1bb 0f00 	cmp.w	fp, #0
 80084c8:	d018      	beq.n	80084fc <ethernet_input+0x168>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 80084ca:	50ca      	str	r2, [r1, r3]
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 80084cc:	f8db 3004 	ldr.w	r3, [fp, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 80084d0:	6831      	ldr	r1, [r6, #0]
 80084d2:	6019      	str	r1, [r3, #0]
 80084d4:	88b1      	ldrh	r1, [r6, #4]
 80084d6:	8099      	strh	r1, [r3, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 80084d8:	f8d9 1000 	ldr.w	r1, [r9]
 80084dc:	f8c3 1006 	str.w	r1, [r3, #6]
 80084e0:	f8b9 1004 	ldrh.w	r1, [r9, #4]
 80084e4:	8159      	strh	r1, [r3, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 80084e6:	2108      	movs	r1, #8
 80084e8:	7319      	strb	r1, [r3, #12]
 80084ea:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 80084ec:	4659      	mov	r1, fp
 80084ee:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80084f2:	4640      	mov	r0, r8
 80084f4:	4798      	blx	r3
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
 80084f6:	4658      	mov	r0, fp
 80084f8:	f7fb fe4e 	bl	8004198 <pbuf_free>
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
 80084fc:	8aab      	ldrh	r3, [r5, #20]
 80084fe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008502:	d00d      	beq.n	8008520 <ethernet_input+0x18c>
 8008504:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008508:	f47f af66 	bne.w	80083d8 <ethernet_input+0x44>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
 800850c:	4640      	mov	r0, r8
 800850e:	a902      	add	r1, sp, #8
 8008510:	f7fa fcd4 	bl	8002ebc <dhcp_arp_reply>
 8008514:	e760      	b.n	80083d8 <ethernet_input+0x44>
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008516:	f105 0616 	add.w	r6, r5, #22
 800851a:	f04f 0b02 	mov.w	fp, #2
 800851e:	e7a2      	b.n	8008466 <ethernet_input+0xd2>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
 8008520:	2f00      	cmp	r7, #0
 8008522:	f43f af59 	beq.w	80083d8 <ethernet_input+0x44>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
 8008526:	2002      	movs	r0, #2
 8008528:	f7f9 f9a0 	bl	800186c <lwip_htons>
 800852c:	82a8      	strh	r0, [r5, #20]

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 800852e:	f8da 3000 	ldr.w	r3, [sl]
 8008532:	f8c5 3026 	str.w	r3, [r5, #38]	; 0x26
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 8008536:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800853a:	61eb      	str	r3, [r5, #28]
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 800853c:	6833      	ldr	r3, [r6, #0]
 800853e:	622b      	str	r3, [r5, #32]
 8008540:	88b3      	ldrh	r3, [r6, #4]
 8008542:	84ab      	strh	r3, [r5, #36]	; 0x24
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 8008544:	6833      	ldr	r3, [r6, #0]
 8008546:	602b      	str	r3, [r5, #0]
 8008548:	88b3      	ldrh	r3, [r6, #4]
 800854a:	80ab      	strh	r3, [r5, #4]
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 800854c:	f8d9 3000 	ldr.w	r3, [r9]
 8008550:	6033      	str	r3, [r6, #0]
 8008552:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 8008556:	80b3      	strh	r3, [r6, #4]
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 8008558:	f8d9 3000 	ldr.w	r3, [r9]
 800855c:	f8c5 3006 	str.w	r3, [r5, #6]
 8008560:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 8008564:	816b      	strh	r3, [r5, #10]

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
 8008566:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800856a:	4640      	mov	r0, r8
 800856c:	4621      	mov	r1, r4
 800856e:	4798      	blx	r3
 8008570:	e732      	b.n	80083d8 <ethernet_input+0x44>
 8008572:	bf00      	nop
 8008574:	0800ca34 	.word	0x0800ca34
 8008578:	200029ac 	.word	0x200029ac

0800857c <low_level_output>:
 *       to become availale since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
 800857c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  err_t errval;
  struct pbuf *q;
  u8 *buffer =  (u8 *)(DMATxDescToSet->Buffer1Addr);
 8008580:	4b32      	ldr	r3, [pc, #200]	; (800864c <low_level_output+0xd0>)
 8008582:	681d      	ldr	r5, [r3, #0]
 *       to become availale since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
 8008584:	b083      	sub	sp, #12

  DmaTxDesc = DMATxDescToSet;
  bufferoffset = 0;

  /* copy frame from pbufs to driver buffers */
  for(q = p; q != NULL; q = q->next)
 8008586:	468a      	mov	sl, r1

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
  err_t errval;
  struct pbuf *q;
  u8 *buffer =  (u8 *)(DMATxDescToSet->Buffer1Addr);
 8008588:	68ab      	ldr	r3, [r5, #8]

  DmaTxDesc = DMATxDescToSet;
  bufferoffset = 0;

  /* copy frame from pbufs to driver buffers */
  for(q = p; q != NULL; q = q->next)
 800858a:	2900      	cmp	r1, #0
 800858c:	d058      	beq.n	8008640 <low_level_output+0xc4>
    {
      /* Is this buffer available? If not, goto error */
      if((DmaTxDesc->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 800858e:	682a      	ldr	r2, [r5, #0]
 8008590:	2a00      	cmp	r2, #0
 8008592:	db4c      	blt.n	800862e <low_level_output+0xb2>
 8008594:	f04f 0800 	mov.w	r8, #0
 8008598:	4646      	mov	r6, r8
      /* Get bytes in current lwIP buffer */
      byteslefttocopy = q->len;
      payloadoffset = 0;

      /* Check if the length of data to copy is bigger than Tx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 800859a:	f240 59f4 	movw	r9, #1524	; 0x5f4
        errval = ERR_BUF;
        goto error;
      }

      /* Get bytes in current lwIP buffer */
      byteslefttocopy = q->len;
 800859e:	f8ba 200a 	ldrh.w	r2, [sl, #10]
      payloadoffset = 0;

      /* Check if the length of data to copy is bigger than Tx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 80085a2:	eb02 0708 	add.w	r7, r2, r8
 80085a6:	454f      	cmp	r7, r9
 80085a8:	d944      	bls.n	8008634 <low_level_output+0xb8>
 80085aa:	f04f 0b00 	mov.w	fp, #0
 80085ae:	e002      	b.n	80085b6 <low_level_output+0x3a>
 80085b0:	454f      	cmp	r7, r9
        {
          errval = ERR_USE;
          goto error;
        }

        buffer = (u8 *)(DmaTxDesc->Buffer1Addr);
 80085b2:	68ab      	ldr	r3, [r5, #8]
      /* Get bytes in current lwIP buffer */
      byteslefttocopy = q->len;
      payloadoffset = 0;

      /* Check if the length of data to copy is bigger than Tx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 80085b4:	d926      	bls.n	8008604 <low_level_output+0x88>
      {
        /* Copy data to Tx buffer*/
        memcpy( (u8_t*)((u8_t*)buffer + bufferoffset), (u8_t*)((u8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
 80085b6:	f5c8 64be 	rsb	r4, r8, #1520	; 0x5f0
 80085ba:	f8da 1004 	ldr.w	r1, [sl, #4]
 80085be:	3404      	adds	r4, #4
 80085c0:	eb03 0008 	add.w	r0, r3, r8
 80085c4:	4459      	add	r1, fp
 80085c6:	4622      	mov	r2, r4
 80085c8:	f002 ffa5 	bl	800b516 <memcpy>

        /* Point to next descriptor */
        DmaTxDesc = (ETH_DMADESCTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
 80085cc:	68ed      	ldr	r5, [r5, #12]

        /* Check if the buffer is available */
        if((DmaTxDesc->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 80085ce:	682b      	ldr	r3, [r5, #0]

        buffer = (u8 *)(DmaTxDesc->Buffer1Addr);

        byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
        payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
        framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
 80085d0:	4426      	add	r6, r4

        /* Point to next descriptor */
        DmaTxDesc = (ETH_DMADESCTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);

        /* Check if the buffer is available */
        if((DmaTxDesc->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 80085d2:	2b00      	cmp	r3, #0
          goto error;
        }

        buffer = (u8 *)(DmaTxDesc->Buffer1Addr);

        byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
 80085d4:	f2a7 57f4 	subw	r7, r7, #1524	; 0x5f4
        payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
 80085d8:	44a3      	add	fp, r4
        framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
 80085da:	b2b6      	uxth	r6, r6
        bufferoffset = 0;
 80085dc:	f04f 0800 	mov.w	r8, #0

        /* Point to next descriptor */
        DmaTxDesc = (ETH_DMADESCTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);

        /* Check if the buffer is available */
        if((DmaTxDesc->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 80085e0:	dae6      	bge.n	80085b0 <low_level_output+0x34>
        {
          errval = ERR_USE;
 80085e2:	f06f 0007 	mvn.w	r0, #7
  errval = ERR_OK;

error:
  
  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
 80085e6:	4b1a      	ldr	r3, [pc, #104]	; (8008650 <low_level_output+0xd4>)
 80085e8:	f241 0214 	movw	r2, #4116	; 0x1014
 80085ec:	5899      	ldr	r1, [r3, r2]
 80085ee:	0689      	lsls	r1, r1, #26
 80085f0:	d505      	bpl.n	80085fe <low_level_output+0x82>
  {
    /* Clear TUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TUS;

    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 80085f2:	f241 0104 	movw	r1, #4100	; 0x1004
  
  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
  {
    /* Clear TUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TUS;
 80085f6:	2520      	movs	r5, #32

    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 80085f8:	2400      	movs	r4, #0
  
  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
  {
    /* Clear TUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TUS;
 80085fa:	509d      	str	r5, [r3, r2]

    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 80085fc:	505c      	str	r4, [r3, r1]
  }
  return errval;
}
 80085fe:	b003      	add	sp, #12
 8008600:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          goto error;
        }

        buffer = (u8 *)(DmaTxDesc->Buffer1Addr);

        byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
 8008604:	46b8      	mov	r8, r7
        payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
        framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
        bufferoffset = 0;
 8008606:	2000      	movs	r0, #0
      }

      /* Copy the remaining bytes */
      memcpy( (u8_t*)((u8_t*)buffer + bufferoffset), (u8_t*)((u8_t*)q->payload + payloadoffset), byteslefttocopy );
 8008608:	f8da 1004 	ldr.w	r1, [sl, #4]
 800860c:	9301      	str	r3, [sp, #4]
 800860e:	4418      	add	r0, r3
 8008610:	4459      	add	r1, fp
 8008612:	463a      	mov	r2, r7
 8008614:	f002 ff7f 	bl	800b516 <memcpy>

  DmaTxDesc = DMATxDescToSet;
  bufferoffset = 0;

  /* copy frame from pbufs to driver buffers */
  for(q = p; q != NULL; q = q->next)
 8008618:	f8da a000 	ldr.w	sl, [sl]
 800861c:	9b01      	ldr	r3, [sp, #4]
      }

      /* Copy the remaining bytes */
      memcpy( (u8_t*)((u8_t*)buffer + bufferoffset), (u8_t*)((u8_t*)q->payload + payloadoffset), byteslefttocopy );
      bufferoffset = bufferoffset + byteslefttocopy;
      framelength = framelength + byteslefttocopy;
 800861e:	443e      	add	r6, r7
 8008620:	b2b6      	uxth	r6, r6

  DmaTxDesc = DMATxDescToSet;
  bufferoffset = 0;

  /* copy frame from pbufs to driver buffers */
  for(q = p; q != NULL; q = q->next)
 8008622:	f1ba 0f00 	cmp.w	sl, #0
 8008626:	d00c      	beq.n	8008642 <low_level_output+0xc6>
    {
      /* Is this buffer available? If not, goto error */
      if((DmaTxDesc->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 8008628:	682a      	ldr	r2, [r5, #0]
 800862a:	2a00      	cmp	r2, #0
 800862c:	dab7      	bge.n	800859e <low_level_output+0x22>
      {
        errval = ERR_BUF;
 800862e:	f06f 0001 	mvn.w	r0, #1
 8008632:	e7d8      	b.n	80085e6 <low_level_output+0x6a>
      /* Get bytes in current lwIP buffer */
      byteslefttocopy = q->len;
      payloadoffset = 0;

      /* Check if the length of data to copy is bigger than Tx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 8008634:	4640      	mov	r0, r8
        goto error;
      }

      /* Get bytes in current lwIP buffer */
      byteslefttocopy = q->len;
      payloadoffset = 0;
 8008636:	f04f 0b00 	mov.w	fp, #0

      /* Check if the length of data to copy is bigger than Tx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 800863a:	46b8      	mov	r8, r7
        errval = ERR_BUF;
        goto error;
      }

      /* Get bytes in current lwIP buffer */
      byteslefttocopy = q->len;
 800863c:	4617      	mov	r7, r2
 800863e:	e7e3      	b.n	8008608 <low_level_output+0x8c>
{
  err_t errval;
  struct pbuf *q;
  u8 *buffer =  (u8 *)(DMATxDescToSet->Buffer1Addr);
  __IO ETH_DMADESCTypeDef *DmaTxDesc;
  uint16_t framelength = 0;
 8008640:	460e      	mov	r6, r1
  
  /* Note: padding and CRC for transmitted frame 
     are automatically inserted by DMA */

  /* Prepare transmit descriptors to give to DMA*/ 
  ETH_Prepare_Transmit_Descriptors(framelength);
 8008642:	4630      	mov	r0, r6
 8008644:	f000 fbbe 	bl	8008dc4 <ETH_Prepare_Transmit_Descriptors>

  errval = ERR_OK;
 8008648:	2000      	movs	r0, #0
 800864a:	e7cc      	b.n	80085e6 <low_level_output+0x6a>
 800864c:	20005778 	.word	0x20005778
 8008650:	40028000 	.word	0x40028000

08008654 <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
err_t ethernetif_input(struct netif *netif)
{
 8008654:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008658:	b087      	sub	sp, #28
 800865a:	9001      	str	r0, [sp, #4]
  uint32_t payloadoffset = 0;
  uint32_t byteslefttocopy = 0;
  uint32_t i=0;  
  
  /* get received frame */
  frame = ETH_Get_Received_Frame();
 800865c:	a803      	add	r0, sp, #12
 800865e:	f000 fb99 	bl	8008d94 <ETH_Get_Received_Frame>
  /* Obtain the size of the packet and put it into the "len" variable. */
  len = frame.length;
  buffer = (u8 *)frame.buffer;
  
  /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 8008662:	2203      	movs	r2, #3
 8008664:	4610      	mov	r0, r2
 8008666:	f8bd 100c 	ldrh.w	r1, [sp, #12]
  uint32_t payloadoffset = 0;
  uint32_t byteslefttocopy = 0;
  uint32_t i=0;  
  
  /* get received frame */
  frame = ETH_Get_Received_Frame();
 800866a:	f8dd a014 	ldr.w	sl, [sp, #20]
  
  /* Obtain the size of the packet and put it into the "len" variable. */
  len = frame.length;
  buffer = (u8 *)frame.buffer;
 800866e:	f8dd 8010 	ldr.w	r8, [sp, #16]
  
  /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 8008672:	f7fb fc39 	bl	8003ee8 <pbuf_alloc>
  
  if (p != NULL)
 8008676:	9000      	str	r0, [sp, #0]
 8008678:	b368      	cbz	r0, 80086d6 <ethernetif_input+0x82>
 800867a:	4683      	mov	fp, r0
 800867c:	4657      	mov	r7, sl
 800867e:	2500      	movs	r5, #0
    {
      byteslefttocopy = q->len;
      payloadoffset = 0;
      
      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 8008680:	f240 59f4 	movw	r9, #1524	; 0x5f4
  {
    DMARxDesc = frame.descriptor;
    bufferoffset = 0;
    for(q = p; q != NULL; q = q->next)
    {
      byteslefttocopy = q->len;
 8008684:	f8bb 200a 	ldrh.w	r2, [fp, #10]
      payloadoffset = 0;
      
      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 8008688:	1950      	adds	r0, r2, r5
 800868a:	4548      	cmp	r0, r9
 800868c:	4629      	mov	r1, r5
 800868e:	f04f 0600 	mov.w	r6, #0
 8008692:	4605      	mov	r5, r0
 8008694:	d914      	bls.n	80086c0 <ethernetif_input+0x6c>
      {
        /* Copy data to pbuf*/
        memcpy( (u8_t*)((u8_t*)q->payload + payloadoffset), (u8_t*)((u8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
 8008696:	f5c1 64be 	rsb	r4, r1, #1520	; 0x5f0
 800869a:	f8db 0004 	ldr.w	r0, [fp, #4]
 800869e:	3404      	adds	r4, #4
 80086a0:	4441      	add	r1, r8
 80086a2:	4430      	add	r0, r6
 80086a4:	4622      	mov	r2, r4
 80086a6:	f002 ff36 	bl	800b516 <memcpy>
        
        /* Point to next descriptor */
        DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
        buffer = (unsigned char *)(DMARxDesc->Buffer1Addr);
        
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
 80086aa:	f2a5 55f4 	subw	r5, r5, #1524	; 0x5f4
      {
        /* Copy data to pbuf*/
        memcpy( (u8_t*)((u8_t*)q->payload + payloadoffset), (u8_t*)((u8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
        
        /* Point to next descriptor */
        DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
 80086ae:	68ff      	ldr	r7, [r7, #12]
    {
      byteslefttocopy = q->len;
      payloadoffset = 0;
      
      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 80086b0:	454d      	cmp	r5, r9
        /* Point to next descriptor */
        DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
        buffer = (unsigned char *)(DMARxDesc->Buffer1Addr);
        
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
 80086b2:	4426      	add	r6, r4
        /* Copy data to pbuf*/
        memcpy( (u8_t*)((u8_t*)q->payload + payloadoffset), (u8_t*)((u8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
        
        /* Point to next descriptor */
        DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
        buffer = (unsigned char *)(DMARxDesc->Buffer1Addr);
 80086b4:	f8d7 8008 	ldr.w	r8, [r7, #8]
        
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
        bufferoffset = 0;
 80086b8:	f04f 0100 	mov.w	r1, #0
    {
      byteslefttocopy = q->len;
      payloadoffset = 0;
      
      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 80086bc:	d8eb      	bhi.n	8008696 <ethernetif_input+0x42>
        
        /* Point to next descriptor */
        DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
        buffer = (unsigned char *)(DMARxDesc->Buffer1Addr);
        
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
 80086be:	462a      	mov	r2, r5
        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
        bufferoffset = 0;
      }
      /* Copy remaining data in pbuf */
      memcpy( (u8_t*)((u8_t*)q->payload + payloadoffset), (u8_t*)((u8_t*)buffer + bufferoffset), byteslefttocopy);
 80086c0:	f8db 0004 	ldr.w	r0, [fp, #4]
 80086c4:	4441      	add	r1, r8
 80086c6:	4430      	add	r0, r6
 80086c8:	f002 ff25 	bl	800b516 <memcpy>
  
  if (p != NULL)
  {
    DMARxDesc = frame.descriptor;
    bufferoffset = 0;
    for(q = p; q != NULL; q = q->next)
 80086cc:	f8db b000 	ldr.w	fp, [fp]
 80086d0:	f1bb 0f00 	cmp.w	fp, #0
 80086d4:	d1d6      	bne.n	8008684 <ethernetif_input+0x30>
  
  /* Release descriptors to DMA */
  DMARxDesc =frame.descriptor;

  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
  for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
 80086d6:	4b16      	ldr	r3, [pc, #88]	; (8008730 <ethernetif_input+0xdc>)
 80086d8:	6819      	ldr	r1, [r3, #0]
 80086da:	688b      	ldr	r3, [r1, #8]
 80086dc:	b153      	cbz	r3, 80086f4 <ethernetif_input+0xa0>
 80086de:	2300      	movs	r3, #0
  {  
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
 80086e0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 80086e4:	f8ca 0000 	str.w	r0, [sl]
    DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
 80086e8:	f8da a00c 	ldr.w	sl, [sl, #12]
  
  /* Release descriptors to DMA */
  DMARxDesc =frame.descriptor;

  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
  for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
 80086ec:	688a      	ldr	r2, [r1, #8]
 80086ee:	3301      	adds	r3, #1
 80086f0:	4293      	cmp	r3, r2
 80086f2:	d3f7      	bcc.n	80086e4 <ethernetif_input+0x90>
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
    DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
  }
  
  /* Clear Segment_Count */
  DMA_RX_FRAME_infos->Seg_Count =0;
 80086f4:	2200      	movs	r2, #0
 80086f6:	608a      	str	r2, [r1, #8]
  
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)  
 80086f8:	4b0e      	ldr	r3, [pc, #56]	; (8008734 <ethernetif_input+0xe0>)
 80086fa:	f241 0114 	movw	r1, #4116	; 0x1014
 80086fe:	5858      	ldr	r0, [r3, r1]
 8008700:	0600      	lsls	r0, r0, #24
 8008702:	d504      	bpl.n	800870e <ethernetif_input+0xba>
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
 8008704:	f241 0008 	movw	r0, #4104	; 0x1008
  
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)  
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
 8008708:	2480      	movs	r4, #128	; 0x80
 800870a:	505c      	str	r4, [r3, r1]
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
 800870c:	501a      	str	r2, [r3, r0]

  /* move received packet into a new pbuf */
  p = low_level_input(netif);

  /* no packet could be read, silently ignore this */
  if (p == NULL) return ERR_MEM;
 800870e:	9800      	ldr	r0, [sp, #0]
 8008710:	b158      	cbz	r0, 800872a <ethernetif_input+0xd6>

  /* entry point to the LwIP stack */
  err = netif->input(p, netif);
 8008712:	9901      	ldr	r1, [sp, #4]
 8008714:	690b      	ldr	r3, [r1, #16]
 8008716:	4798      	blx	r3
  
  if (err != ERR_OK)
 8008718:	4604      	mov	r4, r0
 800871a:	b118      	cbz	r0, 8008724 <ethernetif_input+0xd0>
  {
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
    pbuf_free(p);
 800871c:	9800      	ldr	r0, [sp, #0]
 800871e:	f7fb fd3b 	bl	8004198 <pbuf_free>
 8008722:	4620      	mov	r0, r4
  }
  return err;
}
 8008724:	b007      	add	sp, #28
 8008726:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* move received packet into a new pbuf */
  p = low_level_input(netif);

  /* no packet could be read, silently ignore this */
  if (p == NULL) return ERR_MEM;
 800872a:	f04f 30ff 	mov.w	r0, #4294967295
 800872e:	e7f9      	b.n	8008724 <ethernetif_input+0xd0>
 8008730:	20006fd0 	.word	0x20006fd0
 8008734:	40028000 	.word	0x40028000

08008738 <ethernetif_init>:
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t ethernetif_init(struct netif *netif)
{
 8008738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800873a:	4604      	mov	r4, r0
#if LWIP_NETIF_HOSTNAME
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
 800873c:	2373      	movs	r3, #115	; 0x73
 800873e:	f880 3032 	strb.w	r3, [r0, #50]	; 0x32
#endif
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;

  /* set MAC hardware address */
  netif->hwaddr[0] =  MAC_ADDR0;
 8008742:	2202      	movs	r2, #2
  netif->hwaddr[1] =  MAC_ADDR1;
 8008744:	2000      	movs	r0, #0
  netif->hwaddr[2] =  MAC_ADDR2;
  netif->hwaddr[3] =  MAC_ADDR3;
  netif->hwaddr[4] =  MAC_ADDR4;
  netif->hwaddr[5] =  MAC_ADDR5;
 8008746:	2301      	movs	r3, #1
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
  netif->linkoutput = low_level_output;
 8008748:	4d1c      	ldr	r5, [pc, #112]	; (80087bc <ethernetif_init+0x84>)
  netif->name[1] = IFNAME1;
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
 800874a:	4e1d      	ldr	r6, [pc, #116]	; (80087c0 <ethernetif_init+0x88>)
  netif->linkoutput = low_level_output;
 800874c:	61a5      	str	r5, [r4, #24]
{
#ifdef CHECKSUM_BY_HARDWARE
  int i; 
#endif
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 800874e:	2106      	movs	r1, #6
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
  netif->name[1] = IFNAME1;
 8008750:	2774      	movs	r7, #116	; 0x74
{
#ifdef CHECKSUM_BY_HARDWARE
  int i; 
#endif
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 8008752:	f884 102a 	strb.w	r1, [r4, #42]	; 0x2a

  /* set MAC hardware address */
  netif->hwaddr[0] =  MAC_ADDR0;
 8008756:	f884 202b 	strb.w	r2, [r4, #43]	; 0x2b
  netif->hwaddr[1] =  MAC_ADDR1;
  netif->hwaddr[2] =  MAC_ADDR2;
  netif->hwaddr[3] =  MAC_ADDR3;
  netif->hwaddr[4] =  MAC_ADDR4;
  netif->hwaddr[5] =  MAC_ADDR5;
 800875a:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;

  /* set MAC hardware address */
  netif->hwaddr[0] =  MAC_ADDR0;
  netif->hwaddr[1] =  MAC_ADDR1;
 800875e:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
  netif->hwaddr[2] =  MAC_ADDR2;
 8008762:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
  netif->hwaddr[3] =  MAC_ADDR3;
 8008766:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
  netif->hwaddr[4] =  MAC_ADDR4;
 800876a:	f884 002f 	strb.w	r0, [r4, #47]	; 0x2f
  netif->hwaddr[5] =  MAC_ADDR5;
  
  /* initialize MAC address in ethernet MAC */ 
  ETH_MACAddressConfig(ETH_MAC_Address0, netif->hwaddr); 
 800876e:	f104 012b 	add.w	r1, r4, #43	; 0x2b
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
  netif->name[1] = IFNAME1;
 8008772:	f884 7033 	strb.w	r7, [r4, #51]	; 0x33
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
 8008776:	6166      	str	r6, [r4, #20]
  netif->hwaddr[3] =  MAC_ADDR3;
  netif->hwaddr[4] =  MAC_ADDR4;
  netif->hwaddr[5] =  MAC_ADDR5;
  
  /* initialize MAC address in ethernet MAC */ 
  ETH_MACAddressConfig(ETH_MAC_Address0, netif->hwaddr); 
 8008778:	f000 fb02 	bl	8008d80 <ETH_MACAddressConfig>
  /* maximum transfer unit */
  netif->mtu = 1500;

  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 800877c:	2322      	movs	r3, #34	; 0x22

  /* Initialize Tx Descriptors list: Chain Mode */
  ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 800877e:	4811      	ldr	r0, [pc, #68]	; (80087c4 <ethernetif_init+0x8c>)
  /* maximum transfer unit */
  netif->mtu = 1500;

  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 8008780:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
  
  /* initialize MAC address in ethernet MAC */ 
  ETH_MACAddressConfig(ETH_MAC_Address0, netif->hwaddr); 

  /* maximum transfer unit */
  netif->mtu = 1500;
 8008784:	f240 52dc 	movw	r2, #1500	; 0x5dc
 8008788:	8522      	strh	r2, [r4, #40]	; 0x28
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;

  /* Initialize Tx Descriptors list: Chain Mode */
  ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 800878a:	490f      	ldr	r1, [pc, #60]	; (80087c8 <ethernetif_init+0x90>)
 800878c:	2204      	movs	r2, #4
 800878e:	4604      	mov	r4, r0
 8008790:	f000 fbf6 	bl	8008f80 <ETH_DMATxDescChainInit>
  /* Initialize Rx Descriptors list: Chain Mode  */
  ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 8008794:	2204      	movs	r2, #4
 8008796:	490d      	ldr	r1, [pc, #52]	; (80087cc <ethernetif_init+0x94>)
 8008798:	480d      	ldr	r0, [pc, #52]	; (80087d0 <ethernetif_init+0x98>)
 800879a:	f000 fb7d 	bl	8008e98 <ETH_DMARxDescChainInit>
 800879e:	f104 0580 	add.w	r5, r4, #128	; 0x80

#ifdef CHECKSUM_BY_HARDWARE
  /* Enable the TCP, UDP and ICMP checksum insertion for the Tx frames */
  for(i=0; i<ETH_TXBUFNB; i++)
    {
      ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
 80087a2:	4620      	mov	r0, r4
 80087a4:	f44f 0140 	mov.w	r1, #12582912	; 0xc00000
 80087a8:	3420      	adds	r4, #32
 80087aa:	f000 fc11 	bl	8008fd0 <ETH_DMATxDescChecksumInsertionConfig>
  /* Initialize Rx Descriptors list: Chain Mode  */
  ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);

#ifdef CHECKSUM_BY_HARDWARE
  /* Enable the TCP, UDP and ICMP checksum insertion for the Tx frames */
  for(i=0; i<ETH_TXBUFNB; i++)
 80087ae:	42ac      	cmp	r4, r5
 80087b0:	d1f7      	bne.n	80087a2 <ethernetif_init+0x6a>
#endif

   /* Note: TCP, UDP, ICMP checksum checking for received frame are enabled in DMA config */

  /* Enable MAC and DMA transmission and reception */
  ETH_Start();
 80087b2:	f000 fa79 	bl	8008ca8 <ETH_Start>

  /* initialize the hardware */
  low_level_init(netif);

  return ERR_OK;
 80087b6:	2000      	movs	r0, #0
 80087b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80087ba:	bf00      	nop
 80087bc:	0800857d 	.word	0x0800857d
 80087c0:	08008029 	.word	0x08008029
 80087c4:	2000577c 	.word	0x2000577c
 80087c8:	20007054 	.word	0x20007054
 80087cc:	200057fc 	.word	0x200057fc
 80087d0:	20006fd4 	.word	0x20006fd4

080087d4 <ETH_DeInit>:
  * @brief  De-initializes the ETHERNET peripheral registers to their default reset values.
  * @param  None 
  * @retval None
  */
void ETH_DeInit(void)
{
 80087d4:	b508      	push	{r3, lr}
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
 80087d6:	2101      	movs	r1, #1
 80087d8:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80087dc:	f000 fe82 	bl	80094e4 <RCC_AHB1PeriphResetCmd>
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
 80087e0:	2100      	movs	r1, #0
 80087e2:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
}
 80087e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void ETH_DeInit(void)
{
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
 80087ea:	f000 be7b 	b.w	80094e4 <RCC_AHB1PeriphResetCmd>
 80087ee:	bf00      	nop

080087f0 <ETH_StructInit>:
  * @brief  Fills each ETH_InitStruct member with its default value.
  * @param  ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized.
  * @retval None
  */
void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
 80087f0:	b4f0      	push	{r4, r5, r6, r7}
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;
  /* Disable reception of Broadcast frames */
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
 80087f2:	2120      	movs	r1, #32
{
  /* ETH_InitStruct members default value */
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
 80087f4:	2701      	movs	r7, #1
  /* Ethernet interframe gap set to 96 bits */
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;
  /* Carrier Sense Enabled in Half-Duplex mode */
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;
  /* PHY speed configured to 100Mbit/s */
  ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
 80087f6:	f44f 4680 	mov.w	r6, #16384	; 0x4000
  /* Receive own Frames in Half-Duplex mode enabled */
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;
  /* MAC MII loopback disabled */ 
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;
  /* Full-Duplex mode selected */
  ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
 80087fa:	f44f 6500 	mov.w	r5, #2048	; 0x800
  /* Receive all frames disabled */
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;
 80087fe:	2440      	movs	r4, #64	; 0x40
  /* Initialize hash table high and low regs */
  ETH_InitStruct->ETH_HashTableHigh = 0x0;
  ETH_InitStruct->ETH_HashTableLow = 0x0;
  /* Flow control config (flow control disabled)*/
  ETH_InitStruct->ETH_PauseTime = 0x0;
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;
 8008800:	2280      	movs	r2, #128	; 0x80
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
  /* MAC watchdog enabled: cuts off long frame */
  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;
 8008802:	2300      	movs	r3, #0
{
  /* ETH_InitStruct members default value */
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
 8008804:	6007      	str	r7, [r0, #0]
  /* Ethernet interframe gap set to 96 bits */
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;
  /* Carrier Sense Enabled in Half-Duplex mode */
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;
  /* PHY speed configured to 100Mbit/s */
  ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
 8008806:	6146      	str	r6, [r0, #20]
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;
  
  /*---------------------- DMA Configuration   -------------------------------*/
  
  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
 8008808:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
  /* Flush received frame that created FIFO overflow */
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable;
  /* Store and forward mode enabled for transmit */
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
 800880c:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
  /* Receive own Frames in Half-Duplex mode enabled */
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;
  /* MAC MII loopback disabled */ 
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;
  /* Full-Duplex mode selected */
  ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
 8008810:	6205      	str	r5, [r0, #32]
  /* Receive all frames disabled */
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;
 8008812:	6404      	str	r4, [r0, #64]	; 0x40
  waiting status of previous frame*/
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  /* DMA works on 32-bit aligned start source and destinations addresses */
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
 8008814:	f44f 3580 	mov.w	r5, #65536	; 0x10000
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
 8008818:	f44f 0480 	mov.w	r4, #4194304	; 0x400000
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;
  /* Disable reception of Broadcast frames */
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
 800881c:	6441      	str	r1, [r0, #68]	; 0x44
  /* Initialize hash table high and low regs */
  ETH_InitStruct->ETH_HashTableHigh = 0x0;
  ETH_InitStruct->ETH_HashTableLow = 0x0;
  /* Flow control config (flow control disabled)*/
  ETH_InitStruct->ETH_PauseTime = 0x0;
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;
 800881e:	6642      	str	r2, [r0, #100]	; 0x64
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 8008820:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  /*---------------------- DMA Configuration   -------------------------------*/
  
  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
 8008824:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
  /* MAC watchdog enabled: cuts off long frame */
  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;
 8008828:	6043      	str	r3, [r0, #4]
  /* MAC Jabber enabled in Half-duplex mode */
  ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;
 800882a:	6083      	str	r3, [r0, #8]
  /* Ethernet interframe gap set to 96 bits */
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;
 800882c:	60c3      	str	r3, [r0, #12]
  /* Carrier Sense Enabled in Half-Duplex mode */
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;
 800882e:	6103      	str	r3, [r0, #16]
  /* PHY speed configured to 100Mbit/s */
  ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
  /* Receive own Frames in Half-Duplex mode enabled */
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;
 8008830:	6183      	str	r3, [r0, #24]
  /* MAC MII loopback disabled */ 
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;
 8008832:	61c3      	str	r3, [r0, #28]
  /* Full-Duplex mode selected */
  ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
  /* IPv4 and TCP/UDP/ICMP frame Checksum Offload disabled */
  ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;
 8008834:	6243      	str	r3, [r0, #36]	; 0x24
  /* Retry Transmission enabled for half-duplex mode */ 
  ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;
 8008836:	6283      	str	r3, [r0, #40]	; 0x28
  /* Automatic PAD/CRC strip disabled*/
  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
 8008838:	62c3      	str	r3, [r0, #44]	; 0x2c
  /* half-duplex mode retransmission Backoff time_limit = 10 slot times*/ 
  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;
 800883a:	6303      	str	r3, [r0, #48]	; 0x30
  /* half-duplex mode Deferral check disabled */
  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;
 800883c:	6343      	str	r3, [r0, #52]	; 0x34
  /* Receive all frames disabled */
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
 800883e:	6383      	str	r3, [r0, #56]	; 0x38
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;
 8008840:	63c3      	str	r3, [r0, #60]	; 0x3c
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;
  /* Disable reception of Broadcast frames */
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
  /* Normal Destination address filtering (not reverse addressing) */
  ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;
 8008842:	6483      	str	r3, [r0, #72]	; 0x48
  /* Promiscuous address filtering mode disabled */
  ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
 8008844:	64c3      	str	r3, [r0, #76]	; 0x4c
  /* Perfect address filtering for multicast addresses */
  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
 8008846:	6503      	str	r3, [r0, #80]	; 0x50
  /* Perfect address filtering for unicast addresses */
  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
 8008848:	6543      	str	r3, [r0, #84]	; 0x54
  /* Initialize hash table high and low regs */
  ETH_InitStruct->ETH_HashTableHigh = 0x0;
 800884a:	6583      	str	r3, [r0, #88]	; 0x58
  ETH_InitStruct->ETH_HashTableLow = 0x0;
 800884c:	65c3      	str	r3, [r0, #92]	; 0x5c
  /* Flow control config (flow control disabled)*/
  ETH_InitStruct->ETH_PauseTime = 0x0;
 800884e:	6603      	str	r3, [r0, #96]	; 0x60
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;
  ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;
 8008850:	6683      	str	r3, [r0, #104]	; 0x68
  ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;
 8008852:	66c3      	str	r3, [r0, #108]	; 0x6c
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;
 8008854:	6703      	str	r3, [r0, #112]	; 0x70
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
 8008856:	6743      	str	r3, [r0, #116]	; 0x74
  /* VLANtag config (VLAN field not checked) */
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;
 8008858:	6783      	str	r3, [r0, #120]	; 0x78
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;
 800885a:	67c3      	str	r3, [r0, #124]	; 0x7c
  
  /*---------------------- DMA Configuration   -------------------------------*/
  
  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
 800885c:	f8c0 7080 	str.w	r7, [r0, #128]	; 0x80
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
  /* Flush received frame that created FIFO overflow */
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable;
  /* Store and forward mode enabled for transmit */
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
 8008860:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  waiting status of previous frame*/
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  /* DMA works on 32-bit aligned start source and destinations addresses */
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
 8008864:	f8c0 50a8 	str.w	r5, [r0, #168]	; 0xa8
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
 8008868:	f8c0 40ac 	str.w	r4, [r0, #172]	; 0xac
  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
  /* Flush received frame that created FIFO overflow */
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable;
 800886c:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  /* Store and forward mode enabled for transmit */
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
  /* Threshold TXFIFO level set to 64 bytes (used when threshold mode is enabled) */
  ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;
 8008870:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
  /* Disable forwarding frames with errors (short frames, CRC,...)*/
  ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
 8008874:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
  /* Disable undersized good frames */
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
 8008878:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
  /* Threshold RXFIFO level set to 64 bytes (used when Cut through mode is enabled) */
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;
 800887c:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
  /* Disable Operate on second frame (transmit a second frame to FIFO without 
  waiting status of previous frame*/
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
 8008880:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  /* DMA Ring mode skip length = 0 */
  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
 8008884:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
  /* Equal priority (round-robin) between transmit and receive DMA engines */
  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
 8008888:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 800888c:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0
  /*---------------------- DMA Configuration   -------------------------------*/
  
  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
 8008890:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;
  /* Disable Operate on second frame (transmit a second frame to FIFO without 
  waiting status of previous frame*/
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  /* DMA works on 32-bit aligned start source and destinations addresses */
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
 8008894:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  /* DMA Ring mode skip length = 0 */
  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
  /* Equal priority (round-robin) between transmit and receive DMA engines */
  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
}
 8008898:	bcf0      	pop	{r4, r5, r6, r7}
 800889a:	4770      	bx	lr

0800889c <ETH_Init>:
  * @param PHYAddress: external PHY address
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
 800889c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80088a0:	b08e      	sub	sp, #56	; 0x38
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
 80088a2:	2300      	movs	r3, #0
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));
  /*-------------------------------- MAC Config ------------------------------*/
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 80088a4:	4a6c      	ldr	r2, [pc, #432]	; (8008a58 <ETH_Init+0x1bc>)
  *         ETH_SUCCESS: Ethernet successfully initialized
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
 80088a6:	9301      	str	r3, [sp, #4]
  RCC_ClocksTypeDef  rcc_clocks;
  uint32_t hclk = 60000000;
  __IO uint32_t timeout = 0, err = ETH_SUCCESS;
 80088a8:	2401      	movs	r4, #1
 80088aa:	9302      	str	r3, [sp, #8]
 80088ac:	9403      	str	r4, [sp, #12]
  * @param PHYAddress: external PHY address
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
 80088ae:	4604      	mov	r4, r0
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 80088b0:	a80a      	add	r0, sp, #40	; 0x28
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));
  /*-------------------------------- MAC Config ------------------------------*/
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 80088b2:	6917      	ldr	r7, [r2, #16]
  * @param PHYAddress: external PHY address
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
 80088b4:	460d      	mov	r5, r1
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 80088b6:	f000 fd9f 	bl	80093f8 <RCC_GetClocksFreq>
  hclk = rcc_clocks.HCLK_Frequency;
 80088ba:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
 80088bc:	4b67      	ldr	r3, [pc, #412]	; (8008a5c <ETH_Init+0x1c0>)
 80088be:	4868      	ldr	r0, [pc, #416]	; (8008a60 <ETH_Init+0x1c4>)
 80088c0:	4413      	add	r3, r2
 80088c2:	4283      	cmp	r3, r0
  /*-------------------------------- MAC Config ------------------------------*/
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
 80088c4:	f027 071c 	bic.w	r7, r7, #28
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  hclk = rcc_clocks.HCLK_Frequency;
  
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
 80088c8:	f200 8189 	bhi.w	8008bde <ETH_Init+0x342>
  {
    /* CSR Clock Range between 20-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
 80088cc:	f047 0708 	orr.w	r7, r7, #8
    /* CSR Clock Range between 150-168 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
  }
  
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
 80088d0:	4e61      	ldr	r6, [pc, #388]	; (8008a58 <ETH_Init+0x1bc>)
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 80088d2:	4864      	ldr	r0, [pc, #400]	; (8008a64 <ETH_Init+0x1c8>)
    /* CSR Clock Range between 150-168 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
  }
  
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
 80088d4:	6137      	str	r7, [r6, #16]
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
  uint32_t tmpreg = 0;
  __IO uint32_t timeout = 0;
 80088d6:	2300      	movs	r3, #0
 80088d8:	9304      	str	r3, [sp, #16]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));

  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 80088da:	6933      	ldr	r3, [r6, #16]
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 80088dc:	02ed      	lsls	r5, r5, #11
 80088de:	f003 031c 	and.w	r3, r3, #28
 80088e2:	b2ad      	uxth	r5, r5
 80088e4:	f043 0303 	orr.w	r3, r3, #3
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
 80088e8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 80088ec:	432b      	orrs	r3, r5
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
 80088ee:	6172      	str	r2, [r6, #20]
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
 80088f0:	4632      	mov	r2, r6
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 80088f2:	6133      	str	r3, [r6, #16]
 80088f4:	e002      	b.n	80088fc <ETH_Init+0x60>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 80088f6:	9b04      	ldr	r3, [sp, #16]
 80088f8:	4283      	cmp	r3, r0
 80088fa:	d805      	bhi.n	8008908 <ETH_Init+0x6c>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 80088fc:	9b04      	ldr	r3, [sp, #16]
 80088fe:	3301      	adds	r3, #1
 8008900:	9304      	str	r3, [sp, #16]
    tmpreg = ETH->MACMIIAR;
 8008902:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8008904:	07d9      	lsls	r1, r3, #31
 8008906:	d4f6      	bmi.n	80088f6 <ETH_Init+0x5a>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
 8008908:	9b04      	ldr	r3, [sp, #16]
 800890a:	4e57      	ldr	r6, [pc, #348]	; (8008a68 <ETH_Init+0x1cc>)
 800890c:	42b3      	cmp	r3, r6
 800890e:	f000 80ad 	beq.w	8008a6c <ETH_Init+0x1d0>
    err = ETH_ERROR;
    goto error;
  }
  
  /* Delay to assure PHY reset */
  _eth_delay_(PHY_RESET_DELAY);
 8008912:	20ff      	movs	r0, #255	; 0xff
 8008914:	f002 f980 	bl	800ac18 <Delay>
  
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
 8008918:	6823      	ldr	r3, [r4, #0]
 800891a:	2b00      	cmp	r3, #0
 800891c:	f000 817e 	beq.w	8008c1c <ETH_Init+0x380>
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8008920:	4a4d      	ldr	r2, [pc, #308]	; (8008a58 <ETH_Init+0x1bc>)
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 8008922:	4950      	ldr	r1, [pc, #320]	; (8008a64 <ETH_Init+0x1c8>)
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
 8008924:	4630      	mov	r0, r6
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 8008926:	2600      	movs	r6, #0
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  {
    /* We wait for linked status...*/
    do
    {
      timeout++;
 8008928:	9b02      	ldr	r3, [sp, #8]
 800892a:	3301      	adds	r3, #1
 800892c:	9302      	str	r3, [sp, #8]
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 800892e:	9605      	str	r6, [sp, #20]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8008930:	6913      	ldr	r3, [r2, #16]
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
 8008932:	f003 031c 	and.w	r3, r3, #28
 8008936:	432b      	orrs	r3, r5
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA);/* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 8008938:	f043 0341 	orr.w	r3, r3, #65	; 0x41
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 800893c:	6113      	str	r3, [r2, #16]
 800893e:	e002      	b.n	8008946 <ETH_Init+0xaa>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 8008940:	9b05      	ldr	r3, [sp, #20]
 8008942:	428b      	cmp	r3, r1
 8008944:	d805      	bhi.n	8008952 <ETH_Init+0xb6>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 8008946:	9b05      	ldr	r3, [sp, #20]
 8008948:	3301      	adds	r3, #1
 800894a:	9305      	str	r3, [sp, #20]
    tmpreg = ETH->MACMIIAR;
 800894c:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 800894e:	07db      	lsls	r3, r3, #31
 8008950:	d4f6      	bmi.n	8008940 <ETH_Init+0xa4>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
 8008952:	9b05      	ldr	r3, [sp, #20]
 8008954:	4283      	cmp	r3, r0
 8008956:	d002      	beq.n	800895e <ETH_Init+0xc2>
  {
    return (uint16_t)ETH_ERROR;
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
 8008958:	6953      	ldr	r3, [r2, #20]
  {
    /* We wait for linked status...*/
    do
    {
      timeout++;
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
 800895a:	075f      	lsls	r7, r3, #29
 800895c:	d402      	bmi.n	8008964 <ETH_Init+0xc8>
 800895e:	9b02      	ldr	r3, [sp, #8]
 8008960:	428b      	cmp	r3, r1
 8008962:	d9e1      	bls.n	8008928 <ETH_Init+0x8c>
    
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
 8008964:	4b40      	ldr	r3, [pc, #256]	; (8008a68 <ETH_Init+0x1cc>)
 8008966:	9a02      	ldr	r2, [sp, #8]
 8008968:	429a      	cmp	r2, r3
    {
      err = ETH_ERROR;
 800896a:	f04f 0300 	mov.w	r3, #0
    {
      timeout++;
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
    
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
 800896e:	d07e      	beq.n	8008a6e <ETH_Init+0x1d2>
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));

  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8008970:	4839      	ldr	r0, [pc, #228]	; (8008a58 <ETH_Init+0x1bc>)
      err = ETH_ERROR;
      goto error;
    }
    
    /* Reset Timeout counter */
    timeout = 0; 
 8008972:	9302      	str	r3, [sp, #8]
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
  uint32_t tmpreg = 0;
  __IO uint32_t timeout = 0;
 8008974:	9306      	str	r3, [sp, #24]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));

  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8008976:	6903      	ldr	r3, [r0, #16]
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8008978:	493a      	ldr	r1, [pc, #232]	; (8008a64 <ETH_Init+0x1c8>)
 800897a:	f003 031c 	and.w	r3, r3, #28
 800897e:	f043 0303 	orr.w	r3, r3, #3
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
 8008982:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 8008986:	432b      	orrs	r3, r5
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
 8008988:	6142      	str	r2, [r0, #20]
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
 800898a:	4602      	mov	r2, r0
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 800898c:	6103      	str	r3, [r0, #16]
 800898e:	e002      	b.n	8008996 <ETH_Init+0xfa>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8008990:	9b06      	ldr	r3, [sp, #24]
 8008992:	428b      	cmp	r3, r1
 8008994:	d805      	bhi.n	80089a2 <ETH_Init+0x106>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 8008996:	9b06      	ldr	r3, [sp, #24]
 8008998:	3301      	adds	r3, #1
 800899a:	9306      	str	r3, [sp, #24]
    tmpreg = ETH->MACMIIAR;
 800899c:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 800899e:	07d8      	lsls	r0, r3, #31
 80089a0:	d4f6      	bmi.n	8008990 <ETH_Init+0xf4>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
 80089a2:	9a06      	ldr	r2, [sp, #24]
 80089a4:	4b30      	ldr	r3, [pc, #192]	; (8008a68 <ETH_Init+0x1cc>)
 80089a6:	429a      	cmp	r2, r3
 80089a8:	d101      	bne.n	80089ae <ETH_Init+0x112>
    timeout = 0; 
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
    {
      /* Return ERROR in case of write timeout */
      err = ETH_ERROR;
 80089aa:	2300      	movs	r3, #0
 80089ac:	9303      	str	r3, [sp, #12]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 80089ae:	4a2a      	ldr	r2, [pc, #168]	; (8008a58 <ETH_Init+0x1bc>)
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 80089b0:	492c      	ldr	r1, [pc, #176]	; (8008a64 <ETH_Init+0x1c8>)
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
 80089b2:	4e2d      	ldr	r6, [pc, #180]	; (8008a68 <ETH_Init+0x1cc>)
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 80089b4:	2000      	movs	r0, #0
    }
    
    /* Wait until the auto-negotiation will be completed */
    do
    {
      timeout++;
 80089b6:	9b02      	ldr	r3, [sp, #8]
 80089b8:	3301      	adds	r3, #1
 80089ba:	9302      	str	r3, [sp, #8]
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 80089bc:	9007      	str	r0, [sp, #28]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 80089be:	6913      	ldr	r3, [r2, #16]
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
 80089c0:	f003 031c 	and.w	r3, r3, #28
 80089c4:	432b      	orrs	r3, r5
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA);/* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 80089c6:	f043 0341 	orr.w	r3, r3, #65	; 0x41
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 80089ca:	6113      	str	r3, [r2, #16]
 80089cc:	e002      	b.n	80089d4 <ETH_Init+0x138>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 80089ce:	9b07      	ldr	r3, [sp, #28]
 80089d0:	428b      	cmp	r3, r1
 80089d2:	d805      	bhi.n	80089e0 <ETH_Init+0x144>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 80089d4:	9b07      	ldr	r3, [sp, #28]
 80089d6:	3301      	adds	r3, #1
 80089d8:	9307      	str	r3, [sp, #28]
    tmpreg = ETH->MACMIIAR;
 80089da:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 80089dc:	07db      	lsls	r3, r3, #31
 80089de:	d4f6      	bmi.n	80089ce <ETH_Init+0x132>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
 80089e0:	9b07      	ldr	r3, [sp, #28]
 80089e2:	42b3      	cmp	r3, r6
 80089e4:	d002      	beq.n	80089ec <ETH_Init+0x150>
  {
    return (uint16_t)ETH_ERROR;
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
 80089e6:	6953      	ldr	r3, [r2, #20]
    
    /* Wait until the auto-negotiation will be completed */
    do
    {
      timeout++;
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));
 80089e8:	069f      	lsls	r7, r3, #26
 80089ea:	d402      	bmi.n	80089f2 <ETH_Init+0x156>
 80089ec:	9b02      	ldr	r3, [sp, #8]
 80089ee:	428b      	cmp	r3, r1
 80089f0:	d9e1      	bls.n	80089b6 <ETH_Init+0x11a>

    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
 80089f2:	4b1d      	ldr	r3, [pc, #116]	; (8008a68 <ETH_Init+0x1cc>)
 80089f4:	9a02      	ldr	r2, [sp, #8]
 80089f6:	429a      	cmp	r2, r3
    {
      err = ETH_ERROR;
 80089f8:	f04f 0300 	mov.w	r3, #0
    {
      timeout++;
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));

    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
 80089fc:	d037      	beq.n	8008a6e <ETH_Init+0x1d2>
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 80089fe:	4a16      	ldr	r2, [pc, #88]	; (8008a58 <ETH_Init+0x1bc>)
      err = ETH_ERROR;
      goto error;
    }

    /* Reset Timeout counter */
    timeout = 0;
 8008a00:	9302      	str	r3, [sp, #8]
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 8008a02:	9308      	str	r3, [sp, #32]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8008a04:	6913      	ldr	r3, [r2, #16]
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 8008a06:	4917      	ldr	r1, [pc, #92]	; (8008a64 <ETH_Init+0x1c8>)
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
 8008a08:	f003 031c 	and.w	r3, r3, #28
 8008a0c:	432b      	orrs	r3, r5
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA);/* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 8008a0e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008a12:	f043 0301 	orr.w	r3, r3, #1
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 8008a16:	6113      	str	r3, [r2, #16]
 8008a18:	e002      	b.n	8008a20 <ETH_Init+0x184>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 8008a1a:	9b08      	ldr	r3, [sp, #32]
 8008a1c:	428b      	cmp	r3, r1
 8008a1e:	d805      	bhi.n	8008a2c <ETH_Init+0x190>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 8008a20:	9b08      	ldr	r3, [sp, #32]
 8008a22:	3301      	adds	r3, #1
 8008a24:	9308      	str	r3, [sp, #32]
    tmpreg = ETH->MACMIIAR;
 8008a26:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 8008a28:	07d8      	lsls	r0, r3, #31
 8008a2a:	d4f6      	bmi.n	8008a1a <ETH_Init+0x17e>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
 8008a2c:	9a08      	ldr	r2, [sp, #32]
 8008a2e:	4b0e      	ldr	r3, [pc, #56]	; (8008a68 <ETH_Init+0x1cc>)
 8008a30:	429a      	cmp	r2, r3
 8008a32:	f000 811a 	beq.w	8008c6a <ETH_Init+0x3ce>
  {
    return (uint16_t)ETH_ERROR;
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
 8008a36:	4b08      	ldr	r3, [pc, #32]	; (8008a58 <ETH_Init+0x1bc>)
 8008a38:	695b      	ldr	r3, [r3, #20]
 8008a3a:	b29b      	uxth	r3, r3
      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
    }
    else
    {
      /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
 8008a3c:	f013 0f04 	tst.w	r3, #4
 8008a40:	bf14      	ite	ne
 8008a42:	f44f 6200 	movne.w	r2, #2048	; 0x800
 8008a46:	2200      	moveq	r2, #0
 8008a48:	6222      	str	r2, [r4, #32]
    }
    /* Configure the MAC with the speed fixed by the auto-negotiation process */
    if(RegValue & PHY_SPEED_STATUS)
 8008a4a:	079a      	lsls	r2, r3, #30
 8008a4c:	f140 810f 	bpl.w	8008c6e <ETH_Init+0x3d2>
    {  
      /* Set Ethernet speed to 10M following the auto-negotiation */
      ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
 8008a50:	2300      	movs	r3, #0
 8008a52:	6163      	str	r3, [r4, #20]
 8008a54:	e00c      	b.n	8008a70 <ETH_Init+0x1d4>
 8008a56:	bf00      	nop
 8008a58:	40028000 	.word	0x40028000
 8008a5c:	feced300 	.word	0xfeced300
 8008a60:	00e4e1bf 	.word	0x00e4e1bf
 8008a64:	0004fffe 	.word	0x0004fffe
 8008a68:	0004ffff 	.word	0x0004ffff
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
  {
    /* Return ERROR in case of write timeout */
    err = ETH_ERROR;
 8008a6c:	2300      	movs	r3, #0
 8008a6e:	9303      	str	r3, [sp, #12]
    }  
    /* Delay to assure PHY configuration */
    _eth_delay_(PHY_CONFIG_DELAY);
  }
error:
  if (err == ETH_ERROR) /* Auto-negotiation failed */
 8008a70:	9b03      	ldr	r3, [sp, #12]
 8008a72:	2b00      	cmp	r3, #0
 8008a74:	f000 80bb 	beq.w	8008bee <ETH_Init+0x352>
 8008a78:	6961      	ldr	r1, [r4, #20]
 8008a7a:	6a22      	ldr	r2, [r4, #32]
 8008a7c:	68a5      	ldr	r5, [r4, #8]
 8008a7e:	6867      	ldr	r7, [r4, #4]
 8008a80:	68e0      	ldr	r0, [r4, #12]
 8008a82:	6923      	ldr	r3, [r4, #16]
 8008a84:	69a6      	ldr	r6, [r4, #24]
 8008a86:	432f      	orrs	r7, r5
 8008a88:	4307      	orrs	r7, r0
 8008a8a:	69e5      	ldr	r5, [r4, #28]
 8008a8c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8008a8e:	431f      	orrs	r7, r3
 8008a90:	4337      	orrs	r7, r6
 8008a92:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008a94:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8008a96:	432f      	orrs	r7, r5
 8008a98:	431f      	orrs	r7, r3
    ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
  }

  /*------------------------ ETHERNET MACCR Configuration --------------------*/
    /* Get the ETHERNET MACCR value */
    tmpreg = ETH->MACCR;
 8008a9a:	4d77      	ldr	r5, [pc, #476]	; (8008c78 <ETH_Init+0x3dc>)
 8008a9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008a9e:	f8d5 e000 	ldr.w	lr, [r5]
 8008aa2:	4338      	orrs	r0, r7
 8008aa4:	ea40 0703 	orr.w	r7, r0, r3
 8008aa8:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8008aaa:	4b74      	ldr	r3, [pc, #464]	; (8008c7c <ETH_Init+0x3e0>)
 8008aac:	433e      	orrs	r6, r7
 8008aae:	ea0e 0303 	and.w	r3, lr, r3
 8008ab2:	4330      	orrs	r0, r6
 8008ab4:	4303      	orrs	r3, r0
 8008ab6:	430b      	orrs	r3, r1
  /* Set the IPCO bit according to ETH_ChecksumOffload value */
  /* Set the DR bit according to ETH_RetryTransmission value */
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */
  /* Set the BL bit according to ETH_BackOffLimit value */
  /* Set the DC bit according to ETH_DeferralCheck value */
      tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 8008ab8:	431a      	orrs	r2, r3
                           ETH_InitStruct->ETH_RetryTransmission | 
                           ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
                           ETH_InitStruct->ETH_BackOffLimit | 
                           ETH_InitStruct->ETH_DeferralCheck);
    /* Write to ETHERNET MACCR */
    ETH->MACCR = (uint32_t)tmpreg;
 8008aba:	602a      	str	r2, [r5, #0]
    
  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
    tmpreg = ETH->MACCR;
 8008abc:	682f      	ldr	r7, [r5, #0]
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 8008abe:	4e70      	ldr	r6, [pc, #448]	; (8008c80 <ETH_Init+0x3e4>)
    ETH->MACCR = (uint32_t)tmpreg;
    
  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
    tmpreg = ETH->MACCR;
    _eth_delay_(ETH_REG_WRITE_DELAY);
 8008ac0:	2001      	movs	r0, #1
 8008ac2:	f002 f8a9 	bl	800ac18 <Delay>
    ETH->MACCR = tmpreg; 
 8008ac6:	602f      	str	r7, [r5, #0]
                           ETH_InitStruct->ETH_SourceAddrFilter |
                           ETH_InitStruct->ETH_PassControlFrames |
                           ETH_InitStruct->ETH_BroadcastFramesReception | 
                           ETH_InitStruct->ETH_DestinationAddrFilter |
                           ETH_InitStruct->ETH_PromiscuousMode |
                           ETH_InitStruct->ETH_MulticastFramesFilter |
 8008ac8:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 8008acc:	c90e      	ldmia	r1, {r1, r2, r3}
 8008ace:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8008ad0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8008ad2:	430f      	orrs	r7, r1
 8008ad4:	4317      	orrs	r7, r2
 8008ad6:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 8008ada:	431f      	orrs	r7, r3
 8008adc:	c90e      	ldmia	r1, {r1, r2, r3}
 8008ade:	4338      	orrs	r0, r7
 8008ae0:	4301      	orrs	r1, r0
 8008ae2:	430a      	orrs	r2, r1
 8008ae4:	4313      	orrs	r3, r2
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
 8008ae6:	606b      	str	r3, [r5, #4]
                           ETH_InitStruct->ETH_MulticastFramesFilter |
                           ETH_InitStruct->ETH_UnicastFramesFilter);

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->MACFFR;
 8008ae8:	686f      	ldr	r7, [r5, #4]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008aea:	2001      	movs	r0, #1
 8008aec:	f002 f894 	bl	800ac18 <Delay>
  ETH->MACFFR = tmpreg;
 8008af0:	606f      	str	r7, [r5, #4]

  /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
  /* Write to ETHERNET MACHTHR */
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
 8008af2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8008af4:	60ab      	str	r3, [r5, #8]

  /* Write to ETHERNET MACHTLR */
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
 8008af6:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8008af8:	60eb      	str	r3, [r5, #12]
 8008afa:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8008afe:	c80b      	ldmia	r0, {r0, r1, r3}
 8008b00:	6e67      	ldr	r7, [r4, #100]	; 0x64
 8008b02:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8008b04:	4338      	orrs	r0, r7
 8008b06:	4308      	orrs	r0, r1
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/

  /* Get the ETHERNET MACFCR value */  
  tmpreg = ETH->MACFCR;
 8008b08:	69af      	ldr	r7, [r5, #24]
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */ 
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 8008b0a:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8008b0c:	4318      	orrs	r0, r3
 8008b0e:	f64f 7341 	movw	r3, #65345	; 0xff41
 8008b12:	4302      	orrs	r2, r0
 8008b14:	403b      	ands	r3, r7
 8008b16:	4313      	orrs	r3, r2
 8008b18:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                        ETH_InitStruct->ETH_PauseLowThreshold |
                        ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
                        ETH_InitStruct->ETH_ReceiveFlowControl |
                        ETH_InitStruct->ETH_TransmitFlowControl); 
  /* Write to ETHERNET MACFCR */
  ETH->MACFCR = (uint32_t)tmpreg;
 8008b1c:	61ab      	str	r3, [r5, #24]
  
  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->MACFCR;
 8008b1e:	69af      	ldr	r7, [r5, #24]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008b20:	2001      	movs	r0, #1
 8008b22:	f002 f879 	bl	800ac18 <Delay>
  ETH->MACFCR = tmpreg;
 8008b26:	61af      	str	r7, [r5, #24]

  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
  /* Set the ETV bit according to ETH_VLANTagComparison value */
  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
 8008b28:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 8008b2a:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8008b2c:	4313      	orrs	r3, r2
 8008b2e:	61eb      	str	r3, [r5, #28]
                              ETH_InitStruct->ETH_VLANTagIdentifier);

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->MACVLANTR;
 8008b30:	69ef      	ldr	r7, [r5, #28]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008b32:	2001      	movs	r0, #1
 8008b34:	f002 f870 	bl	800ac18 <Delay>
  ETH->MACVLANTR = tmpreg;
 8008b38:	61ef      	str	r7, [r5, #28]
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8008b3a:	f104 0184 	add.w	r1, r4, #132	; 0x84
 8008b3e:	c90e      	ldmia	r1, {r1, r2, r3}
 8008b40:	f8d4 7080 	ldr.w	r7, [r4, #128]	; 0x80
 8008b44:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 8008b48:	430f      	orrs	r7, r1
 8008b4a:	433a      	orrs	r2, r7
 8008b4c:	ea42 0703 	orr.w	r7, r2, r3
 8008b50:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 8008b54:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8008b58:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
 8008b5c:	4338      	orrs	r0, r7

  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/

  /* Get the ETHERNET DMAOMR value */
  tmpreg = ETH->DMAOMR;
 8008b5e:	f241 0718 	movw	r7, #4120	; 0x1018
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8008b62:	4302      	orrs	r2, r0

  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/

  /* Get the ETHERNET DMAOMR value */
  tmpreg = ETH->DMAOMR;
 8008b64:	f855 e007 	ldr.w	lr, [r5, r7]
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8008b68:	ea42 0003 	orr.w	r0, r2, r3
 8008b6c:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/

  /* Get the ETHERNET DMAOMR value */
  tmpreg = ETH->DMAOMR;
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 8008b70:	4b44      	ldr	r3, [pc, #272]	; (8008c84 <ETH_Init+0x3e8>)
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8008b72:	4301      	orrs	r1, r0
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/

  /* Get the ETHERNET DMAOMR value */
  tmpreg = ETH->DMAOMR;
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 8008b74:	ea0e 0303 	and.w	r3, lr, r3
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8008b78:	430a      	orrs	r2, r1
 8008b7a:	4313      	orrs	r3, r2
                       ETH_InitStruct->ETH_ForwardErrorFrames |
                       ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
                       ETH_InitStruct->ETH_ReceiveThresholdControl |
                       ETH_InitStruct->ETH_SecondFrameOperate); 
  /* Write to ETHERNET DMAOMR */
  ETH->DMAOMR = (uint32_t)tmpreg;
 8008b7c:	51eb      	str	r3, [r5, r7]

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->DMAOMR;
 8008b7e:	f855 8007 	ldr.w	r8, [r5, r7]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008b82:	2001      	movs	r0, #1
 8008b84:	f002 f848 	bl	800ac18 <Delay>
  ETH->DMAOMR = tmpreg;
 8008b88:	f845 8007 	str.w	r8, [r5, r7]
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 8008b8c:	f104 00a8 	add.w	r0, r4, #168	; 0xa8
 8008b90:	c829      	ldmia	r0, {r0, r3, r5}
 8008b92:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
 8008b96:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
 8008b9a:	f8d4 40b4 	ldr.w	r4, [r4, #180]	; 0xb4
 8008b9e:	4301      	orrs	r1, r0
 8008ba0:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8008ba4:	430b      	orrs	r3, r1
 8008ba6:	432b      	orrs	r3, r5
 8008ba8:	4313      	orrs	r3, r2
 8008baa:	ea43 0384 	orr.w	r3, r3, r4, lsl #2
 8008bae:	6033      	str	r3, [r6, #0]
                           ETH_InitStruct->ETH_DMAArbitration |
                           ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->DMABMR;
 8008bb0:	6834      	ldr	r4, [r6, #0]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008bb2:	2001      	movs	r0, #1
 8008bb4:	f002 f830 	bl	800ac18 <Delay>
  ETH->DMABMR = tmpreg;
 8008bb8:	6034      	str	r4, [r6, #0]

#ifdef USE_ENHANCED_DMA_DESCRIPTORS
  /* Enable the Enhanced DMA descriptors */
  ETH->DMABMR |= ETH_DMABMR_EDE;
 8008bba:	6833      	ldr	r3, [r6, #0]
 8008bbc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008bc0:	6033      	str	r3, [r6, #0]

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->DMABMR;
 8008bc2:	6834      	ldr	r4, [r6, #0]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008bc4:	2001      	movs	r0, #1
 8008bc6:	f002 f827 	bl	800ac18 <Delay>
  ETH->DMABMR = tmpreg;
 8008bca:	6034      	str	r4, [r6, #0]
#endif /* USE_ENHANCED_DMA_DESCRIPTORS */

  /* Return Ethernet configuration success */
  if(err == ETH_SUCCESS)
 8008bcc:	9803      	ldr	r0, [sp, #12]
 8008bce:	f1a0 0001 	sub.w	r0, r0, #1
 8008bd2:	fab0 f080 	clz	r0, r0
 8008bd6:	0940      	lsrs	r0, r0, #5
  else /* Auto-negotiation failed */
  {
    /* Return Ethernet error */
    return ETH_ERROR;
  }
}
 8008bd8:	b00e      	add	sp, #56	; 0x38
 8008bda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if((hclk >= 20000000)&&(hclk < 35000000))
  {
    /* CSR Clock Range between 20-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
  }
  else if((hclk >= 35000000)&&(hclk < 60000000))
 8008bde:	4b2a      	ldr	r3, [pc, #168]	; (8008c88 <ETH_Init+0x3ec>)
 8008be0:	492a      	ldr	r1, [pc, #168]	; (8008c8c <ETH_Init+0x3f0>)
 8008be2:	4413      	add	r3, r2
 8008be4:	428b      	cmp	r3, r1
 8008be6:	d809      	bhi.n	8008bfc <ETH_Init+0x360>
  {
    /* CSR Clock Range between 35-60 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;
 8008be8:	f047 070c 	orr.w	r7, r7, #12
 8008bec:	e670      	b.n	80088d0 <ETH_Init+0x34>
  }
error:
  if (err == ETH_ERROR) /* Auto-negotiation failed */
  {
    /* Set Ethernet duplex mode to Full-duplex */
    ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
 8008bee:	f44f 6200 	mov.w	r2, #2048	; 0x800

    /* Set Ethernet speed to 100M */
    ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
 8008bf2:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  }
error:
  if (err == ETH_ERROR) /* Auto-negotiation failed */
  {
    /* Set Ethernet duplex mode to Full-duplex */
    ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
 8008bf6:	6222      	str	r2, [r4, #32]

    /* Set Ethernet speed to 100M */
    ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
 8008bf8:	6161      	str	r1, [r4, #20]
 8008bfa:	e73f      	b.n	8008a7c <ETH_Init+0x1e0>
  else if((hclk >= 35000000)&&(hclk < 60000000))
  {
    /* CSR Clock Range between 35-60 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;
  }  
  else if((hclk >= 60000000)&&(hclk < 100000000))
 8008bfc:	4b24      	ldr	r3, [pc, #144]	; (8008c90 <ETH_Init+0x3f4>)
 8008bfe:	4925      	ldr	r1, [pc, #148]	; (8008c94 <ETH_Init+0x3f8>)
 8008c00:	4413      	add	r3, r2
 8008c02:	428b      	cmp	r3, r1
 8008c04:	f67f ae64 	bls.w	80088d0 <ETH_Init+0x34>
  {
    /* CSR Clock Range between 60-100 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;
  }  
  else if((hclk >= 100000000)&&(hclk < 150000000))
 8008c08:	4b23      	ldr	r3, [pc, #140]	; (8008c98 <ETH_Init+0x3fc>)
 8008c0a:	4924      	ldr	r1, [pc, #144]	; (8008c9c <ETH_Init+0x400>)
 8008c0c:	4413      	add	r3, r2
 8008c0e:	428b      	cmp	r3, r1
  {
    /* CSR Clock Range between 100-150 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 8008c10:	bf94      	ite	ls
 8008c12:	f047 0704 	orrls.w	r7, r7, #4
  }
  else /* ((hclk >= 150000000)&&(hclk <= 168000000)) */
  {
    /* CSR Clock Range between 150-168 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
 8008c16:	f047 0710 	orrhi.w	r7, r7, #16
 8008c1a:	e659      	b.n	80088d0 <ETH_Init+0x34>
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));

  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8008c1c:	4e16      	ldr	r6, [pc, #88]	; (8008c78 <ETH_Init+0x3dc>)
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
  uint32_t tmpreg = 0;
  __IO uint32_t timeout = 0;
 8008c1e:	9309      	str	r3, [sp, #36]	; 0x24
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));

  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8008c20:	6933      	ldr	r3, [r6, #16]
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
    }
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
 8008c22:	6962      	ldr	r2, [r4, #20]
 8008c24:	6a20      	ldr	r0, [r4, #32]
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8008c26:	491e      	ldr	r1, [pc, #120]	; (8008ca0 <ETH_Init+0x404>)
 8008c28:	f003 031c 	and.w	r3, r3, #28
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
    }
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
 8008c2c:	0852      	lsrs	r2, r2, #1
 8008c2e:	f043 0303 	orr.w	r3, r3, #3
 8008c32:	ea42 02d0 	orr.w	r2, r2, r0, lsr #3
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 8008c36:	431d      	orrs	r5, r3
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
    }
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
 8008c38:	b293      	uxth	r3, r2
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
 8008c3a:	6173      	str	r3, [r6, #20]
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
 8008c3c:	4632      	mov	r2, r6
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 8008c3e:	6135      	str	r5, [r6, #16]
 8008c40:	e002      	b.n	8008c48 <ETH_Init+0x3ac>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8008c42:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008c44:	428b      	cmp	r3, r1
 8008c46:	d805      	bhi.n	8008c54 <ETH_Init+0x3b8>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 8008c48:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008c4a:	3301      	adds	r3, #1
 8008c4c:	9309      	str	r3, [sp, #36]	; 0x24
    tmpreg = ETH->MACMIIAR;
 8008c4e:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8008c50:	07db      	lsls	r3, r3, #31
 8008c52:	d4f6      	bmi.n	8008c42 <ETH_Init+0x3a6>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
 8008c54:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008c56:	4b13      	ldr	r3, [pc, #76]	; (8008ca4 <ETH_Init+0x408>)
 8008c58:	429a      	cmp	r2, r3
 8008c5a:	d101      	bne.n	8008c60 <ETH_Init+0x3c4>
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
                                                   (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
    {
      /* Return ERROR in case of write timeout */
      err = ETH_ERROR;
 8008c5c:	2300      	movs	r3, #0
 8008c5e:	9303      	str	r3, [sp, #12]
    }  
    /* Delay to assure PHY configuration */
    _eth_delay_(PHY_CONFIG_DELAY);
 8008c60:	f640 70ff 	movw	r0, #4095	; 0xfff
 8008c64:	f001 ffd8 	bl	800ac18 <Delay>
 8008c68:	e702      	b.n	8008a70 <ETH_Init+0x1d4>
 8008c6a:	2300      	movs	r3, #0
 8008c6c:	6223      	str	r3, [r4, #32]
      ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
    }
    else
    {   
      /* Set Ethernet speed to 100M following the auto-negotiation */ 
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
 8008c6e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8008c72:	6163      	str	r3, [r4, #20]
 8008c74:	e6fc      	b.n	8008a70 <ETH_Init+0x1d4>
 8008c76:	bf00      	nop
 8008c78:	40028000 	.word	0x40028000
 8008c7c:	ff20810f 	.word	0xff20810f
 8008c80:	40029000 	.word	0x40029000
 8008c84:	f8de3f23 	.word	0xf8de3f23
 8008c88:	fde9f140 	.word	0xfde9f140
 8008c8c:	017d783f 	.word	0x017d783f
 8008c90:	fc6c7900 	.word	0xfc6c7900
 8008c94:	026259ff 	.word	0x026259ff
 8008c98:	fa0a1f00 	.word	0xfa0a1f00
 8008c9c:	02faf07f 	.word	0x02faf07f
 8008ca0:	0004fffe 	.word	0x0004fffe
 8008ca4:	0004ffff 	.word	0x0004ffff

08008ca8 <ETH_Start>:
  * @brief  Enables ENET MAC and DMA reception/transmission 
  * @param  None
  * @retval None
  */
void ETH_Start(void)
{
 8008ca8:	b570      	push	{r4, r5, r6, lr}
 8008caa:	b084      	sub	sp, #16
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;
 8008cac:	4c18      	ldr	r4, [pc, #96]	; (8008d10 <ETH_Start+0x68>)
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACTransmissionCmd(FunctionalState NewState)
{ 
  __IO uint32_t tmpreg = 0;
 8008cae:	2600      	movs	r6, #0
 8008cb0:	9603      	str	r6, [sp, #12]
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;
 8008cb2:	6823      	ldr	r3, [r4, #0]
 8008cb4:	f043 0308 	orr.w	r3, r3, #8
 8008cb8:	6023      	str	r3, [r4, #0]
    ETH->MACCR &= ~ETH_MACCR_TE;
  }

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->MACCR;
 8008cba:	6823      	ldr	r3, [r4, #0]
 8008cbc:	9303      	str	r3, [sp, #12]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008cbe:	2001      	movs	r0, #1
 8008cc0:	f001 ffaa 	bl	800ac18 <Delay>
  ETH->MACCR = tmpreg;
 8008cc4:	9b03      	ldr	r3, [sp, #12]
 8008cc6:	6023      	str	r3, [r4, #0]
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACReceptionCmd(FunctionalState NewState)
{ 
  __IO uint32_t tmpreg = 0;
 8008cc8:	9602      	str	r6, [sp, #8]
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the MAC reception */
    ETH->MACCR |= ETH_MACCR_RE;
 8008cca:	6823      	ldr	r3, [r4, #0]
 8008ccc:	f043 0304 	orr.w	r3, r3, #4
 8008cd0:	6023      	str	r3, [r4, #0]
    ETH->MACCR &= ~ETH_MACCR_RE; 
  }

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->MACCR;
 8008cd2:	6823      	ldr	r3, [r4, #0]
 8008cd4:	9302      	str	r3, [sp, #8]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008cd6:	2001      	movs	r0, #1
 8008cd8:	f001 ff9e 	bl	800ac18 <Delay>
  */
void ETH_FlushTransmitFIFO(void)
{
  __IO uint32_t tmpreg = 0;
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;
 8008cdc:	f241 0518 	movw	r5, #4120	; 0x1018

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->MACCR;
  _eth_delay_(ETH_REG_WRITE_DELAY);
  ETH->MACCR = tmpreg;
 8008ce0:	9b02      	ldr	r3, [sp, #8]
 8008ce2:	6023      	str	r3, [r4, #0]
  * @param  None
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
  __IO uint32_t tmpreg = 0;
 8008ce4:	9601      	str	r6, [sp, #4]
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;
 8008ce6:	5963      	ldr	r3, [r4, r5]
 8008ce8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008cec:	5163      	str	r3, [r4, r5]
  
  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->DMAOMR;
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008cee:	2001      	movs	r0, #1
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;
  
  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->DMAOMR;
 8008cf0:	5963      	ldr	r3, [r4, r5]
 8008cf2:	9301      	str	r3, [sp, #4]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008cf4:	f001 ff90 	bl	800ac18 <Delay>
  ETH->DMAOMR = tmpreg;
 8008cf8:	9b01      	ldr	r3, [sp, #4]
 8008cfa:	5163      	str	r3, [r4, r5]
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA transmission */
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
 8008cfc:	5963      	ldr	r3, [r4, r5]
 8008cfe:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8008d02:	5163      	str	r3, [r4, r5]
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA reception */
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
 8008d04:	5963      	ldr	r3, [r4, r5]
 8008d06:	f043 0302 	orr.w	r3, r3, #2
 8008d0a:	5163      	str	r3, [r4, r5]
  /* Start DMA transmission */
  ETH_DMATransmissionCmd(ENABLE);

  /* Start DMA reception */
  ETH_DMAReceptionCmd(ENABLE);
}
 8008d0c:	b004      	add	sp, #16
 8008d0e:	bd70      	pop	{r4, r5, r6, pc}
 8008d10:	40028000 	.word	0x40028000

08008d14 <ETH_Stop>:
  * @brief  Disables ENET MAC and DMA reception/transmission 
  * @param  None
  * @retval None
  */
void ETH_Stop(void)
{  
 8008d14:	b570      	push	{r4, r5, r6, lr}
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
  }
  else
  {
    /* Disable the DMA transmission */
    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
 8008d16:	4c19      	ldr	r4, [pc, #100]	; (8008d7c <ETH_Stop+0x68>)
 8008d18:	f241 0518 	movw	r5, #4120	; 0x1018
  * @brief  Disables ENET MAC and DMA reception/transmission 
  * @param  None
  * @retval None
  */
void ETH_Stop(void)
{  
 8008d1c:	b084      	sub	sp, #16
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
  }
  else
  {
    /* Disable the DMA transmission */
    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
 8008d1e:	5963      	ldr	r3, [r4, r5]
 8008d20:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8008d24:	5163      	str	r3, [r4, r5]
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
  }
  else
  {
    /* Disable the DMA reception */
    ETH->DMAOMR &= ~ETH_DMAOMR_SR;
 8008d26:	5963      	ldr	r3, [r4, r5]
 8008d28:	f023 0302 	bic.w	r3, r3, #2
 8008d2c:	5163      	str	r3, [r4, r5]
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACReceptionCmd(FunctionalState NewState)
{ 
  __IO uint32_t tmpreg = 0;
 8008d2e:	2600      	movs	r6, #0
 8008d30:	9603      	str	r6, [sp, #12]
    ETH->MACCR |= ETH_MACCR_RE;
  }
  else
  {
    /* Disable the MAC reception */
    ETH->MACCR &= ~ETH_MACCR_RE; 
 8008d32:	6823      	ldr	r3, [r4, #0]
 8008d34:	f023 0304 	bic.w	r3, r3, #4
 8008d38:	6023      	str	r3, [r4, #0]
  }

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->MACCR;
 8008d3a:	6823      	ldr	r3, [r4, #0]
 8008d3c:	9303      	str	r3, [sp, #12]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008d3e:	2001      	movs	r0, #1
 8008d40:	f001 ff6a 	bl	800ac18 <Delay>
  ETH->MACCR = tmpreg;
 8008d44:	9b03      	ldr	r3, [sp, #12]
 8008d46:	6023      	str	r3, [r4, #0]
  * @param  None
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
  __IO uint32_t tmpreg = 0;
 8008d48:	9602      	str	r6, [sp, #8]
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;
 8008d4a:	5963      	ldr	r3, [r4, r5]
 8008d4c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008d50:	5163      	str	r3, [r4, r5]
  
  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->DMAOMR;
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008d52:	2001      	movs	r0, #1
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;
  
  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->DMAOMR;
 8008d54:	5963      	ldr	r3, [r4, r5]
 8008d56:	9302      	str	r3, [sp, #8]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008d58:	f001 ff5e 	bl	800ac18 <Delay>
  ETH->DMAOMR = tmpreg;
 8008d5c:	9b02      	ldr	r3, [sp, #8]
 8008d5e:	5163      	str	r3, [r4, r5]
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACTransmissionCmd(FunctionalState NewState)
{ 
  __IO uint32_t tmpreg = 0;
 8008d60:	9601      	str	r6, [sp, #4]
    ETH->MACCR |= ETH_MACCR_TE;
  }
  else
  {
    /* Disable the MAC transmission */
    ETH->MACCR &= ~ETH_MACCR_TE;
 8008d62:	6823      	ldr	r3, [r4, #0]
 8008d64:	f023 0308 	bic.w	r3, r3, #8
 8008d68:	6023      	str	r3, [r4, #0]
  }

  /* Wait until the write operation will be taken into account :
   at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = ETH->MACCR;
 8008d6a:	6823      	ldr	r3, [r4, #0]
 8008d6c:	9301      	str	r3, [sp, #4]
  _eth_delay_(ETH_REG_WRITE_DELAY);
 8008d6e:	2001      	movs	r0, #1
 8008d70:	f001 ff52 	bl	800ac18 <Delay>
  ETH->MACCR = tmpreg;
 8008d74:	9b01      	ldr	r3, [sp, #4]
 8008d76:	6023      	str	r3, [r4, #0]
  /* Flush Transmit FIFO */
  ETH_FlushTransmitFIFO();

  /* Disable transmit state machine of the MAC for transmission on the MII */
  ETH_MACTransmissionCmd(DISABLE);
}
 8008d78:	b004      	add	sp, #16
 8008d7a:	bd70      	pop	{r4, r5, r6, pc}
 8008d7c:	40028000 	.word	0x40028000

08008d80 <ETH_MACAddressConfig>:
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
 8008d80:	4b03      	ldr	r3, [pc, #12]	; (8008d90 <ETH_MACAddressConfig+0x10>)
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
 8008d82:	888a      	ldrh	r2, [r1, #4]
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
 8008d84:	50c2      	str	r2, [r0, r3]
  /* Calculate the selected MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
  
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
 8008d86:	3304      	adds	r3, #4
  /* Calculate the selected MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
  /* Calculate the selected MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
 8008d88:	680a      	ldr	r2, [r1, #0]
  
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
 8008d8a:	50c2      	str	r2, [r0, r3]
 8008d8c:	4770      	bx	lr
 8008d8e:	bf00      	nop
 8008d90:	40028040 	.word	0x40028040

08008d94 <ETH_Get_Received_Frame>:
{ 
  uint32_t framelength = 0;
  FrameTypeDef frame = {0,0,0}; 

  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 8008d94:	4909      	ldr	r1, [pc, #36]	; (8008dbc <ETH_Get_Received_Frame+0x28>)
  frame.length = framelength;

  /* Get the address of the first frame descriptor and the buffer start address */ 
  frame.descriptor = DMA_RX_FRAME_infos->FS_Rx_Desc;
 8008d96:	4b0a      	ldr	r3, [pc, #40]	; (8008dc0 <ETH_Get_Received_Frame+0x2c>)
  *   with polling method only).
  * @param  none
  * @retval Structure of type FrameTypeDef
  */
FrameTypeDef ETH_Get_Received_Frame(void)
{ 
 8008d98:	b470      	push	{r4, r5, r6}
  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
  frame.length = framelength;

  /* Get the address of the first frame descriptor and the buffer start address */ 
  frame.descriptor = DMA_RX_FRAME_infos->FS_Rx_Desc;
 8008d9a:	681a      	ldr	r2, [r3, #0]
{ 
  uint32_t framelength = 0;
  FrameTypeDef frame = {0,0,0}; 

  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 8008d9c:	680c      	ldr	r4, [r1, #0]
 8008d9e:	6823      	ldr	r3, [r4, #0]
  frame.length = framelength;

  /* Get the address of the first frame descriptor and the buffer start address */ 
  frame.descriptor = DMA_RX_FRAME_infos->FS_Rx_Desc;
 8008da0:	6815      	ldr	r5, [r2, #0]
  frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
 8008da2:	6816      	ldr	r6, [r2, #0]
  /* Chained Mode */    
  /* Selects the next DMA Rx descriptor list for next buffer to read */ 
  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);

  /* Return Frame */
  return (frame);
 8008da4:	6085      	str	r5, [r0, #8]
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
  frame.length = framelength;

  /* Get the address of the first frame descriptor and the buffer start address */ 
  frame.descriptor = DMA_RX_FRAME_infos->FS_Rx_Desc;
  frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
 8008da6:	68b6      	ldr	r6, [r6, #8]

  /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */
  /* Chained Mode */    
  /* Selects the next DMA Rx descriptor list for next buffer to read */ 
  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 8008da8:	68e4      	ldr	r4, [r4, #12]
 8008daa:	600c      	str	r4, [r1, #0]

  /* Return Frame */
  return (frame);
 8008dac:	f3c3 430d 	ubfx	r3, r3, #16, #14
 8008db0:	3b04      	subs	r3, #4
 8008db2:	e880 0048 	stmia.w	r0, {r3, r6}
}
 8008db6:	bc70      	pop	{r4, r5, r6}
 8008db8:	4770      	bx	lr
 8008dba:	bf00      	nop
 8008dbc:	20005774 	.word	0x20005774
 8008dc0:	20006fd0 	.word	0x20006fd0

08008dc4 <ETH_Prepare_Transmit_Descriptors>:
  * @brief  Prepares DMA Tx descriptors to transmit an ethernet frame
  * @param  FrameLength : length of the frame to send
  * @retval error status
  */
uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength)
{   
 8008dc4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t buf_count =0, size=0,i=0;
  __IO ETH_DMADESCTypeDef *DMATxDesc;

  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 8008dc6:	4e30      	ldr	r6, [pc, #192]	; (8008e88 <ETH_Prepare_Transmit_Descriptors+0xc4>)
 8008dc8:	6833      	ldr	r3, [r6, #0]
 8008dca:	681a      	ldr	r2, [r3, #0]
 8008dcc:	2a00      	cmp	r2, #0
 8008dce:	db51      	blt.n	8008e74 <ETH_Prepare_Transmit_Descriptors+0xb0>
    return ETH_ERROR;
  }

  DMATxDesc = DMATxDescToSet;
  
  if (FrameLength > ETH_TX_BUF_SIZE)
 8008dd0:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8008dd4:	4290      	cmp	r0, r2
 8008dd6:	d92e      	bls.n	8008e36 <ETH_Prepare_Transmit_Descriptors+0x72>
  {
    buf_count = FrameLength/ETH_TX_BUF_SIZE;
 8008dd8:	4c2c      	ldr	r4, [pc, #176]	; (8008e8c <ETH_Prepare_Transmit_Descriptors+0xc8>)
 8008dda:	fba4 1400 	umull	r1, r4, r4, r0
 8008dde:	0aa4      	lsrs	r4, r4, #10
    if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
 8008de0:	fb02 0214 	mls	r2, r2, r4, r0
 8008de4:	b292      	uxth	r2, r2

  DMATxDesc = DMATxDescToSet;
  
  if (FrameLength > ETH_TX_BUF_SIZE)
  {
    buf_count = FrameLength/ETH_TX_BUF_SIZE;
 8008de6:	b2a4      	uxth	r4, r4
    if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
 8008de8:	b31a      	cbz	r2, 8008e32 <ETH_Prepare_Transmit_Descriptors+0x6e>
 8008dea:	3401      	adds	r4, #1
      if (i== (buf_count-1))
      {
        /* Setting the last segment bit */
        DMATxDesc->Status |= ETH_DMATxDesc_LS;
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
 8008dec:	4f28      	ldr	r7, [pc, #160]	; (8008e90 <ETH_Prepare_Transmit_Descriptors+0xcc>)
 8008dee:	f200 50f4 	addw	r0, r0, #1524	; 0x5f4
 8008df2:	fb07 0004 	mla	r0, r7, r4, r0
 8008df6:	f3c0 070c 	ubfx	r7, r0, #0, #13
 8008dfa:	2200      	movs	r2, #0
        /* Setting the first segment bit */
        DMATxDesc->Status |= ETH_DMATxDesc_FS;  
      }

      /* Program size */
      DMATxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
 8008dfc:	f240 50f4 	movw	r0, #1524	; 0x5f4
      
      if (i== (buf_count-1))
 8008e00:	1e65      	subs	r5, r4, #1
 8008e02:	e007      	b.n	8008e14 <ETH_Prepare_Transmit_Descriptors+0x50>
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
      }

      /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
      DMATxDesc->Status |= ETH_DMATxDesc_OWN;
 8008e04:	6819      	ldr	r1, [r3, #0]
    DMATxDesc->Status |= ETH_DMATxDesc_OWN;
    DMATxDesc= (ETH_DMADESCTypeDef *)(DMATxDesc->Buffer2NextDescAddr);
  }
  else
  {
    for (i=0; i< buf_count; i++)
 8008e06:	3201      	adds	r2, #1
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
      }

      /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
      DMATxDesc->Status |= ETH_DMATxDesc_OWN;
 8008e08:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8008e0c:	6019      	str	r1, [r3, #0]
    DMATxDesc->Status |= ETH_DMATxDesc_OWN;
    DMATxDesc= (ETH_DMADESCTypeDef *)(DMATxDesc->Buffer2NextDescAddr);
  }
  else
  {
    for (i=0; i< buf_count; i++)
 8008e0e:	42a2      	cmp	r2, r4
      }

      /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
      DMATxDesc->Status |= ETH_DMATxDesc_OWN;

      DMATxDesc = (ETH_DMADESCTypeDef *)(DMATxDesc->Buffer2NextDescAddr);
 8008e10:	68db      	ldr	r3, [r3, #12]
    DMATxDesc->Status |= ETH_DMATxDesc_OWN;
    DMATxDesc= (ETH_DMADESCTypeDef *)(DMATxDesc->Buffer2NextDescAddr);
  }
  else
  {
    for (i=0; i< buf_count; i++)
 8008e12:	d01c      	beq.n	8008e4e <ETH_Prepare_Transmit_Descriptors+0x8a>
    {
      /* Clear FIRST and LAST segment bits */
      DMATxDesc->Status &= ~(ETH_DMATxDesc_FS | ETH_DMATxDesc_LS);
 8008e14:	6819      	ldr	r1, [r3, #0]
 8008e16:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 8008e1a:	6019      	str	r1, [r3, #0]
      
      if (i==0) 
 8008e1c:	2a00      	cmp	r2, #0
 8008e1e:	d02c      	beq.n	8008e7a <ETH_Prepare_Transmit_Descriptors+0xb6>
      }

      /* Program size */
      DMATxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
      
      if (i== (buf_count-1))
 8008e20:	4295      	cmp	r5, r2
        /* Setting the first segment bit */
        DMATxDesc->Status |= ETH_DMATxDesc_FS;  
      }

      /* Program size */
      DMATxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
 8008e22:	6058      	str	r0, [r3, #4]
      
      if (i== (buf_count-1))
 8008e24:	d1ee      	bne.n	8008e04 <ETH_Prepare_Transmit_Descriptors+0x40>
      {
        /* Setting the last segment bit */
        DMATxDesc->Status |= ETH_DMATxDesc_LS;
 8008e26:	6819      	ldr	r1, [r3, #0]
 8008e28:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 8008e2c:	6019      	str	r1, [r3, #0]
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
 8008e2e:	605f      	str	r7, [r3, #4]
 8008e30:	e7e8      	b.n	8008e04 <ETH_Prepare_Transmit_Descriptors+0x40>
    buf_count = FrameLength/ETH_TX_BUF_SIZE;
    if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
  }
  else buf_count =1;

  if (buf_count ==1)
 8008e32:	2c01      	cmp	r4, #1
 8008e34:	d1da      	bne.n	8008dec <ETH_Prepare_Transmit_Descriptors+0x28>
  {
    /*set LAST and FIRST segment */
    DMATxDesc->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
 8008e36:	681a      	ldr	r2, [r3, #0]
    /* Set frame size */
    DMATxDesc->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
 8008e38:	f3c0 000c 	ubfx	r0, r0, #0, #13
  else buf_count =1;

  if (buf_count ==1)
  {
    /*set LAST and FIRST segment */
    DMATxDesc->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
 8008e3c:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8008e40:	601a      	str	r2, [r3, #0]
    /* Set frame size */
    DMATxDesc->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
 8008e42:	6058      	str	r0, [r3, #4]
    /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
    DMATxDesc->Status |= ETH_DMATxDesc_OWN;
 8008e44:	681a      	ldr	r2, [r3, #0]
 8008e46:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8008e4a:	601a      	str	r2, [r3, #0]
    DMATxDesc= (ETH_DMADESCTypeDef *)(DMATxDesc->Buffer2NextDescAddr);
 8008e4c:	68db      	ldr	r3, [r3, #12]
  }
  
  DMATxDescToSet = DMATxDesc;

  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
 8008e4e:	4a11      	ldr	r2, [pc, #68]	; (8008e94 <ETH_Prepare_Transmit_Descriptors+0xd0>)

      DMATxDesc = (ETH_DMADESCTypeDef *)(DMATxDesc->Buffer2NextDescAddr);
    }
  }
  
  DMATxDescToSet = DMATxDesc;
 8008e50:	6033      	str	r3, [r6, #0]

  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
 8008e52:	f241 0314 	movw	r3, #4116	; 0x1014
 8008e56:	58d1      	ldr	r1, [r2, r3]
 8008e58:	0749      	lsls	r1, r1, #29
 8008e5a:	d508      	bpl.n	8008e6e <ETH_Prepare_Transmit_Descriptors+0xaa>
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 8008e5c:	f241 0104 	movw	r1, #4100	; 0x1004

  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
 8008e60:	2004      	movs	r0, #4
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 8008e62:	2400      	movs	r4, #0

  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
 8008e64:	50d0      	str	r0, [r2, r3]
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
  }

  /* Return SUCCESS */
  return ETH_SUCCESS;   
 8008e66:	2001      	movs	r0, #1
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 8008e68:	5054      	str	r4, [r2, r1]
  }

  /* Return SUCCESS */
  return ETH_SUCCESS;   
}
 8008e6a:	bcf0      	pop	{r4, r5, r6, r7}
 8008e6c:	4770      	bx	lr
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
  }

  /* Return SUCCESS */
  return ETH_SUCCESS;   
 8008e6e:	2001      	movs	r0, #1
}
 8008e70:	bcf0      	pop	{r4, r5, r6, r7}
 8008e72:	4770      	bx	lr

  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
  {  
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
 8008e74:	2000      	movs	r0, #0
    ETH->DMATPDR = 0;
  }

  /* Return SUCCESS */
  return ETH_SUCCESS;   
}
 8008e76:	bcf0      	pop	{r4, r5, r6, r7}
 8008e78:	4770      	bx	lr
      DMATxDesc->Status &= ~(ETH_DMATxDesc_FS | ETH_DMATxDesc_LS);
      
      if (i==0) 
      {
        /* Setting the first segment bit */
        DMATxDesc->Status |= ETH_DMATxDesc_FS;  
 8008e7a:	6819      	ldr	r1, [r3, #0]
 8008e7c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8008e80:	6019      	str	r1, [r3, #0]
      }

      /* Program size */
      DMATxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
 8008e82:	6058      	str	r0, [r3, #4]
 8008e84:	e7be      	b.n	8008e04 <ETH_Prepare_Transmit_Descriptors+0x40>
 8008e86:	bf00      	nop
 8008e88:	20005778 	.word	0x20005778
 8008e8c:	ac02b00b 	.word	0xac02b00b
 8008e90:	fffffa0c 	.word	0xfffffa0c
 8008e94:	40028000 	.word	0x40028000

08008e98 <ETH_DMARxDescChainInit>:
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
 8008e98:	4b12      	ldr	r3, [pc, #72]	; (8008ee4 <ETH_DMARxDescChainInit+0x4c>)
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
{
 8008e9a:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
 8008e9c:	6018      	str	r0, [r3, #0]
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
 8008e9e:	b1c2      	cbz	r2, 8008ed2 <ETH_DMARxDescChainInit+0x3a>
 8008ea0:	f102 3cff 	add.w	ip, r2, #4294967295
 8008ea4:	4603      	mov	r3, r0
 8008ea6:	2400      	movs	r4, #0
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
 8008ea8:	f04f 4e00 	mov.w	lr, #2147483648	; 0x80000000

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
 8008eac:	f244 57f4 	movw	r7, #17908	; 0x45f4
 8008eb0:	f103 0520 	add.w	r5, r3, #32
 8008eb4:	4564      	cmp	r4, ip
 8008eb6:	bf34      	ite	cc
 8008eb8:	462e      	movcc	r6, r5
 8008eba:	4606      	movcs	r6, r0
 8008ebc:	3401      	adds	r4, #1
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
 8008ebe:	42a2      	cmp	r2, r4
    DMARxDesc->Status = ETH_DMARxDesc_OWN;

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 8008ec0:	6099      	str	r1, [r3, #8]
  for(i=0; i < RxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
 8008ec2:	f8c3 e000 	str.w	lr, [r3]

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
 8008ec6:	605f      	str	r7, [r3, #4]
 8008ec8:	60de      	str	r6, [r3, #12]
 8008eca:	f201 51f4 	addw	r1, r1, #1524	; 0x5f4
 8008ece:	462b      	mov	r3, r5
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
 8008ed0:	d1ee      	bne.n	8008eb0 <ETH_DMARxDescChainInit+0x18>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
  }

  /* Set Receive Descriptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;
 8008ed2:	4c05      	ldr	r4, [pc, #20]	; (8008ee8 <ETH_DMARxDescChainInit+0x50>)

  DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
 8008ed4:	4b05      	ldr	r3, [pc, #20]	; (8008eec <ETH_DMARxDescChainInit+0x54>)
 8008ed6:	4a06      	ldr	r2, [pc, #24]	; (8008ef0 <ETH_DMARxDescChainInit+0x58>)
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
  }

  /* Set Receive Descriptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;
 8008ed8:	f241 010c 	movw	r1, #4108	; 0x100c
 8008edc:	5060      	str	r0, [r4, r1]

  DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
 8008ede:	601a      	str	r2, [r3, #0]
  
}
 8008ee0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008ee2:	bf00      	nop
 8008ee4:	20005774 	.word	0x20005774
 8008ee8:	40028000 	.word	0x40028000
 8008eec:	20006fd0 	.word	0x20006fd0
 8008ef0:	20005768 	.word	0x20005768

08008ef4 <ETH_CheckFrameReceived>:
  * @retval Returns 1 when a frame is received, 0 if none.
  */
uint32_t ETH_CheckFrameReceived(void)
{
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8008ef4:	4a20      	ldr	r2, [pc, #128]	; (8008f78 <ETH_CheckFrameReceived+0x84>)
 8008ef6:	6813      	ldr	r3, [r2, #0]
 8008ef8:	6819      	ldr	r1, [r3, #0]
 8008efa:	2900      	cmp	r1, #0
  * @brief  This function polls for a frame reception
  * @param  None
  * @retval Returns 1 when a frame is received, 0 if none.
  */
uint32_t ETH_CheckFrameReceived(void)
{
 8008efc:	b410      	push	{r4}
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8008efe:	db10      	blt.n	8008f22 <ETH_CheckFrameReceived+0x2e>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
 8008f00:	6819      	ldr	r1, [r3, #0]
  * @retval Returns 1 when a frame is received, 0 if none.
  */
uint32_t ETH_CheckFrameReceived(void)
{
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8008f02:	05cc      	lsls	r4, r1, #23
 8008f04:	d50d      	bpl.n	8008f22 <ETH_CheckFrameReceived+0x2e>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
  {
    DMA_RX_FRAME_infos->Seg_Count++;
 8008f06:	4a1d      	ldr	r2, [pc, #116]	; (8008f7c <ETH_CheckFrameReceived+0x88>)
 8008f08:	6812      	ldr	r2, [r2, #0]
 8008f0a:	6891      	ldr	r1, [r2, #8]
 8008f0c:	3101      	adds	r1, #1
 8008f0e:	6091      	str	r1, [r2, #8]
    if (DMA_RX_FRAME_infos->Seg_Count == 1)
 8008f10:	6891      	ldr	r1, [r2, #8]
 8008f12:	2901      	cmp	r1, #1
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 8008f14:	bf08      	it	eq
 8008f16:	6013      	streq	r3, [r2, #0]
    }
    DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
    return 1;
 8008f18:	2001      	movs	r0, #1
    DMA_RX_FRAME_infos->Seg_Count++;
    if (DMA_RX_FRAME_infos->Seg_Count == 1)
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
    }
    DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
 8008f1a:	6053      	str	r3, [r2, #4]
  {
    (DMA_RX_FRAME_infos->Seg_Count) ++;
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
  } 
  return 0;
}
 8008f1c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008f20:	4770      	bx	lr
    DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
    return 1;
  }

  /* check if first segment */
  else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8008f22:	6819      	ldr	r1, [r3, #0]
 8008f24:	2900      	cmp	r1, #0
 8008f26:	db06      	blt.n	8008f36 <ETH_CheckFrameReceived+0x42>
          ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
 8008f28:	6819      	ldr	r1, [r3, #0]
    DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
    return 1;
  }

  /* check if first segment */
  else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8008f2a:	0588      	lsls	r0, r1, #22
 8008f2c:	d503      	bpl.n	8008f36 <ETH_CheckFrameReceived+0x42>
          ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
            ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
 8008f2e:	6818      	ldr	r0, [r3, #0]
    return 1;
  }

  /* check if first segment */
  else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
          ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
 8008f30:	f410 7080 	ands.w	r0, r0, #256	; 0x100
 8008f34:	d017      	beq.n	8008f66 <ETH_CheckFrameReceived+0x72>
    DMA_RX_FRAME_infos->Seg_Count = 1;   
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
  }

  /* check if intermediate segment */ 
  else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8008f36:	6819      	ldr	r1, [r3, #0]
 8008f38:	2900      	cmp	r1, #0
 8008f3a:	db10      	blt.n	8008f5e <ETH_CheckFrameReceived+0x6a>
          ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
 8008f3c:	6818      	ldr	r0, [r3, #0]
    DMA_RX_FRAME_infos->Seg_Count = 1;   
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
  }

  /* check if intermediate segment */ 
  else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8008f3e:	f410 7000 	ands.w	r0, r0, #512	; 0x200
 8008f42:	d10c      	bne.n	8008f5e <ETH_CheckFrameReceived+0x6a>
          ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
            ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
 8008f44:	6819      	ldr	r1, [r3, #0]
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
  }

  /* check if intermediate segment */ 
  else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
          ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
 8008f46:	05c9      	lsls	r1, r1, #23
 8008f48:	d4e8      	bmi.n	8008f1c <ETH_CheckFrameReceived+0x28>
            ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
  {
    (DMA_RX_FRAME_infos->Seg_Count) ++;
 8008f4a:	490c      	ldr	r1, [pc, #48]	; (8008f7c <ETH_CheckFrameReceived+0x88>)
 8008f4c:	680c      	ldr	r4, [r1, #0]
 8008f4e:	68a1      	ldr	r1, [r4, #8]
 8008f50:	3101      	adds	r1, #1
 8008f52:	60a1      	str	r1, [r4, #8]
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 8008f54:	68db      	ldr	r3, [r3, #12]
 8008f56:	6013      	str	r3, [r2, #0]
  } 
  return 0;
}
 8008f58:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008f5c:	4770      	bx	lr
            ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
  {
    (DMA_RX_FRAME_infos->Seg_Count) ++;
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
  } 
  return 0;
 8008f5e:	2000      	movs	r0, #0
}
 8008f60:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008f64:	4770      	bx	lr
  /* check if first segment */
  else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
          ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
            ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
  {
    DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 8008f66:	4905      	ldr	r1, [pc, #20]	; (8008f7c <ETH_CheckFrameReceived+0x88>)
 8008f68:	6809      	ldr	r1, [r1, #0]
    DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
    DMA_RX_FRAME_infos->Seg_Count = 1;   
 8008f6a:	2401      	movs	r4, #1
  /* check if first segment */
  else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
          ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
            ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
  {
    DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 8008f6c:	600b      	str	r3, [r1, #0]
    DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
 8008f6e:	6048      	str	r0, [r1, #4]
    DMA_RX_FRAME_infos->Seg_Count = 1;   
 8008f70:	608c      	str	r4, [r1, #8]
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 8008f72:	68db      	ldr	r3, [r3, #12]
 8008f74:	6013      	str	r3, [r2, #0]
 8008f76:	e7d1      	b.n	8008f1c <ETH_CheckFrameReceived+0x28>
 8008f78:	20005774 	.word	0x20005774
 8008f7c:	20006fd0 	.word	0x20006fd0

08008f80 <ETH_DMATxDescChainInit>:
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
 8008f80:	4b11      	ldr	r3, [pc, #68]	; (8008fc8 <ETH_DMATxDescChainInit+0x48>)
 8008f82:	6018      	str	r0, [r3, #0]
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 8008f84:	b1d2      	cbz	r2, 8008fbc <ETH_DMATxDescChainInit+0x3c>
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
{
 8008f86:	b5f0      	push	{r4, r5, r6, r7, lr}
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 8008f88:	4603      	mov	r3, r0
 8008f8a:	f102 3eff 	add.w	lr, r2, #4294967295
 8008f8e:	2400      	movs	r4, #0
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
 8008f90:	f44f 1780 	mov.w	r7, #1048576	; 0x100000
 8008f94:	f103 0520 	add.w	r5, r3, #32
 8008f98:	4574      	cmp	r4, lr
 8008f9a:	bf34      	ite	cc
 8008f9c:	462e      	movcc	r6, r5
 8008f9e:	4606      	movcs	r6, r0
 8008fa0:	3401      	adds	r4, #1
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 8008fa2:	42a2      	cmp	r2, r4
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  

    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 8008fa4:	6099      	str	r1, [r3, #8]
  for(i=0; i < TxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
 8008fa6:	601f      	str	r7, [r3, #0]
 8008fa8:	60de      	str	r6, [r3, #12]
 8008faa:	f201 51f4 	addw	r1, r1, #1524	; 0x5f4
 8008fae:	462b      	mov	r3, r5
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 8008fb0:	d1f0      	bne.n	8008f94 <ETH_DMATxDescChainInit+0x14>
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
  }

  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
 8008fb2:	4a06      	ldr	r2, [pc, #24]	; (8008fcc <ETH_DMATxDescChainInit+0x4c>)
 8008fb4:	f241 0310 	movw	r3, #4112	; 0x1010
 8008fb8:	50d0      	str	r0, [r2, r3]
}
 8008fba:	bdf0      	pop	{r4, r5, r6, r7, pc}
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
  }

  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
 8008fbc:	4a03      	ldr	r2, [pc, #12]	; (8008fcc <ETH_DMATxDescChainInit+0x4c>)
 8008fbe:	f241 0310 	movw	r3, #4112	; 0x1010
 8008fc2:	50d0      	str	r0, [r2, r3]
 8008fc4:	4770      	bx	lr
 8008fc6:	bf00      	nop
 8008fc8:	20005778 	.word	0x20005778
 8008fcc:	40028000 	.word	0x40028000

08008fd0 <ETH_DMATxDescChecksumInsertionConfig>:
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
  
  /* Set the selected DMA Tx desc checksum insertion control */
  DMATxDesc->Status |= DMATxDesc_Checksum;
 8008fd0:	6803      	ldr	r3, [r0, #0]
 8008fd2:	4319      	orrs	r1, r3
 8008fd4:	6001      	str	r1, [r0, #0]
 8008fd6:	4770      	bx	lr

08008fd8 <ETH_SoftwareReset>:
  */
void ETH_SoftwareReset(void)
{
  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
  /* After reset all the registers holds their respective reset values */
  ETH->DMABMR |= ETH_DMABMR_SR;
 8008fd8:	4a02      	ldr	r2, [pc, #8]	; (8008fe4 <ETH_SoftwareReset+0xc>)
 8008fda:	6813      	ldr	r3, [r2, #0]
 8008fdc:	f043 0301 	orr.w	r3, r3, #1
 8008fe0:	6013      	str	r3, [r2, #0]
 8008fe2:	4770      	bx	lr
 8008fe4:	40029000 	.word	0x40029000

08008fe8 <ETH_GetSoftwareResetStatus>:
  * @retval The new state of DMA Bus Mode register SR bit (SET or RESET).
  */
FlagStatus ETH_GetSoftwareResetStatus(void)
{
  FlagStatus bitstatus = RESET;
  if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 8008fe8:	4b02      	ldr	r3, [pc, #8]	; (8008ff4 <ETH_GetSoftwareResetStatus+0xc>)
 8008fea:	6818      	ldr	r0, [r3, #0]
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8008fec:	f000 0001 	and.w	r0, r0, #1
 8008ff0:	4770      	bx	lr
 8008ff2:	bf00      	nop
 8008ff4:	40029000 	.word	0x40029000

08008ff8 <ETH_ReadPHYRegister>:
  *     @arg More PHY register could be read depending on the used PHY
  * @retval ETH_ERROR: in case of timeout
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
 8008ff8:	b430      	push	{r4, r5}
 8008ffa:	b082      	sub	sp, #8
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 8008ffc:	2300      	movs	r3, #0
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8008ffe:	4a13      	ldr	r2, [pc, #76]	; (800904c <ETH_ReadPHYRegister+0x54>)
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 8009000:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8009002:	6913      	ldr	r3, [r2, #16]
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 8009004:	4c12      	ldr	r4, [pc, #72]	; (8009050 <ETH_ReadPHYRegister+0x58>)
 8009006:	0189      	lsls	r1, r1, #6
 8009008:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA);/* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
 800900c:	02c0      	lsls	r0, r0, #11
 800900e:	f003 051c 	and.w	r5, r3, #28
 8009012:	b280      	uxth	r0, r0
 8009014:	ea41 0305 	orr.w	r3, r1, r5
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
 8009018:	4303      	orrs	r3, r0
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 800901a:	f043 0301 	orr.w	r3, r3, #1
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 800901e:	6113      	str	r3, [r2, #16]
 8009020:	e002      	b.n	8009028 <ETH_ReadPHYRegister+0x30>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 8009022:	9b01      	ldr	r3, [sp, #4]
 8009024:	42a3      	cmp	r3, r4
 8009026:	d805      	bhi.n	8009034 <ETH_ReadPHYRegister+0x3c>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 8009028:	9b01      	ldr	r3, [sp, #4]
 800902a:	3301      	adds	r3, #1
 800902c:	9301      	str	r3, [sp, #4]
    tmpreg = ETH->MACMIIAR;
 800902e:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 8009030:	07db      	lsls	r3, r3, #31
 8009032:	d4f6      	bmi.n	8009022 <ETH_ReadPHYRegister+0x2a>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
 8009034:	4b07      	ldr	r3, [pc, #28]	; (8009054 <ETH_ReadPHYRegister+0x5c>)
 8009036:	9a01      	ldr	r2, [sp, #4]
 8009038:	429a      	cmp	r2, r3
  {
    return (uint16_t)ETH_ERROR;
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
 800903a:	bf1b      	ittet	ne
 800903c:	4b03      	ldrne	r3, [pc, #12]	; (800904c <ETH_ReadPHYRegister+0x54>)
 800903e:	6958      	ldrne	r0, [r3, #20]
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
  {
    return (uint16_t)ETH_ERROR;
 8009040:	2000      	moveq	r0, #0
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
 8009042:	b280      	uxthne	r0, r0
}
 8009044:	b002      	add	sp, #8
 8009046:	bc30      	pop	{r4, r5}
 8009048:	4770      	bx	lr
 800904a:	bf00      	nop
 800904c:	40028000 	.word	0x40028000
 8009050:	0004fffe 	.word	0x0004fffe
 8009054:	0004ffff 	.word	0x0004ffff

08009058 <ETH_WritePHYRegister>:
  * @param  PHYValue: the value to write
  * @retval ETH_ERROR: in case of timeout
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
 8009058:	b430      	push	{r4, r5}
 800905a:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));

  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 800905c:	4d12      	ldr	r5, [pc, #72]	; (80090a8 <ETH_WritePHYRegister+0x50>)
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 800905e:	4c13      	ldr	r4, [pc, #76]	; (80090ac <ETH_WritePHYRegister+0x54>)
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
  uint32_t tmpreg = 0;
  __IO uint32_t timeout = 0;
 8009060:	2300      	movs	r3, #0
 8009062:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));

  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8009064:	692b      	ldr	r3, [r5, #16]
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
 8009066:	616a      	str	r2, [r5, #20]
 8009068:	0189      	lsls	r1, r1, #6
 800906a:	f003 031c 	and.w	r3, r3, #28
 800906e:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 8009072:	02c0      	lsls	r0, r0, #11
 8009074:	f043 0303 	orr.w	r3, r3, #3
 8009078:	b280      	uxth	r0, r0
 800907a:	4319      	orrs	r1, r3
 800907c:	4301      	orrs	r1, r0
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
 800907e:	462a      	mov	r2, r5
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 8009080:	6129      	str	r1, [r5, #16]
 8009082:	e002      	b.n	800908a <ETH_WritePHYRegister+0x32>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8009084:	9b01      	ldr	r3, [sp, #4]
 8009086:	42a3      	cmp	r3, r4
 8009088:	d805      	bhi.n	8009096 <ETH_WritePHYRegister+0x3e>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 800908a:	9b01      	ldr	r3, [sp, #4]
 800908c:	3301      	adds	r3, #1
 800908e:	9301      	str	r3, [sp, #4]
    tmpreg = ETH->MACMIIAR;
 8009090:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8009092:	07db      	lsls	r3, r3, #31
 8009094:	d4f6      	bmi.n	8009084 <ETH_WritePHYRegister+0x2c>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
 8009096:	9801      	ldr	r0, [sp, #4]
 8009098:	4b05      	ldr	r3, [pc, #20]	; (80090b0 <ETH_WritePHYRegister+0x58>)
    return ETH_ERROR;
  }

  /* Return SUCCESS */
  return ETH_SUCCESS;  
}
 800909a:	1ac0      	subs	r0, r0, r3
 800909c:	bf18      	it	ne
 800909e:	2001      	movne	r0, #1
 80090a0:	b002      	add	sp, #8
 80090a2:	bc30      	pop	{r4, r5}
 80090a4:	4770      	bx	lr
 80090a6:	bf00      	nop
 80090a8:	40028000 	.word	0x40028000
 80090ac:	0004fffe 	.word	0x0004fffe
 80090b0:	0004ffff 	.word	0x0004ffff

080090b4 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 80090b4:	78c3      	ldrb	r3, [r0, #3]
 80090b6:	b95b      	cbnz	r3, 80090d0 <NVIC_Init+0x1c>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80090b8:	7803      	ldrb	r3, [r0, #0]
 80090ba:	4818      	ldr	r0, [pc, #96]	; (800911c <NVIC_Init+0x68>)
 80090bc:	095a      	lsrs	r2, r3, #5
 80090be:	3220      	adds	r2, #32
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80090c0:	f003 031f 	and.w	r3, r3, #31
 80090c4:	2101      	movs	r1, #1
 80090c6:	fa01 f303 	lsl.w	r3, r1, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80090ca:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 80090ce:	4770      	bx	lr
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80090d0:	4b13      	ldr	r3, [pc, #76]	; (8009120 <NVIC_Init+0x6c>)
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 80090d2:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80090d4:	68d9      	ldr	r1, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80090d6:	7847      	ldrb	r7, [r0, #1]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80090d8:	7882      	ldrb	r2, [r0, #2]
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80090da:	7804      	ldrb	r4, [r0, #0]
 80090dc:	4e0f      	ldr	r6, [pc, #60]	; (800911c <NVIC_Init+0x68>)
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80090de:	43c9      	mvns	r1, r1
 80090e0:	f3c1 2102 	ubfx	r1, r1, #8, #3
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80090e4:	f1c1 0504 	rsb	r5, r1, #4
 80090e8:	b2ed      	uxtb	r5, r5
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80090ea:	230f      	movs	r3, #15
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80090ec:	fa07 f505 	lsl.w	r5, r7, r5
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80090f0:	410b      	asrs	r3, r1
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80090f2:	b2ed      	uxtb	r5, r5
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80090f4:	4013      	ands	r3, r2
 80090f6:	432b      	orrs	r3, r5
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80090f8:	f104 4260 	add.w	r2, r4, #3758096384	; 0xe0000000
 80090fc:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
 8009100:	011b      	lsls	r3, r3, #4
 8009102:	b2db      	uxtb	r3, r3
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8009104:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8009108:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800910a:	2201      	movs	r2, #1
 800910c:	f003 011f 	and.w	r1, r3, #31
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8009110:	095b      	lsrs	r3, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8009112:	408a      	lsls	r2, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8009114:	f846 2023 	str.w	r2, [r6, r3, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8009118:	bcf0      	pop	{r4, r5, r6, r7}
 800911a:	4770      	bx	lr
 800911c:	e000e100 	.word	0xe000e100
 8009120:	e000ed00 	.word	0xe000ed00

08009124 <SysTick_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8009124:	4a04      	ldr	r2, [pc, #16]	; (8009138 <SysTick_CLKSourceConfig+0x14>)
 8009126:	6813      	ldr	r3, [r2, #0]
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8009128:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 800912a:	bf0c      	ite	eq
 800912c:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8009130:	f023 0304 	bicne.w	r3, r3, #4
 8009134:	6013      	str	r3, [r2, #0]
 8009136:	4770      	bx	lr
 8009138:	e000e010 	.word	0xe000e010

0800913c <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 800913c:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 800913e:	6844      	ldr	r4, [r0, #4]
 8009140:	680a      	ldr	r2, [r1, #0]
  tmpreg1 &= CR1_CLEAR_MASK;
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8009142:	790e      	ldrb	r6, [r1, #4]
 8009144:	f8d1 e010 	ldr.w	lr, [r1, #16]
 8009148:	68cd      	ldr	r5, [r1, #12]
 800914a:	4b0f      	ldr	r3, [pc, #60]	; (8009188 <ADC_Init+0x4c>)
 800914c:	f024 7440 	bic.w	r4, r4, #50331648	; 0x3000000
 8009150:	f424 7480 	bic.w	r4, r4, #256	; 0x100
 8009154:	4322      	orrs	r2, r4
 8009156:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
                                   ADC_InitStruct->ADC_Resolution);
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 800915a:	6042      	str	r2, [r0, #4]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 800915c:	6887      	ldr	r7, [r0, #8]
 800915e:	688a      	ldr	r2, [r1, #8]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8009160:	794e      	ldrb	r6, [r1, #5]
 8009162:	ea4e 0405 	orr.w	r4, lr, r5
 8009166:	4322      	orrs	r2, r4
 8009168:	403b      	ands	r3, r7
 800916a:	4313      	orrs	r3, r2
 800916c:	ea43 0346 	orr.w	r3, r3, r6, lsl #1
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8009170:	6083      	str	r3, [r0, #8]
  tmpreg1 &= SQR1_L_RESET;
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 8009172:	7d0a      	ldrb	r2, [r1, #20]
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8009174:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  tmpreg1 &= SQR1_L_RESET;
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 8009176:	3a01      	subs	r2, #1
 8009178:	b2d2      	uxtb	r2, r2
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 800917a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 800917e:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8009182:	62c3      	str	r3, [r0, #44]	; 0x2c
 8009184:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009186:	bf00      	nop
 8009188:	c0fff7fd 	.word	0xc0fff7fd

0800918c <ADC_StructInit>:
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 800918c:	2300      	movs	r3, #0

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 800918e:	2201      	movs	r2, #1
 8009190:	7502      	strb	r2, [r0, #20]
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8009192:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8009194:	7103      	strb	r3, [r0, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8009196:	7143      	strb	r3, [r0, #5]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8009198:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 800919a:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 800919c:	6103      	str	r3, [r0, #16]
 800919e:	4770      	bx	lr

080091a0 <ADC_CommonInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 80091a0:	b470      	push	{r4, r5, r6}
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80091a2:	6842      	ldr	r2, [r0, #4]
 80091a4:	6806      	ldr	r6, [r0, #0]
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 80091a6:	4d06      	ldr	r5, [pc, #24]	; (80091c0 <ADC_CommonInit+0x20>)
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80091a8:	6884      	ldr	r4, [r0, #8]
 80091aa:	68c1      	ldr	r1, [r0, #12]
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 80091ac:	4b05      	ldr	r3, [pc, #20]	; (80091c4 <ADC_CommonInit+0x24>)
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 80091ae:	6868      	ldr	r0, [r5, #4]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80091b0:	4332      	orrs	r2, r6
 80091b2:	4322      	orrs	r2, r4
 80091b4:	430a      	orrs	r2, r1
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 80091b6:	4003      	ands	r3, r0
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80091b8:	4313      	orrs	r3, r2
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 80091ba:	606b      	str	r3, [r5, #4]
}
 80091bc:	bc70      	pop	{r4, r5, r6}
 80091be:	4770      	bx	lr
 80091c0:	40012300 	.word	0x40012300
 80091c4:	fffc30e0 	.word	0xfffc30e0

080091c8 <ADC_Cmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 80091c8:	6883      	ldr	r3, [r0, #8]
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80091ca:	b919      	cbnz	r1, 80091d4 <ADC_Cmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 80091cc:	f023 0301 	bic.w	r3, r3, #1
 80091d0:	6083      	str	r3, [r0, #8]
 80091d2:	4770      	bx	lr
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 80091d4:	f043 0301 	orr.w	r3, r3, #1
 80091d8:	6083      	str	r3, [r0, #8]
 80091da:	4770      	bx	lr

080091dc <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80091dc:	2909      	cmp	r1, #9
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80091de:	b470      	push	{r4, r5, r6}
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80091e0:	d91d      	bls.n	800921e <ADC_RegularChannelConfig+0x42>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 80091e2:	f1a1 060a 	sub.w	r6, r1, #10
 80091e6:	eb06 0646 	add.w	r6, r6, r6, lsl #1
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 80091ea:	68c5      	ldr	r5, [r0, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80091ec:	2407      	movs	r4, #7
 80091ee:	40b4      	lsls	r4, r6
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 80091f0:	40b3      	lsls	r3, r6
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80091f2:	ea25 0404 	bic.w	r4, r5, r4
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 80091f6:	4323      	orrs	r3, r4
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 80091f8:	2a06      	cmp	r2, #6
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 80091fa:	60c3      	str	r3, [r0, #12]
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 80091fc:	d91b      	bls.n	8009236 <ADC_RegularChannelConfig+0x5a>
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 80091fe:	2a0c      	cmp	r2, #12
 8009200:	d927      	bls.n	8009252 <ADC_RegularChannelConfig+0x76>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 8009202:	3a0d      	subs	r2, #13
 8009204:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8009208:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 800920a:	241f      	movs	r4, #31
 800920c:	4094      	lsls	r4, r2
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800920e:	fa01 f202 	lsl.w	r2, r1, r2
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8009212:	ea23 0104 	bic.w	r1, r3, r4
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8009216:	430a      	orrs	r2, r1
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8009218:	62c2      	str	r2, [r0, #44]	; 0x2c
  }
}
 800921a:	bc70      	pop	{r4, r5, r6}
 800921c:	4770      	bx	lr
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 800921e:	eb01 0641 	add.w	r6, r1, r1, lsl #1
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8009222:	6905      	ldr	r5, [r0, #16]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8009224:	2407      	movs	r4, #7
 8009226:	40b4      	lsls	r4, r6
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8009228:	40b3      	lsls	r3, r6
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800922a:	ea25 0404 	bic.w	r4, r5, r4
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 800922e:	4323      	orrs	r3, r4
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8009230:	2a06      	cmp	r2, #6
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8009232:	6103      	str	r3, [r0, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8009234:	d8e3      	bhi.n	80091fe <ADC_RegularChannelConfig+0x22>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 8009236:	3a01      	subs	r2, #1
 8009238:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 800923c:	6b43      	ldr	r3, [r0, #52]	; 0x34
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 800923e:	241f      	movs	r4, #31
 8009240:	4094      	lsls	r4, r2
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8009242:	fa01 f202 	lsl.w	r2, r1, r2
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8009246:	ea23 0104 	bic.w	r1, r3, r4
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800924a:	430a      	orrs	r2, r1
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 800924c:	6342      	str	r2, [r0, #52]	; 0x34
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 800924e:	bc70      	pop	{r4, r5, r6}
 8009250:	4770      	bx	lr
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8009252:	3a07      	subs	r2, #7
 8009254:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8009258:	6b03      	ldr	r3, [r0, #48]	; 0x30
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 800925a:	241f      	movs	r4, #31
 800925c:	4094      	lsls	r4, r2
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800925e:	fa01 f202 	lsl.w	r2, r1, r2
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8009262:	ea23 0104 	bic.w	r1, r3, r4
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8009266:	430a      	orrs	r2, r1
    
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8009268:	6302      	str	r2, [r0, #48]	; 0x30
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 800926a:	bc70      	pop	{r4, r5, r6}
 800926c:	4770      	bx	lr
 800926e:	bf00      	nop

08009270 <ADC_SoftwareStartConv>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8009270:	6883      	ldr	r3, [r0, #8]
 8009272:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8009276:	6083      	str	r3, [r0, #8]
 8009278:	4770      	bx	lr
 800927a:	bf00      	nop

0800927c <ADC_GetConversionValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 800927c:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
 800927e:	b280      	uxth	r0, r0
 8009280:	4770      	bx	lr
 8009282:	bf00      	nop

08009284 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8009284:	7983      	ldrb	r3, [r0, #6]
 8009286:	b333      	cbz	r3, 80092d6 <EXTI_Init+0x52>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8009288:	4b1c      	ldr	r3, [pc, #112]	; (80092fc <EXTI_Init+0x78>)
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800928a:	7902      	ldrb	r2, [r0, #4]
    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800928c:	7941      	ldrb	r1, [r0, #5]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800928e:	b4f0      	push	{r4, r5, r6, r7}
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8009290:	6807      	ldr	r7, [r0, #0]
 8009292:	681e      	ldr	r6, [r3, #0]
 8009294:	43fc      	mvns	r4, r7
 8009296:	4026      	ands	r6, r4
 8009298:	601e      	str	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 800929a:	685d      	ldr	r5, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800929c:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80092a0:	4025      	ands	r5, r4
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80092a2:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80092a6:	605d      	str	r5, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80092a8:	6814      	ldr	r4, [r2, #0]
 80092aa:	433c      	orrs	r4, r7
 80092ac:	6014      	str	r4, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 80092ae:	6804      	ldr	r4, [r0, #0]
 80092b0:	6898      	ldr	r0, [r3, #8]
 80092b2:	43e5      	mvns	r5, r4
 80092b4:	4028      	ands	r0, r5
 80092b6:	6098      	str	r0, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80092b8:	68da      	ldr	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80092ba:	2910      	cmp	r1, #16

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80092bc:	ea02 0205 	and.w	r2, r2, r5
 80092c0:	60da      	str	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80092c2:	d013      	beq.n	80092ec <EXTI_Init+0x68>
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80092c4:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 80092c8:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
 80092cc:	681a      	ldr	r2, [r3, #0]
 80092ce:	4314      	orrs	r4, r2
 80092d0:	601c      	str	r4, [r3, #0]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 80092d2:	bcf0      	pop	{r4, r5, r6, r7}
 80092d4:	4770      	bx	lr
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80092d6:	7903      	ldrb	r3, [r0, #4]
 80092d8:	6801      	ldr	r1, [r0, #0]
 80092da:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80092de:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
 80092e2:	681a      	ldr	r2, [r3, #0]
 80092e4:	ea22 0201 	bic.w	r2, r2, r1
 80092e8:	601a      	str	r2, [r3, #0]
  }
}
 80092ea:	4770      	bx	lr
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 80092ec:	689a      	ldr	r2, [r3, #8]
 80092ee:	4322      	orrs	r2, r4
 80092f0:	609a      	str	r2, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 80092f2:	68da      	ldr	r2, [r3, #12]
 80092f4:	4314      	orrs	r4, r2
 80092f6:	60dc      	str	r4, [r3, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 80092f8:	bcf0      	pop	{r4, r5, r6, r7}
 80092fa:	4770      	bx	lr
 80092fc:	40013c00 	.word	0x40013c00

08009300 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8009300:	4b05      	ldr	r3, [pc, #20]	; (8009318 <EXTI_GetITStatus+0x18>)
 8009302:	681a      	ldr	r2, [r3, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8009304:	695b      	ldr	r3, [r3, #20]
 8009306:	4003      	ands	r3, r0
 8009308:	d004      	beq.n	8009314 <EXTI_GetITStatus+0x14>
  {
    bitstatus = SET;
 800930a:	4202      	tst	r2, r0
 800930c:	bf14      	ite	ne
 800930e:	2001      	movne	r0, #1
 8009310:	2000      	moveq	r0, #0
 8009312:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 8009314:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 8009316:	4770      	bx	lr
 8009318:	40013c00 	.word	0x40013c00

0800931c <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 800931c:	4b01      	ldr	r3, [pc, #4]	; (8009324 <EXTI_ClearITPendingBit+0x8>)
 800931e:	6158      	str	r0, [r3, #20]
 8009320:	4770      	bx	lr
 8009322:	bf00      	nop
 8009324:	40013c00 	.word	0x40013c00

08009328 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8009328:	2200      	movs	r2, #0
 800932a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800932e:	4613      	mov	r3, r2
 8009330:	f8d1 e000 	ldr.w	lr, [r1]
  {
    pos = ((uint32_t)0x01) << pinpos;
 8009334:	2701      	movs	r7, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8009336:	f04f 0c03 	mov.w	ip, #3
 800933a:	e004      	b.n	8009346 <GPIO_Init+0x1e>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800933c:	3301      	adds	r3, #1
 800933e:	2b10      	cmp	r3, #16
 8009340:	f102 0202 	add.w	r2, r2, #2
 8009344:	d029      	beq.n	800939a <GPIO_Init+0x72>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8009346:	fa07 f403 	lsl.w	r4, r7, r3
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 800934a:	ea34 050e 	bics.w	r5, r4, lr
 800934e:	d1f5      	bne.n	800933c <GPIO_Init+0x14>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8009350:	f8d0 8000 	ldr.w	r8, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8009354:	790e      	ldrb	r6, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8009356:	fa0c f502 	lsl.w	r5, ip, r2
 800935a:	43ed      	mvns	r5, r5
 800935c:	ea08 0805 	and.w	r8, r8, r5
 8009360:	f8c0 8000 	str.w	r8, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8009364:	f8d0 9000 	ldr.w	r9, [r0]
 8009368:	fa06 fa02 	lsl.w	sl, r6, r2

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800936c:	3e01      	subs	r6, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800936e:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8009372:	2e01      	cmp	r6, #1
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8009374:	fa0c f802 	lsl.w	r8, ip, r2
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8009378:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800937c:	d90f      	bls.n	800939e <GPIO_Init+0x76>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800937e:	68c5      	ldr	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8009380:	79cc      	ldrb	r4, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8009382:	ea25 0508 	bic.w	r5, r5, r8
 8009386:	60c5      	str	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8009388:	68c5      	ldr	r5, [r0, #12]
 800938a:	4094      	lsls	r4, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800938c:	3301      	adds	r3, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800938e:	432c      	orrs	r4, r5
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8009390:	2b10      	cmp	r3, #16
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8009392:	60c4      	str	r4, [r0, #12]
 8009394:	f102 0202 	add.w	r2, r2, #2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8009398:	d1d5      	bne.n	8009346 <GPIO_Init+0x1e>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 800939a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800939e:	6886      	ldr	r6, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80093a0:	f891 9005 	ldrb.w	r9, [r1, #5]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80093a4:	4035      	ands	r5, r6
 80093a6:	6085      	str	r5, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80093a8:	6886      	ldr	r6, [r0, #8]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80093aa:	798d      	ldrb	r5, [r1, #6]
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80093ac:	fa09 f902 	lsl.w	r9, r9, r2
 80093b0:	ea49 0606 	orr.w	r6, r9, r6
 80093b4:	6086      	str	r6, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 80093b6:	6846      	ldr	r6, [r0, #4]
 80093b8:	ea26 0404 	bic.w	r4, r6, r4
 80093bc:	6044      	str	r4, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80093be:	6846      	ldr	r6, [r0, #4]
 80093c0:	fa05 f403 	lsl.w	r4, r5, r3
 80093c4:	b2a4      	uxth	r4, r4
 80093c6:	4334      	orrs	r4, r6
 80093c8:	6044      	str	r4, [r0, #4]
 80093ca:	e7d8      	b.n	800937e <GPIO_Init+0x56>

080093cc <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13 
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 80093cc:	08cb      	lsrs	r3, r1, #3
 80093ce:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80093d2:	f001 0107 	and.w	r1, r1, #7
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13 
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 80093d6:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80093d8:	0089      	lsls	r1, r1, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80093da:	6a04      	ldr	r4, [r0, #32]
 80093dc:	230f      	movs	r3, #15
 80093de:	408b      	lsls	r3, r1
 80093e0:	ea24 0303 	bic.w	r3, r4, r3
 80093e4:	6203      	str	r3, [r0, #32]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80093e6:	6a03      	ldr	r3, [r0, #32]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
}
 80093e8:	f85d 4b04 	ldr.w	r4, [sp], #4
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80093ec:	408a      	lsls	r2, r1
 80093ee:	ea42 0103 	orr.w	r1, r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 80093f2:	6201      	str	r1, [r0, #32]
}
 80093f4:	4770      	bx	lr
 80093f6:	bf00      	nop

080093f8 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 80093f8:	b410      	push	{r4}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80093fa:	4c21      	ldr	r4, [pc, #132]	; (8009480 <RCC_GetClocksFreq+0x88>)
 80093fc:	68a3      	ldr	r3, [r4, #8]

  switch (tmp)
 80093fe:	f003 030c 	and.w	r3, r3, #12
 8009402:	2b04      	cmp	r3, #4
 8009404:	d01b      	beq.n	800943e <RCC_GetClocksFreq+0x46>
 8009406:	2b08      	cmp	r3, #8
 8009408:	d01c      	beq.n	8009444 <RCC_GetClocksFreq+0x4c>

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 800940a:	4b1e      	ldr	r3, [pc, #120]	; (8009484 <RCC_GetClocksFreq+0x8c>)
 800940c:	6003      	str	r3, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 800940e:	4a1c      	ldr	r2, [pc, #112]	; (8009480 <RCC_GetClocksFreq+0x88>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8009410:	491d      	ldr	r1, [pc, #116]	; (8009488 <RCC_GetClocksFreq+0x90>)
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8009412:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 4;
 8009414:	f3c4 1403 	ubfx	r4, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 8009418:	5d0c      	ldrb	r4, [r1, r4]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800941a:	40e3      	lsrs	r3, r4
 800941c:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 800941e:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 10;
 8009420:	f3c4 2482 	ubfx	r4, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 8009424:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8009426:	fa23 f404 	lsr.w	r4, r3, r4
 800942a:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 800942c:	6892      	ldr	r2, [r2, #8]
  tmp = tmp >> 13;
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
}
 800942e:	f85d 4b04 	ldr.w	r4, [sp], #4
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
  tmp = tmp >> 13;
 8009432:	f3c2 3242 	ubfx	r2, r2, #13, #3
  presc = APBAHBPrescTable[tmp];
 8009436:	5c8a      	ldrb	r2, [r1, r2]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8009438:	40d3      	lsrs	r3, r2
 800943a:	60c3      	str	r3, [r0, #12]
}
 800943c:	4770      	bx	lr
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800943e:	4b13      	ldr	r3, [pc, #76]	; (800948c <RCC_GetClocksFreq+0x94>)
 8009440:	6003      	str	r3, [r0, #0]
      break;
 8009442:	e7e4      	b.n	800940e <RCC_GetClocksFreq+0x16>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8009444:	6863      	ldr	r3, [r4, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8009446:	6861      	ldr	r1, [r4, #4]
      
      if (pllsource != 0)
 8009448:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800944c:	6863      	ldr	r3, [r4, #4]
 800944e:	bf18      	it	ne
 8009450:	4c0e      	ldrne	r4, [pc, #56]	; (800948c <RCC_GetClocksFreq+0x94>)

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8009452:	f001 023f 	and.w	r2, r1, #63	; 0x3f
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8009456:	bf0c      	ite	eq
 8009458:	490a      	ldreq	r1, [pc, #40]	; (8009484 <RCC_GetClocksFreq+0x8c>)
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800945a:	fbb4 f1f2 	udivne	r1, r4, r2
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800945e:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8009462:	bf08      	it	eq
 8009464:	fbb1 f1f2 	udiveq	r1, r1, r2
 8009468:	fb01 f203 	mul.w	r2, r1, r3
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800946c:	4b04      	ldr	r3, [pc, #16]	; (8009480 <RCC_GetClocksFreq+0x88>)
 800946e:	685b      	ldr	r3, [r3, #4]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8009470:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8009474:	3301      	adds	r3, #1
 8009476:	005b      	lsls	r3, r3, #1
 8009478:	fbb2 f3f3 	udiv	r3, r2, r3
 800947c:	6003      	str	r3, [r0, #0]
      break;
 800947e:	e7c6      	b.n	800940e <RCC_GetClocksFreq+0x16>
 8009480:	40023800 	.word	0x40023800
 8009484:	00f42400 	.word	0x00f42400
 8009488:	2000000c 	.word	0x2000000c
 800948c:	017d7840 	.word	0x017d7840

08009490 <RCC_AHB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009490:	b929      	cbnz	r1, 800949e <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8009492:	4a05      	ldr	r2, [pc, #20]	; (80094a8 <RCC_AHB1PeriphClockCmd+0x18>)
 8009494:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009496:	ea23 0000 	bic.w	r0, r3, r0
 800949a:	6310      	str	r0, [r2, #48]	; 0x30
 800949c:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 800949e:	4b02      	ldr	r3, [pc, #8]	; (80094a8 <RCC_AHB1PeriphClockCmd+0x18>)
 80094a0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80094a2:	4310      	orrs	r0, r2
 80094a4:	6318      	str	r0, [r3, #48]	; 0x30
 80094a6:	4770      	bx	lr
 80094a8:	40023800 	.word	0x40023800

080094ac <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80094ac:	b929      	cbnz	r1, 80094ba <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80094ae:	4a05      	ldr	r2, [pc, #20]	; (80094c4 <RCC_APB1PeriphClockCmd+0x18>)
 80094b0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80094b2:	ea23 0000 	bic.w	r0, r3, r0
 80094b6:	6410      	str	r0, [r2, #64]	; 0x40
 80094b8:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80094ba:	4b02      	ldr	r3, [pc, #8]	; (80094c4 <RCC_APB1PeriphClockCmd+0x18>)
 80094bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80094be:	4310      	orrs	r0, r2
 80094c0:	6418      	str	r0, [r3, #64]	; 0x40
 80094c2:	4770      	bx	lr
 80094c4:	40023800 	.word	0x40023800

080094c8 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80094c8:	b929      	cbnz	r1, 80094d6 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80094ca:	4a05      	ldr	r2, [pc, #20]	; (80094e0 <RCC_APB2PeriphClockCmd+0x18>)
 80094cc:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80094ce:	ea23 0000 	bic.w	r0, r3, r0
 80094d2:	6450      	str	r0, [r2, #68]	; 0x44
 80094d4:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80094d6:	4b02      	ldr	r3, [pc, #8]	; (80094e0 <RCC_APB2PeriphClockCmd+0x18>)
 80094d8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80094da:	4310      	orrs	r0, r2
 80094dc:	6458      	str	r0, [r3, #68]	; 0x44
 80094de:	4770      	bx	lr
 80094e0:	40023800 	.word	0x40023800

080094e4 <RCC_AHB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80094e4:	b929      	cbnz	r1, 80094f2 <RCC_AHB1PeriphResetCmd+0xe>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 80094e6:	4a05      	ldr	r2, [pc, #20]	; (80094fc <RCC_AHB1PeriphResetCmd+0x18>)
 80094e8:	6913      	ldr	r3, [r2, #16]
 80094ea:	ea23 0000 	bic.w	r0, r3, r0
 80094ee:	6110      	str	r0, [r2, #16]
 80094f0:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 80094f2:	4b02      	ldr	r3, [pc, #8]	; (80094fc <RCC_AHB1PeriphResetCmd+0x18>)
 80094f4:	691a      	ldr	r2, [r3, #16]
 80094f6:	4310      	orrs	r0, r2
 80094f8:	6118      	str	r0, [r3, #16]
 80094fa:	4770      	bx	lr
 80094fc:	40023800 	.word	0x40023800

08009500 <SYSCFG_EXTILineConfig>:
  *           and STM32F427x/STM32F437x devices. 
  *             
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 8009500:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8009504:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8009508:	f503 339c 	add.w	r3, r3, #79872	; 0x13800

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 800950c:	f001 0103 	and.w	r1, r1, #3
  *           and STM32F427x/STM32F437x devices. 
  *             
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 8009510:	b410      	push	{r4}

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 8009512:	0089      	lsls	r1, r1, #2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 8009514:	689c      	ldr	r4, [r3, #8]
 8009516:	220f      	movs	r2, #15
 8009518:	408a      	lsls	r2, r1
 800951a:	ea24 0202 	bic.w	r2, r4, r2
 800951e:	609a      	str	r2, [r3, #8]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8009520:	689a      	ldr	r2, [r3, #8]
}
 8009522:	f85d 4b04 	ldr.w	r4, [sp], #4
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8009526:	4088      	lsls	r0, r1
 8009528:	4310      	orrs	r0, r2
 800952a:	6098      	str	r0, [r3, #8]
}
 800952c:	4770      	bx	lr
 800952e:	bf00      	nop

08009530 <SYSCFG_ETH_MediaInterfaceConfig>:
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 8009530:	4b01      	ldr	r3, [pc, #4]	; (8009538 <SYSCFG_ETH_MediaInterfaceConfig+0x8>)
 8009532:	6018      	str	r0, [r3, #0]
 8009534:	4770      	bx	lr
 8009536:	bf00      	nop
 8009538:	422700dc 	.word	0x422700dc

0800953c <USART_Init>:
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 800953c:	8a02      	ldrh	r2, [r0, #16]
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 800953e:	890b      	ldrh	r3, [r1, #8]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8009540:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8009542:	b292      	uxth	r2, r2
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8009544:	88cf      	ldrh	r7, [r1, #6]
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8009546:	888e      	ldrh	r6, [r1, #4]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8009548:	4604      	mov	r4, r0

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 800954a:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 800954e:	433a      	orrs	r2, r7
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8009550:	8948      	ldrh	r0, [r1, #10]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8009552:	460d      	mov	r5, r1
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8009554:	8989      	ldrh	r1, [r1, #12]
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8009556:	8222      	strh	r2, [r4, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8009558:	89a2      	ldrh	r2, [r4, #12]
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 800955a:	4333      	orrs	r3, r6
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 800955c:	b292      	uxth	r2, r2
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 800955e:	4303      	orrs	r3, r0

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8009560:	f422 52b0 	bic.w	r2, r2, #5632	; 0x1600
 8009564:	f022 020c 	bic.w	r2, r2, #12
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8009568:	b29b      	uxth	r3, r3
 800956a:	4313      	orrs	r3, r2
 800956c:	81a3      	strh	r3, [r4, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 800956e:	8aa3      	ldrh	r3, [r4, #20]
 8009570:	b29b      	uxth	r3, r3

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 8009572:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8009576:	430b      	orrs	r3, r1
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8009578:	b085      	sub	sp, #20
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 800957a:	82a3      	strh	r3, [r4, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 800957c:	4668      	mov	r0, sp
 800957e:	f7ff ff3b 	bl	80093f8 <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 8009582:	4b1d      	ldr	r3, [pc, #116]	; (80095f8 <USART_Init+0xbc>)
 8009584:	429c      	cmp	r4, r3
 8009586:	d028      	beq.n	80095da <USART_Init+0x9e>
 8009588:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800958c:	429c      	cmp	r4, r3
 800958e:	d024      	beq.n	80095da <USART_Init+0x9e>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8009590:	9a02      	ldr	r2, [sp, #8]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8009592:	89a3      	ldrh	r3, [r4, #12]

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8009594:	89a1      	ldrh	r1, [r4, #12]
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8009596:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 800959a:	682b      	ldr	r3, [r5, #0]
 800959c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80095a0:	bf14      	ite	ne
 80095a2:	005b      	lslne	r3, r3, #1
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 80095a4:	009b      	lsleq	r3, r3, #2
 80095a6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80095aa:	fbb2 f0f3 	udiv	r0, r2, r3
  }
  tmpreg = (integerdivider / 100) << 4;
 80095ae:	4a13      	ldr	r2, [pc, #76]	; (80095fc <USART_Init+0xc0>)
 80095b0:	fba2 3500 	umull	r3, r5, r2, r0
 80095b4:	096d      	lsrs	r5, r5, #5

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 80095b6:	2364      	movs	r3, #100	; 0x64

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80095b8:	0409      	lsls	r1, r1, #16
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 80095ba:	fb05 0313 	mls	r3, r5, r3, r0
 80095be:	ea4f 1505 	mov.w	r5, r5, lsl #4

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80095c2:	d40c      	bmi.n	80095de <USART_Init+0xa2>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 80095c4:	011b      	lsls	r3, r3, #4
 80095c6:	3332      	adds	r3, #50	; 0x32
 80095c8:	fba2 2303 	umull	r2, r3, r2, r3
 80095cc:	f3c3 1343 	ubfx	r3, r3, #5, #4
 80095d0:	432b      	orrs	r3, r5
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 80095d2:	b29b      	uxth	r3, r3
 80095d4:	8123      	strh	r3, [r4, #8]
}
 80095d6:	b005      	add	sp, #20
 80095d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);

  if ((USARTx == USART1) || (USARTx == USART6))
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 80095da:	9a03      	ldr	r2, [sp, #12]
 80095dc:	e7d9      	b.n	8009592 <USART_Init+0x56>
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 80095de:	00d9      	lsls	r1, r3, #3
 80095e0:	3132      	adds	r1, #50	; 0x32
 80095e2:	fba2 3101 	umull	r3, r1, r2, r1
 80095e6:	f3c1 1242 	ubfx	r2, r1, #5, #3
 80095ea:	ea42 0305 	orr.w	r3, r2, r5
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 80095ee:	b29b      	uxth	r3, r3
 80095f0:	8123      	strh	r3, [r4, #8]
}
 80095f2:	b005      	add	sp, #20
 80095f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80095f6:	bf00      	nop
 80095f8:	40011000 	.word	0x40011000
 80095fc:	51eb851f 	.word	0x51eb851f

08009600 <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8009600:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8009602:	b929      	cbnz	r1, 8009610 <USART_Cmd+0x10>
    USARTx->CR1 |= USART_CR1_UE;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8009604:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009608:	041b      	lsls	r3, r3, #16
 800960a:	0c1b      	lsrs	r3, r3, #16
 800960c:	8183      	strh	r3, [r0, #12]
 800960e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8009610:	b29b      	uxth	r3, r3
 8009612:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009616:	8183      	strh	r3, [r0, #12]
 8009618:	4770      	bx	lr
 800961a:	bf00      	nop

0800961c <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 800961c:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8009620:	8081      	strh	r1, [r0, #4]
 8009622:	4770      	bx	lr

08009624 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8009624:	b410      	push	{r4}
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 8009626:	f001 041f 	and.w	r4, r1, #31
  } 
    
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 800962a:	f3c1 1142 	ubfx	r1, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 800962e:	2301      	movs	r3, #1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8009630:	2901      	cmp	r1, #1
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 8009632:	fa03 f304 	lsl.w	r3, r3, r4
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8009636:	d011      	beq.n	800965c <USART_ITConfig+0x38>
  {
    usartxbase += 0x0C;
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8009638:	2902      	cmp	r1, #2
  {
    usartxbase += 0x10;
 800963a:	bf0c      	ite	eq
 800963c:	3010      	addeq	r0, #16
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 800963e:	3014      	addne	r0, #20
  }
  if (NewState != DISABLE)
 8009640:	b932      	cbnz	r2, 8009650 <USART_ITConfig+0x2c>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8009642:	6802      	ldr	r2, [r0, #0]
  }
}
 8009644:	f85d 4b04 	ldr.w	r4, [sp], #4
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8009648:	ea22 0303 	bic.w	r3, r2, r3
 800964c:	6003      	str	r3, [r0, #0]
  }
}
 800964e:	4770      	bx	lr
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8009650:	6802      	ldr	r2, [r0, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 8009652:	f85d 4b04 	ldr.w	r4, [sp], #4
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8009656:	4313      	orrs	r3, r2
 8009658:	6003      	str	r3, [r0, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 800965a:	4770      	bx	lr
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
  {
    usartxbase += 0x0C;
 800965c:	300c      	adds	r0, #12
 800965e:	e7ef      	b.n	8009640 <USART_ITConfig+0x1c>

08009660 <USART_GetFlagStatus>:
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8009660:	8803      	ldrh	r3, [r0, #0]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8009662:	4219      	tst	r1, r3
}
 8009664:	bf14      	ite	ne
 8009666:	2001      	movne	r0, #1
 8009668:	2000      	moveq	r0, #0
 800966a:	4770      	bx	lr

0800966c <LCD_SetTextColor>:
  * @brief  Sets the Text color.
  * @param  Color: specifies the Text color code RGB(5-6-5).
  * @retval None
  */
void LCD_SetTextColor(__IO uint16_t Color)
{
 800966c:	b082      	sub	sp, #8
  TextColor = Color;
 800966e:	4a04      	ldr	r2, [pc, #16]	; (8009680 <LCD_SetTextColor+0x14>)
  * @brief  Sets the Text color.
  * @param  Color: specifies the Text color code RGB(5-6-5).
  * @retval None
  */
void LCD_SetTextColor(__IO uint16_t Color)
{
 8009670:	f8ad 0006 	strh.w	r0, [sp, #6]
  TextColor = Color;
 8009674:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009678:	b29b      	uxth	r3, r3
 800967a:	8013      	strh	r3, [r2, #0]
}
 800967c:	b002      	add	sp, #8
 800967e:	4770      	bx	lr
 8009680:	20002a74 	.word	0x20002a74

08009684 <LCD_GetFont>:
  * @param  None.
  * @retval the used font.
  */
sFONT *LCD_GetFont(void)
{
  return LCD_Currentfonts;
 8009684:	4b01      	ldr	r3, [pc, #4]	; (800968c <LCD_GetFont+0x8>)
}
 8009686:	6818      	ldr	r0, [r3, #0]
 8009688:	4770      	bx	lr
 800968a:	bf00      	nop
 800968c:	20002a78 	.word	0x20002a78

08009690 <LCD_ClearLine>:
  *   This parameter can be one of the following values:
  *     @arg Linex: where x can be 0..n
  * @retval None
  */
void LCD_ClearLine(uint16_t Line)
{
 8009690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;
  /* Send the string character by character on lCD */
  while (((refcolumn + 1)& 0xFFFF) >= LCD_Currentfonts->Width)
 8009694:	4b3e      	ldr	r3, [pc, #248]	; (8009790 <LCD_ClearLine+0x100>)
 8009696:	681a      	ldr	r2, [r3, #0]
 8009698:	8891      	ldrh	r1, [r2, #4]
  *   This parameter can be one of the following values:
  *     @arg Linex: where x can be 0..n
  * @retval None
  */
void LCD_ClearLine(uint16_t Line)
{
 800969a:	b085      	sub	sp, #20
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;
  /* Send the string character by character on lCD */
  while (((refcolumn + 1)& 0xFFFF) >= LCD_Currentfonts->Width)
 800969c:	f5b1 7fa0 	cmp.w	r1, #320	; 0x140
  *   This parameter can be one of the following values:
  *     @arg Linex: where x can be 0..n
  * @retval None
  */
void LCD_ClearLine(uint16_t Line)
{
 80096a0:	9002      	str	r0, [sp, #8]
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;
  /* Send the string character by character on lCD */
  while (((refcolumn + 1)& 0xFFFF) >= LCD_Currentfonts->Width)
 80096a2:	dc63      	bgt.n	800976c <LCD_ClearLine+0xdc>
 80096a4:	4b3b      	ldr	r3, [pc, #236]	; (8009794 <LCD_ClearLine+0x104>)
 80096a6:	6810      	ldr	r0, [r2, #0]
 80096a8:	88d2      	ldrh	r2, [r2, #6]
 80096aa:	9200      	str	r2, [sp, #0]
 80096ac:	fba3 2301 	umull	r2, r3, r3, r1
 80096b0:	08db      	lsrs	r3, r3, #3
 80096b2:	00db      	lsls	r3, r3, #3
 80096b4:	2680      	movs	r6, #128	; 0x80
      {
        LCD_WriteRAM(BackColor);
      }
      else
      {
        LCD_WriteRAM(TextColor);
 80096b6:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 8009798 <LCD_ClearLine+0x108>
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
        (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))

      {
        LCD_WriteRAM(BackColor);
 80096ba:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 800979c <LCD_ClearLine+0x10c>
 80096be:	9003      	str	r0, [sp, #12]
 80096c0:	409e      	lsls	r6, r3
  */
void LCD_ClearLine(uint16_t Line)
{
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;
  /* Send the string character by character on lCD */
  while (((refcolumn + 1)& 0xFFFF) >= LCD_Currentfonts->Width)
 80096c2:	f240 1b3f 	movw	fp, #319	; 0x13f
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 80096c6:	f04f 43d0 	mov.w	r3, #1744830464	; 0x68000000
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 80096ca:	f8bd 0008 	ldrh.w	r0, [sp, #8]
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 80096ce:	f04f 0a20 	mov.w	sl, #32
 80096d2:	f8a3 a000 	strh.w	sl, [r3]
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 80096d6:	8058      	strh	r0, [r3, #2]
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 80096d8:	9800      	ldr	r0, [sp, #0]
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 80096da:	2221      	movs	r2, #33	; 0x21
 80096dc:	801a      	strh	r2, [r3, #0]
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 80096de:	f8a3 b002 	strh.w	fp, [r3, #2]
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 80096e2:	2800      	cmp	r0, #0
 80096e4:	d039      	beq.n	800975a <LCD_ClearLine+0xca>
 80096e6:	9803      	ldr	r0, [sp, #12]
 80096e8:	9d02      	ldr	r5, [sp, #8]
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 80096ea:	9201      	str	r2, [sp, #4]
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 80096ec:	f04f 0e00 	mov.w	lr, #0
  * @param  None
  * @retval None
  */
void LCD_WriteRAM_Prepare(void)
{
  LCD->LCD_REG = LCD_REG_34;
 80096f0:	f04f 0222 	mov.w	r2, #34	; 0x22
 80096f4:	801a      	strh	r2, [r3, #0]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 80096f6:	b1f9      	cbz	r1, 8009738 <LCD_ClearLine+0xa8>
 80096f8:	290c      	cmp	r1, #12
 80096fa:	f04f 0200 	mov.w	r2, #0
 80096fe:	d938      	bls.n	8009772 <LCD_ClearLine+0xe2>
 8009700:	e009      	b.n	8009716 <LCD_ClearLine+0x86>
    {
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
 8009702:	f018 0f01 	tst.w	r8, #1
 8009706:	d110      	bne.n	800972a <LCD_ClearLine+0x9a>
        (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))

      {
        LCD_WriteRAM(BackColor);
 8009708:	f8b9 4000 	ldrh.w	r4, [r9]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 800970c:	3201      	adds	r2, #1
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
        (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))

      {
        LCD_WriteRAM(BackColor);
 800970e:	b2a4      	uxth	r4, r4
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009710:	4291      	cmp	r1, r2
  * @retval None
  */
void LCD_WriteRAM(uint16_t RGB_Code)
{
  /* Write 16-bit GRAM Reg */
  LCD->LCD_RAM = RGB_Code;
 8009712:	805c      	strh	r4, [r3, #2]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009714:	d010      	beq.n	8009738 <LCD_ClearLine+0xa8>
    {
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
 8009716:	8804      	ldrh	r4, [r0, #0]
 8009718:	fa46 f702 	asr.w	r7, r6, r2
 800971c:	4227      	tst	r7, r4
 800971e:	fa44 f802 	asr.w	r8, r4, r2
 8009722:	d0ee      	beq.n	8009702 <LCD_ClearLine+0x72>
 8009724:	4114      	asrs	r4, r2
 8009726:	07e4      	lsls	r4, r4, #31
 8009728:	d5ee      	bpl.n	8009708 <LCD_ClearLine+0x78>
      {
        LCD_WriteRAM(BackColor);
      }
      else
      {
        LCD_WriteRAM(TextColor);
 800972a:	f8bc 4000 	ldrh.w	r4, [ip]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 800972e:	3201      	adds	r2, #1
      {
        LCD_WriteRAM(BackColor);
      }
      else
      {
        LCD_WriteRAM(TextColor);
 8009730:	b2a4      	uxth	r4, r4
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009732:	4291      	cmp	r1, r2
  * @retval None
  */
void LCD_WriteRAM(uint16_t RGB_Code)
{
  /* Write 16-bit GRAM Reg */
  LCD->LCD_RAM = RGB_Code;
 8009734:	805c      	strh	r4, [r3, #2]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009736:	d1ee      	bne.n	8009716 <LCD_ClearLine+0x86>
      else
      {
        LCD_WriteRAM(TextColor);
      } 
    }
    Xaddress++;
 8009738:	3501      	adds	r5, #1
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 800973a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 800973e:	f8a3 a000 	strh.w	sl, [r3]
      else
      {
        LCD_WriteRAM(TextColor);
      } 
    }
    Xaddress++;
 8009742:	b2ad      	uxth	r5, r5
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 8009744:	805d      	strh	r5, [r3, #2]
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 8009746:	801a      	strh	r2, [r3, #0]
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 8009748:	9a00      	ldr	r2, [sp, #0]
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 800974a:	f8a3 b002 	strh.w	fp, [r3, #2]
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 800974e:	f10e 0e01 	add.w	lr, lr, #1
 8009752:	4572      	cmp	r2, lr
 8009754:	f100 0002 	add.w	r0, r0, #2
 8009758:	d1ca      	bne.n	80096f0 <LCD_ClearLine+0x60>
  while (((refcolumn + 1)& 0xFFFF) >= LCD_Currentfonts->Width)
  {
    /* Display one character on LCD */
    LCD_DisplayChar(Line, refcolumn, ' ');
    /* Decrement the column position by 16 */
    refcolumn -= LCD_Currentfonts->Width;
 800975a:	ebc1 0b0b 	rsb	fp, r1, fp
 800975e:	fa1f fb8b 	uxth.w	fp, fp
  */
void LCD_ClearLine(uint16_t Line)
{
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;
  /* Send the string character by character on lCD */
  while (((refcolumn + 1)& 0xFFFF) >= LCD_Currentfonts->Width)
 8009762:	f10b 0201 	add.w	r2, fp, #1
 8009766:	b292      	uxth	r2, r2
 8009768:	428a      	cmp	r2, r1
 800976a:	daae      	bge.n	80096ca <LCD_ClearLine+0x3a>
    /* Display one character on LCD */
    LCD_DisplayChar(Line, refcolumn, ' ');
    /* Decrement the column position by 16 */
    refcolumn -= LCD_Currentfonts->Width;
  }
}
 800976c:	b005      	add	sp, #20
 800976e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
    {
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
 8009772:	8807      	ldrh	r7, [r0, #0]
 8009774:	fa46 f402 	asr.w	r4, r6, r2
 8009778:	4227      	tst	r7, r4
        (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))

      {
        LCD_WriteRAM(BackColor);
 800977a:	bf0c      	ite	eq
 800977c:	f8b9 4000 	ldrheq.w	r4, [r9]
      }
      else
      {
        LCD_WriteRAM(TextColor);
 8009780:	f8bc 4000 	ldrhne.w	r4, [ip]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009784:	3201      	adds	r2, #1
      {
        LCD_WriteRAM(BackColor);
      }
      else
      {
        LCD_WriteRAM(TextColor);
 8009786:	b2a4      	uxth	r4, r4
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009788:	4291      	cmp	r1, r2
  * @retval None
  */
void LCD_WriteRAM(uint16_t RGB_Code)
{
  /* Write 16-bit GRAM Reg */
  LCD->LCD_RAM = RGB_Code;
 800978a:	805c      	strh	r4, [r3, #2]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 800978c:	d1f1      	bne.n	8009772 <LCD_ClearLine+0xe2>
 800978e:	e7d3      	b.n	8009738 <LCD_ClearLine+0xa8>
 8009790:	20002a78 	.word	0x20002a78
 8009794:	aaaaaaab 	.word	0xaaaaaaab
 8009798:	20002a74 	.word	0x20002a74
 800979c:	2000001c 	.word	0x2000001c

080097a0 <LCD_DisplayStringLine>:
  *     @arg Linex: where x can be 0..9
  * @param  *ptr: pointer to string to display on LCD.
  * @retval None
  */
void LCD_DisplayStringLine(uint16_t Line, uint8_t *ptr)
{
 80097a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;

  /* Send the string character by character on lCD */
  while ((*ptr != 0) & (((refcolumn + 1) & 0xFFFF) >= LCD_Currentfonts->Width))
 80097a4:	4b46      	ldr	r3, [pc, #280]	; (80098c0 <LCD_DisplayStringLine+0x120>)
 80097a6:	780a      	ldrb	r2, [r1, #0]
  *     @arg Linex: where x can be 0..9
  * @param  *ptr: pointer to string to display on LCD.
  * @retval None
  */
void LCD_DisplayStringLine(uint16_t Line, uint8_t *ptr)
{
 80097a8:	b087      	sub	sp, #28
 80097aa:	9104      	str	r1, [sp, #16]
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;

  /* Send the string character by character on lCD */
  while ((*ptr != 0) & (((refcolumn + 1) & 0xFFFF) >= LCD_Currentfonts->Width))
 80097ac:	6819      	ldr	r1, [r3, #0]
  *     @arg Linex: where x can be 0..9
  * @param  *ptr: pointer to string to display on LCD.
  * @retval None
  */
void LCD_DisplayStringLine(uint16_t Line, uint8_t *ptr)
{
 80097ae:	9003      	str	r0, [sp, #12]
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;

  /* Send the string character by character on lCD */
  while ((*ptr != 0) & (((refcolumn + 1) & 0xFFFF) >= LCD_Currentfonts->Width))
 80097b0:	8888      	ldrh	r0, [r1, #4]
 80097b2:	2a00      	cmp	r2, #0
 80097b4:	d071      	beq.n	800989a <LCD_DisplayStringLine+0xfa>
 80097b6:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
 80097ba:	dc6e      	bgt.n	800989a <LCD_DisplayStringLine+0xfa>
 80097bc:	4b41      	ldr	r3, [pc, #260]	; (80098c4 <LCD_DisplayStringLine+0x124>)
 80097be:	680c      	ldr	r4, [r1, #0]
 80097c0:	9405      	str	r4, [sp, #20]
 80097c2:	fba3 4300 	umull	r4, r3, r3, r0
 80097c6:	88c9      	ldrh	r1, [r1, #6]
      {
        LCD_WriteRAM(BackColor);
      }
      else
      {
        LCD_WriteRAM(TextColor);
 80097c8:	f8df c0fc 	ldr.w	ip, [pc, #252]	; 80098c8 <LCD_DisplayStringLine+0x128>
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
        (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))

      {
        LCD_WriteRAM(BackColor);
 80097cc:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 80098cc <LCD_DisplayStringLine+0x12c>
 80097d0:	08db      	lsrs	r3, r3, #3
 80097d2:	00db      	lsls	r3, r3, #3
 80097d4:	2680      	movs	r6, #128	; 0x80
 80097d6:	409e      	lsls	r6, r3
void LCD_DisplayStringLine(uint16_t Line, uint8_t *ptr)
{
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;

  /* Send the string character by character on lCD */
  while ((*ptr != 0) & (((refcolumn + 1) & 0xFFFF) >= LCD_Currentfonts->Width))
 80097d8:	f240 1b3f 	movw	fp, #319	; 0x13f
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 80097dc:	f04f 43d0 	mov.w	r3, #1744830464	; 0x68000000
 80097e0:	468a      	mov	sl, r1
  * @retval None
  */
void LCD_DisplayChar(uint16_t Line, uint16_t Column, uint8_t Ascii)
{
  Ascii -= 32;
  LCD_DrawChar(Line, Column, &LCD_Currentfonts->table[Ascii * LCD_Currentfonts->Height]);
 80097e2:	3a20      	subs	r2, #32
 80097e4:	b2d2      	uxtb	r2, r2
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 80097e6:	f8bd 500c 	ldrh.w	r5, [sp, #12]
  * @retval None
  */
void LCD_DisplayChar(uint16_t Line, uint16_t Column, uint8_t Ascii)
{
  Ascii -= 32;
  LCD_DrawChar(Line, Column, &LCD_Currentfonts->table[Ascii * LCD_Currentfonts->Height]);
 80097ea:	fb0a f202 	mul.w	r2, sl, r2
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 80097ee:	2420      	movs	r4, #32
 80097f0:	2121      	movs	r1, #33	; 0x21
 80097f2:	801c      	strh	r4, [r3, #0]
  * @retval None
  */
void LCD_DisplayChar(uint16_t Line, uint16_t Column, uint8_t Ascii)
{
  Ascii -= 32;
  LCD_DrawChar(Line, Column, &LCD_Currentfonts->table[Ascii * LCD_Currentfonts->Height]);
 80097f4:	0052      	lsls	r2, r2, #1
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 80097f6:	805d      	strh	r5, [r3, #2]
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 80097f8:	8019      	strh	r1, [r3, #0]
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 80097fa:	f8a3 b002 	strh.w	fp, [r3, #2]
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 80097fe:	f1ba 0f00 	cmp.w	sl, #0
 8009802:	d03b      	beq.n	800987c <LCD_DisplayStringLine+0xdc>
 8009804:	9d05      	ldr	r5, [sp, #20]
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 8009806:	9401      	str	r4, [sp, #4]
 8009808:	442a      	add	r2, r5
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 800980a:	9d03      	ldr	r5, [sp, #12]
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 800980c:	9102      	str	r1, [sp, #8]
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 800980e:	f04f 0e00 	mov.w	lr, #0
  * @param  None
  * @retval None
  */
void LCD_WriteRAM_Prepare(void)
{
  LCD->LCD_REG = LCD_REG_34;
 8009812:	f04f 0122 	mov.w	r1, #34	; 0x22
 8009816:	8019      	strh	r1, [r3, #0]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009818:	b1f8      	cbz	r0, 800985a <LCD_DisplayStringLine+0xba>
 800981a:	280c      	cmp	r0, #12
 800981c:	f04f 0100 	mov.w	r1, #0
 8009820:	d93e      	bls.n	80098a0 <LCD_DisplayStringLine+0x100>
 8009822:	e009      	b.n	8009838 <LCD_DisplayStringLine+0x98>
    {
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
 8009824:	f018 0f01 	tst.w	r8, #1
 8009828:	d110      	bne.n	800984c <LCD_DisplayStringLine+0xac>
        (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))

      {
        LCD_WriteRAM(BackColor);
 800982a:	f8b9 4000 	ldrh.w	r4, [r9]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 800982e:	3101      	adds	r1, #1
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
        (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))

      {
        LCD_WriteRAM(BackColor);
 8009830:	b2a4      	uxth	r4, r4
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009832:	4281      	cmp	r1, r0
  * @retval None
  */
void LCD_WriteRAM(uint16_t RGB_Code)
{
  /* Write 16-bit GRAM Reg */
  LCD->LCD_RAM = RGB_Code;
 8009834:	805c      	strh	r4, [r3, #2]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009836:	d010      	beq.n	800985a <LCD_DisplayStringLine+0xba>
    {
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
 8009838:	8814      	ldrh	r4, [r2, #0]
 800983a:	fa46 f701 	asr.w	r7, r6, r1
 800983e:	4227      	tst	r7, r4
 8009840:	fa44 f801 	asr.w	r8, r4, r1
 8009844:	d0ee      	beq.n	8009824 <LCD_DisplayStringLine+0x84>
 8009846:	410c      	asrs	r4, r1
 8009848:	07e4      	lsls	r4, r4, #31
 800984a:	d5ee      	bpl.n	800982a <LCD_DisplayStringLine+0x8a>
      {
        LCD_WriteRAM(BackColor);
      }
      else
      {
        LCD_WriteRAM(TextColor);
 800984c:	f8bc 4000 	ldrh.w	r4, [ip]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009850:	3101      	adds	r1, #1
      {
        LCD_WriteRAM(BackColor);
      }
      else
      {
        LCD_WriteRAM(TextColor);
 8009852:	b2a4      	uxth	r4, r4
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009854:	4281      	cmp	r1, r0
  * @retval None
  */
void LCD_WriteRAM(uint16_t RGB_Code)
{
  /* Write 16-bit GRAM Reg */
  LCD->LCD_RAM = RGB_Code;
 8009856:	805c      	strh	r4, [r3, #2]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 8009858:	d1ee      	bne.n	8009838 <LCD_DisplayStringLine+0x98>
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 800985a:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 800985e:	8019      	strh	r1, [r3, #0]
      else
      {
        LCD_WriteRAM(TextColor);
      } 
    }
    Xaddress++;
 8009860:	3501      	adds	r5, #1
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 8009862:	f10e 0e01 	add.w	lr, lr, #1
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 8009866:	f8bd 1008 	ldrh.w	r1, [sp, #8]
      else
      {
        LCD_WriteRAM(TextColor);
      } 
    }
    Xaddress++;
 800986a:	b2ad      	uxth	r5, r5
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 800986c:	45d6      	cmp	lr, sl
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 800986e:	805d      	strh	r5, [r3, #2]
 8009870:	f102 0202 	add.w	r2, r2, #2
  * @retval None
  */
void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
{
  /* Write 16-bit Index, then Write Reg */
  LCD->LCD_REG = LCD_Reg;
 8009874:	8019      	strh	r1, [r3, #0]
  /* Write 16-bit Reg */
  LCD->LCD_RAM = LCD_RegValue;
 8009876:	f8a3 b002 	strh.w	fp, [r3, #2]
  uint16_t  Xaddress = 0;
  Xaddress = Xpos;
  
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
 800987a:	d1ca      	bne.n	8009812 <LCD_DisplayStringLine+0x72>
  while ((*ptr != 0) & (((refcolumn + 1) & 0xFFFF) >= LCD_Currentfonts->Width))
  {
    /* Display one character on LCD */
    LCD_DisplayChar(Line, refcolumn, *ptr);
    /* Decrement the column position by 16 */
    refcolumn -= LCD_Currentfonts->Width;
 800987c:	ebc0 0b0b 	rsb	fp, r0, fp
 8009880:	fa1f fb8b 	uxth.w	fp, fp
void LCD_DisplayStringLine(uint16_t Line, uint8_t *ptr)
{
  uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;

  /* Send the string character by character on lCD */
  while ((*ptr != 0) & (((refcolumn + 1) & 0xFFFF) >= LCD_Currentfonts->Width))
 8009884:	9c04      	ldr	r4, [sp, #16]
 8009886:	f10b 0101 	add.w	r1, fp, #1
 800988a:	b289      	uxth	r1, r1
 800988c:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8009890:	9404      	str	r4, [sp, #16]
 8009892:	4281      	cmp	r1, r0
 8009894:	db01      	blt.n	800989a <LCD_DisplayStringLine+0xfa>
 8009896:	2a00      	cmp	r2, #0
 8009898:	d1a3      	bne.n	80097e2 <LCD_DisplayStringLine+0x42>
    /* Decrement the column position by 16 */
    refcolumn -= LCD_Currentfonts->Width;
    /* Point on the next character */
    ptr++;
  }
}
 800989a:	b007      	add	sp, #28
 800989c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
    {
  
      if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
 80098a0:	8817      	ldrh	r7, [r2, #0]
 80098a2:	fa46 f401 	asr.w	r4, r6, r1
 80098a6:	4227      	tst	r7, r4
        (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))

      {
        LCD_WriteRAM(BackColor);
 80098a8:	bf0c      	ite	eq
 80098aa:	f8b9 4000 	ldrheq.w	r4, [r9]
      }
      else
      {
        LCD_WriteRAM(TextColor);
 80098ae:	f8bc 4000 	ldrhne.w	r4, [ip]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 80098b2:	3101      	adds	r1, #1
      {
        LCD_WriteRAM(BackColor);
      }
      else
      {
        LCD_WriteRAM(TextColor);
 80098b4:	b2a4      	uxth	r4, r4
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 80098b6:	4288      	cmp	r0, r1
  * @retval None
  */
void LCD_WriteRAM(uint16_t RGB_Code)
{
  /* Write 16-bit GRAM Reg */
  LCD->LCD_RAM = RGB_Code;
 80098b8:	805c      	strh	r4, [r3, #2]
  LCD_SetCursor(Xaddress, Ypos);
  
  for(index = 0; index < LCD_Currentfonts->Height; index++)
  {
    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    for(i = 0; i < LCD_Currentfonts->Width; i++)
 80098ba:	d1f1      	bne.n	80098a0 <LCD_DisplayStringLine+0x100>
 80098bc:	e7cd      	b.n	800985a <LCD_DisplayStringLine+0xba>
 80098be:	bf00      	nop
 80098c0:	20002a78 	.word	0x20002a78
 80098c4:	aaaaaaab 	.word	0xaaaaaaab
 80098c8:	20002a74 	.word	0x20002a74
 80098cc:	2000001c 	.word	0x2000001c

080098d0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80098d0:	f8df d034 	ldr.w	sp, [pc, #52]	; 8009908 <LoopFillZerobss+0x14>
  
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80098d4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80098d6:	e003      	b.n	80098e0 <LoopCopyDataInit>

080098d8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80098d8:	4b0c      	ldr	r3, [pc, #48]	; (800990c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80098da:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80098dc:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80098de:	3104      	adds	r1, #4

080098e0 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80098e0:	480b      	ldr	r0, [pc, #44]	; (8009910 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80098e2:	4b0c      	ldr	r3, [pc, #48]	; (8009914 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80098e4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80098e6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80098e8:	d3f6      	bcc.n	80098d8 <CopyDataInit>
  ldr  r2, =_sbss
 80098ea:	4a0b      	ldr	r2, [pc, #44]	; (8009918 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80098ec:	e002      	b.n	80098f4 <LoopFillZerobss>

080098ee <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80098ee:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80098f0:	f842 3b04 	str.w	r3, [r2], #4

080098f4 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80098f4:	4b09      	ldr	r3, [pc, #36]	; (800991c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80098f6:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80098f8:	d3f9      	bcc.n	80098ee <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80098fa:	f7f7 f8c3 	bl	8000a84 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 80098fe:	f001 fdd5 	bl	800b4ac <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8009902:	f001 f9af 	bl	800ac64 <main>
  bx  lr    
 8009906:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8009908:	20030000 	.word	0x20030000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800990c:	080198b8 	.word	0x080198b8
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8009910:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8009914:	20000550 	.word	0x20000550
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8009918:	20000550 	.word	0x20000550
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800991c:	20008a30 	.word	0x20008a30

08009920 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8009920:	e7fe      	b.n	8009920 <ADC_IRQHandler>
	...

08009924 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

int _read (int file, char *ptr, int len)
{
 8009924:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8009926:	1e16      	subs	r6, r2, #0
 8009928:	dd07      	ble.n	800993a <_read+0x16>
 800992a:	460c      	mov	r4, r1
 800992c:	198d      	adds	r5, r1, r6
	{
	  *ptr++ = __io_getchar();
 800992e:	f3af 8000 	nop.w
 8009932:	f804 0b01 	strb.w	r0, [r4], #1

int _read (int file, char *ptr, int len)
{
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8009936:	42a5      	cmp	r5, r4
 8009938:	d1f9      	bne.n	800992e <_read+0xa>
	{
	  *ptr++ = __io_getchar();
	}

return len;
}
 800993a:	4630      	mov	r0, r6
 800993c:	bd70      	pop	{r4, r5, r6, pc}
 800993e:	bf00      	nop

08009940 <_write>:

int _write(int file, char *ptr, int len)
{
 8009940:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8009942:	1e16      	subs	r6, r2, #0
 8009944:	dd07      	ble.n	8009956 <_write+0x16>
 8009946:	460c      	mov	r4, r1
 8009948:	198d      	adds	r5, r1, r6
	{
	   __io_putchar( *ptr++ );
 800994a:	f814 0b01 	ldrb.w	r0, [r4], #1
 800994e:	f001 fab7 	bl	800aec0 <__io_putchar>

int _write(int file, char *ptr, int len)
{
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8009952:	42a5      	cmp	r5, r4
 8009954:	d1f9      	bne.n	800994a <_write+0xa>
	{
	   __io_putchar( *ptr++ );
	}
	return len;
}
 8009956:	4630      	mov	r0, r6
 8009958:	bd70      	pop	{r4, r5, r6, pc}
 800995a:	bf00      	nop

0800995c <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 800995c:	4a09      	ldr	r2, [pc, #36]	; (8009984 <_sbrk+0x28>)
 800995e:	6813      	ldr	r3, [r2, #0]
 8009960:	b16b      	cbz	r3, 800997e <_sbrk+0x22>
		heap_end = &end;

	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
 8009962:	4418      	add	r0, r3
 8009964:	4669      	mov	r1, sp
 8009966:	4288      	cmp	r0, r1
 8009968:	d802      	bhi.n	8009970 <_sbrk+0x14>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 800996a:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 800996c:	4618      	mov	r0, r3
 800996e:	4770      	bx	lr
	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 8009970:	4b05      	ldr	r3, [pc, #20]	; (8009988 <_sbrk+0x2c>)
 8009972:	220c      	movs	r2, #12
 8009974:	601a      	str	r2, [r3, #0]
		return (caddr_t) -1;
 8009976:	f04f 33ff 	mov.w	r3, #4294967295
	}

	heap_end += incr;

	return (caddr_t) prev_heap_end;
}
 800997a:	4618      	mov	r0, r3
 800997c:	4770      	bx	lr
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
		heap_end = &end;
 800997e:	4b03      	ldr	r3, [pc, #12]	; (800998c <_sbrk+0x30>)
 8009980:	6013      	str	r3, [r2, #0]
 8009982:	e7ee      	b.n	8009962 <_sbrk+0x6>
 8009984:	20002a7c 	.word	0x20002a7c
 8009988:	20008a2c 	.word	0x20008a2c
 800998c:	20008a30 	.word	0x20008a30

08009990 <_close>:
}

int _close(int file)
{
	return -1;
}
 8009990:	f04f 30ff 	mov.w	r0, #4294967295
 8009994:	4770      	bx	lr
 8009996:	bf00      	nop

08009998 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8009998:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800999c:	604b      	str	r3, [r1, #4]
	return 0;
}
 800999e:	2000      	movs	r0, #0
 80099a0:	4770      	bx	lr
 80099a2:	bf00      	nop

080099a4 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 80099a4:	2001      	movs	r0, #1
 80099a6:	4770      	bx	lr

080099a8 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 80099a8:	2000      	movs	r0, #0
 80099aa:	4770      	bx	lr

080099ac <fs_open>:
}

/*-----------------------------------------------------------------------------------*/
struct fs_file *
fs_open(const char *name)
{
 80099ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
static struct fs_file *
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
    if(fs_memory[i].inuse == 0) {
 80099b0:	4e4e      	ldr	r6, [pc, #312]	; (8009aec <fs_open+0x140>)
 80099b2:	7d37      	ldrb	r7, [r6, #20]
 80099b4:	b347      	cbz	r7, 8009a08 <fs_open+0x5c>
 80099b6:	f896 302c 	ldrb.w	r3, [r6, #44]	; 0x2c
 80099ba:	2b00      	cmp	r3, #0
 80099bc:	d077      	beq.n	8009aae <fs_open+0x102>
 80099be:	f896 3044 	ldrb.w	r3, [r6, #68]	; 0x44
 80099c2:	2b00      	cmp	r3, #0
 80099c4:	d075      	beq.n	8009ab2 <fs_open+0x106>
 80099c6:	f896 305c 	ldrb.w	r3, [r6, #92]	; 0x5c
 80099ca:	2b00      	cmp	r3, #0
 80099cc:	d073      	beq.n	8009ab6 <fs_open+0x10a>
 80099ce:	f896 3074 	ldrb.w	r3, [r6, #116]	; 0x74
 80099d2:	2b00      	cmp	r3, #0
 80099d4:	d071      	beq.n	8009aba <fs_open+0x10e>
 80099d6:	f896 308c 	ldrb.w	r3, [r6, #140]	; 0x8c
 80099da:	2b00      	cmp	r3, #0
 80099dc:	d06f      	beq.n	8009abe <fs_open+0x112>
 80099de:	f896 30a4 	ldrb.w	r3, [r6, #164]	; 0xa4
 80099e2:	2b00      	cmp	r3, #0
 80099e4:	d06d      	beq.n	8009ac2 <fs_open+0x116>
 80099e6:	f896 30bc 	ldrb.w	r3, [r6, #188]	; 0xbc
 80099ea:	2b00      	cmp	r3, #0
 80099ec:	d06b      	beq.n	8009ac6 <fs_open+0x11a>
 80099ee:	f896 30d4 	ldrb.w	r3, [r6, #212]	; 0xd4
 80099f2:	b143      	cbz	r3, 8009a06 <fs_open+0x5a>
 80099f4:	f896 30ec 	ldrb.w	r3, [r6, #236]	; 0xec
/*-----------------------------------------------------------------------------------*/
static struct fs_file *
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 80099f8:	2709      	movs	r7, #9
    if(fs_memory[i].inuse == 0) {
 80099fa:	b12b      	cbz	r3, 8009a08 <fs_open+0x5c>
  struct fs_file *file;
  const struct fsdata_file *f;

  file = fs_malloc();
  if(file == NULL) {
    return NULL;
 80099fc:	f04f 0900 	mov.w	r9, #0
      return file;
    }
  }
  fs_free(file);
  return NULL;
}
 8009a00:	4648      	mov	r0, r9
 8009a02:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
/*-----------------------------------------------------------------------------------*/
static struct fs_file *
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8009a06:	2708      	movs	r7, #8
    if(fs_memory[i].inuse == 0) {
      fs_memory[i].inuse = 1;
 8009a08:	ea4f 0a47 	mov.w	sl, r7, lsl #1
 8009a0c:	eb0a 0807 	add.w	r8, sl, r7
 8009a10:	eb06 08c8 	add.w	r8, r6, r8, lsl #3
 8009a14:	2301      	movs	r3, #1
 8009a16:	4605      	mov	r5, r0
 8009a18:	f888 3014 	strb.w	r3, [r8, #20]
      return(&fs_memory[i].file);
 8009a1c:	46c1      	mov	r9, r8
 8009a1e:	4934      	ldr	r1, [pc, #208]	; (8009af0 <fs_open+0x144>)
 8009a20:	4c34      	ldr	r4, [pc, #208]	; (8009af4 <fs_open+0x148>)
 8009a22:	e000      	b.n	8009a26 <fs_open+0x7a>
 8009a24:	6861      	ldr	r1, [r4, #4]
  }
  file->is_custom_file = 0;
#endif /* LWIP_HTTPD_CUSTOM_FILES */

  for(f = FS_ROOT; f != NULL; f = f->next) {
    if (!strcmp(name, (char *)f->name)) {
 8009a26:	4628      	mov	r0, r5
 8009a28:	f7f6 fbda 	bl	80001e0 <strcmp>
 8009a2c:	b388      	cbz	r0, 8009a92 <fs_open+0xe6>
    return file;
  }
  file->is_custom_file = 0;
#endif /* LWIP_HTTPD_CUSTOM_FILES */

  for(f = FS_ROOT; f != NULL; f = f->next) {
 8009a2e:	6824      	ldr	r4, [r4, #0]
 8009a30:	2c00      	cmp	r4, #0
 8009a32:	d1f7      	bne.n	8009a24 <fs_open+0x78>
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
    if(&fs_memory[i].file == file) {
 8009a34:	45b0      	cmp	r8, r6
 8009a36:	d021      	beq.n	8009a7c <fs_open+0xd0>
 8009a38:	4b2f      	ldr	r3, [pc, #188]	; (8009af8 <fs_open+0x14c>)
 8009a3a:	4598      	cmp	r8, r3
 8009a3c:	d047      	beq.n	8009ace <fs_open+0x122>
 8009a3e:	f103 0218 	add.w	r2, r3, #24
 8009a42:	4590      	cmp	r8, r2
 8009a44:	d041      	beq.n	8009aca <fs_open+0x11e>
 8009a46:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8009a4a:	4590      	cmp	r8, r2
 8009a4c:	d041      	beq.n	8009ad2 <fs_open+0x126>
 8009a4e:	f103 0248 	add.w	r2, r3, #72	; 0x48
 8009a52:	4590      	cmp	r8, r2
 8009a54:	d03f      	beq.n	8009ad6 <fs_open+0x12a>
 8009a56:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8009a5a:	4590      	cmp	r8, r2
 8009a5c:	d03d      	beq.n	8009ada <fs_open+0x12e>
 8009a5e:	f103 0278 	add.w	r2, r3, #120	; 0x78
 8009a62:	4590      	cmp	r8, r2
 8009a64:	d03d      	beq.n	8009ae2 <fs_open+0x136>
 8009a66:	3390      	adds	r3, #144	; 0x90
 8009a68:	4598      	cmp	r8, r3
 8009a6a:	d038      	beq.n	8009ade <fs_open+0x132>
 8009a6c:	3318      	adds	r3, #24
 8009a6e:	4598      	cmp	r8, r3
 8009a70:	d039      	beq.n	8009ae6 <fs_open+0x13a>
 8009a72:	3318      	adds	r3, #24
 8009a74:	4598      	cmp	r8, r3
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8009a76:	bf08      	it	eq
 8009a78:	2409      	moveq	r4, #9
    if(&fs_memory[i].file == file) {
 8009a7a:	d1bf      	bne.n	80099fc <fs_open+0x50>
      fs_memory[i].inuse = 0;
 8009a7c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8009a80:	eb06 04c4 	add.w	r4, r6, r4, lsl #3
 8009a84:	f04f 0900 	mov.w	r9, #0
 8009a88:	f884 9014 	strb.w	r9, [r4, #20]
      return file;
    }
  }
  fs_free(file);
  return NULL;
}
 8009a8c:	4648      	mov	r0, r9
 8009a8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  file->is_custom_file = 0;
#endif /* LWIP_HTTPD_CUSTOM_FILES */

  for(f = FS_ROOT; f != NULL; f = f->next) {
    if (!strcmp(name, (char *)f->name)) {
      file->data = (const char *)f->data;
 8009a92:	4457      	add	r7, sl
 8009a94:	00ff      	lsls	r7, r7, #3
 8009a96:	68a3      	ldr	r3, [r4, #8]
 8009a98:	51f3      	str	r3, [r6, r7]
 8009a9a:	443e      	add	r6, r7
      file->len = f->len;
 8009a9c:	68e3      	ldr	r3, [r4, #12]
 8009a9e:	6073      	str	r3, [r6, #4]
      file->index = f->len;
      file->pextension = NULL;
 8009aa0:	60f0      	str	r0, [r6, #12]

  for(f = FS_ROOT; f != NULL; f = f->next) {
    if (!strcmp(name, (char *)f->name)) {
      file->data = (const char *)f->data;
      file->len = f->len;
      file->index = f->len;
 8009aa2:	60b3      	str	r3, [r6, #8]
      file->pextension = NULL;
      file->http_header_included = f->http_header_included;
 8009aa4:	7c23      	ldrb	r3, [r4, #16]
 8009aa6:	7433      	strb	r3, [r6, #16]
      return file;
    }
  }
  fs_free(file);
  return NULL;
}
 8009aa8:	4648      	mov	r0, r9
 8009aaa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
/*-----------------------------------------------------------------------------------*/
static struct fs_file *
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8009aae:	2701      	movs	r7, #1
 8009ab0:	e7aa      	b.n	8009a08 <fs_open+0x5c>
 8009ab2:	2702      	movs	r7, #2
 8009ab4:	e7a8      	b.n	8009a08 <fs_open+0x5c>
 8009ab6:	2703      	movs	r7, #3
 8009ab8:	e7a6      	b.n	8009a08 <fs_open+0x5c>
 8009aba:	2704      	movs	r7, #4
 8009abc:	e7a4      	b.n	8009a08 <fs_open+0x5c>
 8009abe:	2705      	movs	r7, #5
 8009ac0:	e7a2      	b.n	8009a08 <fs_open+0x5c>
 8009ac2:	2706      	movs	r7, #6
 8009ac4:	e7a0      	b.n	8009a08 <fs_open+0x5c>
 8009ac6:	2707      	movs	r7, #7
 8009ac8:	e79e      	b.n	8009a08 <fs_open+0x5c>
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8009aca:	2402      	movs	r4, #2
 8009acc:	e7d6      	b.n	8009a7c <fs_open+0xd0>
 8009ace:	2401      	movs	r4, #1
 8009ad0:	e7d4      	b.n	8009a7c <fs_open+0xd0>
 8009ad2:	2403      	movs	r4, #3
 8009ad4:	e7d2      	b.n	8009a7c <fs_open+0xd0>
 8009ad6:	2404      	movs	r4, #4
 8009ad8:	e7d0      	b.n	8009a7c <fs_open+0xd0>
 8009ada:	2405      	movs	r4, #5
 8009adc:	e7ce      	b.n	8009a7c <fs_open+0xd0>
 8009ade:	2407      	movs	r4, #7
 8009ae0:	e7cc      	b.n	8009a7c <fs_open+0xd0>
 8009ae2:	2406      	movs	r4, #6
 8009ae4:	e7ca      	b.n	8009a7c <fs_open+0xd0>
 8009ae6:	2408      	movs	r4, #8
 8009ae8:	e7c8      	b.n	8009a7c <fs_open+0xd0>
 8009aea:	bf00      	nop
 8009aec:	20008824 	.word	0x20008824
 8009af0:	080105ac 	.word	0x080105ac
 8009af4:	08011594 	.word	0x08011594
 8009af8:	2000883c 	.word	0x2000883c

08009afc <fs_close>:
    if(&fs_memory[i].file == file) {
 8009afc:	4b20      	ldr	r3, [pc, #128]	; (8009b80 <fs_close+0x84>)
 8009afe:	4298      	cmp	r0, r3
 8009b00:	d02e      	beq.n	8009b60 <fs_close+0x64>
 8009b02:	f103 0218 	add.w	r2, r3, #24
 8009b06:	4290      	cmp	r0, r2
 8009b08:	d02c      	beq.n	8009b64 <fs_close+0x68>
 8009b0a:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8009b0e:	4290      	cmp	r0, r2
 8009b10:	d02a      	beq.n	8009b68 <fs_close+0x6c>
 8009b12:	f103 0248 	add.w	r2, r3, #72	; 0x48
 8009b16:	4290      	cmp	r0, r2
 8009b18:	d028      	beq.n	8009b6c <fs_close+0x70>
 8009b1a:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8009b1e:	4290      	cmp	r0, r2
 8009b20:	d026      	beq.n	8009b70 <fs_close+0x74>
 8009b22:	f103 0278 	add.w	r2, r3, #120	; 0x78
 8009b26:	4290      	cmp	r0, r2
 8009b28:	d024      	beq.n	8009b74 <fs_close+0x78>
 8009b2a:	f103 0290 	add.w	r2, r3, #144	; 0x90
 8009b2e:	4290      	cmp	r0, r2
 8009b30:	d022      	beq.n	8009b78 <fs_close+0x7c>
 8009b32:	f103 02a8 	add.w	r2, r3, #168	; 0xa8
 8009b36:	4290      	cmp	r0, r2
 8009b38:	d020      	beq.n	8009b7c <fs_close+0x80>
 8009b3a:	f103 02c0 	add.w	r2, r3, #192	; 0xc0
 8009b3e:	4290      	cmp	r0, r2
 8009b40:	d006      	beq.n	8009b50 <fs_close+0x54>
 8009b42:	f103 02d8 	add.w	r2, r3, #216	; 0xd8
 8009b46:	4290      	cmp	r0, r2
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8009b48:	bf08      	it	eq
 8009b4a:	2209      	moveq	r2, #9
    if(&fs_memory[i].file == file) {
 8009b4c:	d001      	beq.n	8009b52 <fs_close+0x56>
 8009b4e:	4770      	bx	lr
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8009b50:	2208      	movs	r2, #8
    if(&fs_memory[i].file == file) {
      fs_memory[i].inuse = 0;
 8009b52:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8009b56:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8009b5a:	2200      	movs	r2, #0
 8009b5c:	751a      	strb	r2, [r3, #20]
 8009b5e:	4770      	bx	lr
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8009b60:	2200      	movs	r2, #0
 8009b62:	e7f6      	b.n	8009b52 <fs_close+0x56>
 8009b64:	2201      	movs	r2, #1
 8009b66:	e7f4      	b.n	8009b52 <fs_close+0x56>
 8009b68:	2202      	movs	r2, #2
 8009b6a:	e7f2      	b.n	8009b52 <fs_close+0x56>
 8009b6c:	2203      	movs	r2, #3
 8009b6e:	e7f0      	b.n	8009b52 <fs_close+0x56>
 8009b70:	2204      	movs	r2, #4
 8009b72:	e7ee      	b.n	8009b52 <fs_close+0x56>
 8009b74:	2205      	movs	r2, #5
 8009b76:	e7ec      	b.n	8009b52 <fs_close+0x56>
 8009b78:	2206      	movs	r2, #6
 8009b7a:	e7ea      	b.n	8009b52 <fs_close+0x56>
 8009b7c:	2207      	movs	r2, #7
 8009b7e:	e7e8      	b.n	8009b52 <fs_close+0x56>
 8009b80:	20008824 	.word	0x20008824

08009b84 <fs_read>:
  fs_free(file);
}
/*-----------------------------------------------------------------------------------*/
int
fs_read(struct fs_file *file, char *buffer, int count)
{
 8009b84:	b570      	push	{r4, r5, r6, lr}
  int read;

  if(file->index == file->len) {
 8009b86:	6886      	ldr	r6, [r0, #8]
 8009b88:	6844      	ldr	r4, [r0, #4]
 8009b8a:	42a6      	cmp	r6, r4
 8009b8c:	d010      	beq.n	8009bb0 <fs_read+0x2c>
 8009b8e:	4603      	mov	r3, r0
    return -1;
  }

  read = file->len - file->index;
 8009b90:	1ba4      	subs	r4, r4, r6
 8009b92:	4294      	cmp	r4, r2
 8009b94:	4608      	mov	r0, r1
  if(read > count) {
    read = count;
  }

  MEMCPY(buffer, (file->data + file->index), read);
 8009b96:	6819      	ldr	r1, [r3, #0]
 8009b98:	bfa8      	it	ge
 8009b9a:	4614      	movge	r4, r2
 8009b9c:	461d      	mov	r5, r3
 8009b9e:	4622      	mov	r2, r4
 8009ba0:	4431      	add	r1, r6
 8009ba2:	f001 fcb8 	bl	800b516 <memcpy>
  file->index += read;
 8009ba6:	68ab      	ldr	r3, [r5, #8]
 8009ba8:	4423      	add	r3, r4
 8009baa:	60ab      	str	r3, [r5, #8]

  return(read);
 8009bac:	4620      	mov	r0, r4
 8009bae:	bd70      	pop	{r4, r5, r6, pc}
fs_read(struct fs_file *file, char *buffer, int count)
{
  int read;

  if(file->index == file->len) {
    return -1;
 8009bb0:	f04f 30ff 	mov.w	r0, #4294967295

  MEMCPY(buffer, (file->data + file->index), read);
  file->index += read;

  return(read);
}
 8009bb4:	bd70      	pop	{r4, r5, r6, pc}
 8009bb6:	bf00      	nop

08009bb8 <fs_bytes_left>:
/*-----------------------------------------------------------------------------------*/
int fs_bytes_left(struct fs_file *file)
{
  return file->len - file->index;
 8009bb8:	6842      	ldr	r2, [r0, #4]
 8009bba:	6880      	ldr	r0, [r0, #8]
}
 8009bbc:	1a10      	subs	r0, r2, r0
 8009bbe:	4770      	bx	lr

08009bc0 <strnstr>:
#endif /* LWIP_HTTPD_CGI */

#if LWIP_HTTPD_STRNSTR_PRIVATE
/** Like strstr but does not need 'buffer' to be NULL-terminated */
static char* strnstr(const char* buffer, const char* token, size_t n)
{
 8009bc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009bc4:	4604      	mov	r4, r0
  const char* p;
  int tokenlen = (int)strlen(token);
 8009bc6:	4608      	mov	r0, r1
#endif /* LWIP_HTTPD_CGI */

#if LWIP_HTTPD_STRNSTR_PRIVATE
/** Like strstr but does not need 'buffer' to be NULL-terminated */
static char* strnstr(const char* buffer, const char* token, size_t n)
{
 8009bc8:	4688      	mov	r8, r1
 8009bca:	4616      	mov	r6, r2
  const char* p;
  int tokenlen = (int)strlen(token);
 8009bcc:	f7f6 fb12 	bl	80001f4 <strlen>
  if (tokenlen == 0) {
 8009bd0:	b1c0      	cbz	r0, 8009c04 <strnstr+0x44>
 8009bd2:	4605      	mov	r5, r0
    return (char *)buffer;
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 8009bd4:	7820      	ldrb	r0, [r4, #0]
 8009bd6:	b1b0      	cbz	r0, 8009c06 <strnstr+0x46>
 8009bd8:	4426      	add	r6, r4
 8009bda:	1963      	adds	r3, r4, r5
 8009bdc:	429e      	cmp	r6, r3
 8009bde:	d314      	bcc.n	8009c0a <strnstr+0x4a>
 8009be0:	f898 7000 	ldrb.w	r7, [r8]
 8009be4:	e005      	b.n	8009bf2 <strnstr+0x32>
 8009be6:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8009bea:	1963      	adds	r3, r4, r5
 8009bec:	b158      	cbz	r0, 8009c06 <strnstr+0x46>
 8009bee:	429e      	cmp	r6, r3
 8009bf0:	d30b      	bcc.n	8009c0a <strnstr+0x4a>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
 8009bf2:	4287      	cmp	r7, r0
 8009bf4:	d1f7      	bne.n	8009be6 <strnstr+0x26>
 8009bf6:	462a      	mov	r2, r5
 8009bf8:	4641      	mov	r1, r8
 8009bfa:	4620      	mov	r0, r4
 8009bfc:	f001 fd00 	bl	800b600 <strncmp>
 8009c00:	2800      	cmp	r0, #0
 8009c02:	d1f0      	bne.n	8009be6 <strnstr+0x26>
 8009c04:	4620      	mov	r0, r4
      return (char *)p;
    }
  }
  return NULL;
} 
 8009c06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
      return (char *)p;
    }
  }
  return NULL;
 8009c0a:	2000      	movs	r0, #0
 8009c0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08009c10 <http_accept>:

/**
 * A new incoming connection has been accepted.
 */
static err_t http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
 8009c10:	b538      	push	{r3, r4, r5, lr}
  LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept %p / %p\n", (void*)pcb, arg));

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);
  /* Set priority */
  tcp_setprio(pcb, HTTPD_TCP_PRIO);
 8009c12:	4608      	mov	r0, r1

/**
 * A new incoming connection has been accepted.
 */
static err_t http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
 8009c14:	460c      	mov	r4, r1
  LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept %p / %p\n", (void*)pcb, arg));

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);
  /* Set priority */
  tcp_setprio(pcb, HTTPD_TCP_PRIO);
 8009c16:	2101      	movs	r1, #1
 8009c18:	f7fa ff34 	bl	8004a84 <tcp_setprio>
{
  struct http_state *ret;
#if HTTPD_USE_MEM_POOL
  ret = (struct http_state *)memp_malloc(MEMP_HTTPD_STATE);
#else /* HTTPD_USE_MEM_POOL */
  ret = (struct http_state *)mem_malloc(sizeof(struct http_state));
 8009c1c:	f44f 70ba 	mov.w	r0, #372	; 0x174
 8009c20:	f7f9 ff60 	bl	8003ae4 <mem_malloc>
#endif /* HTTPD_USE_MEM_POOL */
  if (ret != NULL) {
 8009c24:	b1e0      	cbz	r0, 8009c60 <http_accept+0x50>
    /* Initialize the structure. */
    memset(ret, 0, sizeof(struct http_state));
 8009c26:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8009c2a:	4605      	mov	r5, r0
 8009c2c:	2100      	movs	r1, #0
 8009c2e:	f001 fc7d 	bl	800b52c <memset>
    return ERR_MEM;
  }

  /* Tell TCP that this is the structure we wish to be passed for our
     callbacks. */
  tcp_arg(pcb, hs);
 8009c32:	4629      	mov	r1, r5
 8009c34:	4620      	mov	r0, r4
 8009c36:	f7fa ff27 	bl	8004a88 <tcp_arg>

  /* Set up the various callback functions */
  tcp_recv(pcb, http_recv);
 8009c3a:	4620      	mov	r0, r4
 8009c3c:	490a      	ldr	r1, [pc, #40]	; (8009c68 <http_accept+0x58>)
 8009c3e:	f7fa ff25 	bl	8004a8c <tcp_recv>
  tcp_err(pcb, http_err);
 8009c42:	4620      	mov	r0, r4
 8009c44:	4909      	ldr	r1, [pc, #36]	; (8009c6c <http_accept+0x5c>)
 8009c46:	f7fa ff25 	bl	8004a94 <tcp_err>
  tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 8009c4a:	2204      	movs	r2, #4
 8009c4c:	4620      	mov	r0, r4
 8009c4e:	4908      	ldr	r1, [pc, #32]	; (8009c70 <http_accept+0x60>)
 8009c50:	f7fa ff26 	bl	8004aa0 <tcp_poll>
  tcp_sent(pcb, http_sent);
 8009c54:	4620      	mov	r0, r4
 8009c56:	4907      	ldr	r1, [pc, #28]	; (8009c74 <http_accept+0x64>)
 8009c58:	f7fa ff1a 	bl	8004a90 <tcp_sent>

  return ERR_OK;
 8009c5c:	2000      	movs	r0, #0
 8009c5e:	bd38      	pop	{r3, r4, r5, pc}
  /* Allocate memory for the structure that holds the state of the
     connection - initialized by that function. */
  hs = http_state_alloc();
  if (hs == NULL) {
    LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept: Out of memory, RST\n"));
    return ERR_MEM;
 8009c60:	f04f 30ff 	mov.w	r0, #4294967295
  tcp_err(pcb, http_err);
  tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
  tcp_sent(pcb, http_sent);

  return ERR_OK;
}
 8009c64:	bd38      	pop	{r3, r4, r5, pc}
 8009c66:	bf00      	nop
 8009c68:	0800a4f1 	.word	0x0800a4f1
 8009c6c:	08009c79 	.word	0x08009c79
 8009c70:	0800a425 	.word	0x0800a425
 8009c74:	0800a409 	.word	0x0800a409

08009c78 <http_err>:
  struct http_state *hs = (struct http_state *)arg;
  LWIP_UNUSED_ARG(err);

  LWIP_DEBUGF(HTTPD_DEBUG, ("http_err: %s", lwip_strerr(err)));

  if (hs != NULL) {
 8009c78:	b190      	cbz	r0, 8009ca0 <http_err+0x28>
/**
 * The pcb had an error and is already deallocated.
 * The argument might still be valid (if != NULL).
 */
static void http_err(void *arg, err_t err)
{
 8009c7a:	b510      	push	{r4, lr}
 8009c7c:	4604      	mov	r4, r0
 * Also frees the file data if dynamic.
 */
static void http_state_free(struct http_state *hs)
{
  if (hs != NULL) {
    if(hs->handle) {
 8009c7e:	6800      	ldr	r0, [r0, #0]
 8009c80:	b118      	cbz	r0, 8009c8a <http_err+0x12>
      u32_t ms_needed = sys_now() - hs->time_started;
      u32_t needed = LWIP_MAX(1, (ms_needed/100));
      LWIP_DEBUGF(HTTPD_DEBUG_TIMING, ("httpd: needed %"U32_F" ms to send file of %d bytes -> %"U32_F" bytes/sec\n",
        ms_needed, hs->handle->len, ((((u32_t)hs->handle->len) * 10) / needed)));
#endif /* LWIP_HTTPD_TIMING */
      fs_close(hs->handle);
 8009c82:	f7ff ff3b 	bl	8009afc <fs_close>
      hs->handle = NULL;
 8009c86:	2300      	movs	r3, #0
 8009c88:	6023      	str	r3, [r4, #0]
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    if (hs->buf != NULL) {
 8009c8a:	68e0      	ldr	r0, [r4, #12]
 8009c8c:	b118      	cbz	r0, 8009c96 <http_err+0x1e>
      mem_free(hs->buf);
 8009c8e:	f7f9 fe83 	bl	8003998 <mem_free>
      hs->buf = NULL;
 8009c92:	2300      	movs	r3, #0
 8009c94:	60e3      	str	r3, [r4, #12]
    }
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
#if HTTPD_USE_MEM_POOL
    memp_free(MEMP_HTTPD_STATE, hs);
#else /* HTTPD_USE_MEM_POOL */
    mem_free(hs);
 8009c96:	4620      	mov	r0, r4
  LWIP_DEBUGF(HTTPD_DEBUG, ("http_err: %s", lwip_strerr(err)));

  if (hs != NULL) {
    http_state_free(hs);
  }
}
 8009c98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
#if HTTPD_USE_MEM_POOL
    memp_free(MEMP_HTTPD_STATE, hs);
#else /* HTTPD_USE_MEM_POOL */
    mem_free(hs);
 8009c9c:	f7f9 be7c 	b.w	8003998 <mem_free>
 8009ca0:	4770      	bx	lr
 8009ca2:	bf00      	nop

08009ca4 <http_send_data>:
 *
 * @param pcb the pcb to send data
 * @param hs connection state
 */
static u8_t http_send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
 8009ca4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  err = ERR_OK;
#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */

  /* Have we run out of file data to send? If so, we need to read the next
   * block from the file. */
  if (hs->left == 0) {
 8009ca8:	694b      	ldr	r3, [r1, #20]
 *
 * @param pcb the pcb to send data
 * @param hs connection state
 */
static u8_t http_send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
 8009caa:	b085      	sub	sp, #20
 8009cac:	460c      	mov	r4, r1
 8009cae:	4606      	mov	r6, r0
  err = ERR_OK;
#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */

  /* Have we run out of file data to send? If so, we need to read the next
   * block from the file. */
  if (hs->left == 0) {
 8009cb0:	2b00      	cmp	r3, #0
 8009cb2:	d13a      	bne.n	8009d2a <http_send_data+0x86>
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    int count;
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */

    /* Do we have a valid file handle? */
    if (hs->handle == NULL) {
 8009cb4:	680d      	ldr	r5, [r1, #0]
 8009cb6:	2d00      	cmp	r5, #0
 8009cb8:	f000 816d 	beq.w	8009f96 <http_send_data+0x2f2>
      /* No - close the connection. */
      http_close_conn(pcb, hs);
      return 0;
    }
    if (fs_bytes_left(hs->handle) <= 0) {
 8009cbc:	4628      	mov	r0, r5
 8009cbe:	9300      	str	r3, [sp, #0]
 8009cc0:	f7ff ff7a 	bl	8009bb8 <fs_bytes_left>
 8009cc4:	2800      	cmp	r0, #0
 8009cc6:	9b00      	ldr	r3, [sp, #0]
 8009cc8:	f340 828e 	ble.w	800a1e8 <http_send_data+0x544>
      http_close_conn(pcb, hs);
      return 0;
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    /* Do we already have a send buffer allocated? */
    if(hs->buf) {
 8009ccc:	68e1      	ldr	r1, [r4, #12]
 8009cce:	2900      	cmp	r1, #0
 8009cd0:	f000 8228 	beq.w	800a124 <http_send_data+0x480>
    }

    /* Read a block of data from the file. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Trying to read %d bytes.\n", count));

    count = fs_read(hs->handle, hs->buf, count);
 8009cd4:	6922      	ldr	r2, [r4, #16]
 8009cd6:	6820      	ldr	r0, [r4, #0]
 8009cd8:	f7ff ff54 	bl	8009b84 <fs_read>
    if(count < 0) {
 8009cdc:	2800      	cmp	r0, #0
 8009cde:	f2c0 823d 	blt.w	800a15c <http_send_data+0x4b8>
    LWIP_ASSERT("SSI and DYNAMIC_HEADERS turned off but eof not reached", 0);
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
  }

#if LWIP_HTTPD_SSI
  if(!hs->tag_check) {
 8009ce2:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    }

    /* Set up to send the block of data we just read */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Read %d bytes.\n", count));
    hs->left = count;
    hs->file = hs->buf;
 8009ce6:	68e7      	ldr	r7, [r4, #12]
 8009ce8:	6067      	str	r7, [r4, #4]
      return 1;
    }

    /* Set up to send the block of data we just read */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Read %d bytes.\n", count));
    hs->left = count;
 8009cea:	4603      	mov	r3, r0
 8009cec:	6160      	str	r0, [r4, #20]
    hs->file = hs->buf;
#if LWIP_HTTPD_SSI
    hs->parse_left = count;
 8009cee:	6260      	str	r0, [r4, #36]	; 0x24
    hs->parsed = hs->buf;
 8009cf0:	61e7      	str	r7, [r4, #28]
    LWIP_ASSERT("SSI and DYNAMIC_HEADERS turned off but eof not reached", 0);
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
  }

#if LWIP_HTTPD_SSI
  if(!hs->tag_check) {
 8009cf2:	b1fa      	cbz	r2, 8009d34 <http_send_data+0x90>
static u8_t http_send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
  err_t err;
  u16_t len;
  u16_t mss;
  u8_t data_to_send = false;
 8009cf4:	f04f 0800 	mov.w	r8, #0
     * them with insert strings. We need to be careful here since a tag may
     * straddle the boundary of two blocks read from the file and we may also
     * have to split the insert string between two tcp_write operations. */

    /* How much data could we send? */
    len = tcp_sndbuf(pcb);
 8009cf8:	f8b6 5066 	ldrh.w	r5, [r6, #102]	; 0x66
      return 1;
    }
  }
#else /* LWIP_HTTPD_DYNAMIC_HEADERS */
  /* Assume no error until we find otherwise */
  err = ERR_OK;
 8009cfc:	4647      	mov	r7, r8
            hs->parsed++;
            break;
          }

          /* Have we found the next character we expect for the tag leadout? */
          if(*hs->parsed == g_pcTagLeadOut[hs->tag_index]) {
 8009cfe:	f8df b558 	ldr.w	fp, [pc, #1368]	; 800a258 <http_send_data+0x5b4>
 8009d02:	2b00      	cmp	r3, #0
 8009d04:	f000 80b9 	beq.w	8009e7a <http_send_data+0x1d6>
 8009d08:	2d00      	cmp	r5, #0
 8009d0a:	f000 8205 	beq.w	800a118 <http_send_data+0x474>

    LWIP_DEBUGF(HTTPD_DEBUG, ("State %d, %d left\n", hs->tag_state, hs->parse_left));

    /* We have sent all the data that was already parsed so continue parsing
     * the buffer contents looking for SSI tags. */
    while((hs->parse_left) && (err == ERR_OK)) {
 8009d0e:	2f00      	cmp	r7, #0
 8009d10:	f040 80b3 	bne.w	8009e7a <http_send_data+0x1d6>
 8009d14:	f894 20f1 	ldrb.w	r2, [r4, #241]	; 0xf1
      /* @todo: somewhere in this loop, 'len' should grow again... */
      if (len == 0) {
        return data_to_send;
      }
      switch(hs->tag_state) {
 8009d18:	2a04      	cmp	r2, #4
 8009d1a:	d8fd      	bhi.n	8009d18 <http_send_data+0x74>
 8009d1c:	e8df f012 	tbh	[pc, r2, lsl #1]
 8009d20:	01220118 	.word	0x01220118
 8009d24:	00dd00f6 	.word	0x00dd00f6
 8009d28:	008a      	.short	0x008a
    LWIP_ASSERT("SSI and DYNAMIC_HEADERS turned off but eof not reached", 0);
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
  }

#if LWIP_HTTPD_SSI
  if(!hs->tag_check) {
 8009d2a:	f891 202c 	ldrb.w	r2, [r1, #44]	; 0x2c
 8009d2e:	2a00      	cmp	r2, #0
 8009d30:	d12f      	bne.n	8009d92 <http_send_data+0xee>
 8009d32:	684f      	ldr	r7, [r1, #4]
    /* We are not processing an SHTML file so no tag checking is necessary.
     * Just send the data as we received it from the file. */

    /* We cannot send more data than space available in the send
       buffer. */
    if (tcp_sndbuf(pcb) < hs->left) {
 8009d34:	f8b6 5066 	ldrh.w	r5, [r6, #102]	; 0x66
 8009d38:	429d      	cmp	r5, r3
      len = tcp_sndbuf(pcb);
    } else {
      len = (u16_t)hs->left;
 8009d3a:	bf28      	it	cs
 8009d3c:	b29d      	uxthcs	r5, r3
      LWIP_ASSERT("hs->left did not fit into u16_t!", (len == hs->left));
    }
    mss = tcp_mss(pcb);
 8009d3e:	7fb3      	ldrb	r3, [r6, #30]
 8009d40:	f013 0f08 	tst.w	r3, #8
 8009d44:	8ef3      	ldrh	r3, [r6, #54]	; 0x36
 8009d46:	bf1c      	itt	ne
 8009d48:	3b0c      	subne	r3, #12
 8009d4a:	b29b      	uxthne	r3, r3
    if(len > (2 * mss)) {
 8009d4c:	005b      	lsls	r3, r3, #1
 8009d4e:	429d      	cmp	r5, r3
      len = 2 * mss;
 8009d50:	bfc8      	it	gt
 8009d52:	b29d      	uxthgt	r5, r3
   err_t err;
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
 8009d54:	2300      	movs	r3, #0
 8009d56:	462a      	mov	r2, r5
 8009d58:	4639      	mov	r1, r7
 8009d5a:	4630      	mov	r0, r6
 8009d5c:	f7fc fb52 	bl	8006404 <tcp_write>
     if (err == ERR_MEM) {
 8009d60:	1c43      	adds	r3, r0, #1
 8009d62:	d048      	beq.n	8009df6 <http_send_data+0x152>
    if(len > (2 * mss)) {
      len = 2 * mss;
    }

    err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
    if (err == ERR_OK) {
 8009d64:	2800      	cmp	r0, #0
 8009d66:	d150      	bne.n	8009e0a <http_send_data+0x166>
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
        data_to_send = true;
        hs->file += len;
 8009d68:	6862      	ldr	r2, [r4, #4]
        hs->left -= len;
 8009d6a:	6963      	ldr	r3, [r4, #20]
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
        data_to_send = true;
        hs->file += len;
 8009d6c:	442a      	add	r2, r5
        hs->left -= len;
 8009d6e:	1b5d      	subs	r5, r3, r5
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
        data_to_send = true;
        hs->file += len;
 8009d70:	6062      	str	r2, [r4, #4]
        hs->left -= len;
 8009d72:	6165      	str	r5, [r4, #20]
        len = 2 * tcp_mss(pcb);
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
        data_to_send = true;
 8009d74:	f04f 0801 	mov.w	r8, #1
      }
    }
  }
#endif /* LWIP_HTTPD_SSI */

  if((hs->left == 0) && (fs_bytes_left(hs->handle) <= 0)) {
 8009d78:	b11d      	cbz	r5, 8009d82 <http_send_data+0xde>
    LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
    http_close_conn(pcb, hs);
    return 0;
  }
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("send_data end.\n"));
  return data_to_send;
 8009d7a:	4640      	mov	r0, r8
}
 8009d7c:	b005      	add	sp, #20
 8009d7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
    }
  }
#endif /* LWIP_HTTPD_SSI */

  if((hs->left == 0) && (fs_bytes_left(hs->handle) <= 0)) {
 8009d82:	6820      	ldr	r0, [r4, #0]
 8009d84:	f7ff ff18 	bl	8009bb8 <fs_bytes_left>
 8009d88:	2800      	cmp	r0, #0
 8009d8a:	dcf6      	bgt.n	8009d7a <http_send_data+0xd6>
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 8009d8c:	4629      	mov	r1, r5
 8009d8e:	4630      	mov	r0, r6
 8009d90:	e102      	b.n	8009f98 <http_send_data+0x2f4>

    /* How much data could we send? */
    len = tcp_sndbuf(pcb);

    /* Do we have remaining data to send before parsing more? */
    if(hs->parsed > hs->file) {
 8009d92:	69cb      	ldr	r3, [r1, #28]
 8009d94:	f8d1 8004 	ldr.w	r8, [r1, #4]
     * them with insert strings. We need to be careful here since a tag may
     * straddle the boundary of two blocks read from the file and we may also
     * have to split the insert string between two tcp_write operations. */

    /* How much data could we send? */
    len = tcp_sndbuf(pcb);
 8009d98:	f8b0 5066 	ldrh.w	r5, [r0, #102]	; 0x66

    /* Do we have remaining data to send before parsing more? */
    if(hs->parsed > hs->file) {
 8009d9c:	4543      	cmp	r3, r8
 8009d9e:	f240 824f 	bls.w	800a240 <http_send_data+0x59c>
      /* We cannot send more data than space available in the send
         buffer. */
      if (tcp_sndbuf(pcb) < (hs->parsed - hs->file)) {
 8009da2:	ebc8 0303 	rsb	r3, r8, r3
 8009da6:	429d      	cmp	r5, r3
        len = tcp_sndbuf(pcb);
      } else {
        LWIP_ASSERT("Data size does not fit into u16_t!",
                    (hs->parsed - hs->file) <= 0xffff);
        len = (u16_t)(hs->parsed - hs->file);
 8009da8:	bfa8      	it	ge
 8009daa:	b29d      	uxthge	r5, r3
      }
      mss = tcp_mss(pcb);
 8009dac:	7f83      	ldrb	r3, [r0, #30]
 8009dae:	f013 0f08 	tst.w	r3, #8
 8009db2:	8ec3      	ldrh	r3, [r0, #54]	; 0x36
 8009db4:	bf1c      	itt	ne
 8009db6:	3b0c      	subne	r3, #12
 8009db8:	b29b      	uxthne	r3, r3
      if(len > (2 * mss)) {
 8009dba:	005b      	lsls	r3, r3, #1
 8009dbc:	42ab      	cmp	r3, r5
        len = 2 * mss;
 8009dbe:	bfb8      	it	lt
 8009dc0:	b29d      	uxthlt	r5, r3
   err_t err;
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
 8009dc2:	4641      	mov	r1, r8
 8009dc4:	2301      	movs	r3, #1
 8009dc6:	462a      	mov	r2, r5
 8009dc8:	4630      	mov	r0, r6
 8009dca:	f7fc fb1b 	bl	8006404 <tcp_write>
     if (err == ERR_MEM) {
 8009dce:	1c41      	adds	r1, r0, #1
 8009dd0:	d021      	beq.n	8009e16 <http_send_data+0x172>
 8009dd2:	4607      	mov	r7, r0
      if(len > (2 * mss)) {
        len = 2 * mss;
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
 8009dd4:	2800      	cmp	r0, #0
 8009dd6:	f040 8229 	bne.w	800a22c <http_send_data+0x588>
        data_to_send = true;
        hs->file += len;
 8009dda:	6862      	ldr	r2, [r4, #4]
        hs->left -= len;
 8009ddc:	6963      	ldr	r3, [r4, #20]
 8009dde:	f8b6 1066 	ldrh.w	r1, [r6, #102]	; 0x66
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
        data_to_send = true;
        hs->file += len;
 8009de2:	442a      	add	r2, r5
        hs->left -= len;
 8009de4:	1b5b      	subs	r3, r3, r5
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
        data_to_send = true;
        hs->file += len;
 8009de6:	6062      	str	r2, [r4, #4]
        hs->left -= len;
 8009de8:	6163      	str	r3, [r4, #20]
        len = 2 * mss;
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
        data_to_send = true;
 8009dea:	f04f 0801 	mov.w	r8, #1
        hs->file += len;
        hs->left -= len;
      }

      /* If the send buffer is full, return now. */
      if(tcp_sndbuf(pcb) == 0) {
 8009dee:	2900      	cmp	r1, #0
 8009df0:	d0c3      	beq.n	8009d7a <http_send_data+0xd6>
 8009df2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009df4:	e783      	b.n	8009cfe <http_send_data+0x5a>
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 8009df6:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
           (pcb->snd_queuelen >= TCP_SND_QUEUELEN)) {
         /* no need to try smaller sizes */
         len = 1;
       } else {
         len /= 2;
 8009dfa:	086d      	lsrs	r5, r5, #1
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 8009dfc:	b12b      	cbz	r3, 8009e0a <http_send_data+0x166>
 8009dfe:	f8b6 3068 	ldrh.w	r3, [r6, #104]	; 0x68
 8009e02:	2b07      	cmp	r3, #7
 8009e04:	d801      	bhi.n	8009e0a <http_send_data+0x166>
         len = 1;
       } else {
         len /= 2;
       }
     }
   } while ((err == ERR_MEM) && (len > 1));
 8009e06:	2d01      	cmp	r5, #1
 8009e08:	d8a4      	bhi.n	8009d54 <http_send_data+0xb0>
 8009e0a:	6965      	ldr	r5, [r4, #20]
static u8_t http_send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
  err_t err;
  u16_t len;
  u16_t mss;
  u8_t data_to_send = false;
 8009e0c:	f04f 0800 	mov.w	r8, #0
      }
    }
  }
#endif /* LWIP_HTTPD_SSI */

  if((hs->left == 0) && (fs_bytes_left(hs->handle) <= 0)) {
 8009e10:	2d00      	cmp	r5, #0
 8009e12:	d1b2      	bne.n	8009d7a <http_send_data+0xd6>
 8009e14:	e7b5      	b.n	8009d82 <http_send_data+0xde>
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 8009e16:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
           (pcb->snd_queuelen >= TCP_SND_QUEUELEN)) {
         /* no need to try smaller sizes */
         len = 1;
       } else {
         len /= 2;
 8009e1a:	086d      	lsrs	r5, r5, #1
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 8009e1c:	2b00      	cmp	r3, #0
 8009e1e:	f000 817f 	beq.w	800a120 <http_send_data+0x47c>
 8009e22:	f8b6 3068 	ldrh.w	r3, [r6, #104]	; 0x68
 8009e26:	2b07      	cmp	r3, #7
 8009e28:	f200 81c4 	bhi.w	800a1b4 <http_send_data+0x510>
         len = 1;
       } else {
         len /= 2;
       }
     }
   } while ((err == ERR_MEM) && (len > 1));
 8009e2c:	2d01      	cmp	r5, #1
 8009e2e:	d8c8      	bhi.n	8009dc2 <http_send_data+0x11e>
 8009e30:	4607      	mov	r7, r0
 8009e32:	e1c1      	b.n	800a1b8 <http_send_data+0x514>
         * from the file prior to the insert point or the insert string itself.
         */
        case TAG_SENDING:
          /* Do we have any remaining file data to send from the buffer prior
           * to the tag? */
          if(hs->tag_end > hs->file) {
 8009e34:	6a22      	ldr	r2, [r4, #32]
 8009e36:	f8d4 9004 	ldr.w	r9, [r4, #4]
 8009e3a:	454a      	cmp	r2, r9
 8009e3c:	f240 80e0 	bls.w	800a000 <http_send_data+0x35c>
            /* How much of the data can we send? */
#if LWIP_HTTPD_SSI_INCLUDE_TAG
            if(len > hs->tag_end - hs->file) {
 8009e40:	ebc9 0202 	rsb	r2, r9, r2
 8009e44:	4295      	cmp	r5, r2
 8009e46:	f300 8156 	bgt.w	800a0f6 <http_send_data+0x452>
              /* we would include the tag in sending */
              len = (u16_t)(hs->tag_started - hs->file);
            }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/
            if (len != 0) {
              err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 8009e4a:	f894 a02c 	ldrb.w	sl, [r4, #44]	; 0x2c
 8009e4e:	f11a 0a00 	adds.w	sl, sl, #0
 8009e52:	bf18      	it	ne
 8009e54:	f04f 0a01 	movne.w	sl, #1
   err_t err;
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
 8009e58:	4649      	mov	r1, r9
 8009e5a:	4653      	mov	r3, sl
 8009e5c:	462a      	mov	r2, r5
 8009e5e:	4630      	mov	r0, r6
 8009e60:	f7fc fad0 	bl	8006404 <tcp_write>
     if (err == ERR_MEM) {
 8009e64:	1c41      	adds	r1, r0, #1
 8009e66:	f000 8108 	beq.w	800a07a <http_send_data+0x3d6>
            if (len != 0) {
              err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
            } else {
              err = ERR_OK;
            }
            if (err == ERR_OK) {
 8009e6a:	2800      	cmp	r0, #0
 8009e6c:	f000 82bc 	beq.w	800a3e8 <http_send_data+0x744>
 8009e70:	4607      	mov	r7, r0
 8009e72:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009e74:	2b00      	cmp	r3, #0
 8009e76:	f47f af47 	bne.w	8009d08 <http_send_data+0x64>
    }

    /* If we drop out of the end of the for loop, this implies we must have
     * file data to send so send it now. In TAG_SENDING state, we've already
     * handled this so skip the send if that's the case. */
    if((hs->tag_state != TAG_SENDING) && (hs->parsed > hs->file)) {
 8009e7a:	f894 30f1 	ldrb.w	r3, [r4, #241]	; 0xf1
 8009e7e:	2b04      	cmp	r3, #4
 8009e80:	d026      	beq.n	8009ed0 <http_send_data+0x22c>
 8009e82:	69e3      	ldr	r3, [r4, #28]
 8009e84:	6867      	ldr	r7, [r4, #4]
 8009e86:	42bb      	cmp	r3, r7
 8009e88:	d922      	bls.n	8009ed0 <http_send_data+0x22c>
      /* We cannot send more data than space available in the send
         buffer. */
      if (tcp_sndbuf(pcb) < (hs->parsed - hs->file)) {
 8009e8a:	f8b6 5066 	ldrh.w	r5, [r6, #102]	; 0x66
 8009e8e:	1bdb      	subs	r3, r3, r7
 8009e90:	429d      	cmp	r5, r3
        len = tcp_sndbuf(pcb);
      } else {
        LWIP_ASSERT("Data size does not fit into u16_t!",
                    (hs->parsed - hs->file) <= 0xffff);
        len = (u16_t)(hs->parsed - hs->file);
 8009e92:	bfa8      	it	ge
 8009e94:	b29d      	uxthge	r5, r3
      }
      if(len > (2 * tcp_mss(pcb))) {
 8009e96:	7fb3      	ldrb	r3, [r6, #30]
 8009e98:	f013 0f08 	tst.w	r3, #8
 8009e9c:	8ef3      	ldrh	r3, [r6, #54]	; 0x36
 8009e9e:	f040 818e 	bne.w	800a1be <http_send_data+0x51a>
 8009ea2:	005b      	lsls	r3, r3, #1
 8009ea4:	42ab      	cmp	r3, r5
 8009ea6:	da00      	bge.n	8009eaa <http_send_data+0x206>
        len = 2 * tcp_mss(pcb);
 8009ea8:	b29d      	uxth	r5, r3
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 8009eaa:	f894 902c 	ldrb.w	r9, [r4, #44]	; 0x2c
 8009eae:	f119 0900 	adds.w	r9, r9, #0
 8009eb2:	bf18      	it	ne
 8009eb4:	f04f 0901 	movne.w	r9, #1
   err_t err;
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
 8009eb8:	464b      	mov	r3, r9
 8009eba:	462a      	mov	r2, r5
 8009ebc:	4639      	mov	r1, r7
 8009ebe:	4630      	mov	r0, r6
 8009ec0:	f7fc faa0 	bl	8006404 <tcp_write>
     if (err == ERR_MEM) {
 8009ec4:	1c43      	adds	r3, r0, #1
 8009ec6:	f000 8180 	beq.w	800a1ca <http_send_data+0x526>
      if(len > (2 * tcp_mss(pcb))) {
        len = 2 * tcp_mss(pcb);
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
 8009eca:	2800      	cmp	r0, #0
 8009ecc:	f43f af4c 	beq.w	8009d68 <http_send_data+0xc4>
 8009ed0:	6965      	ldr	r5, [r4, #20]
      }
    }
  }
#endif /* LWIP_HTTPD_SSI */

  if((hs->left == 0) && (fs_bytes_left(hs->handle) <= 0)) {
 8009ed2:	2d00      	cmp	r5, #0
 8009ed4:	f47f af51 	bne.w	8009d7a <http_send_data+0xd6>
 8009ed8:	e753      	b.n	8009d82 <http_send_data+0xde>

        /* We are looking for the end of the lead-out marker. */
        case TAG_LEADOUT:
          /* Remove leading whitespace between the tag leading and the first
           * tag leadout character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 8009eda:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8009edc:	69e2      	ldr	r2, [r4, #28]
 8009ede:	2900      	cmp	r1, #0
 8009ee0:	f040 80ba 	bne.w	800a058 <http_send_data+0x3b4>
 8009ee4:	f892 e000 	ldrb.w	lr, [r2]
 8009ee8:	f1ae 0009 	sub.w	r0, lr, #9
 8009eec:	b2c0      	uxtb	r0, r0
 8009eee:	2817      	cmp	r0, #23
 8009ef0:	f240 80d9 	bls.w	800a0a6 <http_send_data+0x402>
            hs->parsed++;
            break;
          }

          /* Have we found the next character we expect for the tag leadout? */
          if(*hs->parsed == g_pcTagLeadOut[hs->tag_index]) {
 8009ef4:	f1be 0f2d 	cmp.w	lr, #45	; 0x2d
 8009ef8:	f000 819d 	beq.w	800a236 <http_send_data+0x592>
              hs->tag_index++;
            }
          } else {
            /* We found an unexpected character so this is not a tag. Move
             * back to idle state. */
            hs->parse_left--;
 8009efc:	3b01      	subs	r3, #1
            hs->parsed++;
 8009efe:	3201      	adds	r2, #1
            hs->tag_state = TAG_NONE;
 8009f00:	2100      	movs	r1, #0
              hs->tag_index++;
            }
          } else {
            /* We found an unexpected character so this is not a tag. Move
             * back to idle state. */
            hs->parse_left--;
 8009f02:	6263      	str	r3, [r4, #36]	; 0x24
            hs->parsed++;
 8009f04:	61e2      	str	r2, [r4, #28]
            hs->tag_state = TAG_NONE;
 8009f06:	f884 10f1 	strb.w	r1, [r4, #241]	; 0xf1
 8009f0a:	e6fa      	b.n	8009d02 <http_send_data+0x5e>
          /* We are reading the tag name, looking for the start of the
           * lead-out marker and removing any whitespace found. */

          /* Remove leading whitespace between the tag leading and the first
           * tag name character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 8009f0c:	8d20      	ldrh	r0, [r4, #40]	; 0x28
 8009f0e:	69e1      	ldr	r1, [r4, #28]
 8009f10:	2800      	cmp	r0, #0
 8009f12:	d16f      	bne.n	8009ff4 <http_send_data+0x350>
 8009f14:	f891 e000 	ldrb.w	lr, [r1]
 8009f18:	f1ae 0209 	sub.w	r2, lr, #9
 8009f1c:	b2d2      	uxtb	r2, r2
 8009f1e:	2a17      	cmp	r2, #23
 8009f20:	f240 80b8 	bls.w	800a094 <http_send_data+0x3f0>
            break;
          }

          /* Have we found the end of the tag name? This is signalled by
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
 8009f24:	f1be 0f2d 	cmp.w	lr, #45	; 0x2d
 8009f28:	d00a      	beq.n	8009f40 <http_send_data+0x29c>
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
 8009f2a:	2a17      	cmp	r2, #23
 8009f2c:	d82b      	bhi.n	8009f86 <http_send_data+0x2e2>
 8009f2e:	f8df e324 	ldr.w	lr, [pc, #804]	; 800a254 <http_send_data+0x5b0>
 8009f32:	fa2e f202 	lsr.w	r2, lr, r2
 8009f36:	07d2      	lsls	r2, r2, #31
 8009f38:	d525      	bpl.n	8009f86 <http_send_data+0x2e2>
             (*hs->parsed == '\n')  || (*hs->parsed == '\r')) {

            if(hs->tag_index == 0) {
 8009f3a:	2800      	cmp	r0, #0
 8009f3c:	f040 80c5 	bne.w	800a0ca <http_send_data+0x426>
            /* This character is part of the tag name so save it */
            if(hs->tag_index < LWIP_HTTPD_MAX_TAG_NAME_LEN) {
              hs->tag_name[hs->tag_index++] = *hs->parsed;
            } else {
              /* The tag was too long so ignore it. */
              hs->tag_state = TAG_NONE;
 8009f40:	2200      	movs	r2, #0
 8009f42:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
            }
          }

          /* Move on to the next character in the buffer */
          hs->parse_left--;
 8009f46:	3b01      	subs	r3, #1
          hs->parsed++;
 8009f48:	3101      	adds	r1, #1
              hs->tag_state = TAG_NONE;
            }
          }

          /* Move on to the next character in the buffer */
          hs->parse_left--;
 8009f4a:	6263      	str	r3, [r4, #36]	; 0x24
          hs->parsed++;
 8009f4c:	61e1      	str	r1, [r4, #28]

          break;
 8009f4e:	e6d8      	b.n	8009d02 <http_send_data+0x5e>
      }
      switch(hs->tag_state) {
        case TAG_NONE:
          /* We are not currently processing an SSI tag so scan for the
           * start of the lead-in marker. */
          if(*hs->parsed == g_pcTagLeadIn[0]) {
 8009f50:	69e2      	ldr	r2, [r4, #28]
 8009f52:	7811      	ldrb	r1, [r2, #0]
 8009f54:	293c      	cmp	r1, #60	; 0x3c
 8009f56:	f000 80ad 	beq.w	800a0b4 <http_send_data+0x410>
           * tag leadout character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
             (*hs->parsed == '\r'))) {
            /* Move on to the next character in the buffer */
            hs->parse_left--;
 8009f5a:	3b01      	subs	r3, #1
            hs->parsed++;
 8009f5c:	3201      	adds	r2, #1
           * tag leadout character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
             (*hs->parsed == '\r'))) {
            /* Move on to the next character in the buffer */
            hs->parse_left--;
 8009f5e:	6263      	str	r3, [r4, #36]	; 0x24
            hs->parsed++;
 8009f60:	61e2      	str	r2, [r4, #28]
            break;
 8009f62:	e6ce      	b.n	8009d02 <http_send_data+0x5e>
        case TAG_LEADIN:
          /* We are processing the lead-in marker, looking for the start of
           * the tag name. */

          /* Have we reached the end of the leadin? */
          if(hs->tag_index == LEN_TAG_LEAD_IN) {
 8009f64:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8009f66:	2905      	cmp	r1, #5
 8009f68:	f000 80a9 	beq.w	800a0be <http_send_data+0x41a>
            hs->tag_index = 0;
            hs->tag_state = TAG_FOUND;
          } else {
            /* Have we found the next character we expect for the tag leadin? */
            if(*hs->parsed == g_pcTagLeadIn[hs->tag_index]) {
 8009f6c:	69e2      	ldr	r2, [r4, #28]
 8009f6e:	48b7      	ldr	r0, [pc, #732]	; (800a24c <http_send_data+0x5a8>)
 8009f70:	f892 e000 	ldrb.w	lr, [r2]
 8009f74:	5c08      	ldrb	r0, [r1, r0]
 8009f76:	4586      	cmp	lr, r0
              /* Yes - move to the next one unless we have found the complete
               * leadin, in which case we start looking for the tag itself */
              hs->tag_index++;
 8009f78:	bf0b      	itete	eq
 8009f7a:	3101      	addeq	r1, #1
            } else {
              /* We found an unexpected character so this is not a tag. Move
               * back to idle state. */
              hs->tag_state = TAG_NONE;
 8009f7c:	2100      	movne	r1, #0
          } else {
            /* Have we found the next character we expect for the tag leadin? */
            if(*hs->parsed == g_pcTagLeadIn[hs->tag_index]) {
              /* Yes - move to the next one unless we have found the complete
               * leadin, in which case we start looking for the tag itself */
              hs->tag_index++;
 8009f7e:	8521      	strheq	r1, [r4, #40]	; 0x28
            } else {
              /* We found an unexpected character so this is not a tag. Move
               * back to idle state. */
              hs->tag_state = TAG_NONE;
 8009f80:	f884 10f1 	strbne.w	r1, [r4, #241]	; 0xf1
 8009f84:	e7e9      	b.n	8009f5a <http_send_data+0x2b6>
                hs->tag_index = 0;
              }
            }
          } else {
            /* This character is part of the tag name so save it */
            if(hs->tag_index < LWIP_HTTPD_MAX_TAG_NAME_LEN) {
 8009f86:	2800      	cmp	r0, #0
 8009f88:	d1da      	bne.n	8009f40 <http_send_data+0x29c>
              hs->tag_name[hs->tag_index++] = *hs->parsed;
 8009f8a:	2201      	movs	r2, #1
 8009f8c:	8522      	strh	r2, [r4, #40]	; 0x28
 8009f8e:	780a      	ldrb	r2, [r1, #0]
 8009f90:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
 8009f94:	e7d7      	b.n	8009f46 <http_send_data+0x2a2>
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 8009f96:	4629      	mov	r1, r5
 8009f98:	f7fa fd76 	bl	8004a88 <tcp_arg>
  tcp_recv(pcb, NULL);
 8009f9c:	4629      	mov	r1, r5
 8009f9e:	4630      	mov	r0, r6
 8009fa0:	f7fa fd74 	bl	8004a8c <tcp_recv>
  tcp_err(pcb, NULL);
 8009fa4:	4629      	mov	r1, r5
 8009fa6:	4630      	mov	r0, r6
 8009fa8:	f7fa fd74 	bl	8004a94 <tcp_err>
  tcp_poll(pcb, NULL, 0);
 8009fac:	462a      	mov	r2, r5
 8009fae:	4629      	mov	r1, r5
 8009fb0:	4630      	mov	r0, r6
 8009fb2:	f7fa fd75 	bl	8004aa0 <tcp_poll>
  tcp_sent(pcb, NULL);
 8009fb6:	4630      	mov	r0, r6
 8009fb8:	4629      	mov	r1, r5
 8009fba:	f7fa fd69 	bl	8004a90 <tcp_sent>
 * Also frees the file data if dynamic.
 */
static void http_state_free(struct http_state *hs)
{
  if (hs != NULL) {
    if(hs->handle) {
 8009fbe:	6820      	ldr	r0, [r4, #0]
 8009fc0:	b110      	cbz	r0, 8009fc8 <http_send_data+0x324>
      u32_t ms_needed = sys_now() - hs->time_started;
      u32_t needed = LWIP_MAX(1, (ms_needed/100));
      LWIP_DEBUGF(HTTPD_DEBUG_TIMING, ("httpd: needed %"U32_F" ms to send file of %d bytes -> %"U32_F" bytes/sec\n",
        ms_needed, hs->handle->len, ((((u32_t)hs->handle->len) * 10) / needed)));
#endif /* LWIP_HTTPD_TIMING */
      fs_close(hs->handle);
 8009fc2:	f7ff fd9b 	bl	8009afc <fs_close>
      hs->handle = NULL;
 8009fc6:	6025      	str	r5, [r4, #0]
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    if (hs->buf != NULL) {
 8009fc8:	68e0      	ldr	r0, [r4, #12]
 8009fca:	b118      	cbz	r0, 8009fd4 <http_send_data+0x330>
      mem_free(hs->buf);
 8009fcc:	f7f9 fce4 	bl	8003998 <mem_free>
      hs->buf = NULL;
 8009fd0:	2300      	movs	r3, #0
 8009fd2:	60e3      	str	r3, [r4, #12]
    }
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
#if HTTPD_USE_MEM_POOL
    memp_free(MEMP_HTTPD_STATE, hs);
#else /* HTTPD_USE_MEM_POOL */
    mem_free(hs);
 8009fd4:	4620      	mov	r0, r4
 8009fd6:	f7f9 fcdf 	bl	8003998 <mem_free>
  tcp_err(pcb, NULL);
  tcp_poll(pcb, NULL, 0);
  tcp_sent(pcb, NULL);
  http_state_free(hs);

  err = tcp_close(pcb);
 8009fda:	4630      	mov	r0, r6
 8009fdc:	f7fb f968 	bl	80052b0 <tcp_close>
  if (err != ERR_OK) {
 8009fe0:	b120      	cbz	r0, 8009fec <http_send_data+0x348>
    LWIP_DEBUGF(HTTPD_DEBUG, ("Error %d closing %p\n", err, (void*)pcb));
    /* error closing, try again later in poll */
    tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 8009fe2:	4630      	mov	r0, r6
 8009fe4:	2204      	movs	r2, #4
 8009fe6:	499a      	ldr	r1, [pc, #616]	; (800a250 <http_send_data+0x5ac>)
 8009fe8:	f7fa fd5a 	bl	8004aa0 <tcp_poll>

    /* Do we have a valid file handle? */
    if (hs->handle == NULL) {
      /* No - close the connection. */
      http_close_conn(pcb, hs);
      return 0;
 8009fec:	2000      	movs	r0, #0
    http_close_conn(pcb, hs);
    return 0;
  }
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("send_data end.\n"));
  return data_to_send;
}
 8009fee:	b005      	add	sp, #20
 8009ff0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            break;
          }

          /* Have we found the end of the tag name? This is signalled by
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
 8009ff4:	780a      	ldrb	r2, [r1, #0]
 8009ff6:	2a2d      	cmp	r2, #45	; 0x2d
 8009ff8:	d067      	beq.n	800a0ca <http_send_data+0x426>
 8009ffa:	3a09      	subs	r2, #9
 8009ffc:	b2d2      	uxtb	r2, r2
 8009ffe:	e794      	b.n	8009f2a <http_send_data+0x286>
              }
            }
#endif /* LWIP_HTTPD_SSI_MULTIPART */

            /* Do we still have insert data left to send? */
            if(hs->tag_index < hs->tag_insert_len) {
 800a000:	f8b4 9028 	ldrh.w	r9, [r4, #40]	; 0x28
 800a004:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 800a006:	4591      	cmp	r9, r2
 800a008:	d270      	bcs.n	800a0ec <http_send_data+0x448>
              /* We are sending the insert string itself. How much of the
               * insert can we send? */
              if(len > (hs->tag_insert_len - hs->tag_index)) {
 800a00a:	ebc9 0202 	rsb	r2, r9, r2
 800a00e:	4295      	cmp	r5, r2

              /* Note that we set the copy flag here since we only have a
               * single tag insert buffer per connection. If we don't do
               * this, insert corruption can occur if more than one insert
               * is processed before we call tcp_output. */
              err = http_write(pcb, &(hs->tag_insert[hs->tag_index]), &len,
 800a010:	f109 0930 	add.w	r9, r9, #48	; 0x30
            /* Do we still have insert data left to send? */
            if(hs->tag_index < hs->tag_insert_len) {
              /* We are sending the insert string itself. How much of the
               * insert can we send? */
              if(len > (hs->tag_insert_len - hs->tag_index)) {
                len = (hs->tag_insert_len - hs->tag_index);
 800a014:	bfc8      	it	gt
 800a016:	b295      	uxthgt	r5, r2

              /* Note that we set the copy flag here since we only have a
               * single tag insert buffer per connection. If we don't do
               * this, insert corruption can occur if more than one insert
               * is processed before we call tcp_output. */
              err = http_write(pcb, &(hs->tag_insert[hs->tag_index]), &len,
 800a018:	44a1      	add	r9, r4
   err_t err;
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
 800a01a:	462a      	mov	r2, r5
 800a01c:	2301      	movs	r3, #1
 800a01e:	4649      	mov	r1, r9
 800a020:	4630      	mov	r0, r6
 800a022:	f7fc f9ef 	bl	8006404 <tcp_write>
     if (err == ERR_MEM) {
 800a026:	1c42      	adds	r2, r0, #1
 800a028:	d00a      	beq.n	800a040 <http_send_data+0x39c>
 800a02a:	4607      	mov	r7, r0
               * single tag insert buffer per connection. If we don't do
               * this, insert corruption can occur if more than one insert
               * is processed before we call tcp_output. */
              err = http_write(pcb, &(hs->tag_insert[hs->tag_index]), &len,
                               HTTP_IS_TAG_VOLATILE(hs));
              if (err == ERR_OK) {
 800a02c:	2800      	cmp	r0, #0
 800a02e:	f47f af20 	bne.w	8009e72 <http_send_data+0x1ce>
                data_to_send = true;
                hs->tag_index += len;
 800a032:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 800a034:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a036:	442a      	add	r2, r5
 800a038:	8522      	strh	r2, [r4, #40]	; 0x28
               * this, insert corruption can occur if more than one insert
               * is processed before we call tcp_output. */
              err = http_write(pcb, &(hs->tag_insert[hs->tag_index]), &len,
                               HTTP_IS_TAG_VOLATILE(hs));
              if (err == ERR_OK) {
                data_to_send = true;
 800a03a:	f04f 0801 	mov.w	r8, #1
 800a03e:	e660      	b.n	8009d02 <http_send_data+0x5e>
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a040:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
           (pcb->snd_queuelen >= TCP_SND_QUEUELEN)) {
         /* no need to try smaller sizes */
         len = 1;
       } else {
         len /= 2;
 800a044:	086d      	lsrs	r5, r5, #1
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a046:	2b00      	cmp	r3, #0
 800a048:	d062      	beq.n	800a110 <http_send_data+0x46c>
 800a04a:	f8b6 3068 	ldrh.w	r3, [r6, #104]	; 0x68
 800a04e:	2b07      	cmp	r3, #7
 800a050:	d85e      	bhi.n	800a110 <http_send_data+0x46c>
         len = 1;
       } else {
         len /= 2;
       }
     }
   } while ((err == ERR_MEM) && (len > 1));
 800a052:	2d01      	cmp	r5, #1
 800a054:	d8e1      	bhi.n	800a01a <http_send_data+0x376>
 800a056:	e70b      	b.n	8009e70 <http_send_data+0x1cc>
            hs->parsed++;
            break;
          }

          /* Have we found the next character we expect for the tag leadout? */
          if(*hs->parsed == g_pcTagLeadOut[hs->tag_index]) {
 800a058:	f811 000b 	ldrb.w	r0, [r1, fp]
 800a05c:	f892 e000 	ldrb.w	lr, [r2]
 800a060:	4586      	cmp	lr, r0
 800a062:	f47f af4b 	bne.w	8009efc <http_send_data+0x258>
            /* Yes - move to the next one unless we have found the complete
             * leadout, in which case we need to call the client to process
             * the tag. */

            /* Move on to the next character in the buffer */
            hs->parse_left--;
 800a066:	3b01      	subs	r3, #1
            hs->parsed++;
 800a068:	3201      	adds	r2, #1

            if(hs->tag_index == (LEN_TAG_LEAD_OUT - 1)) {
 800a06a:	2902      	cmp	r1, #2
            /* Yes - move to the next one unless we have found the complete
             * leadout, in which case we need to call the client to process
             * the tag. */

            /* Move on to the next character in the buffer */
            hs->parse_left--;
 800a06c:	6263      	str	r3, [r4, #36]	; 0x24
            hs->parsed++;
 800a06e:	61e2      	str	r2, [r4, #28]

            if(hs->tag_index == (LEN_TAG_LEAD_OUT - 1)) {
 800a070:	f000 80f4 	beq.w	800a25c <http_send_data+0x5b8>
                  hs->file += len;
                  hs->left -= len;
                }
              }
            } else {
              hs->tag_index++;
 800a074:	3101      	adds	r1, #1
 800a076:	8521      	strh	r1, [r4, #40]	; 0x28
 800a078:	e643      	b.n	8009d02 <http_send_data+0x5e>
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a07a:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
           (pcb->snd_queuelen >= TCP_SND_QUEUELEN)) {
         /* no need to try smaller sizes */
         len = 1;
       } else {
         len /= 2;
 800a07e:	086d      	lsrs	r5, r5, #1
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a080:	2b00      	cmp	r3, #0
 800a082:	d045      	beq.n	800a110 <http_send_data+0x46c>
 800a084:	f8b6 3068 	ldrh.w	r3, [r6, #104]	; 0x68
 800a088:	2b07      	cmp	r3, #7
 800a08a:	d841      	bhi.n	800a110 <http_send_data+0x46c>
         len = 1;
       } else {
         len /= 2;
       }
     }
   } while ((err == ERR_MEM) && (len > 1));
 800a08c:	2d01      	cmp	r5, #1
 800a08e:	f63f aee3 	bhi.w	8009e58 <http_send_data+0x1b4>
 800a092:	e6ed      	b.n	8009e70 <http_send_data+0x1cc>
          /* We are reading the tag name, looking for the start of the
           * lead-out marker and removing any whitespace found. */

          /* Remove leading whitespace between the tag leading and the first
           * tag name character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 800a094:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 800a254 <http_send_data+0x5b0>
 800a098:	fa2e fe02 	lsr.w	lr, lr, r2
 800a09c:	f01e 0f01 	tst.w	lr, #1
 800a0a0:	f47f af51 	bne.w	8009f46 <http_send_data+0x2a2>
 800a0a4:	e741      	b.n	8009f2a <http_send_data+0x286>

        /* We are looking for the end of the lead-out marker. */
        case TAG_LEADOUT:
          /* Remove leading whitespace between the tag leading and the first
           * tag leadout character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 800a0a6:	496b      	ldr	r1, [pc, #428]	; (800a254 <http_send_data+0x5b0>)
 800a0a8:	fa21 f000 	lsr.w	r0, r1, r0
 800a0ac:	07c1      	lsls	r1, r0, #31
 800a0ae:	f57f af25 	bpl.w	8009efc <http_send_data+0x258>
 800a0b2:	e752      	b.n	8009f5a <http_send_data+0x2b6>
          /* We are not currently processing an SSI tag so scan for the
           * start of the lead-in marker. */
          if(*hs->parsed == g_pcTagLeadIn[0]) {
            /* We found what could be the lead-in for a new tag so change
             * state appropriately. */
            hs->tag_state = TAG_LEADIN;
 800a0b4:	2101      	movs	r1, #1
 800a0b6:	f884 10f1 	strb.w	r1, [r4, #241]	; 0xf1
            hs->tag_index = 1;
 800a0ba:	8521      	strh	r1, [r4, #40]	; 0x28
 800a0bc:	e74d      	b.n	8009f5a <http_send_data+0x2b6>
          /* We are processing the lead-in marker, looking for the start of
           * the tag name. */

          /* Have we reached the end of the leadin? */
          if(hs->tag_index == LEN_TAG_LEAD_IN) {
            hs->tag_index = 0;
 800a0be:	2100      	movs	r1, #0
            hs->tag_state = TAG_FOUND;
 800a0c0:	2202      	movs	r2, #2
          /* We are processing the lead-in marker, looking for the start of
           * the tag name. */

          /* Have we reached the end of the leadin? */
          if(hs->tag_index == LEN_TAG_LEAD_IN) {
            hs->tag_index = 0;
 800a0c2:	8521      	strh	r1, [r4, #40]	; 0x28
            hs->tag_state = TAG_FOUND;
 800a0c4:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
 800a0c8:	e61b      	b.n	8009d02 <http_send_data+0x5e>
              /* We read a non-empty tag so go ahead and look for the
               * leadout string. */
              hs->tag_state = TAG_LEADOUT;
              LWIP_ASSERT("hs->tag_index <= 0xff", hs->tag_index <= 0xff);
              hs->tag_name_len = (u8_t)hs->tag_index;
              hs->tag_name[hs->tag_index] = '\0';
 800a0ca:	eb04 0e00 	add.w	lr, r4, r0
 800a0ce:	2200      	movs	r2, #0
              /* We read a zero length tag so ignore it. */
              hs->tag_state = TAG_NONE;
            } else {
              /* We read a non-empty tag so go ahead and look for the
               * leadout string. */
              hs->tag_state = TAG_LEADOUT;
 800a0d0:	f04f 0c03 	mov.w	ip, #3
              LWIP_ASSERT("hs->tag_index <= 0xff", hs->tag_index <= 0xff);
              hs->tag_name_len = (u8_t)hs->tag_index;
 800a0d4:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
              /* We read a zero length tag so ignore it. */
              hs->tag_state = TAG_NONE;
            } else {
              /* We read a non-empty tag so go ahead and look for the
               * leadout string. */
              hs->tag_state = TAG_LEADOUT;
 800a0d8:	f884 c0f1 	strb.w	ip, [r4, #241]	; 0xf1
              LWIP_ASSERT("hs->tag_index <= 0xff", hs->tag_index <= 0xff);
              hs->tag_name_len = (u8_t)hs->tag_index;
              hs->tag_name[hs->tag_index] = '\0';
 800a0dc:	f88e 202e 	strb.w	r2, [lr, #46]	; 0x2e
              if(*hs->parsed == g_pcTagLeadOut[0]) {
 800a0e0:	7808      	ldrb	r0, [r1, #0]
 800a0e2:	282d      	cmp	r0, #45	; 0x2d
                hs->tag_index = 1;
 800a0e4:	bf08      	it	eq
 800a0e6:	2201      	moveq	r2, #1
              } else {
                hs->tag_index = 0;
 800a0e8:	8522      	strh	r2, [r4, #40]	; 0x28
 800a0ea:	e72c      	b.n	8009f46 <http_send_data+0x2a2>
              }
            } else {
              /* We have sent all the insert data so go back to looking for
               * a new tag. */
              LWIP_DEBUGF(HTTPD_DEBUG, ("Everything sent.\n"));
              hs->tag_index = 0;
 800a0ec:	2200      	movs	r2, #0
 800a0ee:	8522      	strh	r2, [r4, #40]	; 0x28
              hs->tag_state = TAG_NONE;
 800a0f0:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
 800a0f4:	e605      	b.n	8009d02 <http_send_data+0x5e>
           * to the tag? */
          if(hs->tag_end > hs->file) {
            /* How much of the data can we send? */
#if LWIP_HTTPD_SSI_INCLUDE_TAG
            if(len > hs->tag_end - hs->file) {
              len = (u16_t)(hs->tag_end - hs->file);
 800a0f6:	b295      	uxth	r5, r2
            if (len > hs->tag_started - hs->file) {
              /* we would include the tag in sending */
              len = (u16_t)(hs->tag_started - hs->file);
            }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/
            if (len != 0) {
 800a0f8:	2d00      	cmp	r5, #0
 800a0fa:	f47f aea6 	bne.w	8009e4a <http_send_data+0x1a6>
                /* pretend to have sent the tag, too */
                len += hs->tag_end - hs->tag_started;
              }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
              hs->file += len;
              hs->left -= len;
 800a0fe:	6962      	ldr	r2, [r4, #20]
              if(hs->tag_started <= hs->file) {
                /* pretend to have sent the tag, too */
                len += hs->tag_end - hs->tag_started;
              }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
              hs->file += len;
 800a100:	eb09 0105 	add.w	r1, r9, r5
              hs->left -= len;
 800a104:	1b52      	subs	r2, r2, r5
              if(hs->tag_started <= hs->file) {
                /* pretend to have sent the tag, too */
                len += hs->tag_end - hs->tag_started;
              }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
              hs->file += len;
 800a106:	6061      	str	r1, [r4, #4]
              hs->left -= len;
 800a108:	6162      	str	r2, [r4, #20]
              err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
            } else {
              err = ERR_OK;
            }
            if (err == ERR_OK) {
              data_to_send = true;
 800a10a:	f04f 0801 	mov.w	r8, #1
 800a10e:	e5f8      	b.n	8009d02 <http_send_data+0x5e>
 800a110:	4607      	mov	r7, r0
 800a112:	6a63      	ldr	r3, [r4, #36]	; 0x24
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a114:	2501      	movs	r5, #1
 800a116:	e5f4      	b.n	8009d02 <http_send_data+0x5e>

    LWIP_DEBUGF(HTTPD_DEBUG, ("State %d, %d left\n", hs->tag_state, hs->parse_left));

    /* We have sent all the data that was already parsed so continue parsing
     * the buffer contents looking for SSI tags. */
    while((hs->parse_left) && (err == ERR_OK)) {
 800a118:	2f00      	cmp	r7, #0
 800a11a:	f43f ae2e 	beq.w	8009d7a <http_send_data+0xd6>
 800a11e:	e6ac      	b.n	8009e7a <http_send_data+0x1d6>
 800a120:	4618      	mov	r0, r3
 800a122:	e62b      	b.n	8009d7c <http_send_data+0xd8>
    if(hs->buf) {
      /* Yes - get the length of the buffer */
      count = hs->buf_len;
    } else {
      /* We don't have a send buffer so allocate one up to 2mss bytes long. */
      count = 2 * tcp_mss(pcb);
 800a124:	7fb3      	ldrb	r3, [r6, #30]
 800a126:	8ef5      	ldrh	r5, [r6, #54]	; 0x36
 800a128:	071a      	lsls	r2, r3, #28
 800a12a:	bf48      	it	mi
 800a12c:	3d0c      	submi	r5, #12
 800a12e:	006d      	lsls	r5, r5, #1
 800a130:	e003      	b.n	800a13a <http_send_data+0x496>
        hs->buf = (char*)mem_malloc((mem_size_t)count);
        if (hs->buf != NULL) {
          hs->buf_len = count;
          break;
        }
        count = count / 2;
 800a132:	105d      	asrs	r5, r3, #1
      } while (count > 100);
 800a134:	2d64      	cmp	r5, #100	; 0x64
 800a136:	f77f af59 	ble.w	8009fec <http_send_data+0x348>
      count = hs->buf_len;
    } else {
      /* We don't have a send buffer so allocate one up to 2mss bytes long. */
      count = 2 * tcp_mss(pcb);
      do {
        hs->buf = (char*)mem_malloc((mem_size_t)count);
 800a13a:	b2a8      	uxth	r0, r5
 800a13c:	f7f9 fcd2 	bl	8003ae4 <mem_malloc>
        if (hs->buf != NULL) {
          hs->buf_len = count;
          break;
        }
        count = count / 2;
 800a140:	eb05 73d5 	add.w	r3, r5, r5, lsr #31
      count = hs->buf_len;
    } else {
      /* We don't have a send buffer so allocate one up to 2mss bytes long. */
      count = 2 * tcp_mss(pcb);
      do {
        hs->buf = (char*)mem_malloc((mem_size_t)count);
 800a144:	60e0      	str	r0, [r4, #12]
        if (hs->buf != NULL) {
 800a146:	2800      	cmp	r0, #0
 800a148:	d0f3      	beq.n	800a132 <http_send_data+0x48e>
    }

    /* Read a block of data from the file. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Trying to read %d bytes.\n", count));

    count = fs_read(hs->handle, hs->buf, count);
 800a14a:	4601      	mov	r1, r0
      /* We don't have a send buffer so allocate one up to 2mss bytes long. */
      count = 2 * tcp_mss(pcb);
      do {
        hs->buf = (char*)mem_malloc((mem_size_t)count);
        if (hs->buf != NULL) {
          hs->buf_len = count;
 800a14c:	6125      	str	r5, [r4, #16]
    }

    /* Read a block of data from the file. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Trying to read %d bytes.\n", count));

    count = fs_read(hs->handle, hs->buf, count);
 800a14e:	462a      	mov	r2, r5
 800a150:	6820      	ldr	r0, [r4, #0]
 800a152:	f7ff fd17 	bl	8009b84 <fs_read>
    if(count < 0) {
 800a156:	2800      	cmp	r0, #0
 800a158:	f6bf adc3 	bge.w	8009ce2 <http_send_data+0x3e>
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 800a15c:	2100      	movs	r1, #0
 800a15e:	4630      	mov	r0, r6
 800a160:	f7fa fc92 	bl	8004a88 <tcp_arg>
  tcp_recv(pcb, NULL);
 800a164:	2100      	movs	r1, #0
 800a166:	4630      	mov	r0, r6
 800a168:	f7fa fc90 	bl	8004a8c <tcp_recv>
  tcp_err(pcb, NULL);
 800a16c:	2100      	movs	r1, #0
 800a16e:	4630      	mov	r0, r6
 800a170:	f7fa fc90 	bl	8004a94 <tcp_err>
  tcp_poll(pcb, NULL, 0);
 800a174:	2200      	movs	r2, #0
 800a176:	4611      	mov	r1, r2
 800a178:	4630      	mov	r0, r6
 800a17a:	f7fa fc91 	bl	8004aa0 <tcp_poll>
  tcp_sent(pcb, NULL);
 800a17e:	4630      	mov	r0, r6
 800a180:	2100      	movs	r1, #0
 800a182:	f7fa fc85 	bl	8004a90 <tcp_sent>
 * Also frees the file data if dynamic.
 */
static void http_state_free(struct http_state *hs)
{
  if (hs != NULL) {
    if(hs->handle) {
 800a186:	6820      	ldr	r0, [r4, #0]
 800a188:	b118      	cbz	r0, 800a192 <http_send_data+0x4ee>
      u32_t ms_needed = sys_now() - hs->time_started;
      u32_t needed = LWIP_MAX(1, (ms_needed/100));
      LWIP_DEBUGF(HTTPD_DEBUG_TIMING, ("httpd: needed %"U32_F" ms to send file of %d bytes -> %"U32_F" bytes/sec\n",
        ms_needed, hs->handle->len, ((((u32_t)hs->handle->len) * 10) / needed)));
#endif /* LWIP_HTTPD_TIMING */
      fs_close(hs->handle);
 800a18a:	f7ff fcb7 	bl	8009afc <fs_close>
      hs->handle = NULL;
 800a18e:	2300      	movs	r3, #0
 800a190:	6023      	str	r3, [r4, #0]
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    if (hs->buf != NULL) {
 800a192:	68e0      	ldr	r0, [r4, #12]
 800a194:	b118      	cbz	r0, 800a19e <http_send_data+0x4fa>
      mem_free(hs->buf);
 800a196:	f7f9 fbff 	bl	8003998 <mem_free>
      hs->buf = NULL;
 800a19a:	2300      	movs	r3, #0
 800a19c:	60e3      	str	r3, [r4, #12]
    }
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
#if HTTPD_USE_MEM_POOL
    memp_free(MEMP_HTTPD_STATE, hs);
#else /* HTTPD_USE_MEM_POOL */
    mem_free(hs);
 800a19e:	4620      	mov	r0, r4
 800a1a0:	f7f9 fbfa 	bl	8003998 <mem_free>
  tcp_err(pcb, NULL);
  tcp_poll(pcb, NULL, 0);
  tcp_sent(pcb, NULL);
  http_state_free(hs);

  err = tcp_close(pcb);
 800a1a4:	4630      	mov	r0, r6
 800a1a6:	f7fb f883 	bl	80052b0 <tcp_close>
  if (err != ERR_OK) {
 800a1aa:	2800      	cmp	r0, #0
 800a1ac:	f040 80cb 	bne.w	800a346 <http_send_data+0x6a2>
    if(count < 0) {
      /* We reached the end of the file so this request is done.
       * @todo: don't close here for HTTP/1.1? */
      LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
      http_close_conn(pcb, hs);
      return 1;
 800a1b0:	2001      	movs	r0, #1
 800a1b2:	e5e3      	b.n	8009d7c <http_send_data+0xd8>
 800a1b4:	4607      	mov	r7, r0
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a1b6:	2501      	movs	r5, #1
        len = 2 * mss;
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
      if (err == ERR_OK) {
        data_to_send = true;
 800a1b8:	f04f 0800 	mov.w	r8, #0
 800a1bc:	e619      	b.n	8009df2 <http_send_data+0x14e>
      } else {
        LWIP_ASSERT("Data size does not fit into u16_t!",
                    (hs->parsed - hs->file) <= 0xffff);
        len = (u16_t)(hs->parsed - hs->file);
      }
      if(len > (2 * tcp_mss(pcb))) {
 800a1be:	3b0c      	subs	r3, #12
 800a1c0:	005b      	lsls	r3, r3, #1
 800a1c2:	42ab      	cmp	r3, r5
 800a1c4:	f6bf ae71 	bge.w	8009eaa <http_send_data+0x206>
 800a1c8:	e66e      	b.n	8009ea8 <http_send_data+0x204>
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a1ca:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
           (pcb->snd_queuelen >= TCP_SND_QUEUELEN)) {
         /* no need to try smaller sizes */
         len = 1;
       } else {
         len /= 2;
 800a1ce:	086d      	lsrs	r5, r5, #1
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a1d0:	2b00      	cmp	r3, #0
 800a1d2:	f43f ae7d 	beq.w	8009ed0 <http_send_data+0x22c>
 800a1d6:	f8b6 3068 	ldrh.w	r3, [r6, #104]	; 0x68
 800a1da:	2b07      	cmp	r3, #7
 800a1dc:	f63f ae78 	bhi.w	8009ed0 <http_send_data+0x22c>
         len = 1;
       } else {
         len /= 2;
       }
     }
   } while ((err == ERR_MEM) && (len > 1));
 800a1e0:	2d01      	cmp	r5, #1
 800a1e2:	f63f ae69 	bhi.w	8009eb8 <http_send_data+0x214>
 800a1e6:	e673      	b.n	8009ed0 <http_send_data+0x22c>
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 800a1e8:	4619      	mov	r1, r3
 800a1ea:	4630      	mov	r0, r6
 800a1ec:	f7fa fc4c 	bl	8004a88 <tcp_arg>
  tcp_recv(pcb, NULL);
 800a1f0:	9b00      	ldr	r3, [sp, #0]
 800a1f2:	4630      	mov	r0, r6
 800a1f4:	4619      	mov	r1, r3
 800a1f6:	f7fa fc49 	bl	8004a8c <tcp_recv>
  tcp_err(pcb, NULL);
 800a1fa:	9b00      	ldr	r3, [sp, #0]
 800a1fc:	4630      	mov	r0, r6
 800a1fe:	4619      	mov	r1, r3
 800a200:	f7fa fc48 	bl	8004a94 <tcp_err>
  tcp_poll(pcb, NULL, 0);
 800a204:	9b00      	ldr	r3, [sp, #0]
 800a206:	4630      	mov	r0, r6
 800a208:	461a      	mov	r2, r3
 800a20a:	4619      	mov	r1, r3
 800a20c:	f7fa fc48 	bl	8004aa0 <tcp_poll>
  tcp_sent(pcb, NULL);
 800a210:	9b00      	ldr	r3, [sp, #0]
 800a212:	4630      	mov	r0, r6
 800a214:	4619      	mov	r1, r3
 800a216:	f7fa fc3b 	bl	8004a90 <tcp_sent>
 * Also frees the file data if dynamic.
 */
static void http_state_free(struct http_state *hs)
{
  if (hs != NULL) {
    if(hs->handle) {
 800a21a:	6820      	ldr	r0, [r4, #0]
 800a21c:	2800      	cmp	r0, #0
 800a21e:	f43f aed3 	beq.w	8009fc8 <http_send_data+0x324>
      u32_t ms_needed = sys_now() - hs->time_started;
      u32_t needed = LWIP_MAX(1, (ms_needed/100));
      LWIP_DEBUGF(HTTPD_DEBUG_TIMING, ("httpd: needed %"U32_F" ms to send file of %d bytes -> %"U32_F" bytes/sec\n",
        ms_needed, hs->handle->len, ((((u32_t)hs->handle->len) * 10) / needed)));
#endif /* LWIP_HTTPD_TIMING */
      fs_close(hs->handle);
 800a222:	f7ff fc6b 	bl	8009afc <fs_close>
      hs->handle = NULL;
 800a226:	9b00      	ldr	r3, [sp, #0]
 800a228:	6023      	str	r3, [r4, #0]
 800a22a:	e6cd      	b.n	8009fc8 <http_send_data+0x324>
 800a22c:	f8b6 1066 	ldrh.w	r1, [r6, #102]	; 0x66
static u8_t http_send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
  err_t err;
  u16_t len;
  u16_t mss;
  u8_t data_to_send = false;
 800a230:	f04f 0800 	mov.w	r8, #0
 800a234:	e5db      	b.n	8009dee <http_send_data+0x14a>
            /* Yes - move to the next one unless we have found the complete
             * leadout, in which case we need to call the client to process
             * the tag. */

            /* Move on to the next character in the buffer */
            hs->parse_left--;
 800a236:	3b01      	subs	r3, #1
            hs->parsed++;
 800a238:	3201      	adds	r2, #1
            /* Yes - move to the next one unless we have found the complete
             * leadout, in which case we need to call the client to process
             * the tag. */

            /* Move on to the next character in the buffer */
            hs->parse_left--;
 800a23a:	6263      	str	r3, [r4, #36]	; 0x24
            hs->parsed++;
 800a23c:	61e2      	str	r2, [r4, #28]
 800a23e:	e719      	b.n	800a074 <http_send_data+0x3d0>
static u8_t http_send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
  err_t err;
  u16_t len;
  u16_t mss;
  u8_t data_to_send = false;
 800a240:	f04f 0800 	mov.w	r8, #0
 800a244:	6a4b      	ldr	r3, [r1, #36]	; 0x24
      return 1;
    }
  }
#else /* LWIP_HTTPD_DYNAMIC_HEADERS */
  /* Assume no error until we find otherwise */
  err = ERR_OK;
 800a246:	4647      	mov	r7, r8
 800a248:	e559      	b.n	8009cfe <http_send_data+0x5a>
 800a24a:	bf00      	nop
 800a24c:	080196bc 	.word	0x080196bc
 800a250:	0800a425 	.word	0x0800a425
 800a254:	00800013 	.word	0x00800013
 800a258:	080196c4 	.word	0x080196c4
#if LWIP_HTTPD_SSI_MULTIPART
  u16_t current_tag_part = hs->tag_part;
  hs->tag_part = HTTPD_LAST_TAG_PART;
#endif /* LWIP_HTTPD_SSI_MULTIPART */

  if(g_pfnSSIHandler && g_ppcTags && g_iNumTags) {
 800a25c:	4b64      	ldr	r3, [pc, #400]	; (800a3f0 <http_send_data+0x74c>)
 800a25e:	681b      	ldr	r3, [r3, #0]
 800a260:	9301      	str	r3, [sp, #4]
 800a262:	2b00      	cmp	r3, #0
 800a264:	d076      	beq.n	800a354 <http_send_data+0x6b0>
 800a266:	4b63      	ldr	r3, [pc, #396]	; (800a3f4 <http_send_data+0x750>)
 800a268:	681a      	ldr	r2, [r3, #0]
 800a26a:	2a00      	cmp	r2, #0
 800a26c:	d072      	beq.n	800a354 <http_send_data+0x6b0>
 800a26e:	4b62      	ldr	r3, [pc, #392]	; (800a3f8 <http_send_data+0x754>)
 800a270:	681b      	ldr	r3, [r3, #0]

    /* Find this tag in the list we have been provided. */
    for(loop = 0; loop < g_iNumTags; loop++) {
 800a272:	2b00      	cmp	r3, #0
#if LWIP_HTTPD_SSI_MULTIPART
  u16_t current_tag_part = hs->tag_part;
  hs->tag_part = HTTPD_LAST_TAG_PART;
#endif /* LWIP_HTTPD_SSI_MULTIPART */

  if(g_pfnSSIHandler && g_ppcTags && g_iNumTags) {
 800a274:	4619      	mov	r1, r3

    /* Find this tag in the list we have been provided. */
    for(loop = 0; loop < g_iNumTags; loop++) {
 800a276:	dd6d      	ble.n	800a354 <http_send_data+0x6b0>
 800a278:	f1a2 0a04 	sub.w	sl, r2, #4
 800a27c:	f104 032e 	add.w	r3, r4, #46	; 0x2e
 800a280:	f04f 0900 	mov.w	r9, #0
 800a284:	4632      	mov	r2, r6
 800a286:	9702      	str	r7, [sp, #8]
 800a288:	9503      	str	r5, [sp, #12]
 800a28a:	4657      	mov	r7, sl
 800a28c:	464e      	mov	r6, r9
 800a28e:	46a2      	mov	sl, r4
 800a290:	9300      	str	r3, [sp, #0]
 800a292:	460d      	mov	r5, r1
 800a294:	461c      	mov	r4, r3
 800a296:	4691      	mov	r9, r2
 800a298:	e003      	b.n	800a2a2 <http_send_data+0x5fe>
 800a29a:	3601      	adds	r6, #1
 800a29c:	42b5      	cmp	r5, r6
 800a29e:	f000 809d 	beq.w	800a3dc <http_send_data+0x738>
      if(strcmp((hs->tag_name), g_ppcTags[loop]) == 0) {
 800a2a2:	f857 1f04 	ldr.w	r1, [r7, #4]!
 800a2a6:	4620      	mov	r0, r4
 800a2a8:	f7f5 ff9a 	bl	80001e0 <strcmp>
 800a2ac:	2800      	cmp	r0, #0
 800a2ae:	d1f4      	bne.n	800a29a <http_send_data+0x5f6>
 800a2b0:	464b      	mov	r3, r9
 800a2b2:	46b1      	mov	r9, r6
        hs->tag_insert_len = g_pfnSSIHandler(loop, hs->tag_insert,
 800a2b4:	4648      	mov	r0, r9
 800a2b6:	461e      	mov	r6, r3
 800a2b8:	22c0      	movs	r2, #192	; 0xc0
 800a2ba:	f10a 0130 	add.w	r1, sl, #48	; 0x30
 800a2be:	9b01      	ldr	r3, [sp, #4]
 800a2c0:	9f02      	ldr	r7, [sp, #8]
 800a2c2:	9d03      	ldr	r5, [sp, #12]
 800a2c4:	4798      	blx	r3
 800a2c6:	4654      	mov	r4, sl
 800a2c8:	f8aa 002a 	strh.w	r0, [sl, #42]	; 0x2a
              /* Next time through, we are going to be sending data
               * immediately, either the end of the block we start
               * sending here or the insert string. */
              hs->tag_index = 0;
              hs->tag_state = TAG_SENDING;
              hs->tag_end = hs->parsed;
 800a2cc:	69e3      	ldr	r3, [r4, #28]
              hs->parsed = hs->tag_started;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/

              /* If there is any unsent data in the buffer prior to the
               * tag, we need to send it now. */
              if (hs->tag_end > hs->file) {
 800a2ce:	f8d4 9004 	ldr.w	r9, [r4, #4]
              /* Next time through, we are going to be sending data
               * immediately, either the end of the block we start
               * sending here or the insert string. */
              hs->tag_index = 0;
              hs->tag_state = TAG_SENDING;
              hs->tag_end = hs->parsed;
 800a2d2:	6223      	str	r3, [r4, #32]
              get_tag_insert(hs);

              /* Next time through, we are going to be sending data
               * immediately, either the end of the block we start
               * sending here or the insert string. */
              hs->tag_index = 0;
 800a2d4:	2200      	movs	r2, #0
 800a2d6:	8522      	strh	r2, [r4, #40]	; 0x28
              hs->parsed = hs->tag_started;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/

              /* If there is any unsent data in the buffer prior to the
               * tag, we need to send it now. */
              if (hs->tag_end > hs->file) {
 800a2d8:	454b      	cmp	r3, r9

              /* Next time through, we are going to be sending data
               * immediately, either the end of the block we start
               * sending here or the insert string. */
              hs->tag_index = 0;
              hs->tag_state = TAG_SENDING;
 800a2da:	f04f 0204 	mov.w	r2, #4
 800a2de:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
              hs->parsed = hs->tag_started;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/

              /* If there is any unsent data in the buffer prior to the
               * tag, we need to send it now. */
              if (hs->tag_end > hs->file) {
 800a2e2:	f67f adc6 	bls.w	8009e72 <http_send_data+0x1ce>
                /* How much of the data can we send? */
#if LWIP_HTTPD_SSI_INCLUDE_TAG
                if(len > hs->tag_end - hs->file) {
 800a2e6:	ebc9 0303 	rsb	r3, r9, r3
                  /* we would include the tag in sending */
                  len = (u16_t)(hs->tag_started - hs->file);
                }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/

                err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 800a2ea:	f894 a02c 	ldrb.w	sl, [r4, #44]	; 0x2c
              /* If there is any unsent data in the buffer prior to the
               * tag, we need to send it now. */
              if (hs->tag_end > hs->file) {
                /* How much of the data can we send? */
#if LWIP_HTTPD_SSI_INCLUDE_TAG
                if(len > hs->tag_end - hs->file) {
 800a2ee:	429d      	cmp	r5, r3
                  len = (u16_t)(hs->tag_end - hs->file);
 800a2f0:	bfc8      	it	gt
 800a2f2:	b29d      	uxthgt	r5, r3
                  /* we would include the tag in sending */
                  len = (u16_t)(hs->tag_started - hs->file);
                }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/

                err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 800a2f4:	f11a 0a00 	adds.w	sl, sl, #0
 800a2f8:	bf18      	it	ne
 800a2fa:	f04f 0a01 	movne.w	sl, #1
   err_t err;
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
 800a2fe:	4653      	mov	r3, sl
 800a300:	462a      	mov	r2, r5
 800a302:	4649      	mov	r1, r9
 800a304:	4630      	mov	r0, r6
 800a306:	f7fc f87d 	bl	8006404 <tcp_write>
     if (err == ERR_MEM) {
 800a30a:	1c47      	adds	r7, r0, #1
 800a30c:	d00d      	beq.n	800a32a <http_send_data+0x686>
 800a30e:	4607      	mov	r7, r0
                  len = (u16_t)(hs->tag_started - hs->file);
                }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/

                err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
                if (err == ERR_OK) {
 800a310:	2800      	cmp	r0, #0
 800a312:	f47f adae 	bne.w	8009e72 <http_send_data+0x1ce>
                  if(hs->tag_started <= hs->file) {
                    /* pretend to have sent the tag, too */
                    len += hs->tag_end - hs->tag_started;
                  }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
                  hs->file += len;
 800a316:	6861      	ldr	r1, [r4, #4]
                  hs->left -= len;
 800a318:	6962      	ldr	r2, [r4, #20]
 800a31a:	6a63      	ldr	r3, [r4, #36]	; 0x24
                  if(hs->tag_started <= hs->file) {
                    /* pretend to have sent the tag, too */
                    len += hs->tag_end - hs->tag_started;
                  }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
                  hs->file += len;
 800a31c:	4429      	add	r1, r5
                  hs->left -= len;
 800a31e:	1b52      	subs	r2, r2, r5
                  if(hs->tag_started <= hs->file) {
                    /* pretend to have sent the tag, too */
                    len += hs->tag_end - hs->tag_started;
                  }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
                  hs->file += len;
 800a320:	6061      	str	r1, [r4, #4]
                  hs->left -= len;
 800a322:	6162      	str	r2, [r4, #20]
                }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/

                err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
                if (err == ERR_OK) {
                  data_to_send = true;
 800a324:	f04f 0801 	mov.w	r8, #1
 800a328:	e4eb      	b.n	8009d02 <http_send_data+0x5e>
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a32a:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
           (pcb->snd_queuelen >= TCP_SND_QUEUELEN)) {
         /* no need to try smaller sizes */
         len = 1;
       } else {
         len /= 2;
 800a32e:	086d      	lsrs	r5, r5, #1
   len = *length;
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
     if (err == ERR_MEM) {
       if ((tcp_sndbuf(pcb) == 0) ||
 800a330:	2b00      	cmp	r3, #0
 800a332:	f43f aeed 	beq.w	800a110 <http_send_data+0x46c>
 800a336:	f8b6 3068 	ldrh.w	r3, [r6, #104]	; 0x68
 800a33a:	2b07      	cmp	r3, #7
 800a33c:	f63f aee8 	bhi.w	800a110 <http_send_data+0x46c>
         len = 1;
       } else {
         len /= 2;
       }
     }
   } while ((err == ERR_MEM) && (len > 1));
 800a340:	2d01      	cmp	r5, #1
 800a342:	d8dc      	bhi.n	800a2fe <http_send_data+0x65a>
 800a344:	e594      	b.n	8009e70 <http_send_data+0x1cc>

  err = tcp_close(pcb);
  if (err != ERR_OK) {
    LWIP_DEBUGF(HTTPD_DEBUG, ("Error %d closing %p\n", err, (void*)pcb));
    /* error closing, try again later in poll */
    tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 800a346:	4630      	mov	r0, r6
 800a348:	2204      	movs	r2, #4
 800a34a:	492c      	ldr	r1, [pc, #176]	; (800a3fc <http_send_data+0x758>)
 800a34c:	f7fa fba8 	bl	8004aa0 <tcp_poll>
    if(count < 0) {
      /* We reached the end of the file so this request is done.
       * @todo: don't close here for HTTP/1.1? */
      LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
      http_close_conn(pcb, hs);
      return 1;
 800a350:	2001      	movs	r0, #1
 800a352:	e513      	b.n	8009d7c <http_send_data+0xd8>
 800a354:	f104 032e 	add.w	r3, r4, #46	; 0x2e
 800a358:	9300      	str	r3, [sp, #0]
 800a35a:	4618      	mov	r0, r3
   * marker. */
#define UNKNOWN_TAG1_TEXT "<b>***UNKNOWN TAG "
#define UNKNOWN_TAG1_LEN  18
#define UNKNOWN_TAG2_TEXT "***</b>"
#define UNKNOWN_TAG2_LEN  7
  len = LWIP_MIN(strlen(hs->tag_name),
 800a35c:	f7f5 ff4a 	bl	80001f4 <strlen>
 800a360:	28a6      	cmp	r0, #166	; 0xa6
 800a362:	4686      	mov	lr, r0
 800a364:	d934      	bls.n	800a3d0 <http_send_data+0x72c>
 800a366:	23c0      	movs	r3, #192	; 0xc0
 800a368:	9301      	str	r3, [sp, #4]
 800a36a:	f04f 0ab9 	mov.w	sl, #185	; 0xb9
 800a36e:	f04f 0ea7 	mov.w	lr, #167	; 0xa7
    LWIP_HTTPD_MAX_TAG_INSERT_LEN - (UNKNOWN_TAG1_LEN + UNKNOWN_TAG2_LEN));
  MEMCPY(hs->tag_insert, UNKNOWN_TAG1_TEXT, UNKNOWN_TAG1_LEN);
 800a372:	f8df c090 	ldr.w	ip, [pc, #144]	; 800a404 <http_send_data+0x760>
 800a376:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800a37a:	f8bc c000 	ldrh.w	ip, [ip]
 800a37e:	6320      	str	r0, [r4, #48]	; 0x30
 800a380:	f8a4 c040 	strh.w	ip, [r4, #64]	; 0x40
 800a384:	6361      	str	r1, [r4, #52]	; 0x34
 800a386:	63a2      	str	r2, [r4, #56]	; 0x38
 800a388:	63e3      	str	r3, [r4, #60]	; 0x3c
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN], hs->tag_name, len);
 800a38a:	4672      	mov	r2, lr
 800a38c:	9900      	ldr	r1, [sp, #0]
 800a38e:	f104 0042 	add.w	r0, r4, #66	; 0x42
 800a392:	f001 f8c0 	bl	800b516 <memcpy>
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN + len], UNKNOWN_TAG2_TEXT, UNKNOWN_TAG2_LEN);
  hs->tag_insert[UNKNOWN_TAG1_LEN + len + UNKNOWN_TAG2_LEN] = 0;
 800a396:	9a01      	ldr	r2, [sp, #4]
#define UNKNOWN_TAG2_LEN  7
  len = LWIP_MIN(strlen(hs->tag_name),
    LWIP_HTTPD_MAX_TAG_INSERT_LEN - (UNKNOWN_TAG1_LEN + UNKNOWN_TAG2_LEN));
  MEMCPY(hs->tag_insert, UNKNOWN_TAG1_TEXT, UNKNOWN_TAG1_LEN);
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN], hs->tag_name, len);
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN + len], UNKNOWN_TAG2_TEXT, UNKNOWN_TAG2_LEN);
 800a398:	4b19      	ldr	r3, [pc, #100]	; (800a400 <http_send_data+0x75c>)
 800a39a:	f10a 0a30 	add.w	sl, sl, #48	; 0x30
  hs->tag_insert[UNKNOWN_TAG1_LEN + len + UNKNOWN_TAG2_LEN] = 0;
 800a39e:	4422      	add	r2, r4
 800a3a0:	4611      	mov	r1, r2
#define UNKNOWN_TAG2_LEN  7
  len = LWIP_MIN(strlen(hs->tag_name),
    LWIP_HTTPD_MAX_TAG_INSERT_LEN - (UNKNOWN_TAG1_LEN + UNKNOWN_TAG2_LEN));
  MEMCPY(hs->tag_insert, UNKNOWN_TAG1_TEXT, UNKNOWN_TAG1_LEN);
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN], hs->tag_name, len);
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN + len], UNKNOWN_TAG2_TEXT, UNKNOWN_TAG2_LEN);
 800a3a2:	eb04 020a 	add.w	r2, r4, sl
 800a3a6:	6818      	ldr	r0, [r3, #0]
 800a3a8:	f8b3 e004 	ldrh.w	lr, [r3, #4]
 800a3ac:	f893 c006 	ldrb.w	ip, [r3, #6]
 800a3b0:	f844 000a 	str.w	r0, [r4, sl]
  hs->tag_insert[UNKNOWN_TAG1_LEN + len + UNKNOWN_TAG2_LEN] = 0;
 800a3b4:	2300      	movs	r3, #0
#define UNKNOWN_TAG1_LEN  18
#define UNKNOWN_TAG2_TEXT "***</b>"
#define UNKNOWN_TAG2_LEN  7
  len = LWIP_MIN(strlen(hs->tag_name),
    LWIP_HTTPD_MAX_TAG_INSERT_LEN - (UNKNOWN_TAG1_LEN + UNKNOWN_TAG2_LEN));
  MEMCPY(hs->tag_insert, UNKNOWN_TAG1_TEXT, UNKNOWN_TAG1_LEN);
 800a3b6:	f104 0930 	add.w	r9, r4, #48	; 0x30
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN], hs->tag_name, len);
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN + len], UNKNOWN_TAG2_TEXT, UNKNOWN_TAG2_LEN);
 800a3ba:	f8a2 e004 	strh.w	lr, [r2, #4]
 800a3be:	f882 c006 	strb.w	ip, [r2, #6]
  hs->tag_insert[UNKNOWN_TAG1_LEN + len + UNKNOWN_TAG2_LEN] = 0;

  len = strlen(hs->tag_insert);
 800a3c2:	4648      	mov	r0, r9
  len = LWIP_MIN(strlen(hs->tag_name),
    LWIP_HTTPD_MAX_TAG_INSERT_LEN - (UNKNOWN_TAG1_LEN + UNKNOWN_TAG2_LEN));
  MEMCPY(hs->tag_insert, UNKNOWN_TAG1_TEXT, UNKNOWN_TAG1_LEN);
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN], hs->tag_name, len);
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN + len], UNKNOWN_TAG2_TEXT, UNKNOWN_TAG2_LEN);
  hs->tag_insert[UNKNOWN_TAG1_LEN + len + UNKNOWN_TAG2_LEN] = 0;
 800a3c4:	f881 3030 	strb.w	r3, [r1, #48]	; 0x30

  len = strlen(hs->tag_insert);
 800a3c8:	f7f5 ff14 	bl	80001f4 <strlen>
  LWIP_ASSERT("len <= 0xffff", len <= 0xffff);
  hs->tag_insert_len = (u16_t)len;
 800a3cc:	8560      	strh	r0, [r4, #42]	; 0x2a
 800a3ce:	e77d      	b.n	800a2cc <http_send_data+0x628>
 800a3d0:	f100 0319 	add.w	r3, r0, #25
 800a3d4:	f100 0a12 	add.w	sl, r0, #18
 800a3d8:	9301      	str	r3, [sp, #4]
 800a3da:	e7ca      	b.n	800a372 <http_send_data+0x6ce>
 800a3dc:	9f02      	ldr	r7, [sp, #8]
 800a3de:	9d03      	ldr	r5, [sp, #12]
 800a3e0:	9800      	ldr	r0, [sp, #0]
 800a3e2:	464e      	mov	r6, r9
 800a3e4:	4654      	mov	r4, sl
 800a3e6:	e7b9      	b.n	800a35c <http_send_data+0x6b8>
 800a3e8:	f8d4 9004 	ldr.w	r9, [r4, #4]
 800a3ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a3ee:	e686      	b.n	800a0fe <http_send_data+0x45a>
 800a3f0:	20002a80 	.word	0x20002a80
 800a3f4:	20002a84 	.word	0x20002a84
 800a3f8:	20002a90 	.word	0x20002a90
 800a3fc:	0800a425 	.word	0x0800a425
 800a400:	080196dc 	.word	0x080196dc
 800a404:	080196c8 	.word	0x080196c8

0800a408 <http_sent>:

  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_sent %p\n", (void*)pcb));

  LWIP_UNUSED_ARG(len);

  if (hs == NULL) {
 800a408:	b148      	cbz	r0, 800a41e <http_sent+0x16>
/**
 * Data has been sent and acknowledged by the remote host.
 * This means that more data can be sent.
 */
static err_t http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
 800a40a:	b508      	push	{r3, lr}
 800a40c:	4603      	mov	r3, r0

  if (hs == NULL) {
    return ERR_OK;
  }

  hs->retries = 0;
 800a40e:	2200      	movs	r2, #0
 800a410:	4608      	mov	r0, r1
 800a412:	761a      	strb	r2, [r3, #24]

  http_send_data(pcb, hs);
 800a414:	4619      	mov	r1, r3
 800a416:	f7ff fc45 	bl	8009ca4 <http_send_data>

  return ERR_OK;
}
 800a41a:	2000      	movs	r0, #0
 800a41c:	bd08      	pop	{r3, pc}
 800a41e:	2000      	movs	r0, #0
 800a420:	4770      	bx	lr
 800a422:	bf00      	nop

0800a424 <http_poll>:
 * If the last portion of a file has not been sent in 2 seconds, close.
 *
 * This could be increased, but we don't want to waste resources for bad connections.
 */
static err_t http_poll(void *arg, struct tcp_pcb *pcb)
{
 800a424:	b538      	push	{r3, r4, r5, lr}
 800a426:	460d      	mov	r5, r1
  struct http_state *hs = (struct http_state *)arg;
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_poll: pcb=%p hs=%p pcb_state=%s\n",
    (void*)pcb, (void*)hs, tcp_debug_state_str(pcb->state)));

  if (hs == NULL) {
 800a428:	4604      	mov	r4, r0
 800a42a:	2800      	cmp	r0, #0
 800a42c:	d042      	beq.n	800a4b4 <http_poll+0x90>
    /* arg is null, close. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("http_poll: arg is NULL, close\n"));
    http_close_conn(pcb, hs);
    return ERR_OK;
  } else {
    hs->retries++;
 800a42e:	7e03      	ldrb	r3, [r0, #24]
 800a430:	3301      	adds	r3, #1
 800a432:	b2db      	uxtb	r3, r3
    if (hs->retries == HTTPD_MAX_RETRIES) {
 800a434:	2b04      	cmp	r3, #4
    /* arg is null, close. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("http_poll: arg is NULL, close\n"));
    http_close_conn(pcb, hs);
    return ERR_OK;
  } else {
    hs->retries++;
 800a436:	7603      	strb	r3, [r0, #24]
    if (hs->retries == HTTPD_MAX_RETRIES) {
 800a438:	d00d      	beq.n	800a456 <http_poll+0x32>
    }

    /* If this connection has a file open, try to send some more data. If
     * it has not yet received a GET request, don't do this since it will
     * cause the connection to close immediately. */
    if(hs && (hs->handle)) {
 800a43a:	6803      	ldr	r3, [r0, #0]
 800a43c:	b123      	cbz	r3, 800a448 <http_poll+0x24>
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_poll: try to send more data\n"));
      if(http_send_data(pcb, hs)) {
 800a43e:	4601      	mov	r1, r0
 800a440:	4628      	mov	r0, r5
 800a442:	f7ff fc2f 	bl	8009ca4 <http_send_data>
 800a446:	b908      	cbnz	r0, 800a44c <http_poll+0x28>
      }
    }
  }

  return ERR_OK;
}
 800a448:	2000      	movs	r0, #0
 800a44a:	bd38      	pop	{r3, r4, r5, pc}
    if(hs && (hs->handle)) {
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_poll: try to send more data\n"));
      if(http_send_data(pcb, hs)) {
        /* If we wrote anything to be sent, go ahead and send it now. */
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("tcp_output\n"));
        tcp_output(pcb);
 800a44c:	4628      	mov	r0, r5
 800a44e:	f7fc fb19 	bl	8006a84 <tcp_output>
      }
    }
  }

  return ERR_OK;
}
 800a452:	2000      	movs	r0, #0
 800a454:	bd38      	pop	{r3, r4, r5, pc}
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 800a456:	2100      	movs	r1, #0
 800a458:	4628      	mov	r0, r5
 800a45a:	f7fa fb15 	bl	8004a88 <tcp_arg>
  tcp_recv(pcb, NULL);
 800a45e:	2100      	movs	r1, #0
 800a460:	4628      	mov	r0, r5
 800a462:	f7fa fb13 	bl	8004a8c <tcp_recv>
  tcp_err(pcb, NULL);
 800a466:	2100      	movs	r1, #0
 800a468:	4628      	mov	r0, r5
 800a46a:	f7fa fb13 	bl	8004a94 <tcp_err>
  tcp_poll(pcb, NULL, 0);
 800a46e:	2200      	movs	r2, #0
 800a470:	4611      	mov	r1, r2
 800a472:	4628      	mov	r0, r5
 800a474:	f7fa fb14 	bl	8004aa0 <tcp_poll>
  tcp_sent(pcb, NULL);
 800a478:	4628      	mov	r0, r5
 800a47a:	2100      	movs	r1, #0
 800a47c:	f7fa fb08 	bl	8004a90 <tcp_sent>
 * Also frees the file data if dynamic.
 */
static void http_state_free(struct http_state *hs)
{
  if (hs != NULL) {
    if(hs->handle) {
 800a480:	6820      	ldr	r0, [r4, #0]
 800a482:	b118      	cbz	r0, 800a48c <http_poll+0x68>
      u32_t ms_needed = sys_now() - hs->time_started;
      u32_t needed = LWIP_MAX(1, (ms_needed/100));
      LWIP_DEBUGF(HTTPD_DEBUG_TIMING, ("httpd: needed %"U32_F" ms to send file of %d bytes -> %"U32_F" bytes/sec\n",
        ms_needed, hs->handle->len, ((((u32_t)hs->handle->len) * 10) / needed)));
#endif /* LWIP_HTTPD_TIMING */
      fs_close(hs->handle);
 800a484:	f7ff fb3a 	bl	8009afc <fs_close>
      hs->handle = NULL;
 800a488:	2300      	movs	r3, #0
 800a48a:	6023      	str	r3, [r4, #0]
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    if (hs->buf != NULL) {
 800a48c:	68e0      	ldr	r0, [r4, #12]
 800a48e:	b118      	cbz	r0, 800a498 <http_poll+0x74>
      mem_free(hs->buf);
 800a490:	f7f9 fa82 	bl	8003998 <mem_free>
      hs->buf = NULL;
 800a494:	2300      	movs	r3, #0
 800a496:	60e3      	str	r3, [r4, #12]
    }
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
#if HTTPD_USE_MEM_POOL
    memp_free(MEMP_HTTPD_STATE, hs);
#else /* HTTPD_USE_MEM_POOL */
    mem_free(hs);
 800a498:	4620      	mov	r0, r4
 800a49a:	f7f9 fa7d 	bl	8003998 <mem_free>
  tcp_err(pcb, NULL);
  tcp_poll(pcb, NULL, 0);
  tcp_sent(pcb, NULL);
  http_state_free(hs);

  err = tcp_close(pcb);
 800a49e:	4628      	mov	r0, r5
 800a4a0:	f7fa ff06 	bl	80052b0 <tcp_close>
  if (err != ERR_OK) {
 800a4a4:	2800      	cmp	r0, #0
 800a4a6:	d0cf      	beq.n	800a448 <http_poll+0x24>
    LWIP_DEBUGF(HTTPD_DEBUG, ("Error %d closing %p\n", err, (void*)pcb));
    /* error closing, try again later in poll */
    tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 800a4a8:	4628      	mov	r0, r5
 800a4aa:	2204      	movs	r2, #4
 800a4ac:	490f      	ldr	r1, [pc, #60]	; (800a4ec <http_poll+0xc8>)
 800a4ae:	f7fa faf7 	bl	8004aa0 <tcp_poll>
 800a4b2:	e7c9      	b.n	800a448 <http_poll+0x24>
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 800a4b4:	4601      	mov	r1, r0
 800a4b6:	4628      	mov	r0, r5
 800a4b8:	f7fa fae6 	bl	8004a88 <tcp_arg>
  tcp_recv(pcb, NULL);
 800a4bc:	4621      	mov	r1, r4
 800a4be:	4628      	mov	r0, r5
 800a4c0:	f7fa fae4 	bl	8004a8c <tcp_recv>
  tcp_err(pcb, NULL);
 800a4c4:	4621      	mov	r1, r4
 800a4c6:	4628      	mov	r0, r5
 800a4c8:	f7fa fae4 	bl	8004a94 <tcp_err>
  tcp_poll(pcb, NULL, 0);
 800a4cc:	4622      	mov	r2, r4
 800a4ce:	4621      	mov	r1, r4
 800a4d0:	4628      	mov	r0, r5
 800a4d2:	f7fa fae5 	bl	8004aa0 <tcp_poll>
  tcp_sent(pcb, NULL);
 800a4d6:	4628      	mov	r0, r5
 800a4d8:	4621      	mov	r1, r4
 800a4da:	f7fa fad9 	bl	8004a90 <tcp_sent>
  http_state_free(hs);

  err = tcp_close(pcb);
 800a4de:	4628      	mov	r0, r5
 800a4e0:	f7fa fee6 	bl	80052b0 <tcp_close>
  if (err != ERR_OK) {
 800a4e4:	2800      	cmp	r0, #0
 800a4e6:	d0af      	beq.n	800a448 <http_poll+0x24>
 800a4e8:	e7de      	b.n	800a4a8 <http_poll+0x84>
 800a4ea:	bf00      	nop
 800a4ec:	0800a425 	.word	0x0800a425

0800a4f0 <http_recv>:
/**
 * Data has been received on this pcb.
 * For HTTP 1.0, this should normally only happen once (if the request fits in one packet).
 */
static err_t http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800a4f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a4f4:	4605      	mov	r5, r0
 800a4f6:	b083      	sub	sp, #12
 800a4f8:	460c      	mov	r4, r1
 800a4fa:	4616      	mov	r6, r2
  err_t parsed = ERR_ABRT;
  struct http_state *hs = (struct http_state *)arg;
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: pcb=%p pbuf=%p err=%s\n", (void*)pcb,
    (void*)p, lwip_strerr(err)));

  if ((err != ERR_OK) || (p == NULL) || (hs == NULL)) {
 800a4fc:	b9b3      	cbnz	r3, 800a52c <http_recv+0x3c>
 800a4fe:	b1ea      	cbz	r2, 800a53c <http_recv+0x4c>
 800a500:	b1a8      	cbz	r0, 800a52e <http_recv+0x3e>
     hs->unrecved_bytes += p->tot_len;
  } else
#endif /* LWIP_HTTPD_SUPPORT_POST && LWIP_HTTPD_POST_MANUAL_WND */
  {
    /* Inform TCP that we have taken the data. */
    tcp_recved(pcb, p->tot_len);
 800a502:	8911      	ldrh	r1, [r2, #8]
 800a504:	4620      	mov	r0, r4
 800a506:	f7fa f877 	bl	80045f8 <tcp_recved>
    }
    return ERR_OK;
  } else
#endif /* LWIP_HTTPD_SUPPORT_POST */
  {
    if (hs->handle == NULL) {
 800a50a:	682b      	ldr	r3, [r5, #0]
 800a50c:	2b00      	cmp	r3, #0
 800a50e:	d067      	beq.n	800a5e0 <http_recv+0xf0>
 800a510:	68a8      	ldr	r0, [r5, #8]
 * Data has been received on this pcb.
 * For HTTP 1.0, this should normally only happen once (if the request fits in one packet).
 */
static err_t http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  err_t parsed = ERR_ABRT;
 800a512:	f06f 0609 	mvn.w	r6, #9
      LWIP_DEBUGF(HTTPD_DEBUG, ("http_recv: already sending data\n"));
    }
#if LWIP_HTTPD_SUPPORT_REQUESTLIST
    if (parsed != ERR_INPROGRESS) {
      /* request fully parsed or error */
      if (hs->req != NULL) {
 800a516:	b128      	cbz	r0, 800a524 <http_recv+0x34>
        pbuf_free(hs->req);
 800a518:	f7f9 fe3e 	bl	8004198 <pbuf_free>
        hs->req = NULL;
 800a51c:	2300      	movs	r3, #0
#endif /* LWIP_HTTPD_SUPPORT_POST */
      {
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: data %p len %"S32_F"\n", hs->file, hs->left));
        http_send_data(pcb, hs);
      }
    } else if (parsed == ERR_ARG) {
 800a51e:	360e      	adds	r6, #14
#if LWIP_HTTPD_SUPPORT_REQUESTLIST
    if (parsed != ERR_INPROGRESS) {
      /* request fully parsed or error */
      if (hs->req != NULL) {
        pbuf_free(hs->req);
        hs->req = NULL;
 800a520:	60ab      	str	r3, [r5, #8]
#endif /* LWIP_HTTPD_SUPPORT_POST */
      {
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: data %p len %"S32_F"\n", hs->file, hs->left));
        http_send_data(pcb, hs);
      }
    } else if (parsed == ERR_ARG) {
 800a522:	d044      	beq.n	800a5ae <http_recv+0xbe>
      /* @todo: close on ERR_USE? */
      http_close_conn(pcb, hs);
    }
  }
  return ERR_OK;
}
 800a524:	2000      	movs	r0, #0
 800a526:	b003      	add	sp, #12
 800a528:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: pcb=%p pbuf=%p err=%s\n", (void*)pcb,
    (void*)p, lwip_strerr(err)));

  if ((err != ERR_OK) || (p == NULL) || (hs == NULL)) {
    /* error or closed by other side? */
    if (p != NULL) {
 800a52c:	b132      	cbz	r2, 800a53c <http_recv+0x4c>
      /* Inform TCP that we have taken the data. */
      tcp_recved(pcb, p->tot_len);
 800a52e:	4620      	mov	r0, r4
 800a530:	8931      	ldrh	r1, [r6, #8]
 800a532:	f7fa f861 	bl	80045f8 <tcp_recved>
      pbuf_free(p);
 800a536:	4630      	mov	r0, r6
 800a538:	f7f9 fe2e 	bl	8004198 <pbuf_free>
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 800a53c:	2100      	movs	r1, #0
 800a53e:	4620      	mov	r0, r4
 800a540:	f7fa faa2 	bl	8004a88 <tcp_arg>
  tcp_recv(pcb, NULL);
 800a544:	2100      	movs	r1, #0
 800a546:	4620      	mov	r0, r4
 800a548:	f7fa faa0 	bl	8004a8c <tcp_recv>
  tcp_err(pcb, NULL);
 800a54c:	2100      	movs	r1, #0
 800a54e:	4620      	mov	r0, r4
 800a550:	f7fa faa0 	bl	8004a94 <tcp_err>
  tcp_poll(pcb, NULL, 0);
 800a554:	2200      	movs	r2, #0
 800a556:	4611      	mov	r1, r2
 800a558:	4620      	mov	r0, r4
 800a55a:	f7fa faa1 	bl	8004aa0 <tcp_poll>
  tcp_sent(pcb, NULL);
 800a55e:	2100      	movs	r1, #0
 800a560:	4620      	mov	r0, r4
 800a562:	f7fa fa95 	bl	8004a90 <tcp_sent>
/** Free a struct http_state.
 * Also frees the file data if dynamic.
 */
static void http_state_free(struct http_state *hs)
{
  if (hs != NULL) {
 800a566:	b175      	cbz	r5, 800a586 <http_recv+0x96>
    if(hs->handle) {
 800a568:	6828      	ldr	r0, [r5, #0]
 800a56a:	b118      	cbz	r0, 800a574 <http_recv+0x84>
      u32_t ms_needed = sys_now() - hs->time_started;
      u32_t needed = LWIP_MAX(1, (ms_needed/100));
      LWIP_DEBUGF(HTTPD_DEBUG_TIMING, ("httpd: needed %"U32_F" ms to send file of %d bytes -> %"U32_F" bytes/sec\n",
        ms_needed, hs->handle->len, ((((u32_t)hs->handle->len) * 10) / needed)));
#endif /* LWIP_HTTPD_TIMING */
      fs_close(hs->handle);
 800a56c:	f7ff fac6 	bl	8009afc <fs_close>
      hs->handle = NULL;
 800a570:	2300      	movs	r3, #0
 800a572:	602b      	str	r3, [r5, #0]
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    if (hs->buf != NULL) {
 800a574:	68e8      	ldr	r0, [r5, #12]
 800a576:	b118      	cbz	r0, 800a580 <http_recv+0x90>
      mem_free(hs->buf);
 800a578:	f7f9 fa0e 	bl	8003998 <mem_free>
      hs->buf = NULL;
 800a57c:	2300      	movs	r3, #0
 800a57e:	60eb      	str	r3, [r5, #12]
    }
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
#if HTTPD_USE_MEM_POOL
    memp_free(MEMP_HTTPD_STATE, hs);
#else /* HTTPD_USE_MEM_POOL */
    mem_free(hs);
 800a580:	4628      	mov	r0, r5
 800a582:	f7f9 fa09 	bl	8003998 <mem_free>
  tcp_err(pcb, NULL);
  tcp_poll(pcb, NULL, 0);
  tcp_sent(pcb, NULL);
  http_state_free(hs);

  err = tcp_close(pcb);
 800a586:	4620      	mov	r0, r4
 800a588:	f7fa fe92 	bl	80052b0 <tcp_close>
  if (err != ERR_OK) {
 800a58c:	2800      	cmp	r0, #0
 800a58e:	d0c9      	beq.n	800a524 <http_recv+0x34>
    LWIP_DEBUGF(HTTPD_DEBUG, ("Error %d closing %p\n", err, (void*)pcb));
    /* error closing, try again later in poll */
    tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 800a590:	4620      	mov	r0, r4
 800a592:	2204      	movs	r2, #4
 800a594:	49c0      	ldr	r1, [pc, #768]	; (800a898 <http_recv+0x3a8>)
 800a596:	f7fa fa83 	bl	8004aa0 <tcp_poll>
      /* @todo: close on ERR_USE? */
      http_close_conn(pcb, hs);
    }
  }
  return ERR_OK;
}
 800a59a:	2000      	movs	r0, #0
 800a59c:	b003      	add	sp, #12
 800a59e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        /* received GET request */
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Received POST request\n"));
#endif /* LWIP_HTTPD_SUPPORT_POST */
      } else {
        /* null-terminate the METHOD (pbuf is freed anyway wen returning) */
        data[4] = 0;
 800a5a2:	f888 a004 	strb.w	sl, [r8, #4]
 800a5a6:	68a8      	ldr	r0, [r5, #8]
      LWIP_DEBUGF(HTTPD_DEBUG, ("http_recv: already sending data\n"));
    }
#if LWIP_HTTPD_SUPPORT_REQUESTLIST
    if (parsed != ERR_INPROGRESS) {
      /* request fully parsed or error */
      if (hs->req != NULL) {
 800a5a8:	2800      	cmp	r0, #0
 800a5aa:	f040 8087 	bne.w	800a6bc <http_recv+0x1cc>
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 800a5ae:	2100      	movs	r1, #0
 800a5b0:	4620      	mov	r0, r4
 800a5b2:	f7fa fa69 	bl	8004a88 <tcp_arg>
  tcp_recv(pcb, NULL);
 800a5b6:	2100      	movs	r1, #0
 800a5b8:	4620      	mov	r0, r4
 800a5ba:	f7fa fa67 	bl	8004a8c <tcp_recv>
  tcp_err(pcb, NULL);
 800a5be:	2100      	movs	r1, #0
 800a5c0:	4620      	mov	r0, r4
 800a5c2:	f7fa fa67 	bl	8004a94 <tcp_err>
  tcp_poll(pcb, NULL, 0);
 800a5c6:	2200      	movs	r2, #0
 800a5c8:	4611      	mov	r1, r2
 800a5ca:	4620      	mov	r0, r4
 800a5cc:	f7fa fa68 	bl	8004aa0 <tcp_poll>
  tcp_sent(pcb, NULL);
 800a5d0:	4620      	mov	r0, r4
 800a5d2:	2100      	movs	r1, #0
 800a5d4:	f7fa fa5c 	bl	8004a90 <tcp_sent>
 * Also frees the file data if dynamic.
 */
static void http_state_free(struct http_state *hs)
{
  if (hs != NULL) {
    if(hs->handle) {
 800a5d8:	6828      	ldr	r0, [r5, #0]
 800a5da:	2800      	cmp	r0, #0
 800a5dc:	d1c6      	bne.n	800a56c <http_recv+0x7c>
 800a5de:	e7c9      	b.n	800a574 <http_recv+0x84>

  LWIP_UNUSED_ARG(pcb); /* only used for post */
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("hs != NULL", hs != NULL);

  if ((hs->handle != NULL) || (hs->file != NULL)) {
 800a5e0:	686b      	ldr	r3, [r5, #4]
 800a5e2:	68a8      	ldr	r0, [r5, #8]
 800a5e4:	2b00      	cmp	r3, #0
 800a5e6:	f040 80e4 	bne.w	800a7b2 <http_recv+0x2c2>
  LWIP_DEBUGF(HTTPD_DEBUG, ("Received %d bytes\n", p->tot_len));

  /* first check allowed characters in this pbuf? */

  /* enqueue the pbuf */
  if (hs->req == NULL) {
 800a5ea:	2800      	cmp	r0, #0
 800a5ec:	f000 80d9 	beq.w	800a7a2 <http_recv+0x2b2>
    LWIP_DEBUGF(HTTPD_DEBUG, ("First pbuf\n"));
    hs->req = p;
  } else {
    LWIP_DEBUGF(HTTPD_DEBUG, ("pbuf enqueued\n"));
    pbuf_cat(hs->req, p);
 800a5f0:	4631      	mov	r1, r6
 800a5f2:	f7f9 fe0f 	bl	8004214 <pbuf_cat>
 800a5f6:	68a8      	ldr	r0, [r5, #8]
  }

  if (hs->req->next != NULL) {
 800a5f8:	6803      	ldr	r3, [r0, #0]
 800a5fa:	2b00      	cmp	r3, #0
 800a5fc:	f000 80d4 	beq.w	800a7a8 <http_recv+0x2b8>
    data_len = LWIP_MIN(hs->req->tot_len, LWIP_HTTPD_MAX_REQ_LENGTH);
 800a600:	f8b0 9008 	ldrh.w	r9, [r0, #8]
    pbuf_copy_partial(hs->req, httpd_req_buf, data_len, 0);
 800a604:	49a5      	ldr	r1, [pc, #660]	; (800a89c <http_recv+0x3ac>)
    LWIP_DEBUGF(HTTPD_DEBUG, ("pbuf enqueued\n"));
    pbuf_cat(hs->req, p);
  }

  if (hs->req->next != NULL) {
    data_len = LWIP_MIN(hs->req->tot_len, LWIP_HTTPD_MAX_REQ_LENGTH);
 800a606:	f240 33ff 	movw	r3, #1023	; 0x3ff
 800a60a:	4599      	cmp	r9, r3
 800a60c:	bf28      	it	cs
 800a60e:	4699      	movcs	r9, r3
    pbuf_copy_partial(hs->req, httpd_req_buf, data_len, 0);
 800a610:	464a      	mov	r2, r9
 800a612:	2300      	movs	r3, #0
    data = httpd_req_buf;
 800a614:	4688      	mov	r8, r1
    pbuf_cat(hs->req, p);
  }

  if (hs->req->next != NULL) {
    data_len = LWIP_MIN(hs->req->tot_len, LWIP_HTTPD_MAX_REQ_LENGTH);
    pbuf_copy_partial(hs->req, httpd_req_buf, data_len, 0);
 800a616:	f7f9 fe95 	bl	8004344 <pbuf_copy_partial>
      LWIP_DEBUGF(HTTPD_DEBUG, ("Warning: incomplete header due to chained pbufs\n"));
    }
  }

  /* received enough data for minimal request? */
  if (data_len >= MIN_REQ_LEN) {
 800a61a:	f1b9 0f06 	cmp.w	r9, #6
 800a61e:	d941      	bls.n	800a6a4 <http_recv+0x1b4>
  const char* p;
  int tokenlen = (int)strlen(token);
  if (tokenlen == 0) {
    return (char *)buffer;
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 800a620:	f898 3000 	ldrb.w	r3, [r8]
 800a624:	2b00      	cmp	r3, #0
 800a626:	d03d      	beq.n	800a6a4 <http_recv+0x1b4>
 800a628:	eb08 0709 	add.w	r7, r8, r9
 800a62c:	f108 0202 	add.w	r2, r8, #2
 800a630:	4297      	cmp	r7, r2
 800a632:	d337      	bcc.n	800a6a4 <http_recv+0x1b4>
 800a634:	3f01      	subs	r7, #1
 800a636:	4646      	mov	r6, r8
 800a638:	e004      	b.n	800a644 <http_recv+0x154>
 800a63a:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800a63e:	b38b      	cbz	r3, 800a6a4 <http_recv+0x1b4>
 800a640:	42be      	cmp	r6, r7
 800a642:	d02f      	beq.n	800a6a4 <http_recv+0x1b4>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
 800a644:	2b0d      	cmp	r3, #13
 800a646:	d1f8      	bne.n	800a63a <http_recv+0x14a>
 800a648:	2202      	movs	r2, #2
 800a64a:	4995      	ldr	r1, [pc, #596]	; (800a8a0 <http_recv+0x3b0>)
 800a64c:	4630      	mov	r0, r6
 800a64e:	f000 ffd7 	bl	800b600 <strncmp>
 800a652:	2800      	cmp	r0, #0
 800a654:	d1f1      	bne.n	800a63a <http_recv+0x14a>
 800a656:	4682      	mov	sl, r0
      int is_09 = 0;
      char *sp1, *sp2;
      u16_t left_len, uri_len;
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("CRLF received, parsing request\n"));
      /* parse method */
      if (!strncmp(data, "GET ", 4)) {
 800a658:	2204      	movs	r2, #4
 800a65a:	4992      	ldr	r1, [pc, #584]	; (800a8a4 <http_recv+0x3b4>)
 800a65c:	4640      	mov	r0, r8
 800a65e:	f000 ffcf 	bl	800b600 <strncmp>
 800a662:	2800      	cmp	r0, #0
 800a664:	d19d      	bne.n	800a5a2 <http_recv+0xb2>
        LWIP_DEBUGF(HTTPD_DEBUG, ("Unsupported request method (not implemented): \"%s\"\n",
          data));
        return http_find_error_file(hs, 501);
      }
      /* if we come here, method is OK, parse URI */
      left_len = data_len - ((sp1 +1) - data);
 800a666:	f108 0704 	add.w	r7, r8, #4
 800a66a:	4638      	mov	r0, r7
  const char* p;
  int tokenlen = (int)strlen(token);
  if (tokenlen == 0) {
    return (char *)buffer;
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 800a66c:	4603      	mov	r3, r0
          data));
        return http_find_error_file(hs, 501);
      }
      /* if we come here, method is OK, parse URI */
      left_len = data_len - ((sp1 +1) - data);
      sp2 = strnstr(sp1 + 1, " ", left_len);
 800a66e:	f1a9 0204 	sub.w	r2, r9, #4
  const char* p;
  int tokenlen = (int)strlen(token);
  if (tokenlen == 0) {
    return (char *)buffer;
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 800a672:	f813 1b01 	ldrb.w	r1, [r3], #1
          data));
        return http_find_error_file(hs, 501);
      }
      /* if we come here, method is OK, parse URI */
      left_len = data_len - ((sp1 +1) - data);
      sp2 = strnstr(sp1 + 1, " ", left_len);
 800a676:	b292      	uxth	r2, r2
  const char* p;
  int tokenlen = (int)strlen(token);
  if (tokenlen == 0) {
    return (char *)buffer;
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 800a678:	eb07 0e02 	add.w	lr, r7, r2
      char *sp1, *sp2;
      u16_t left_len, uri_len;
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("CRLF received, parsing request\n"));
      /* parse method */
      if (!strncmp(data, "GET ", 4)) {
        sp1 = data + 3;
 800a67c:	f108 0603 	add.w	r6, r8, #3
  const char* p;
  int tokenlen = (int)strlen(token);
  if (tokenlen == 0) {
    return (char *)buffer;
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 800a680:	b149      	cbz	r1, 800a696 <http_recv+0x1a6>
 800a682:	459e      	cmp	lr, r3
 800a684:	d307      	bcc.n	800a696 <http_recv+0x1a6>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
 800a686:	2920      	cmp	r1, #32
 800a688:	d01b      	beq.n	800a6c2 <http_recv+0x1d2>
 800a68a:	4618      	mov	r0, r3
  const char* p;
  int tokenlen = (int)strlen(token);
  if (tokenlen == 0) {
    return (char *)buffer;
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 800a68c:	4603      	mov	r3, r0
 800a68e:	f813 1b01 	ldrb.w	r1, [r3], #1
 800a692:	2900      	cmp	r1, #0
 800a694:	d1f5      	bne.n	800a682 <http_recv+0x192>
      left_len = data_len - ((sp1 +1) - data);
      sp2 = strnstr(sp1 + 1, " ", left_len);
#if LWIP_HTTPD_SUPPORT_V09
      if (sp2 == NULL) {
        /* HTTP 0.9: respond with correct protocol version */
        sp2 = strnstr(sp1 + 1, CRLF, left_len);
 800a696:	4982      	ldr	r1, [pc, #520]	; (800a8a0 <http_recv+0x3b0>)
 800a698:	4638      	mov	r0, r7
 800a69a:	f7ff fa91 	bl	8009bc0 <strnstr>
        }
#endif /* LWIP_HTTPD_SUPPORT_POST */
      }
#endif /* LWIP_HTTPD_SUPPORT_V09 */
      uri_len = sp2 - (sp1 + 1);
      if ((sp2 != 0) && (sp2 > sp1)) {
 800a69e:	2800      	cmp	r0, #0
 800a6a0:	f040 8133 	bne.w	800a90a <http_recv+0x41a>
      }
    }
  }

#if LWIP_HTTPD_SUPPORT_REQUESTLIST
  clen = pbuf_clen(hs->req);
 800a6a4:	68a8      	ldr	r0, [r5, #8]
 800a6a6:	f7f9 fda5 	bl	80041f4 <pbuf_clen>
 800a6aa:	4603      	mov	r3, r0
  if ((hs->req->tot_len <= LWIP_HTTPD_REQ_BUFSIZE) &&
 800a6ac:	68a8      	ldr	r0, [r5, #8]
 800a6ae:	8902      	ldrh	r2, [r0, #8]
 800a6b0:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800a6b4:	d202      	bcs.n	800a6bc <http_recv+0x1cc>
 800a6b6:	2b0a      	cmp	r3, #10
 800a6b8:	f67f af34 	bls.w	800a524 <http_recv+0x34>
 800a6bc:	f06f 060d 	mvn.w	r6, #13
 800a6c0:	e72a      	b.n	800a518 <http_recv+0x28>
          goto badrequest;
        }
#endif /* LWIP_HTTPD_SUPPORT_POST */
      }
#endif /* LWIP_HTTPD_SUPPORT_V09 */
      uri_len = sp2 - (sp1 + 1);
 800a6c2:	1bc3      	subs	r3, r0, r7
    crlf = strnstr(data, CRLF, data_len);
    if (crlf != NULL) {
#if LWIP_HTTPD_SUPPORT_POST
      int is_post = 0;
#endif /* LWIP_HTTPD_SUPPORT_POST */
      int is_09 = 0;
 800a6c4:	f04f 0a00 	mov.w	sl, #0
        }
#endif /* LWIP_HTTPD_SUPPORT_POST */
      }
#endif /* LWIP_HTTPD_SUPPORT_V09 */
      uri_len = sp2 - (sp1 + 1);
      if ((sp2 != 0) && (sp2 > sp1)) {
 800a6c8:	4286      	cmp	r6, r0
 800a6ca:	d2eb      	bcs.n	800a6a4 <http_recv+0x1b4>
        char *uri = sp1 + 1;
        /* null-terminate the METHOD (pbuf is freed anyway wen returning) */
        *sp1 = 0;
        uri[uri_len] = 0;
 800a6cc:	b29b      	uxth	r3, r3
#endif /* LWIP_HTTPD_SUPPORT_V09 */
      uri_len = sp2 - (sp1 + 1);
      if ((sp2 != 0) && (sp2 > sp1)) {
        char *uri = sp1 + 1;
        /* null-terminate the METHOD (pbuf is freed anyway wen returning) */
        *sp1 = 0;
 800a6ce:	2200      	movs	r2, #0
 800a6d0:	f888 2003 	strb.w	r2, [r8, #3]
        uri[uri_len] = 0;
 800a6d4:	54fa      	strb	r2, [r7, r3]
#if LWIP_HTTPD_SSI
  /*
   * By default, assume we will not be processing server-side-includes
   * tags
   */
  hs->tag_check = false;
 800a6d6:	f885 202c 	strb.w	r2, [r5, #44]	; 0x2c
#endif /* LWIP_HTTPD_SSI */

  /* Have we been asked for the default root file? */
  if((uri[0] == '/') &&  (uri[1] == 0)) {
 800a6da:	f898 3004 	ldrb.w	r3, [r8, #4]
 800a6de:	2b2f      	cmp	r3, #47	; 0x2f
 800a6e0:	f000 80ea 	beq.w	800a8b8 <http_recv+0x3c8>
    }
  } else {
    /* No - we've been asked for a specific file. */
#if LWIP_HTTPD_CGI
    /* First, isolate the base URI (without any parameters) */
    params = (char *)strchr(uri, '?');
 800a6e4:	213f      	movs	r1, #63	; 0x3f
 800a6e6:	4638      	mov	r0, r7
 800a6e8:	f000 ff7c 	bl	800b5e4 <strchr>
    if (params != NULL) {
 800a6ec:	4681      	mov	r9, r0
 800a6ee:	b110      	cbz	r0, 800a6f6 <http_recv+0x206>
      /* URI contains parameters. NULL-terminate the base URI */
      *params = '\0';
 800a6f0:	2300      	movs	r3, #0
 800a6f2:	f809 3b01 	strb.w	r3, [r9], #1
      params++;
    }

    /* Does the base URI we have isolated correspond to a CGI handler? */
    if (g_iNumCGIs && g_pCGIs) {
 800a6f6:	4b6c      	ldr	r3, [pc, #432]	; (800a8a8 <http_recv+0x3b8>)
 800a6f8:	f8d3 8000 	ldr.w	r8, [r3]
 800a6fc:	f1b8 0f00 	cmp.w	r8, #0
 800a700:	d077      	beq.n	800a7f2 <http_recv+0x302>
 800a702:	4b6a      	ldr	r3, [pc, #424]	; (800a8ac <http_recv+0x3bc>)
 800a704:	f8d3 b000 	ldr.w	fp, [r3]
 800a708:	f1bb 0f00 	cmp.w	fp, #0
 800a70c:	d071      	beq.n	800a7f2 <http_recv+0x302>
      for (i = 0; i < g_iNumCGIs; i++) {
 800a70e:	f1b8 0f00 	cmp.w	r8, #0
 800a712:	dd6e      	ble.n	800a7f2 <http_recv+0x302>
 800a714:	2600      	movs	r6, #0
 800a716:	e002      	b.n	800a71e <http_recv+0x22e>
 800a718:	3601      	adds	r6, #1
 800a71a:	45b0      	cmp	r8, r6
 800a71c:	d063      	beq.n	800a7e6 <http_recv+0x2f6>
        if (strcmp(uri, g_pCGIs[i].pcCGIName) == 0) {
 800a71e:	f85b 1036 	ldr.w	r1, [fp, r6, lsl #3]
 800a722:	4638      	mov	r0, r7
 800a724:	f7f5 fd5c 	bl	80001e0 <strcmp>
 800a728:	00f3      	lsls	r3, r6, #3
 800a72a:	2800      	cmp	r0, #0
 800a72c:	d1f4      	bne.n	800a718 <http_recv+0x228>
  char *pair;
  char *equals;
  int loop;

  /* If we have no parameters at all, return immediately. */
  if(!params || (params[0] == '\0')) {
 800a72e:	f1b9 0f00 	cmp.w	r9, #0
 800a732:	d048      	beq.n	800a7c6 <http_recv+0x2d6>
 800a734:	f899 2000 	ldrb.w	r2, [r9]
 800a738:	2a00      	cmp	r2, #0
 800a73a:	d044      	beq.n	800a7c6 <http_recv+0x2d6>
 800a73c:	f105 0bf0 	add.w	fp, r5, #240	; 0xf0
 800a740:	e88d 0028 	stmia.w	sp, {r3, r5}
 800a744:	4607      	mov	r7, r0
 800a746:	465d      	mov	r5, fp
 800a748:	46a3      	mov	fp, r4
 800a74a:	464c      	mov	r4, r9
 800a74c:	e016      	b.n	800a77c <http_recv+0x28c>

    /* Find the start of the next name=value pair and replace the delimiter
     * with a 0 to terminate the previous pair string. */
    pair = strchr(pair, '&');
    if(pair) {
      *pair = '\0';
 800a74e:	f04f 0300 	mov.w	r3, #0
 800a752:	f808 3b01 	strb.w	r3, [r8], #1
        pair = NULL;
    }

    /* Now find the '=' in the previous pair, replace it with '\0' and save
     * the parameter value string. */
    equals = strchr(equals, '=');
 800a756:	4620      	mov	r0, r4
 800a758:	213d      	movs	r1, #61	; 0x3d
 800a75a:	f000 ff43 	bl	800b5e4 <strchr>
    if(equals) {
 800a75e:	2800      	cmp	r0, #0
 800a760:	f000 80c6 	beq.w	800a8f0 <http_recv+0x400>
      *equals = '\0';
 800a764:	f04f 0300 	mov.w	r3, #0
 800a768:	f800 3b01 	strb.w	r3, [r0], #1
      hs->param_vals[loop] = equals + 1;
 800a76c:	6428      	str	r0, [r5, #64]	; 0x40
  /* Get a pointer to our first parameter */
  pair = params;

  /* Parse up to LWIP_HTTPD_MAX_CGI_PARAMETERS from the passed string and ignore the
   * remainder (if any) */
  for(loop = 0; (loop < LWIP_HTTPD_MAX_CGI_PARAMETERS) && pair; loop++) {
 800a76e:	3701      	adds	r7, #1
 800a770:	2f10      	cmp	r7, #16
 800a772:	d024      	beq.n	800a7be <http_recv+0x2ce>
 800a774:	f1b8 0f00 	cmp.w	r8, #0
 800a778:	d021      	beq.n	800a7be <http_recv+0x2ce>
 800a77a:	4644      	mov	r4, r8

    /* Save the name of the parameter */
    hs->params[loop] = pair;
 800a77c:	f845 4f04 	str.w	r4, [r5, #4]!
    /* Remember the start of this name=value pair */
    equals = pair;

    /* Find the start of the next name=value pair and replace the delimiter
     * with a 0 to terminate the previous pair string. */
    pair = strchr(pair, '&');
 800a780:	2126      	movs	r1, #38	; 0x26
 800a782:	4620      	mov	r0, r4
 800a784:	f000 ff2e 	bl	800b5e4 <strchr>
    if(pair) {
 800a788:	4680      	mov	r8, r0
 800a78a:	2800      	cmp	r0, #0
 800a78c:	d1df      	bne.n	800a74e <http_recv+0x25e>
      *pair = '\0';
      pair++;
    } else {
       /* We didn't find a new parameter so find the end of the URI and
        * replace the space with a '\0' */
        pair = strchr(equals, ' ');
 800a78e:	2120      	movs	r1, #32
 800a790:	4620      	mov	r0, r4
 800a792:	f000 ff27 	bl	800b5e4 <strchr>
        if(pair) {
 800a796:	2800      	cmp	r0, #0
 800a798:	f000 80bb 	beq.w	800a912 <http_recv+0x422>
            *pair = '\0';
 800a79c:	f880 8000 	strb.w	r8, [r0]
 800a7a0:	e7d9      	b.n	800a756 <http_recv+0x266>
  /* first check allowed characters in this pbuf? */

  /* enqueue the pbuf */
  if (hs->req == NULL) {
    LWIP_DEBUGF(HTTPD_DEBUG, ("First pbuf\n"));
    hs->req = p;
 800a7a2:	60ae      	str	r6, [r5, #8]
 800a7a4:	4630      	mov	r0, r6
 800a7a6:	e727      	b.n	800a5f8 <http_recv+0x108>
    pbuf_copy_partial(hs->req, httpd_req_buf, data_len, 0);
    data = httpd_req_buf;
  } else
#endif /* LWIP_HTTPD_SUPPORT_REQUESTLIST */
  {
    data = (char *)p->payload;
 800a7a8:	f8d6 8004 	ldr.w	r8, [r6, #4]
    data_len = p->len;
 800a7ac:	f8b6 900a 	ldrh.w	r9, [r6, #10]
 800a7b0:	e733      	b.n	800a61a <http_recv+0x12a>

  if ((hs->handle != NULL) || (hs->file != NULL)) {
    LWIP_DEBUGF(HTTPD_DEBUG, ("Received data while sending a file\n"));
    /* already sending a file */
    /* @todo: abort? */
    return ERR_USE;
 800a7b2:	f06f 0607 	mvn.w	r6, #7
      LWIP_DEBUGF(HTTPD_DEBUG, ("http_recv: already sending data\n"));
    }
#if LWIP_HTTPD_SUPPORT_REQUESTLIST
    if (parsed != ERR_INPROGRESS) {
      /* request fully parsed or error */
      if (hs->req != NULL) {
 800a7b6:	2800      	cmp	r0, #0
 800a7b8:	f47f aeae 	bne.w	800a518 <http_recv+0x28>
 800a7bc:	e6b2      	b.n	800a524 <http_recv+0x34>
 800a7be:	e89d 0028 	ldmia.w	sp, {r3, r5}
 800a7c2:	465c      	mov	r4, fp
  /* Get a pointer to our first parameter */
  pair = params;

  /* Parse up to LWIP_HTTPD_MAX_CGI_PARAMETERS from the passed string and ignore the
   * remainder (if any) */
  for(loop = 0; (loop < LWIP_HTTPD_MAX_CGI_PARAMETERS) && pair; loop++) {
 800a7c4:	4638      	mov	r0, r7
          /*
           * We found a CGI that handles this URI so extract the
           * parameters and call the handler.
           */
           count = extract_uri_parameters(hs, params);
           uri = g_pCGIs[i].pfnCGIHandler(i, count, hs->params,
 800a7c6:	4a39      	ldr	r2, [pc, #228]	; (800a8ac <http_recv+0x3bc>)
 800a7c8:	6812      	ldr	r2, [r2, #0]
 800a7ca:	4413      	add	r3, r2
 800a7cc:	4601      	mov	r1, r0
 800a7ce:	685f      	ldr	r7, [r3, #4]
 800a7d0:	f105 02f4 	add.w	r2, r5, #244	; 0xf4
 800a7d4:	f505 739a 	add.w	r3, r5, #308	; 0x134
 800a7d8:	4630      	mov	r0, r6
 800a7da:	47b8      	blx	r7
        }
      }

      /* Did we handle this URL as a CGI? If not, reinstate the
       * original URL and pass it to the file system directly. */
      if (i == g_iNumCGIs) {
 800a7dc:	4b32      	ldr	r3, [pc, #200]	; (800a8a8 <http_recv+0x3b8>)
 800a7de:	681b      	ldr	r3, [r3, #0]
 800a7e0:	42b3      	cmp	r3, r6
          /*
           * We found a CGI that handles this URI so extract the
           * parameters and call the handler.
           */
           count = extract_uri_parameters(hs, params);
           uri = g_pCGIs[i].pfnCGIHandler(i, count, hs->params,
 800a7e2:	4607      	mov	r7, r0
        }
      }

      /* Did we handle this URL as a CGI? If not, reinstate the
       * original URL and pass it to the file system directly. */
      if (i == g_iNumCGIs) {
 800a7e4:	d105      	bne.n	800a7f2 <http_recv+0x302>
        /* Replace the ? marker at the beginning of the parameters */
        if (params != NULL) {
 800a7e6:	f1b9 0f00 	cmp.w	r9, #0
 800a7ea:	d002      	beq.n	800a7f2 <http_recv+0x302>
           params--;
          *params = '?';
 800a7ec:	233f      	movs	r3, #63	; 0x3f
 800a7ee:	f809 3c01 	strb.w	r3, [r9, #-1]
    }
#endif /* LWIP_HTTPD_CGI */

    LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Opening %s\n", uri));

    file = fs_open(uri);
 800a7f2:	4638      	mov	r0, r7
 800a7f4:	f7ff f8da 	bl	80099ac <fs_open>
    if (file == NULL) {
 800a7f8:	4606      	mov	r6, r0
 800a7fa:	2800      	cmp	r0, #0
 800a7fc:	d07e      	beq.n	800a8fc <http_recv+0x40c>
       * See if we have been asked for an shtml file and, if so,
       * enable tag checking.
       */
      hs->tag_check = false;
      for (loop = 0; loop < NUM_SHTML_EXTENSIONS; loop++) {
        if (strstr(uri, g_pcSSIExtensions[loop])) {
 800a7fe:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 800a8b4 <http_recv+0x3c4>
    if (file != NULL) {
      /*
       * See if we have been asked for an shtml file and, if so,
       * enable tag checking.
       */
      hs->tag_check = false;
 800a802:	2300      	movs	r3, #0
      for (loop = 0; loop < NUM_SHTML_EXTENSIONS; loop++) {
        if (strstr(uri, g_pcSSIExtensions[loop])) {
 800a804:	f8d8 1000 	ldr.w	r1, [r8]
    if (file != NULL) {
      /*
       * See if we have been asked for an shtml file and, if so,
       * enable tag checking.
       */
      hs->tag_check = false;
 800a808:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
      for (loop = 0; loop < NUM_SHTML_EXTENSIONS; loop++) {
        if (strstr(uri, g_pcSSIExtensions[loop])) {
 800a80c:	4638      	mov	r0, r7
 800a80e:	f000 ff0c 	bl	800b62a <strstr>
 800a812:	2800      	cmp	r0, #0
 800a814:	d16e      	bne.n	800a8f4 <http_recv+0x404>
 800a816:	f8d8 1004 	ldr.w	r1, [r8, #4]
 800a81a:	4638      	mov	r0, r7
 800a81c:	f000 ff05 	bl	800b62a <strstr>
 800a820:	2800      	cmp	r0, #0
 800a822:	d167      	bne.n	800a8f4 <http_recv+0x404>
 800a824:	f8d8 1008 	ldr.w	r1, [r8, #8]
 800a828:	4638      	mov	r0, r7
 800a82a:	f000 fefe 	bl	800b62a <strstr>
 800a82e:	2800      	cmp	r0, #0
 800a830:	d160      	bne.n	800a8f4 <http_recv+0x404>
 800a832:	f8d8 100c 	ldr.w	r1, [r8, #12]
 800a836:	4638      	mov	r0, r7
 800a838:	f000 fef7 	bl	800b62a <strstr>
 800a83c:	2800      	cmp	r0, #0
 800a83e:	d159      	bne.n	800a8f4 <http_recv+0x404>
    /* file opened, initialise struct http_state */
#if LWIP_HTTPD_SSI
    hs->tag_index = 0;
    hs->tag_state = TAG_NONE;
    hs->parsed = file->data;
    hs->parse_left = file->len;
 800a840:	e896 0180 	ldmia.w	r6, {r7, r8}
static err_t http_init_file(struct http_state *hs, struct fs_file *file, int is_09, const char *uri)
{
  if (file != NULL) {
    /* file opened, initialise struct http_state */
#if LWIP_HTTPD_SSI
    hs->tag_index = 0;
 800a844:	2300      	movs	r3, #0
 800a846:	852b      	strh	r3, [r5, #40]	; 0x28
    hs->tag_state = TAG_NONE;
 800a848:	f885 30f1 	strb.w	r3, [r5, #241]	; 0xf1
    hs->parsed = file->data;
 800a84c:	61ef      	str	r7, [r5, #28]
#endif /* LWIP_HTTPD_SSI */
    hs->handle = file;
    hs->file = (char*)file->data;
    LWIP_ASSERT("File length must be positive!", (file->len >= 0));
    hs->left = file->len;
    hs->retries = 0;
 800a84e:	762b      	strb	r3, [r5, #24]
    /* file opened, initialise struct http_state */
#if LWIP_HTTPD_SSI
    hs->tag_index = 0;
    hs->tag_state = TAG_NONE;
    hs->parsed = file->data;
    hs->parse_left = file->len;
 800a850:	f8c5 8024 	str.w	r8, [r5, #36]	; 0x24
    hs->tag_end = file->data;
 800a854:	622f      	str	r7, [r5, #32]
#endif /* LWIP_HTTPD_SSI */
    hs->handle = file;
    hs->file = (char*)file->data;
 800a856:	606f      	str	r7, [r5, #4]
    LWIP_ASSERT("File length must be positive!", (file->len >= 0));
    hs->left = file->len;
 800a858:	f8c5 8014 	str.w	r8, [r5, #20]
    hs->tag_state = TAG_NONE;
    hs->parsed = file->data;
    hs->parse_left = file->len;
    hs->tag_end = file->data;
#endif /* LWIP_HTTPD_SSI */
    hs->handle = file;
 800a85c:	602e      	str	r6, [r5, #0]
#endif /* LWIP_HTTPD_TIMING */
#if !LWIP_HTTPD_DYNAMIC_HEADERS
    LWIP_ASSERT("HTTP headers not included in file system", hs->handle->http_header_included);
#endif /* !LWIP_HTTPD_DYNAMIC_HEADERS */
#if LWIP_HTTPD_SUPPORT_V09
    if (hs->handle->http_header_included && is_09) {
 800a85e:	7c33      	ldrb	r3, [r6, #16]
 800a860:	b173      	cbz	r3, 800a880 <http_recv+0x390>
 800a862:	f1ba 0f00 	cmp.w	sl, #0
 800a866:	d00b      	beq.n	800a880 <http_recv+0x390>
      /* HTTP/0.9 responses are sent without HTTP header,
         search for the end of the header. */
      char *file_start = strnstr(hs->file, CRLF CRLF, hs->left);
 800a868:	4642      	mov	r2, r8
 800a86a:	4911      	ldr	r1, [pc, #68]	; (800a8b0 <http_recv+0x3c0>)
 800a86c:	4638      	mov	r0, r7
 800a86e:	f7ff f9a7 	bl	8009bc0 <strnstr>
      if (file_start != NULL) {
 800a872:	b128      	cbz	r0, 800a880 <http_recv+0x390>
        size_t diff = file_start + 4 - hs->file;
 800a874:	1d03      	adds	r3, r0, #4
        hs->file += diff;
        hs->left -= (u32_t)diff;
 800a876:	1bdf      	subs	r7, r3, r7
 800a878:	ebc7 0708 	rsb	r7, r7, r8
 800a87c:	616f      	str	r7, [r5, #20]
      /* HTTP/0.9 responses are sent without HTTP header,
         search for the end of the header. */
      char *file_start = strnstr(hs->file, CRLF CRLF, hs->left);
      if (file_start != NULL) {
        size_t diff = file_start + 4 - hs->file;
        hs->file += diff;
 800a87e:	606b      	str	r3, [r5, #4]
      LWIP_DEBUGF(HTTPD_DEBUG, ("http_recv: already sending data\n"));
    }
#if LWIP_HTTPD_SUPPORT_REQUESTLIST
    if (parsed != ERR_INPROGRESS) {
      /* request fully parsed or error */
      if (hs->req != NULL) {
 800a880:	68a8      	ldr	r0, [r5, #8]
 800a882:	b118      	cbz	r0, 800a88c <http_recv+0x39c>
        pbuf_free(hs->req);
 800a884:	f7f9 fc88 	bl	8004198 <pbuf_free>
        hs->req = NULL;
 800a888:	2300      	movs	r3, #0
 800a88a:	60ab      	str	r3, [r5, #8]
#if LWIP_HTTPD_SUPPORT_POST
      if (hs->post_content_len_left == 0)
#endif /* LWIP_HTTPD_SUPPORT_POST */
      {
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: data %p len %"S32_F"\n", hs->file, hs->left));
        http_send_data(pcb, hs);
 800a88c:	4629      	mov	r1, r5
 800a88e:	4620      	mov	r0, r4
 800a890:	f7ff fa08 	bl	8009ca4 <http_send_data>
 800a894:	e646      	b.n	800a524 <http_recv+0x34>
 800a896:	bf00      	nop
 800a898:	0800a425 	.word	0x0800a425
 800a89c:	20002a94 	.word	0x20002a94
 800a8a0:	08019708 	.word	0x08019708
 800a8a4:	08019714 	.word	0x08019714
 800a8a8:	20002a88 	.word	0x20002a88
 800a8ac:	20002a8c 	.word	0x20002a8c
 800a8b0:	0801970c 	.word	0x0801970c
 800a8b4:	20000020 	.word	0x20000020
   */
  hs->tag_check = false;
#endif /* LWIP_HTTPD_SSI */

  /* Have we been asked for the default root file? */
  if((uri[0] == '/') &&  (uri[1] == 0)) {
 800a8b8:	f898 3005 	ldrb.w	r3, [r8, #5]
 800a8bc:	2b00      	cmp	r3, #0
 800a8be:	f47f af11 	bne.w	800a6e4 <http_recv+0x1f4>
 800a8c2:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 800a978 <http_recv+0x488>
 800a8c6:	461f      	mov	r7, r3
    /* Try each of the configured default filenames until we find one
       that exists. */
    for (loop = 0; loop < NUM_DEFAULT_FILENAMES; loop++) {
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Looking for %s...\n", g_psDefaultFilenames[loop].name));
      file = fs_open((char *)g_psDefaultFilenames[loop].name);
 800a8c8:	f859 0037 	ldr.w	r0, [r9, r7, lsl #3]
 800a8cc:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 800a978 <http_recv+0x488>
 800a8d0:	f7ff f86c 	bl	80099ac <fs_open>
 800a8d4:	00fb      	lsls	r3, r7, #3

  /* Have we been asked for the default root file? */
  if((uri[0] == '/') &&  (uri[1] == 0)) {
    /* Try each of the configured default filenames until we find one
       that exists. */
    for (loop = 0; loop < NUM_DEFAULT_FILENAMES; loop++) {
 800a8d6:	3701      	adds	r7, #1
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Looking for %s...\n", g_psDefaultFilenames[loop].name));
      file = fs_open((char *)g_psDefaultFilenames[loop].name);
      uri = (char *)g_psDefaultFilenames[loop].name;
      if(file != NULL) {
 800a8d8:	bb20      	cbnz	r0, 800a924 <http_recv+0x434>

  /* Have we been asked for the default root file? */
  if((uri[0] == '/') &&  (uri[1] == 0)) {
    /* Try each of the configured default filenames until we find one
       that exists. */
    for (loop = 0; loop < NUM_DEFAULT_FILENAMES; loop++) {
 800a8da:	2f05      	cmp	r7, #5
 800a8dc:	d1f4      	bne.n	800a8c8 <http_recv+0x3d8>
static struct fs_file * http_get_404_file(const char **uri)
{
  struct fs_file *file;

  *uri = "/404.html";
  file = fs_open(*uri);
 800a8de:	4823      	ldr	r0, [pc, #140]	; (800a96c <http_recv+0x47c>)
 800a8e0:	f7ff f864 	bl	80099ac <fs_open>
  if(file == NULL) {
 800a8e4:	4606      	mov	r6, r0
 800a8e6:	b318      	cbz	r0, 800a930 <http_recv+0x440>
    }
    if (file == NULL) {
      /* None of the default filenames exist so send back a 404 page */
      file = http_get_404_file(&uri);
#if LWIP_HTTPD_SSI
      hs->tag_check = false;
 800a8e8:	2300      	movs	r3, #0
 800a8ea:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
 800a8ee:	e7a7      	b.n	800a840 <http_recv+0x350>
    equals = strchr(equals, '=');
    if(equals) {
      *equals = '\0';
      hs->param_vals[loop] = equals + 1;
    } else {
      hs->param_vals[loop] = NULL;
 800a8f0:	6428      	str	r0, [r5, #64]	; 0x40
 800a8f2:	e73c      	b.n	800a76e <http_recv+0x27e>
       * enable tag checking.
       */
      hs->tag_check = false;
      for (loop = 0; loop < NUM_SHTML_EXTENSIONS; loop++) {
        if (strstr(uri, g_pcSSIExtensions[loop])) {
          hs->tag_check = true;
 800a8f4:	2301      	movs	r3, #1
 800a8f6:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
 800a8fa:	e7a1      	b.n	800a840 <http_recv+0x350>
static struct fs_file * http_get_404_file(const char **uri)
{
  struct fs_file *file;

  *uri = "/404.html";
  file = fs_open(*uri);
 800a8fc:	481b      	ldr	r0, [pc, #108]	; (800a96c <http_recv+0x47c>)
 800a8fe:	f7ff f855 	bl	80099ac <fs_open>
  if(file == NULL) {
 800a902:	4606      	mov	r6, r0
 800a904:	b138      	cbz	r0, 800a916 <http_recv+0x426>
 */
static struct fs_file * http_get_404_file(const char **uri)
{
  struct fs_file *file;

  *uri = "/404.html";
 800a906:	4f19      	ldr	r7, [pc, #100]	; (800a96c <http_recv+0x47c>)
 800a908:	e779      	b.n	800a7fe <http_recv+0x30e>
          goto badrequest;
        }
#endif /* LWIP_HTTPD_SUPPORT_POST */
      }
#endif /* LWIP_HTTPD_SUPPORT_V09 */
      uri_len = sp2 - (sp1 + 1);
 800a90a:	1bc3      	subs	r3, r0, r7
      sp2 = strnstr(sp1 + 1, " ", left_len);
#if LWIP_HTTPD_SUPPORT_V09
      if (sp2 == NULL) {
        /* HTTP 0.9: respond with correct protocol version */
        sp2 = strnstr(sp1 + 1, CRLF, left_len);
        is_09 = 1;
 800a90c:	f04f 0a01 	mov.w	sl, #1
 800a910:	e6da      	b.n	800a6c8 <http_recv+0x1d8>
        if(pair) {
            *pair = '\0';
        }

        /* Revert to NULL so that we exit the loop as expected. */
        pair = NULL;
 800a912:	4680      	mov	r8, r0
 800a914:	e71f      	b.n	800a756 <http_recv+0x266>
  *uri = "/404.html";
  file = fs_open(*uri);
  if(file == NULL) {
    /* 404.html doesn't exist. Try 404.htm instead. */
    *uri = "/404.htm";
    file = fs_open(*uri);
 800a916:	4816      	ldr	r0, [pc, #88]	; (800a970 <http_recv+0x480>)
 800a918:	f7ff f848 	bl	80099ac <fs_open>
    if(file == NULL) {
 800a91c:	4606      	mov	r6, r0
 800a91e:	b1e8      	cbz	r0, 800a95c <http_recv+0x46c>

  *uri = "/404.html";
  file = fs_open(*uri);
  if(file == NULL) {
    /* 404.html doesn't exist. Try 404.htm instead. */
    *uri = "/404.htm";
 800a920:	4f13      	ldr	r7, [pc, #76]	; (800a970 <http_recv+0x480>)
 800a922:	e76c      	b.n	800a7fe <http_recv+0x30e>
      file = fs_open((char *)g_psDefaultFilenames[loop].name);
      uri = (char *)g_psDefaultFilenames[loop].name;
      if(file != NULL) {
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Opened.\n"));
#if LWIP_HTTPD_SSI
        hs->tag_check = g_psDefaultFilenames[loop].shtml;
 800a924:	4443      	add	r3, r8
 800a926:	4606      	mov	r6, r0
 800a928:	791b      	ldrb	r3, [r3, #4]
 800a92a:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
 800a92e:	e787      	b.n	800a840 <http_recv+0x350>
  *uri = "/404.html";
  file = fs_open(*uri);
  if(file == NULL) {
    /* 404.html doesn't exist. Try 404.htm instead. */
    *uri = "/404.htm";
    file = fs_open(*uri);
 800a930:	480f      	ldr	r0, [pc, #60]	; (800a970 <http_recv+0x480>)
 800a932:	f7ff f83b 	bl	80099ac <fs_open>
    if(file == NULL) {
 800a936:	4606      	mov	r6, r0
 800a938:	2800      	cmp	r0, #0
 800a93a:	d1d5      	bne.n	800a8e8 <http_recv+0x3f8>
      /* 404.htm doesn't exist either. Try 404.shtml instead. */
      *uri = "/404.shtml";
      file = fs_open(*uri);
 800a93c:	480d      	ldr	r0, [pc, #52]	; (800a974 <http_recv+0x484>)
 800a93e:	f7ff f835 	bl	80099ac <fs_open>
    }
    if (file == NULL) {
      /* None of the default filenames exist so send back a 404 page */
      file = http_get_404_file(&uri);
#if LWIP_HTTPD_SSI
      hs->tag_check = false;
 800a942:	2300      	movs	r3, #0
 * @return ERR_OK if file was found and hs has been initialized correctly
 *         another err_t otherwise
 */
static err_t http_init_file(struct http_state *hs, struct fs_file *file, int is_09, const char *uri)
{
  if (file != NULL) {
 800a944:	4606      	mov	r6, r0
    }
    if (file == NULL) {
      /* None of the default filenames exist so send back a 404 page */
      file = http_get_404_file(&uri);
#if LWIP_HTTPD_SSI
      hs->tag_check = false;
 800a946:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
 * @return ERR_OK if file was found and hs has been initialized correctly
 *         another err_t otherwise
 */
static err_t http_init_file(struct http_state *hs, struct fs_file *file, int is_09, const char *uri)
{
  if (file != NULL) {
 800a94a:	2800      	cmp	r0, #0
 800a94c:	f47f af78 	bne.w	800a840 <http_recv+0x350>
        hs->left -= (u32_t)diff;
      }
    }
#endif /* LWIP_HTTPD_SUPPORT_V09*/
  } else {
    hs->handle = NULL;
 800a950:	2300      	movs	r3, #0
 800a952:	602b      	str	r3, [r5, #0]
    hs->file = NULL;
 800a954:	606b      	str	r3, [r5, #4]
    hs->left = 0;
 800a956:	616b      	str	r3, [r5, #20]
    hs->retries = 0;
 800a958:	762b      	strb	r3, [r5, #24]
 800a95a:	e791      	b.n	800a880 <http_recv+0x390>
    *uri = "/404.htm";
    file = fs_open(*uri);
    if(file == NULL) {
      /* 404.htm doesn't exist either. Try 404.shtml instead. */
      *uri = "/404.shtml";
      file = fs_open(*uri);
 800a95c:	4805      	ldr	r0, [pc, #20]	; (800a974 <http_recv+0x484>)
 800a95e:	f7ff f825 	bl	80099ac <fs_open>
      if(file == NULL) {
 800a962:	4606      	mov	r6, r0
 800a964:	2800      	cmp	r0, #0
 800a966:	d0f3      	beq.n	800a950 <http_recv+0x460>
    /* 404.html doesn't exist. Try 404.htm instead. */
    *uri = "/404.htm";
    file = fs_open(*uri);
    if(file == NULL) {
      /* 404.htm doesn't exist either. Try 404.shtml instead. */
      *uri = "/404.shtml";
 800a968:	4f02      	ldr	r7, [pc, #8]	; (800a974 <http_recv+0x484>)
 800a96a:	e748      	b.n	800a7fe <http_recv+0x30e>
 800a96c:	080196f0 	.word	0x080196f0
 800a970:	080196fc 	.word	0x080196fc
 800a974:	080196e4 	.word	0x080196e4
 800a978:	08019774 	.word	0x08019774

0800a97c <httpd_init>:

/**
 * Initialize the httpd: set up a listening PCB and bind it to the defined port
 */
void httpd_init(void)
{
 800a97c:	b510      	push	{r4, lr}
  LWIP_DEBUGF(HTTPD_DEBUG, ("httpd_init\n"));

#if LWIP_HTTPD_SSI
  httpd_ssi_init();
 800a97e:	f000 f933 	bl	800abe8 <httpd_ssi_init>
#endif
  
#if LWIP_HTTPD_CGI
  httpd_cgi_init();
 800a982:	f000 f93b 	bl	800abfc <httpd_cgi_init>
static void httpd_init_addr(struct ip_addr *local_addr)
{
  struct tcp_pcb *pcb;
  err_t err;

  pcb = tcp_new();
 800a986:	f7fa fc01 	bl	800518c <tcp_new>
  LWIP_ASSERT("httpd_init: tcp_new failed", pcb != NULL);
  tcp_setprio(pcb, HTTPD_TCP_PRIO);
 800a98a:	2101      	movs	r1, #1
static void httpd_init_addr(struct ip_addr *local_addr)
{
  struct tcp_pcb *pcb;
  err_t err;

  pcb = tcp_new();
 800a98c:	4604      	mov	r4, r0
  LWIP_ASSERT("httpd_init: tcp_new failed", pcb != NULL);
  tcp_setprio(pcb, HTTPD_TCP_PRIO);
 800a98e:	f7fa f879 	bl	8004a84 <tcp_setprio>
  /* set SOF_REUSEADDR here to explicitly bind httpd to multiple interfaces */
  err = tcp_bind(pcb, local_addr, HTTPD_SERVER_PORT);
 800a992:	2250      	movs	r2, #80	; 0x50
 800a994:	4620      	mov	r0, r4
 800a996:	4908      	ldr	r1, [pc, #32]	; (800a9b8 <httpd_init+0x3c>)
 800a998:	f7f9 fd4e 	bl	8004438 <tcp_bind>
  LWIP_ASSERT("httpd_init: tcp_bind failed", err == ERR_OK);
  pcb = tcp_listen(pcb);
 800a99c:	4620      	mov	r0, r4
 800a99e:	21ff      	movs	r1, #255	; 0xff
 800a9a0:	f7f9 fdb2 	bl	8004508 <tcp_listen_with_backlog>
 800a9a4:	4604      	mov	r4, r0
  LWIP_ASSERT("httpd_init: tcp_listen failed", pcb != NULL);
  /* initialize callback arg and accept callback */
  tcp_arg(pcb, pcb);
 800a9a6:	4601      	mov	r1, r0
 800a9a8:	f7fa f86e 	bl	8004a88 <tcp_arg>
  tcp_accept(pcb, http_accept);
 800a9ac:	4620      	mov	r0, r4
 800a9ae:	4903      	ldr	r1, [pc, #12]	; (800a9bc <httpd_init+0x40>)
#if LWIP_HTTPD_CGI
  httpd_cgi_init();
#endif
  
  httpd_init_addr(IP_ADDR_ANY);
}
 800a9b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ASSERT("httpd_init: tcp_bind failed", err == ERR_OK);
  pcb = tcp_listen(pcb);
  LWIP_ASSERT("httpd_init: tcp_listen failed", pcb != NULL);
  /* initialize callback arg and accept callback */
  tcp_arg(pcb, pcb);
  tcp_accept(pcb, http_accept);
 800a9b4:	f7fa b872 	b.w	8004a9c <tcp_accept>
 800a9b8:	0800c9e0 	.word	0x0800c9e0
 800a9bc:	08009c11 	.word	0x08009c11

0800a9c0 <http_set_ssi_handler>:
 * @param ssi_handler the SSI handler function
 * @param tags an array of SSI tag strings to search for in SSI-enabled files
 * @param num_tags number of tags in the 'tags' array
 */
void http_set_ssi_handler(tSSIHandler ssi_handler, const char **tags, int num_tags)
{
 800a9c0:	b430      	push	{r4, r5}
  LWIP_ASSERT("no tags given", tags != NULL);
  LWIP_ASSERT("invalid number of tags", num_tags > 0);

  g_pfnSSIHandler = ssi_handler;
  g_ppcTags = tags;
  g_iNumTags = num_tags;
 800a9c2:	4b04      	ldr	r3, [pc, #16]	; (800a9d4 <http_set_ssi_handler+0x14>)

  LWIP_ASSERT("no ssi_handler given", ssi_handler != NULL);
  LWIP_ASSERT("no tags given", tags != NULL);
  LWIP_ASSERT("invalid number of tags", num_tags > 0);

  g_pfnSSIHandler = ssi_handler;
 800a9c4:	4d04      	ldr	r5, [pc, #16]	; (800a9d8 <http_set_ssi_handler+0x18>)
  g_ppcTags = tags;
 800a9c6:	4c05      	ldr	r4, [pc, #20]	; (800a9dc <http_set_ssi_handler+0x1c>)

  LWIP_ASSERT("no ssi_handler given", ssi_handler != NULL);
  LWIP_ASSERT("no tags given", tags != NULL);
  LWIP_ASSERT("invalid number of tags", num_tags > 0);

  g_pfnSSIHandler = ssi_handler;
 800a9c8:	6028      	str	r0, [r5, #0]
  g_ppcTags = tags;
 800a9ca:	6021      	str	r1, [r4, #0]
  g_iNumTags = num_tags;
 800a9cc:	601a      	str	r2, [r3, #0]
}
 800a9ce:	bc30      	pop	{r4, r5}
 800a9d0:	4770      	bx	lr
 800a9d2:	bf00      	nop
 800a9d4:	20002a90 	.word	0x20002a90
 800a9d8:	20002a80 	.word	0x20002a80
 800a9dc:	20002a84 	.word	0x20002a84

0800a9e0 <http_set_cgi_handlers>:
void http_set_cgi_handlers(const tCGI *cgis, int num_handlers)
{
  LWIP_ASSERT("no cgis given", cgis != NULL);
  LWIP_ASSERT("invalid number of handlers", num_handlers > 0);
  
  g_pCGIs = cgis;
 800a9e0:	4a02      	ldr	r2, [pc, #8]	; (800a9ec <http_set_cgi_handlers+0xc>)
  g_iNumCGIs = num_handlers;
 800a9e2:	4b03      	ldr	r3, [pc, #12]	; (800a9f0 <http_set_cgi_handlers+0x10>)
void http_set_cgi_handlers(const tCGI *cgis, int num_handlers)
{
  LWIP_ASSERT("no cgis given", cgis != NULL);
  LWIP_ASSERT("invalid number of handlers", num_handlers > 0);
  
  g_pCGIs = cgis;
 800a9e4:	6010      	str	r0, [r2, #0]
  g_iNumCGIs = num_handlers;
 800a9e6:	6019      	str	r1, [r3, #0]
 800a9e8:	4770      	bx	lr
 800a9ea:	bf00      	nop
 800a9ec:	20002a8c 	.word	0x20002a8c
 800a9f0:	20002a88 	.word	0x20002a88
 800a9f4:	00000000 	.word	0x00000000

0800a9f8 <ADC_Handler>:
  * @brief  ADC_Handler : SSI handler for ADC page 
  */
u16_t ADC_Handler(int iIndex, char *pcInsert, int iInsertLen)
{
  /* We have only one SSI handler iIndex = 0 */
  if (iIndex ==0)
 800a9f8:	2800      	cmp	r0, #0
 800a9fa:	d14a      	bne.n	800aa92 <ADC_Handler+0x9a>

/**
  * @brief  ADC_Handler : SSI handler for ADC page 
  */
u16_t ADC_Handler(int iIndex, char *pcInsert, int iInsertLen)
{
 800a9fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  {  
    char Digit1=0, Digit2=0, Digit3=0, Digit4=0; 
    uint32_t ADCVal = 0;        

     /* configure ADC if not yet configured */
     if (ADC_not_configured ==1)       
 800aa00:	4f45      	ldr	r7, [pc, #276]	; (800ab18 <ADC_Handler+0x120>)
 800aa02:	683e      	ldr	r6, [r7, #0]
 800aa04:	2e01      	cmp	r6, #1

/**
  * @brief  ADC_Handler : SSI handler for ADC page 
  */
u16_t ADC_Handler(int iIndex, char *pcInsert, int iInsertLen)
{
 800aa06:	b08c      	sub	sp, #48	; 0x30
 800aa08:	4605      	mov	r5, r0
 800aa0a:	460c      	mov	r4, r1
  {  
    char Digit1=0, Digit2=0, Digit3=0, Digit4=0; 
    uint32_t ADCVal = 0;        

     /* configure ADC if not yet configured */
     if (ADC_not_configured ==1)       
 800aa0c:	d043      	beq.n	800aa96 <ADC_Handler+0x9e>
        ADC_Configuration();
        ADC_not_configured=0;
     }
     
     /* get ADC conversion value */
     ADCVal = ADC_GetConversionValue(ADC3);
 800aa0e:	4843      	ldr	r0, [pc, #268]	; (800ab1c <ADC_Handler+0x124>)
     
     /* get digits to display */
     
     Digit1= ADCVal/1000;
     Digit2= (ADCVal-(Digit1*1000))/100 ;
     Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
 800aa10:	4e43      	ldr	r6, [pc, #268]	; (800ab20 <ADC_Handler+0x128>)
        ADC_Configuration();
        ADC_not_configured=0;
     }
     
     /* get ADC conversion value */
     ADCVal = ADC_GetConversionValue(ADC3);
 800aa12:	f7fe fc33 	bl	800927c <ADC_GetConversionValue>
     
     /* convert to Voltage,  step = 0.8 mV */
     ADCVal = (uint32_t)(ADCVal * 0.8);  
 800aa16:	f7f5 fd8d 	bl	8000534 <__aeabi_ui2d>
 800aa1a:	a33d      	add	r3, pc, #244	; (adr r3, 800ab10 <ADC_Handler+0x118>)
 800aa1c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aa20:	f7f5 fdfe 	bl	8000620 <__aeabi_dmul>
 800aa24:	f7f6 f80e 	bl	8000a44 <__aeabi_d2uiz>
     
     /* get digits to display */
     
     Digit1= ADCVal/1000;
 800aa28:	4a3e      	ldr	r2, [pc, #248]	; (800ab24 <ADC_Handler+0x12c>)
     Digit2= (ADCVal-(Digit1*1000))/100 ;
 800aa2a:	493f      	ldr	r1, [pc, #252]	; (800ab28 <ADC_Handler+0x130>)
 800aa2c:	4b3f      	ldr	r3, [pc, #252]	; (800ab2c <ADC_Handler+0x134>)
     /* convert to Voltage,  step = 0.8 mV */
     ADCVal = (uint32_t)(ADCVal * 0.8);  
     
     /* get digits to display */
     
     Digit1= ADCVal/1000;
 800aa2e:	fba2 5200 	umull	r5, r2, r2, r0
 800aa32:	f3c2 1587 	ubfx	r5, r2, #6, #8
     Digit2= (ADCVal-(Digit1*1000))/100 ;
 800aa36:	fb01 0105 	mla	r1, r1, r5, r0
 800aa3a:	fba3 3101 	umull	r3, r1, r3, r1
     Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
 800aa3e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
     ADCVal = (uint32_t)(ADCVal * 0.8);  
     
     /* get digits to display */
     
     Digit1= ADCVal/1000;
     Digit2= (ADCVal-(Digit1*1000))/100 ;
 800aa42:	f3c1 1147 	ubfx	r1, r1, #5, #8
     Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
 800aa46:	fb03 f305 	mul.w	r3, r3, r5
 800aa4a:	2264      	movs	r2, #100	; 0x64
 800aa4c:	fb02 3301 	mla	r3, r2, r1, r3
 800aa50:	1ac3      	subs	r3, r0, r3
        
     /* prepare data to be inserted in html */
     *pcInsert       = (char)(Digit1+0x30);
     *(pcInsert + 1) = (char)(Digit2+0x30);
     *(pcInsert + 2) = (char)(Digit3+0x30);
     *(pcInsert + 3) = (char)(Digit4+0x30);
 800aa52:	f100 0230 	add.w	r2, r0, #48	; 0x30
     
     /* get digits to display */
     
     Digit1= ADCVal/1000;
     Digit2= (ADCVal-(Digit1*1000))/100 ;
     Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
 800aa56:	fba6 0303 	umull	r0, r3, r6, r3
        
     /* prepare data to be inserted in html */
     *pcInsert       = (char)(Digit1+0x30);
     *(pcInsert + 1) = (char)(Digit2+0x30);
     *(pcInsert + 2) = (char)(Digit3+0x30);
     *(pcInsert + 3) = (char)(Digit4+0x30);
 800aa5a:	eba5 0085 	sub.w	r0, r5, r5, lsl #2
 800aa5e:	eb01 0681 	add.w	r6, r1, r1, lsl #2
 800aa62:	eba2 02c0 	sub.w	r2, r2, r0, lsl #3
     
     /* get digits to display */
     
     Digit1= ADCVal/1000;
     Digit2= (ADCVal-(Digit1*1000))/100 ;
     Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
 800aa66:	f3c3 03c7 	ubfx	r3, r3, #3, #8
        
     /* prepare data to be inserted in html */
     *pcInsert       = (char)(Digit1+0x30);
     *(pcInsert + 1) = (char)(Digit2+0x30);
     *(pcInsert + 2) = (char)(Digit3+0x30);
     *(pcInsert + 3) = (char)(Digit4+0x30);
 800aa6a:	eb06 0086 	add.w	r0, r6, r6, lsl #2
 800aa6e:	eba2 0080 	sub.w	r0, r2, r0, lsl #2
 800aa72:	eb03 0683 	add.w	r6, r3, r3, lsl #2
 800aa76:	eba0 0046 	sub.w	r0, r0, r6, lsl #1
     Digit2= (ADCVal-(Digit1*1000))/100 ;
     Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
     Digit4= ADCVal -((Digit1*1000)+(Digit2*100)+ (Digit3*10));
        
     /* prepare data to be inserted in html */
     *pcInsert       = (char)(Digit1+0x30);
 800aa7a:	f105 0230 	add.w	r2, r5, #48	; 0x30
     *(pcInsert + 1) = (char)(Digit2+0x30);
 800aa7e:	3130      	adds	r1, #48	; 0x30
     *(pcInsert + 2) = (char)(Digit3+0x30);
 800aa80:	3330      	adds	r3, #48	; 0x30
     *(pcInsert + 3) = (char)(Digit4+0x30);
 800aa82:	70e0      	strb	r0, [r4, #3]
 800aa84:	2004      	movs	r0, #4
     Digit2= (ADCVal-(Digit1*1000))/100 ;
     Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
     Digit4= ADCVal -((Digit1*1000)+(Digit2*100)+ (Digit3*10));
        
     /* prepare data to be inserted in html */
     *pcInsert       = (char)(Digit1+0x30);
 800aa86:	7022      	strb	r2, [r4, #0]
     *(pcInsert + 1) = (char)(Digit2+0x30);
 800aa88:	7061      	strb	r1, [r4, #1]
     *(pcInsert + 2) = (char)(Digit3+0x30);
 800aa8a:	70a3      	strb	r3, [r4, #2]
    
    /* 4 characters need to be inserted in html*/
    return 4;
  }
  return 0;
}
 800aa8c:	b00c      	add	sp, #48	; 0x30
 800aa8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     *(pcInsert + 3) = (char)(Digit4+0x30);
    
    /* 4 characters need to be inserted in html*/
    return 4;
  }
  return 0;
 800aa92:	2000      	movs	r0, #0
 800aa94:	4770      	bx	lr
  ADC_InitTypeDef ADC_InitStructure;
  ADC_CommonInitTypeDef ADC_CommonInitStructure;
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable ADC3 clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
 800aa96:	4631      	mov	r1, r6
 800aa98:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800aa9c:	f7fe fd14 	bl	80094c8 <RCC_APB2PeriphClockCmd>

  /* Configure ADC Channel 7 as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 800aaa0:	f04f 0803 	mov.w	r8, #3
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOF, &GPIO_InitStructure);
 800aaa4:	4669      	mov	r1, sp

  /* Enable ADC3 clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);

  /* Configure ADC Channel 7 as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 800aaa6:	f44f 7300 	mov.w	r3, #512	; 0x200
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOF, &GPIO_InitStructure);
 800aaaa:	4821      	ldr	r0, [pc, #132]	; (800ab30 <ADC_Handler+0x138>)

  /* Enable ADC3 clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);

  /* Configure ADC Channel 7 as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 800aaac:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 800aaae:	f88d 5007 	strb.w	r5, [sp, #7]
  /* Enable ADC3 clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);

  /* Configure ADC Channel 7 as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 800aab2:	f88d 8004 	strb.w	r8, [sp, #4]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOF, &GPIO_InitStructure);
 800aab6:	f7fe fc37 	bl	8009328 <GPIO_Init>

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div6;
 800aaba:	f44f 3300 	mov.w	r3, #131072	; 0x20000
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles; 
  ADC_CommonInit(&ADC_CommonInitStructure); 
 800aabe:	a802      	add	r0, sp, #8
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOF, &GPIO_InitStructure);

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div6;
 800aac0:	9303      	str	r3, [sp, #12]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOF, &GPIO_InitStructure);

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
 800aac2:	9502      	str	r5, [sp, #8]
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div6;
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 800aac4:	9504      	str	r5, [sp, #16]
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles; 
 800aac6:	9505      	str	r5, [sp, #20]
  ADC_CommonInit(&ADC_CommonInitStructure); 
 800aac8:	f7fe fb6a 	bl	80091a0 <ADC_CommonInit>

  /* ADC3 Configuration ------------------------------------------------------*/
  ADC_StructInit(&ADC_InitStructure);
 800aacc:	a806      	add	r0, sp, #24
 800aace:	f7fe fb5d 	bl	800918c <ADC_StructInit>
  ADC_InitStructure.ADC_ScanConvMode = DISABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None; 
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 1;
  ADC_Init(ADC3, &ADC_InitStructure);
 800aad2:	a906      	add	r1, sp, #24
 800aad4:	4811      	ldr	r0, [pc, #68]	; (800ab1c <ADC_Handler+0x124>)
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles; 
  ADC_CommonInit(&ADC_CommonInitStructure); 

  /* ADC3 Configuration ------------------------------------------------------*/
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 800aad6:	9506      	str	r5, [sp, #24]
  ADC_InitStructure.ADC_ScanConvMode = DISABLE;
 800aad8:	f88d 501c 	strb.w	r5, [sp, #28]
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
 800aadc:	f88d 601d 	strb.w	r6, [sp, #29]
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None; 
 800aae0:	9508      	str	r5, [sp, #32]
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 800aae2:	950a      	str	r5, [sp, #40]	; 0x28
  ADC_InitStructure.ADC_NbrOfConversion = 1;
 800aae4:	f88d 602c 	strb.w	r6, [sp, #44]	; 0x2c
  ADC_Init(ADC3, &ADC_InitStructure);
 800aae8:	f7fe fb28 	bl	800913c <ADC_Init>

  /* ADC3 Regular Channel Config */
  ADC_RegularChannelConfig(ADC3, ADC_Channel_7, 1, ADC_SampleTime_56Cycles);
 800aaec:	4643      	mov	r3, r8
 800aaee:	4632      	mov	r2, r6
 800aaf0:	2107      	movs	r1, #7
 800aaf2:	480a      	ldr	r0, [pc, #40]	; (800ab1c <ADC_Handler+0x124>)
 800aaf4:	f7fe fb72 	bl	80091dc <ADC_RegularChannelConfig>

  /* Enable ADC3 */
  ADC_Cmd(ADC3, ENABLE);
 800aaf8:	4631      	mov	r1, r6
 800aafa:	4808      	ldr	r0, [pc, #32]	; (800ab1c <ADC_Handler+0x124>)
 800aafc:	f7fe fb64 	bl	80091c8 <ADC_Cmd>

  /* ADC3 regular Software Start Conv */ 
  ADC_SoftwareStartConv(ADC3);
 800ab00:	4806      	ldr	r0, [pc, #24]	; (800ab1c <ADC_Handler+0x124>)
 800ab02:	f7fe fbb5 	bl	8009270 <ADC_SoftwareStartConv>

     /* configure ADC if not yet configured */
     if (ADC_not_configured ==1)       
     {
        ADC_Configuration();
        ADC_not_configured=0;
 800ab06:	603d      	str	r5, [r7, #0]
 800ab08:	e781      	b.n	800aa0e <ADC_Handler+0x16>
 800ab0a:	bf00      	nop
 800ab0c:	f3af 8000 	nop.w
 800ab10:	9999999a 	.word	0x9999999a
 800ab14:	3fe99999 	.word	0x3fe99999
 800ab18:	20000038 	.word	0x20000038
 800ab1c:	40012200 	.word	0x40012200
 800ab20:	cccccccd 	.word	0xcccccccd
 800ab24:	10624dd3 	.word	0x10624dd3
 800ab28:	fffffc18 	.word	0xfffffc18
 800ab2c:	51eb851f 	.word	0x51eb851f
 800ab30:	40021400 	.word	0x40021400

0800ab34 <LEDS_CGI_Handler>:
const char * LEDS_CGI_Handler(int iIndex, int iNumParams, char *pcParam[], char *pcValue[])
{
  uint32_t i=0;
  
  /* We have only one SSI handler iIndex = 0 */
  if (iIndex==0)
 800ab34:	b108      	cbz	r0, 800ab3a <LEDS_CGI_Handler+0x6>
      }
    }
  }
  /* uri to send after cgi call*/
  return "/STM32F4x7LED.html";  
}
 800ab36:	4826      	ldr	r0, [pc, #152]	; (800abd0 <LEDS_CGI_Handler+0x9c>)
 800ab38:	4770      	bx	lr

/**
  * @brief  CGI handler for LEDs control 
  */
const char * LEDS_CGI_Handler(int iIndex, int iNumParams, char *pcParam[], char *pcValue[])
{
 800ab3a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ab3e:	4604      	mov	r4, r0
  
  /* We have only one SSI handler iIndex = 0 */
  if (iIndex==0)
  {
    /* All leds off */
    STM_EVAL_LEDOff(LED5);
 800ab40:	2002      	movs	r0, #2
 800ab42:	460f      	mov	r7, r1
 800ab44:	4698      	mov	r8, r3
 800ab46:	4615      	mov	r5, r2
 800ab48:	f000 f9fc 	bl	800af44 <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED6);
 800ab4c:	2003      	movs	r0, #3
 800ab4e:	f000 f9f9 	bl	800af44 <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED3);
 800ab52:	2001      	movs	r0, #1
 800ab54:	f000 f9f6 	bl	800af44 <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED4);
 800ab58:	4620      	mov	r0, r4
 800ab5a:	f000 f9f3 	bl	800af44 <STM_EVAL_LEDOff>
    
    /* Check cgi parameter : example GET /leds.cgi?led=2&led=4 */
    for (i=0; i<iNumParams; i++)
 800ab5e:	b347      	cbz	r7, 800abb2 <LEDS_CGI_Handler+0x7e>
 800ab60:	3d04      	subs	r5, #4
 800ab62:	e010      	b.n	800ab86 <LEDS_CGI_Handler+0x52>
        /* switch led1 ON if 1 */
        if(strcmp(pcValue[i], "1") ==0) 
          STM_EVAL_LEDOn(LED5);
          
        /* switch led2 ON if 2 */
        else if(strcmp(pcValue[i], "2") ==0) 
 800ab64:	4630      	mov	r0, r6
 800ab66:	f7f5 fb3b 	bl	80001e0 <strcmp>
          STM_EVAL_LEDOn(LED6);
        
        /* switch led3 ON if 3 */
        else if(strcmp(pcValue[i], "3") ==0) 
 800ab6a:	491a      	ldr	r1, [pc, #104]	; (800abd4 <LEDS_CGI_Handler+0xa0>)
        /* switch led1 ON if 1 */
        if(strcmp(pcValue[i], "1") ==0) 
          STM_EVAL_LEDOn(LED5);
          
        /* switch led2 ON if 2 */
        else if(strcmp(pcValue[i], "2") ==0) 
 800ab6c:	b320      	cbz	r0, 800abb8 <LEDS_CGI_Handler+0x84>
          STM_EVAL_LEDOn(LED6);
        
        /* switch led3 ON if 3 */
        else if(strcmp(pcValue[i], "3") ==0) 
 800ab6e:	4630      	mov	r0, r6
 800ab70:	f7f5 fb36 	bl	80001e0 <strcmp>
          STM_EVAL_LEDOn(LED3);
        
        /* switch led4 ON if 4 */
        else if(strcmp(pcValue[i], "4") ==0) 
 800ab74:	4918      	ldr	r1, [pc, #96]	; (800abd8 <LEDS_CGI_Handler+0xa4>)
        /* switch led2 ON if 2 */
        else if(strcmp(pcValue[i], "2") ==0) 
          STM_EVAL_LEDOn(LED6);
        
        /* switch led3 ON if 3 */
        else if(strcmp(pcValue[i], "3") ==0) 
 800ab76:	b318      	cbz	r0, 800abc0 <LEDS_CGI_Handler+0x8c>
          STM_EVAL_LEDOn(LED3);
        
        /* switch led4 ON if 4 */
        else if(strcmp(pcValue[i], "4") ==0) 
 800ab78:	4630      	mov	r0, r6
 800ab7a:	f7f5 fb31 	bl	80001e0 <strcmp>
 800ab7e:	b318      	cbz	r0, 800abc8 <LEDS_CGI_Handler+0x94>
    STM_EVAL_LEDOff(LED6);
    STM_EVAL_LEDOff(LED3);
    STM_EVAL_LEDOff(LED4);
    
    /* Check cgi parameter : example GET /leds.cgi?led=2&led=4 */
    for (i=0; i<iNumParams; i++)
 800ab80:	3401      	adds	r4, #1
 800ab82:	42bc      	cmp	r4, r7
 800ab84:	d015      	beq.n	800abb2 <LEDS_CGI_Handler+0x7e>
    {
      /* check parameter "led" */
      if (strcmp(pcParam[i] , "led")==0)   
 800ab86:	4915      	ldr	r1, [pc, #84]	; (800abdc <LEDS_CGI_Handler+0xa8>)
 800ab88:	f855 0f04 	ldr.w	r0, [r5, #4]!
 800ab8c:	f7f5 fb28 	bl	80001e0 <strcmp>
      {
        /* switch led1 ON if 1 */
        if(strcmp(pcValue[i], "1") ==0) 
 800ab90:	4913      	ldr	r1, [pc, #76]	; (800abe0 <LEDS_CGI_Handler+0xac>)
    
    /* Check cgi parameter : example GET /leds.cgi?led=2&led=4 */
    for (i=0; i<iNumParams; i++)
    {
      /* check parameter "led" */
      if (strcmp(pcParam[i] , "led")==0)   
 800ab92:	2800      	cmp	r0, #0
 800ab94:	d1f4      	bne.n	800ab80 <LEDS_CGI_Handler+0x4c>
      {
        /* switch led1 ON if 1 */
        if(strcmp(pcValue[i], "1") ==0) 
 800ab96:	f858 6024 	ldr.w	r6, [r8, r4, lsl #2]
 800ab9a:	4630      	mov	r0, r6
 800ab9c:	f7f5 fb20 	bl	80001e0 <strcmp>
          STM_EVAL_LEDOn(LED5);
          
        /* switch led2 ON if 2 */
        else if(strcmp(pcValue[i], "2") ==0) 
 800aba0:	4910      	ldr	r1, [pc, #64]	; (800abe4 <LEDS_CGI_Handler+0xb0>)
    {
      /* check parameter "led" */
      if (strcmp(pcParam[i] , "led")==0)   
      {
        /* switch led1 ON if 1 */
        if(strcmp(pcValue[i], "1") ==0) 
 800aba2:	2800      	cmp	r0, #0
 800aba4:	d1de      	bne.n	800ab64 <LEDS_CGI_Handler+0x30>
          STM_EVAL_LEDOn(LED5);
 800aba6:	2002      	movs	r0, #2
    STM_EVAL_LEDOff(LED6);
    STM_EVAL_LEDOff(LED3);
    STM_EVAL_LEDOff(LED4);
    
    /* Check cgi parameter : example GET /leds.cgi?led=2&led=4 */
    for (i=0; i<iNumParams; i++)
 800aba8:	3401      	adds	r4, #1
      /* check parameter "led" */
      if (strcmp(pcParam[i] , "led")==0)   
      {
        /* switch led1 ON if 1 */
        if(strcmp(pcValue[i], "1") ==0) 
          STM_EVAL_LEDOn(LED5);
 800abaa:	f000 f9bf 	bl	800af2c <STM_EVAL_LEDOn>
    STM_EVAL_LEDOff(LED6);
    STM_EVAL_LEDOff(LED3);
    STM_EVAL_LEDOff(LED4);
    
    /* Check cgi parameter : example GET /leds.cgi?led=2&led=4 */
    for (i=0; i<iNumParams; i++)
 800abae:	42bc      	cmp	r4, r7
 800abb0:	d1e9      	bne.n	800ab86 <LEDS_CGI_Handler+0x52>
      }
    }
  }
  /* uri to send after cgi call*/
  return "/STM32F4x7LED.html";  
}
 800abb2:	4807      	ldr	r0, [pc, #28]	; (800abd0 <LEDS_CGI_Handler+0x9c>)
 800abb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(strcmp(pcValue[i], "1") ==0) 
          STM_EVAL_LEDOn(LED5);
          
        /* switch led2 ON if 2 */
        else if(strcmp(pcValue[i], "2") ==0) 
          STM_EVAL_LEDOn(LED6);
 800abb8:	2003      	movs	r0, #3
 800abba:	f000 f9b7 	bl	800af2c <STM_EVAL_LEDOn>
 800abbe:	e7df      	b.n	800ab80 <LEDS_CGI_Handler+0x4c>
        
        /* switch led3 ON if 3 */
        else if(strcmp(pcValue[i], "3") ==0) 
          STM_EVAL_LEDOn(LED3);
 800abc0:	2001      	movs	r0, #1
 800abc2:	f000 f9b3 	bl	800af2c <STM_EVAL_LEDOn>
 800abc6:	e7db      	b.n	800ab80 <LEDS_CGI_Handler+0x4c>
        
        /* switch led4 ON if 4 */
        else if(strcmp(pcValue[i], "4") ==0) 
          STM_EVAL_LEDOn(LED4);
 800abc8:	f000 f9b0 	bl	800af2c <STM_EVAL_LEDOn>
 800abcc:	e7d8      	b.n	800ab80 <LEDS_CGI_Handler+0x4c>
 800abce:	bf00      	nop
 800abd0:	080197a4 	.word	0x080197a4
 800abd4:	080197c4 	.word	0x080197c4
 800abd8:	080197c8 	.word	0x080197c8
 800abdc:	080197b8 	.word	0x080197b8
 800abe0:	080197bc 	.word	0x080197bc
 800abe4:	080197c0 	.word	0x080197c0

0800abe8 <httpd_ssi_init>:
 * Initialize SSI handlers
 */
void httpd_ssi_init(void)
{  
  /* configure SSI handlers (ADC page SSI) */
  http_set_ssi_handler(ADC_Handler, (char const **)TAGS, 1);
 800abe8:	4b02      	ldr	r3, [pc, #8]	; (800abf4 <httpd_ssi_init+0xc>)
 800abea:	4803      	ldr	r0, [pc, #12]	; (800abf8 <httpd_ssi_init+0x10>)
 800abec:	6819      	ldr	r1, [r3, #0]
 800abee:	2201      	movs	r2, #1
 800abf0:	f7ff bee6 	b.w	800a9c0 <http_set_ssi_handler>
 800abf4:	20000034 	.word	0x20000034
 800abf8:	0800a9f9 	.word	0x0800a9f9

0800abfc <httpd_cgi_init>:
 * Initialize CGI handlers
 */
void httpd_cgi_init(void)
{ 
  /* configure CGI handlers (LEDs control CGI) */
  CGI_TAB[0] = LEDS_CGI;
 800abfc:	4a04      	ldr	r2, [pc, #16]	; (800ac10 <httpd_cgi_init+0x14>)
 800abfe:	4b05      	ldr	r3, [pc, #20]	; (800ac14 <httpd_cgi_init+0x18>)
 800ac00:	e892 0003 	ldmia.w	r2, {r0, r1}
 800ac04:	e883 0003 	stmia.w	r3, {r0, r1}
  http_set_cgi_handlers(CGI_TAB, 1);
 800ac08:	4618      	mov	r0, r3
 800ac0a:	2101      	movs	r1, #1
 800ac0c:	f7ff bee8 	b.w	800a9e0 <http_set_cgi_handlers>
 800ac10:	0801979c 	.word	0x0801979c
 800ac14:	20008918 	.word	0x20008918

0800ac18 <Delay>:
  * @retval None
  */
void Delay(uint32_t nCount)
{
  /* Capture the current local time */
  timingdelay = LocalTime + nCount;
 800ac18:	4a04      	ldr	r2, [pc, #16]	; (800ac2c <Delay+0x14>)
 800ac1a:	4905      	ldr	r1, [pc, #20]	; (800ac30 <Delay+0x18>)
 800ac1c:	6813      	ldr	r3, [r2, #0]
 800ac1e:	4418      	add	r0, r3
 800ac20:	6008      	str	r0, [r1, #0]

  /* wait until the desired delay finish */
  while(timingdelay > LocalTime)
 800ac22:	6813      	ldr	r3, [r2, #0]
 800ac24:	4298      	cmp	r0, r3
 800ac26:	d8fc      	bhi.n	800ac22 <Delay+0xa>
  {
  }
}
 800ac28:	4770      	bx	lr
 800ac2a:	bf00      	nop
 800ac2c:	20002e94 	.word	0x20002e94
 800ac30:	20008930 	.word	0x20008930

0800ac34 <Time_Update>:
  * @param  None
  * @retval None
  */
void Time_Update(void)
{
  LocalTime += SYSTEMTICK_PERIOD_MS;
 800ac34:	4a02      	ldr	r2, [pc, #8]	; (800ac40 <Time_Update+0xc>)
 800ac36:	6813      	ldr	r3, [r2, #0]
 800ac38:	330a      	adds	r3, #10
 800ac3a:	6013      	str	r3, [r2, #0]
 800ac3c:	4770      	bx	lr
 800ac3e:	bf00      	nop
 800ac40:	20002e94 	.word	0x20002e94

0800ac44 <LCD_LED_Init>:
  * @brief  Initializes the STM324xG-EVAL's LCD and LEDs resources.
  * @param  None
  * @retval None
  */
void LCD_LED_Init(void)
{
 800ac44:	b508      	push	{r3, lr}
  /* Initialize the STM324xG-EVAL's LCD */
  STM324xG_LCD_Init();
#endif

  /* Initialize STM324xG-EVAL's LEDs */
  STM_EVAL_LEDInit(LED5);
 800ac46:	2002      	movs	r0, #2
 800ac48:	f000 f94a 	bl	800aee0 <STM_EVAL_LEDInit>
  STM_EVAL_LEDInit(LED6);
 800ac4c:	2003      	movs	r0, #3
 800ac4e:	f000 f947 	bl	800aee0 <STM_EVAL_LEDInit>
  STM_EVAL_LEDInit(LED3);
 800ac52:	2001      	movs	r0, #1
 800ac54:	f000 f944 	bl	800aee0 <STM_EVAL_LEDInit>
  STM_EVAL_LEDInit(LED4);
 800ac58:	2000      	movs	r0, #0
  LCD_DisplayStringLine(Line0, (uint8_t*)MESSAGE1);
  LCD_DisplayStringLine(Line1, (uint8_t*)MESSAGE2);
  LCD_DisplayStringLine(Line2, (uint8_t*)MESSAGE3);
  LCD_DisplayStringLine(Line3, (uint8_t*)MESSAGE4);
#endif
}
 800ac5a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  /* Initialize STM324xG-EVAL's LEDs */
  STM_EVAL_LEDInit(LED5);
  STM_EVAL_LEDInit(LED6);
  STM_EVAL_LEDInit(LED3);
  STM_EVAL_LEDInit(LED4);
 800ac5e:	f000 b93f 	b.w	800aee0 <STM_EVAL_LEDInit>
 800ac62:	bf00      	nop

0800ac64 <main>:
  * @param  None
  * @retval None
  */
RCC_ClocksTypeDef RCC_Clocks;
int main(void)
{
 800ac64:	b508      	push	{r3, lr}
       startup file (startup_stm32f4xx.s) before to branch to application main.
       To reconfigure the default setting of SystemInit() function, refer to
       system_stm32f4xx.c file
     */

	RCC_GetClocksFreq(&RCC_Clocks);
 800ac66:	480e      	ldr	r0, [pc, #56]	; (800aca0 <main+0x3c>)
 800ac68:	4c0e      	ldr	r4, [pc, #56]	; (800aca4 <main+0x40>)
 800ac6a:	f7fe fbc5 	bl	80093f8 <RCC_GetClocksFreq>

#ifdef SERIAL_DEBUG
  DebugComPort_Init();
 800ac6e:	f000 f90f 	bl	800ae90 <DebugComPort_Init>
  printf("STM32DISCOVERY is booting...\r\n");
 800ac72:	480d      	ldr	r0, [pc, #52]	; (800aca8 <main+0x44>)
 800ac74:	f000 fcae 	bl	800b5d4 <puts>
#endif

  /*Initialize LCD and Leds */
  LCD_LED_Init();
 800ac78:	f7ff ffe4 	bl	800ac44 <LCD_LED_Init>

  /* configure ethernet (GPIOs, clocks, MAC, DMA) */
  ETH_BSP_Config();
 800ac7c:	f000 f9d0 	bl	800b020 <ETH_BSP_Config>

  /* Initilaize the LwIP stack */
  LwIP_Init();
 800ac80:	f000 f814 	bl	800acac <LwIP_Init>

  /* Http webserver Init */
  httpd_init();
 800ac84:	f7ff fe7a 	bl	800a97c <httpd_init>
 800ac88:	e002      	b.n	800ac90 <main+0x2c>
    {
      /* process received ethernet packet */
      LwIP_Pkt_Handle();
    }
    /* handle periodic timers for LwIP */
    LwIP_Periodic_Handle(LocalTime);
 800ac8a:	6820      	ldr	r0, [r4, #0]
 800ac8c:	f000 f876 	bl	800ad7c <LwIP_Periodic_Handle>

  /* Infinite loop */
  while (1)
  {
    /* check if any packet received */
    if (ETH_CheckFrameReceived())
 800ac90:	f7fe f930 	bl	8008ef4 <ETH_CheckFrameReceived>
 800ac94:	2800      	cmp	r0, #0
 800ac96:	d0f8      	beq.n	800ac8a <main+0x26>
    {
      /* process received ethernet packet */
      LwIP_Pkt_Handle();
 800ac98:	f000 f86a 	bl	800ad70 <LwIP_Pkt_Handle>
 800ac9c:	e7f5      	b.n	800ac8a <main+0x26>
 800ac9e:	bf00      	nop
 800aca0:	20008920 	.word	0x20008920
 800aca4:	20002e94 	.word	0x20002e94
 800aca8:	080197dc 	.word	0x080197dc

0800acac <LwIP_Init>:
* @brief  Initializes the lwIP stack
* @param  None
* @retval None
*/
void LwIP_Init(void)
{
 800acac:	b530      	push	{r4, r5, lr}
 800acae:	b089      	sub	sp, #36	; 0x24
  uint8_t iptab[4] = {0};
  uint8_t iptxt[20];
#endif
  
  /* Initializes the dynamic memory heap defined by MEM_SIZE.*/
  mem_init();
 800acb0:	f7f8 fe52 	bl	8003958 <mem_init>
  Give pointers to cleared ip_addr structures when using DHCP,
  or fill them with sane numbers otherwise. The state pointer may be NULL.

  The init function pointer must point to a initialization function for
  your ethernet netif interface. The following code illustrates it's use.*/
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 800acb4:	4d26      	ldr	r5, [pc, #152]	; (800ad50 <LwIP_Init+0xa4>)
  
  /* Initializes the dynamic memory heap defined by MEM_SIZE.*/
  mem_init();
  
  /* Initializes the memory pools defined by MEMP_NUM_x.*/
  memp_init();
 800acb6:	f7f8 ff79 	bl	8003bac <memp_init>
  
#ifdef USE_DHCP
  ipaddr.addr = 0;
  netmask.addr = 0;
  gw.addr = 0;
 800acba:	ab08      	add	r3, sp, #32
  
  /* Initializes the memory pools defined by MEMP_NUM_x.*/
  memp_init();
  
#ifdef USE_DHCP
  ipaddr.addr = 0;
 800acbc:	2400      	movs	r4, #0
  Give pointers to cleared ip_addr structures when using DHCP,
  or fill them with sane numbers otherwise. The state pointer may be NULL.

  The init function pointer must point to a initialization function for
  your ethernet netif interface. The following code illustrates it's use.*/
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 800acbe:	4925      	ldr	r1, [pc, #148]	; (800ad54 <LwIP_Init+0xa8>)
 800acc0:	4a25      	ldr	r2, [pc, #148]	; (800ad58 <LwIP_Init+0xac>)
  memp_init();
  
#ifdef USE_DHCP
  ipaddr.addr = 0;
  netmask.addr = 0;
  gw.addr = 0;
 800acc2:	f843 4d04 	str.w	r4, [r3, #-4]!
  Give pointers to cleared ip_addr structures when using DHCP,
  or fill them with sane numbers otherwise. The state pointer may be NULL.

  The init function pointer must point to a initialization function for
  your ethernet netif interface. The following code illustrates it's use.*/
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 800acc6:	4628      	mov	r0, r5
 800acc8:	9102      	str	r1, [sp, #8]
 800acca:	9201      	str	r2, [sp, #4]
 800accc:	a905      	add	r1, sp, #20
 800acce:	aa06      	add	r2, sp, #24
 800acd0:	9400      	str	r4, [sp, #0]
  
  /* Initializes the memory pools defined by MEMP_NUM_x.*/
  memp_init();
  
#ifdef USE_DHCP
  ipaddr.addr = 0;
 800acd2:	9405      	str	r4, [sp, #20]
  netmask.addr = 0;
 800acd4:	9406      	str	r4, [sp, #24]
  Give pointers to cleared ip_addr structures when using DHCP,
  or fill them with sane numbers otherwise. The state pointer may be NULL.

  The init function pointer must point to a initialization function for
  your ethernet netif interface. The following code illustrates it's use.*/
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 800acd6:	f7f8 ffbd 	bl	8003c54 <netif_add>

  /*  Registers the default network interface.*/
  netif_set_default(&gnetif);
 800acda:	4628      	mov	r0, r5
 800acdc:	f7f9 f8ac 	bl	8003e38 <netif_set_default>

  if (EthStatus == (ETH_INIT_FLAG | ETH_LINK_FLAG))
 800ace0:	4b1e      	ldr	r3, [pc, #120]	; (800ad5c <LwIP_Init+0xb0>)
 800ace2:	681b      	ldr	r3, [r3, #0]
 800ace4:	2b11      	cmp	r3, #17
 800ace6:	d026      	beq.n	800ad36 <LwIP_Init+0x8a>
#endif /* USE_DHCP */
  }
  else
  {
    /* When the netif link is down this function must be called */
    netif_set_down(&gnetif);
 800ace8:	4628      	mov	r0, r5
 800acea:	f7f9 f8bd 	bl	8003e68 <netif_set_down>

#ifdef USE_DHCP
    DHCP_state = DHCP_LINK_DOWN;
 800acee:	4b1c      	ldr	r3, [pc, #112]	; (800ad60 <LwIP_Init+0xb4>)
 800acf0:	2205      	movs	r2, #5
#endif /* USE_DHCP */
    /* Set the LCD Text Color */
    LCD_SetTextColor(Red);
 800acf2:	f44f 4078 	mov.w	r0, #63488	; 0xf800
  {
    /* When the netif link is down this function must be called */
    netif_set_down(&gnetif);

#ifdef USE_DHCP
    DHCP_state = DHCP_LINK_DOWN;
 800acf6:	701a      	strb	r2, [r3, #0]
#endif /* USE_DHCP */
    /* Set the LCD Text Color */
    LCD_SetTextColor(Red);
 800acf8:	f7fe fcb8 	bl	800966c <LCD_SetTextColor>

    /* Display message on the LCD */
    LCD_DisplayStringLine(Line5, (uint8_t*)"  Network Cable is  ");
 800acfc:	f7fe fcc2 	bl	8009684 <LCD_GetFont>
 800ad00:	88c0      	ldrh	r0, [r0, #6]
 800ad02:	4918      	ldr	r1, [pc, #96]	; (800ad64 <LwIP_Init+0xb8>)
 800ad04:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800ad08:	b280      	uxth	r0, r0
 800ad0a:	f7fe fd49 	bl	80097a0 <LCD_DisplayStringLine>
    LCD_DisplayStringLine(Line6, (uint8_t*)"    not connected   ");
 800ad0e:	f7fe fcb9 	bl	8009684 <LCD_GetFont>
 800ad12:	88c0      	ldrh	r0, [r0, #6]
 800ad14:	4914      	ldr	r1, [pc, #80]	; (800ad68 <LwIP_Init+0xbc>)
 800ad16:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800ad1a:	0040      	lsls	r0, r0, #1
 800ad1c:	b280      	uxth	r0, r0
 800ad1e:	f7fe fd3f 	bl	80097a0 <LCD_DisplayStringLine>

    /* Set the LCD Text Color */
    LCD_SetTextColor(White);
 800ad22:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ad26:	f7fe fca1 	bl	800966c <LCD_SetTextColor>
  }

  /* Set the link callback function, this function is called on change of link status*/
  netif_set_link_callback(&gnetif, ETH_link_callback);
 800ad2a:	4910      	ldr	r1, [pc, #64]	; (800ad6c <LwIP_Init+0xc0>)
 800ad2c:	4808      	ldr	r0, [pc, #32]	; (800ad50 <LwIP_Init+0xa4>)
 800ad2e:	f7f9 f8d7 	bl	8003ee0 <netif_set_link_callback>
}
 800ad32:	b009      	add	sp, #36	; 0x24
 800ad34:	bd30      	pop	{r4, r5, pc}
  netif_set_default(&gnetif);

  if (EthStatus == (ETH_INIT_FLAG | ETH_LINK_FLAG))
  {
    /* Set Ethernet link flag */
    gnetif.flags |= NETIF_FLAG_LINK_UP;
 800ad36:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31

    /* When the netif is fully configured this function must be called */
    netif_set_up(&gnetif);
 800ad3a:	4628      	mov	r0, r5
  netif_set_default(&gnetif);

  if (EthStatus == (ETH_INIT_FLAG | ETH_LINK_FLAG))
  {
    /* Set Ethernet link flag */
    gnetif.flags |= NETIF_FLAG_LINK_UP;
 800ad3c:	f043 0310 	orr.w	r3, r3, #16
 800ad40:	f885 3031 	strb.w	r3, [r5, #49]	; 0x31

    /* When the netif is fully configured this function must be called */
    netif_set_up(&gnetif);
 800ad44:	f7f9 f87e 	bl	8003e44 <netif_set_up>

#ifdef USE_DHCP
    DHCP_state = DHCP_START;
 800ad48:	4b05      	ldr	r3, [pc, #20]	; (800ad60 <LwIP_Init+0xb4>)
 800ad4a:	2201      	movs	r2, #1
 800ad4c:	701a      	strb	r2, [r3, #0]
 800ad4e:	e7ec      	b.n	800ad2a <LwIP_Init+0x7e>
 800ad50:	20008934 	.word	0x20008934
 800ad54:	08008395 	.word	0x08008395
 800ad58:	08008739 	.word	0x08008739
 800ad5c:	20002eac 	.word	0x20002eac
 800ad60:	2000896c 	.word	0x2000896c
 800ad64:	080197fc 	.word	0x080197fc
 800ad68:	08019814 	.word	0x08019814
 800ad6c:	0800b339 	.word	0x0800b339

0800ad70 <LwIP_Pkt_Handle>:
* @retval None
*/
void LwIP_Pkt_Handle(void)
{
  /* Read a received packet from the Ethernet buffers and send it to the lwIP for handling */
  ethernetif_input(&gnetif);
 800ad70:	4801      	ldr	r0, [pc, #4]	; (800ad78 <LwIP_Pkt_Handle+0x8>)
 800ad72:	f7fd bc6f 	b.w	8008654 <ethernetif_input>
 800ad76:	bf00      	nop
 800ad78:	20008934 	.word	0x20008934

0800ad7c <LwIP_Periodic_Handle>:
* @brief  LwIP periodic tasks
* @param  localtime the current LocalTime value
* @retval None
*/
void LwIP_Periodic_Handle(__IO uint32_t localtime)
{
 800ad7c:	b570      	push	{r4, r5, r6, lr}
 800ad7e:	b086      	sub	sp, #24
#if LWIP_TCP
  /* TCP periodic process every 250 ms */
  if (localtime - TCPTimer >= TCP_TMR_INTERVAL)
 800ad80:	4a3b      	ldr	r2, [pc, #236]	; (800ae70 <LwIP_Periodic_Handle+0xf4>)
* @brief  LwIP periodic tasks
* @param  localtime the current LocalTime value
* @retval None
*/
void LwIP_Periodic_Handle(__IO uint32_t localtime)
{
 800ad82:	9001      	str	r0, [sp, #4]
#if LWIP_TCP
  /* TCP periodic process every 250 ms */
  if (localtime - TCPTimer >= TCP_TMR_INTERVAL)
 800ad84:	9b01      	ldr	r3, [sp, #4]
 800ad86:	6811      	ldr	r1, [r2, #0]
 800ad88:	1a5b      	subs	r3, r3, r1
 800ad8a:	2bf9      	cmp	r3, #249	; 0xf9
 800ad8c:	d859      	bhi.n	800ae42 <LwIP_Periodic_Handle+0xc6>
    tcp_tmr();
  }
#endif
  
  /* ARP periodic process every 5s */
  if ((localtime - ARPTimer) >= ARP_TMR_INTERVAL)
 800ad8e:	4a39      	ldr	r2, [pc, #228]	; (800ae74 <LwIP_Periodic_Handle+0xf8>)
 800ad90:	9b01      	ldr	r3, [sp, #4]
 800ad92:	6810      	ldr	r0, [r2, #0]
 800ad94:	f241 3187 	movw	r1, #4999	; 0x1387
 800ad98:	1a1b      	subs	r3, r3, r0
 800ad9a:	428b      	cmp	r3, r1
 800ad9c:	d84c      	bhi.n	800ae38 <LwIP_Periodic_Handle+0xbc>
    etharp_tmr();
  }
  
#ifdef USE_DHCP
  /* Fine DHCP periodic process every 500ms */
  if (localtime - DHCPfineTimer >= DHCP_FINE_TIMER_MSECS)
 800ad9e:	4a36      	ldr	r2, [pc, #216]	; (800ae78 <LwIP_Periodic_Handle+0xfc>)
 800ada0:	9b01      	ldr	r3, [sp, #4]
 800ada2:	6811      	ldr	r1, [r2, #0]
 800ada4:	1a5b      	subs	r3, r3, r1
 800ada6:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 800adaa:	d20d      	bcs.n	800adc8 <LwIP_Periodic_Handle+0x4c>
      LwIP_DHCP_Process_Handle();    
    }
  }

  /* DHCP Coarse periodic process every 60s */
  if (localtime - DHCPcoarseTimer >= DHCP_COARSE_TIMER_MSECS)
 800adac:	4a33      	ldr	r2, [pc, #204]	; (800ae7c <LwIP_Periodic_Handle+0x100>)
 800adae:	9b01      	ldr	r3, [sp, #4]
 800adb0:	6810      	ldr	r0, [r2, #0]
 800adb2:	f64e 215f 	movw	r1, #59999	; 0xea5f
 800adb6:	1a1b      	subs	r3, r3, r0
 800adb8:	428b      	cmp	r3, r1
 800adba:	d903      	bls.n	800adc4 <LwIP_Periodic_Handle+0x48>
  {
    DHCPcoarseTimer =  localtime;
 800adbc:	9b01      	ldr	r3, [sp, #4]
 800adbe:	6013      	str	r3, [r2, #0]
    dhcp_coarse_tmr();
 800adc0:	f7f8 fba4 	bl	800350c <dhcp_coarse_tmr>
  }

#endif
}
 800adc4:	b006      	add	sp, #24
 800adc6:	bd70      	pop	{r4, r5, r6, pc}
  /* Fine DHCP periodic process every 500ms */
  if (localtime - DHCPfineTimer >= DHCP_FINE_TIMER_MSECS)
  {
    DHCPfineTimer =  localtime;
    dhcp_fine_tmr();
    if ((DHCP_state != DHCP_ADDRESS_ASSIGNED) && 
 800adc8:	4c2d      	ldr	r4, [pc, #180]	; (800ae80 <LwIP_Periodic_Handle+0x104>)
  
#ifdef USE_DHCP
  /* Fine DHCP periodic process every 500ms */
  if (localtime - DHCPfineTimer >= DHCP_FINE_TIMER_MSECS)
  {
    DHCPfineTimer =  localtime;
 800adca:	9b01      	ldr	r3, [sp, #4]
 800adcc:	6013      	str	r3, [r2, #0]
    dhcp_fine_tmr();
 800adce:	f7f8 fd53 	bl	8003878 <dhcp_fine_tmr>
    if ((DHCP_state != DHCP_ADDRESS_ASSIGNED) && 
 800add2:	7823      	ldrb	r3, [r4, #0]
 800add4:	2b03      	cmp	r3, #3
 800add6:	d0e9      	beq.n	800adac <LwIP_Periodic_Handle+0x30>
        (DHCP_state != DHCP_TIMEOUT) &&
 800add8:	7823      	ldrb	r3, [r4, #0]
  /* Fine DHCP periodic process every 500ms */
  if (localtime - DHCPfineTimer >= DHCP_FINE_TIMER_MSECS)
  {
    DHCPfineTimer =  localtime;
    dhcp_fine_tmr();
    if ((DHCP_state != DHCP_ADDRESS_ASSIGNED) && 
 800adda:	2b04      	cmp	r3, #4
 800addc:	d0e6      	beq.n	800adac <LwIP_Periodic_Handle+0x30>
        (DHCP_state != DHCP_TIMEOUT) &&
          (DHCP_state != DHCP_LINK_DOWN))
 800adde:	7823      	ldrb	r3, [r4, #0]
  if (localtime - DHCPfineTimer >= DHCP_FINE_TIMER_MSECS)
  {
    DHCPfineTimer =  localtime;
    dhcp_fine_tmr();
    if ((DHCP_state != DHCP_ADDRESS_ASSIGNED) && 
        (DHCP_state != DHCP_TIMEOUT) &&
 800ade0:	2b05      	cmp	r3, #5
 800ade2:	d0e3      	beq.n	800adac <LwIP_Periodic_Handle+0x30>
          (DHCP_state != DHCP_LINK_DOWN))
    {
      /* toggle LED1 to indicate DHCP on-going process */
      STM_EVAL_LEDToggle(LED5);
 800ade4:	2002      	movs	r0, #2
 800ade6:	f000 f8b9 	bl	800af5c <STM_EVAL_LEDToggle>
  struct ip_addr netmask;
  struct ip_addr gw;
  uint8_t iptab[4] = {0};
  uint8_t iptxt[20];
  
  switch (DHCP_state)
 800adea:	7825      	ldrb	r5, [r4, #0]
 800adec:	b2ed      	uxtb	r5, r5
 800adee:	2d01      	cmp	r5, #1
 800adf0:	d02c      	beq.n	800ae4c <LwIP_Periodic_Handle+0xd0>
 800adf2:	2d02      	cmp	r5, #2
 800adf4:	d1da      	bne.n	800adac <LwIP_Periodic_Handle+0x30>
    break;

  case DHCP_WAIT_ADDRESS:
    {
      /* Read the new IP address */
      IPaddress = gnetif.ip_addr.addr;
 800adf6:	4e23      	ldr	r6, [pc, #140]	; (800ae84 <LwIP_Periodic_Handle+0x108>)
 800adf8:	4a23      	ldr	r2, [pc, #140]	; (800ae88 <LwIP_Periodic_Handle+0x10c>)
 800adfa:	6873      	ldr	r3, [r6, #4]
 800adfc:	6013      	str	r3, [r2, #0]
      
      if (IPaddress!=0) 
 800adfe:	bb73      	cbnz	r3, 800ae5e <LwIP_Periodic_Handle+0xe2>
        STM_EVAL_LEDOn(LED5);
      }
      else
      {
        /* DHCP timeout */
        if (gnetif.dhcp->tries > MAX_DHCP_TRIES)
 800ae00:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800ae02:	7b5b      	ldrb	r3, [r3, #13]
 800ae04:	2b04      	cmp	r3, #4
 800ae06:	d9d1      	bls.n	800adac <LwIP_Periodic_Handle+0x30>
        {
          DHCP_state = DHCP_TIMEOUT;
 800ae08:	2304      	movs	r3, #4

          /* Stop DHCP */
          dhcp_stop(&gnetif);
 800ae0a:	4630      	mov	r0, r6
      else
      {
        /* DHCP timeout */
        if (gnetif.dhcp->tries > MAX_DHCP_TRIES)
        {
          DHCP_state = DHCP_TIMEOUT;
 800ae0c:	7023      	strb	r3, [r4, #0]

          /* Stop DHCP */
          dhcp_stop(&gnetif);
 800ae0e:	f7f8 fd8b 	bl	8003928 <dhcp_stop>

          /* Static address used */
          IP4_ADDR(&ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 );
          IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3);
          IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
 800ae12:	ab06      	add	r3, sp, #24
 800ae14:	4a1d      	ldr	r2, [pc, #116]	; (800ae8c <LwIP_Periodic_Handle+0x110>)
 800ae16:	f843 2d04 	str.w	r2, [r3, #-4]!

          /* Stop DHCP */
          dhcp_stop(&gnetif);

          /* Static address used */
          IP4_ADDR(&ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 );
 800ae1a:	f102 42dc 	add.w	r2, r2, #1845493760	; 0x6e000000
          IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3);
          IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
          netif_set_addr(&gnetif, &ipaddr , &netmask, &gw);
 800ae1e:	4630      	mov	r0, r6

          /* Stop DHCP */
          dhcp_stop(&gnetif);

          /* Static address used */
          IP4_ADDR(&ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 );
 800ae20:	9203      	str	r2, [sp, #12]
          IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3);
 800ae22:	f06f 447f 	mvn.w	r4, #4278190080	; 0xff000000
          IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
          netif_set_addr(&gnetif, &ipaddr , &netmask, &gw);
 800ae26:	aa04      	add	r2, sp, #16
 800ae28:	a903      	add	r1, sp, #12
          /* Stop DHCP */
          dhcp_stop(&gnetif);

          /* Static address used */
          IP4_ADDR(&ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 );
          IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3);
 800ae2a:	9404      	str	r4, [sp, #16]
          IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
          netif_set_addr(&gnetif, &ipaddr , &netmask, &gw);
 800ae2c:	f7f8 ff7a 	bl	8003d24 <netif_set_addr>
          LCD_ClearLine(Line6);

          LCD_DisplayStringLine(Line8, (uint8_t*)"  Static IP address   ");
          LCD_DisplayStringLine(Line9, iptxt);         
#endif
          STM_EVAL_LEDOn(LED5);
 800ae30:	4628      	mov	r0, r5
 800ae32:	f000 f87b 	bl	800af2c <STM_EVAL_LEDOn>
 800ae36:	e7b9      	b.n	800adac <LwIP_Periodic_Handle+0x30>
#endif
  
  /* ARP periodic process every 5s */
  if ((localtime - ARPTimer) >= ARP_TMR_INTERVAL)
  {
    ARPTimer =  localtime;
 800ae38:	9b01      	ldr	r3, [sp, #4]
 800ae3a:	6013      	str	r3, [r2, #0]
    etharp_tmr();
 800ae3c:	f7fc ff66 	bl	8007d0c <etharp_tmr>
 800ae40:	e7ad      	b.n	800ad9e <LwIP_Periodic_Handle+0x22>
{
#if LWIP_TCP
  /* TCP periodic process every 250 ms */
  if (localtime - TCPTimer >= TCP_TMR_INTERVAL)
  {
    TCPTimer =  localtime;
 800ae42:	9b01      	ldr	r3, [sp, #4]
 800ae44:	6013      	str	r3, [r2, #0]
    tcp_tmr();
 800ae46:	f7fa f85f 	bl	8004f08 <tcp_tmr>
 800ae4a:	e7a0      	b.n	800ad8e <LwIP_Periodic_Handle+0x12>
  
  switch (DHCP_state)
  {
  case DHCP_START:
    {
      DHCP_state = DHCP_WAIT_ADDRESS;
 800ae4c:	2302      	movs	r3, #2
      dhcp_start(&gnetif);
 800ae4e:	480d      	ldr	r0, [pc, #52]	; (800ae84 <LwIP_Periodic_Handle+0x108>)
  
  switch (DHCP_state)
  {
  case DHCP_START:
    {
      DHCP_state = DHCP_WAIT_ADDRESS;
 800ae50:	7023      	strb	r3, [r4, #0]
      dhcp_start(&gnetif);
 800ae52:	f7f7 ffad 	bl	8002db0 <dhcp_start>
      /* IP address should be set to 0 
         every time we want to assign a new DHCP address */
      IPaddress = 0;
 800ae56:	4b0c      	ldr	r3, [pc, #48]	; (800ae88 <LwIP_Periodic_Handle+0x10c>)
 800ae58:	2200      	movs	r2, #0
 800ae5a:	601a      	str	r2, [r3, #0]
 800ae5c:	e7a6      	b.n	800adac <LwIP_Periodic_Handle+0x30>
      if (IPaddress!=0) 
      {
        DHCP_state = DHCP_ADDRESS_ASSIGNED;	
        
        /* Stop DHCP */
        dhcp_stop(&gnetif);
 800ae5e:	4630      	mov	r0, r6
      /* Read the new IP address */
      IPaddress = gnetif.ip_addr.addr;
      
      if (IPaddress!=0) 
      {
        DHCP_state = DHCP_ADDRESS_ASSIGNED;	
 800ae60:	2303      	movs	r3, #3
 800ae62:	7023      	strb	r3, [r4, #0]
        
        /* Stop DHCP */
        dhcp_stop(&gnetif);
 800ae64:	f7f8 fd60 	bl	8003928 <dhcp_stop>
        /* Display the IP address */
        LCD_DisplayStringLine(Line7, (uint8_t*)"IP address assigned ");
        LCD_DisplayStringLine(Line8, (uint8_t*)"  by a DHCP server  ");
        LCD_DisplayStringLine(Line9, iptxt);
#endif
        STM_EVAL_LEDOn(LED5);
 800ae68:	4628      	mov	r0, r5
 800ae6a:	f000 f85f 	bl	800af2c <STM_EVAL_LEDOn>
 800ae6e:	e79d      	b.n	800adac <LwIP_Periodic_Handle+0x30>
 800ae70:	20002ea0 	.word	0x20002ea0
 800ae74:	20002e9c 	.word	0x20002e9c
 800ae78:	20002ea8 	.word	0x20002ea8
 800ae7c:	20002e98 	.word	0x20002e98
 800ae80:	2000896c 	.word	0x2000896c
 800ae84:	20008934 	.word	0x20008934
 800ae88:	20002ea4 	.word	0x20002ea4
 800ae8c:	0100a8c0 	.word	0x0100a8c0

0800ae90 <DebugComPort_Init>:
  * @note   COM1 interface is defined in stm3210g_eval.h file (under Utilities\STM32_EVAL\STM324xG_EVAL)  
  * @param  None
  * @retval None
  */
void DebugComPort_Init(void)
{
 800ae90:	b510      	push	{r4, lr}
        - No parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
  */
  USART_InitStructure.USART_BaudRate = 115200;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800ae92:	2300      	movs	r3, #0
  * @note   COM1 interface is defined in stm3210g_eval.h file (under Utilities\STM32_EVAL\STM324xG_EVAL)  
  * @param  None
  * @retval None
  */
void DebugComPort_Init(void)
{
 800ae94:	b084      	sub	sp, #16
  USART_InitStructure.USART_BaudRate = 115200;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800ae96:	220c      	movs	r2, #12

  STM_EVAL_COMInit(COM1, &USART_InitStructure);
 800ae98:	4618      	mov	r0, r3
        - One Stop Bit
        - No parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
  */
  USART_InitStructure.USART_BaudRate = 115200;
 800ae9a:	f44f 34e1 	mov.w	r4, #115200	; 0x1c200
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  STM_EVAL_COMInit(COM1, &USART_InitStructure);
 800ae9e:	4669      	mov	r1, sp
        - No parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
  */
  USART_InitStructure.USART_BaudRate = 115200;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800aea0:	f8ad 3004 	strh.w	r3, [sp, #4]
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
 800aea4:	f8ad 3006 	strh.w	r3, [sp, #6]
  USART_InitStructure.USART_Parity = USART_Parity_No;
 800aea8:	f8ad 3008 	strh.w	r3, [sp, #8]
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 800aeac:	f8ad 300c 	strh.w	r3, [sp, #12]
        - One Stop Bit
        - No parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
  */
  USART_InitStructure.USART_BaudRate = 115200;
 800aeb0:	9400      	str	r4, [sp, #0]
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800aeb2:	f8ad 200a 	strh.w	r2, [sp, #10]

  STM_EVAL_COMInit(COM1, &USART_InitStructure);
 800aeb6:	f000 f85f 	bl	800af78 <STM_EVAL_COMInit>
}
 800aeba:	b004      	add	sp, #16
 800aebc:	bd10      	pop	{r4, pc}
 800aebe:	bf00      	nop

0800aec0 <__io_putchar>:
  * @brief  Retargets the C library printf function to the USART.
  * @param  None
  * @retval None
  */
PUTCHAR_PROTOTYPE
{
 800aec0:	b510      	push	{r4, lr}
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART */
  USART_SendData(EVAL_COM1, (uint8_t) ch);
 800aec2:	b2c1      	uxtb	r1, r0
  * @brief  Retargets the C library printf function to the USART.
  * @param  None
  * @retval None
  */
PUTCHAR_PROTOTYPE
{
 800aec4:	4604      	mov	r4, r0
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART */
  USART_SendData(EVAL_COM1, (uint8_t) ch);
 800aec6:	4805      	ldr	r0, [pc, #20]	; (800aedc <__io_putchar+0x1c>)
 800aec8:	f7fe fba8 	bl	800961c <USART_SendData>

  /* Loop until the end of transmission */
  while (USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TC) == RESET)
 800aecc:	2140      	movs	r1, #64	; 0x40
 800aece:	4803      	ldr	r0, [pc, #12]	; (800aedc <__io_putchar+0x1c>)
 800aed0:	f7fe fbc6 	bl	8009660 <USART_GetFlagStatus>
 800aed4:	2800      	cmp	r0, #0
 800aed6:	d0f9      	beq.n	800aecc <__io_putchar+0xc>
  {}

  return ch;
}
 800aed8:	4620      	mov	r0, r4
 800aeda:	bd10      	pop	{r4, pc}
 800aedc:	40004800 	.word	0x40004800

0800aee0 <STM_EVAL_LEDInit>:
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 800aee0:	b510      	push	{r4, lr}
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 800aee2:	4b0f      	ldr	r3, [pc, #60]	; (800af20 <STM_EVAL_LEDInit+0x40>)
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 800aee4:	b082      	sub	sp, #8
 800aee6:	4604      	mov	r4, r0
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 800aee8:	2101      	movs	r1, #1
 800aeea:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800aeee:	f7fe facf 	bl	8009490 <RCC_AHB1PeriphClockCmd>

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 800aef2:	4b0c      	ldr	r3, [pc, #48]	; (800af24 <STM_EVAL_LEDInit+0x44>)
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 800aef4:	4a0c      	ldr	r2, [pc, #48]	; (800af28 <STM_EVAL_LEDInit+0x48>)
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 800aef6:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 800aefa:	f852 0024 	ldr.w	r0, [r2, r4, lsl #2]
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 800aefe:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800af00:	2202      	movs	r2, #2
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800af02:	2301      	movs	r3, #1
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800af04:	2400      	movs	r4, #0
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 800af06:	4669      	mov	r1, sp
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800af08:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800af0c:	f88d 3007 	strb.w	r3, [sp, #7]
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800af10:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800af14:	f88d 2005 	strb.w	r2, [sp, #5]
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 800af18:	f7fe fa06 	bl	8009328 <GPIO_Init>
}
 800af1c:	b002      	add	sp, #8
 800af1e:	bd10      	pop	{r4, pc}
 800af20:	0801982c 	.word	0x0801982c
 800af24:	0801983c 	.word	0x0801983c
 800af28:	2000003c 	.word	0x2000003c

0800af2c <STM_EVAL_LEDOn>:
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDOn(Led_TypeDef Led)
{
  GPIO_PORT[Led]->BSRRL = GPIO_PIN[Led];
 800af2c:	4b03      	ldr	r3, [pc, #12]	; (800af3c <STM_EVAL_LEDOn+0x10>)
 800af2e:	4a04      	ldr	r2, [pc, #16]	; (800af40 <STM_EVAL_LEDOn+0x14>)
 800af30:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800af34:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
 800af38:	831a      	strh	r2, [r3, #24]
 800af3a:	4770      	bx	lr
 800af3c:	2000003c 	.word	0x2000003c
 800af40:	0801983c 	.word	0x0801983c

0800af44 <STM_EVAL_LEDOff>:
  *     @arg LED6 
  * @retval None
  */
void STM_EVAL_LEDOff(Led_TypeDef Led)
{
  GPIO_PORT[Led]->BSRRH = GPIO_PIN[Led];  
 800af44:	4b03      	ldr	r3, [pc, #12]	; (800af54 <STM_EVAL_LEDOff+0x10>)
 800af46:	4a04      	ldr	r2, [pc, #16]	; (800af58 <STM_EVAL_LEDOff+0x14>)
 800af48:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800af4c:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
 800af50:	835a      	strh	r2, [r3, #26]
 800af52:	4770      	bx	lr
 800af54:	2000003c 	.word	0x2000003c
 800af58:	0801983c 	.word	0x0801983c

0800af5c <STM_EVAL_LEDToggle>:
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDToggle(Led_TypeDef Led)
{
  GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
 800af5c:	4a04      	ldr	r2, [pc, #16]	; (800af70 <STM_EVAL_LEDToggle+0x14>)
 800af5e:	4b05      	ldr	r3, [pc, #20]	; (800af74 <STM_EVAL_LEDToggle+0x18>)
 800af60:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 800af64:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 800af68:	6953      	ldr	r3, [r2, #20]
 800af6a:	404b      	eors	r3, r1
 800af6c:	6153      	str	r3, [r2, #20]
 800af6e:	4770      	bx	lr
 800af70:	2000003c 	.word	0x2000003c
 800af74:	0801983c 	.word	0x0801983c

0800af78 <STM_EVAL_COMInit>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that
  *   contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void STM_EVAL_COMInit(COM_TypeDef COM, USART_InitTypeDef* USART_InitStruct)
{
 800af78:	b5f0      	push	{r4, r5, r6, r7, lr}
 800af7a:	b087      	sub	sp, #28
       - No parity
       - Hardware flow control disabled (RTS and CTS signals)
       - Receive and transmit enabled
 */
 USART_InitStructure.USART_BaudRate = 115200;
 USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800af7c:	2400      	movs	r4, #0
 USART_InitStructure.USART_StopBits = USART_StopBits_1;
 USART_InitStructure.USART_Parity = USART_Parity_No;
 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800af7e:	230c      	movs	r3, #12

 /* Enable UART clock */
 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);

 /* Connect PXx to USARTx_Tx*/
 GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART3);
 800af80:	4d25      	ldr	r5, [pc, #148]	; (800b018 <STM_EVAL_COMInit+0xa0>)
 USART_InitStructure.USART_BaudRate = 115200;
 USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 USART_InitStructure.USART_StopBits = USART_StopBits_1;
 USART_InitStructure.USART_Parity = USART_Parity_No;
 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800af82:	f8ad 3012 	strh.w	r3, [sp, #18]
       - One Stop Bit
       - No parity
       - Hardware flow control disabled (RTS and CTS signals)
       - Receive and transmit enabled
 */
 USART_InitStructure.USART_BaudRate = 115200;
 800af86:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

 GPIO_InitTypeDef GPIO_InitStructure;

 /* Enable GPIO clock */
 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOC, ENABLE);
 800af8a:	2101      	movs	r1, #1
 800af8c:	2004      	movs	r0, #4
       - One Stop Bit
       - No parity
       - Hardware flow control disabled (RTS and CTS signals)
       - Receive and transmit enabled
 */
 USART_InitStructure.USART_BaudRate = 115200;
 800af8e:	9202      	str	r2, [sp, #8]
 USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800af90:	f8ad 400c 	strh.w	r4, [sp, #12]
 USART_InitStructure.USART_StopBits = USART_StopBits_1;
 800af94:	f8ad 400e 	strh.w	r4, [sp, #14]
 USART_InitStructure.USART_Parity = USART_Parity_No;
 800af98:	f8ad 4010 	strh.w	r4, [sp, #16]
 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 800af9c:	f8ad 4014 	strh.w	r4, [sp, #20]
 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

 GPIO_InitTypeDef GPIO_InitStructure;

 /* Enable GPIO clock */
 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOC, ENABLE);
 800afa0:	f7fe fa76 	bl	8009490 <RCC_AHB1PeriphClockCmd>

 /* Enable UART clock */
 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
 800afa4:	2101      	movs	r1, #1
 800afa6:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800afaa:	f7fe fa7f 	bl	80094ac <RCC_APB1PeriphClockCmd>

 /* Connect PXx to USARTx_Tx*/
 GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART3);
 800afae:	4628      	mov	r0, r5
 800afb0:	2207      	movs	r2, #7
 800afb2:	210a      	movs	r1, #10
 800afb4:	f7fe fa0a 	bl	80093cc <GPIO_PinAFConfig>

 /* Connect PXx to USARTx_Rx*/
 GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_USART3);
 800afb8:	2207      	movs	r2, #7
 800afba:	4628      	mov	r0, r5
 800afbc:	210b      	movs	r1, #11
 800afbe:	f7fe fa05 	bl	80093cc <GPIO_PinAFConfig>

 /* Configure USART Tx as alternate function  */
 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800afc2:	2601      	movs	r6, #1
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800afc4:	2702      	movs	r7, #2

 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 GPIO_Init(GPIOC, &GPIO_InitStructure);
 800afc6:	4628      	mov	r0, r5
 800afc8:	4669      	mov	r1, sp
 /* Configure USART Tx as alternate function  */
 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;

 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 800afca:	f44f 6380 	mov.w	r3, #1024	; 0x400

 /* Connect PXx to USARTx_Rx*/
 GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_USART3);

 /* Configure USART Tx as alternate function  */
 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800afce:	f88d 4006 	strb.w	r4, [sp, #6]
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 GPIO_Init(GPIOC, &GPIO_InitStructure);

 /* USART configuration */
 USART_Init(USART3, &USART_InitStructure);
 800afd2:	4c12      	ldr	r4, [pc, #72]	; (800b01c <STM_EVAL_COMInit+0xa4>)
 /* Configure USART Tx as alternate function  */
 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;

 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 800afd4:	9300      	str	r3, [sp, #0]
 /* Connect PXx to USARTx_Rx*/
 GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_USART3);

 /* Configure USART Tx as alternate function  */
 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800afd6:	f88d 6007 	strb.w	r6, [sp, #7]
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800afda:	f88d 7004 	strb.w	r7, [sp, #4]

 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800afde:	f88d 7005 	strb.w	r7, [sp, #5]
 GPIO_Init(GPIOC, &GPIO_InitStructure);
 800afe2:	f7fe f9a1 	bl	8009328 <GPIO_Init>

 /* Configure USART Rx as alternate function  */
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 800afe6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 GPIO_Init(GPIOC, &GPIO_InitStructure);
 800afea:	4669      	mov	r1, sp
 800afec:	4628      	mov	r0, r5
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 GPIO_Init(GPIOC, &GPIO_InitStructure);

 /* Configure USART Rx as alternate function  */
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 800afee:	9300      	str	r3, [sp, #0]
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 GPIO_Init(GPIOC, &GPIO_InitStructure);

 /* Configure USART Rx as alternate function  */
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800aff0:	f88d 7004 	strb.w	r7, [sp, #4]
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 GPIO_Init(GPIOC, &GPIO_InitStructure);
 800aff4:	f7fe f998 	bl	8009328 <GPIO_Init>

 /* USART configuration */
 USART_Init(USART3, &USART_InitStructure);
 800aff8:	4620      	mov	r0, r4
 800affa:	a902      	add	r1, sp, #8
 800affc:	f7fe fa9e 	bl	800953c <USART_Init>

 /* Enable USART */
 USART_Cmd(USART3, ENABLE);
 800b000:	4631      	mov	r1, r6
 800b002:	4620      	mov	r0, r4
 800b004:	f7fe fafc 	bl	8009600 <USART_Cmd>

 /* Enable interrupt */
 USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
 800b008:	4632      	mov	r2, r6
 800b00a:	4620      	mov	r0, r4
 800b00c:	f240 5125 	movw	r1, #1317	; 0x525
 800b010:	f7fe fb08 	bl	8009624 <USART_ITConfig>
}
 800b014:	b007      	add	sp, #28
 800b016:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b018:	40020800 	.word	0x40020800
 800b01c:	40004800 	.word	0x40004800

0800b020 <ETH_BSP_Config>:
  * @brief  ETH_BSP_Config
  * @param  None
  * @retval None
  */
void ETH_BSP_Config(void)
{
 800b020:	b570      	push	{r4, r5, r6, lr}
         must be configured before Ethernet initialization and, the interrupt 
         priority should be the highest one.
  *****************************************************************************/
  
  /* Configure Systick clock source as HCLK */
  SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
 800b022:	2004      	movs	r0, #4
  * @brief  ETH_BSP_Config
  * @param  None
  * @retval None
  */
void ETH_BSP_Config(void)
{
 800b024:	b08a      	sub	sp, #40	; 0x28
         must be configured before Ethernet initialization and, the interrupt 
         priority should be the highest one.
  *****************************************************************************/
  
  /* Configure Systick clock source as HCLK */
  SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
 800b026:	f7fe f87d 	bl	8009124 <SysTick_CLKSourceConfig>

  /* SystTick configuration: an interrupt every 10ms */
  RCC_GetClocksFreq(&RCC_Clocks);
 800b02a:	a806      	add	r0, sp, #24
 800b02c:	f7fe f9e4 	bl	80093f8 <RCC_GetClocksFreq>
  SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);
 800b030:	9b07      	ldr	r3, [sp, #28]
 800b032:	4aa9      	ldr	r2, [pc, #676]	; (800b2d8 <ETH_BSP_Config+0x2b8>)
 800b034:	fba2 2303 	umull	r2, r3, r2, r3
 800b038:	095b      	lsrs	r3, r3, #5
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
 800b03a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800b03e:	d20a      	bcs.n	800b056 <ETH_BSP_Config+0x36>

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 800b040:	4aa6      	ldr	r2, [pc, #664]	; (800b2dc <ETH_BSP_Config+0x2bc>)
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800b042:	4ca7      	ldr	r4, [pc, #668]	; (800b2e0 <ETH_BSP_Config+0x2c0>)
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 800b044:	3b01      	subs	r3, #1
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800b046:	25f0      	movs	r5, #240	; 0xf0
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 800b048:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800b04a:	2107      	movs	r1, #7
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 800b04c:	6053      	str	r3, [r2, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800b04e:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 800b052:	6090      	str	r0, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800b054:	6011      	str	r1, [r2, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800b056:	4ba2      	ldr	r3, [pc, #648]	; (800b2e0 <ETH_BSP_Config+0x2c0>)
 800b058:	2600      	movs	r6, #0
 800b05a:	f883 6023 	strb.w	r6, [r3, #35]	; 0x23
void ETH_GPIO_Config(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  
  /* Enable GPIOs clocks */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB |
 800b05e:	2101      	movs	r1, #1
 800b060:	f240 10e7 	movw	r0, #487	; 0x1e7
 800b064:	f7fe fa14 	bl	8009490 <RCC_AHB1PeriphClockCmd>
                         RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOI |
                         RCC_AHB1Periph_GPIOG | RCC_AHB1Periph_GPIOH |
                         RCC_AHB1Periph_GPIOF, ENABLE);

  /* Enable SYSCFG clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800b068:	2101      	movs	r1, #1
 800b06a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800b06e:	f7fe fa2b 	bl	80094c8 <RCC_APB2PeriphClockCmd>

  /* Configure MCO (PA8) */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800b072:	2402      	movs	r4, #2

  /* Enable SYSCFG clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure MCO (PA8) */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 800b074:	f44f 7380 	mov.w	r3, #256	; 0x100
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 800b078:	2503      	movs	r5, #3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;  
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800b07a:	a904      	add	r1, sp, #16
 800b07c:	4899      	ldr	r0, [pc, #612]	; (800b2e4 <ETH_BSP_Config+0x2c4>)

  /* Enable SYSCFG clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure MCO (PA8) */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 800b07e:	9304      	str	r3, [sp, #16]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800b080:	f88d 6016 	strb.w	r6, [sp, #22]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;  
 800b084:	f88d 6017 	strb.w	r6, [sp, #23]
  /* Enable SYSCFG clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure MCO (PA8) */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 800b088:	f88d 5015 	strb.w	r5, [sp, #21]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800b08c:	f88d 4014 	strb.w	r4, [sp, #20]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;  
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800b090:	f7fe f94a 	bl	8009328 <GPIO_Init>
 #endif /* PHY_CLOCK_MCO */

  SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_MII);
#elif defined RMII_MODE  /* Mode RMII with STM324xx-EVAL */

  SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_RMII);
 800b094:	2001      	movs	r0, #1
 800b096:	f7fe fa4b 	bl	8009530 <SYSCFG_ETH_MediaInterfaceConfig>
        ETH_MII_TXD0/ETH_RMII_TXD0 -------> PG13
        ETH_MII_TXD1/ETH_RMII_TXD1 -------> PG14
                                                  */

  /* Configure PA1, PA2 and PA7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7;
 800b09a:	2386      	movs	r3, #134	; 0x86
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800b09c:	a904      	add	r1, sp, #16
 800b09e:	4891      	ldr	r0, [pc, #580]	; (800b2e4 <ETH_BSP_Config+0x2c4>)
        ETH_MII_TXD0/ETH_RMII_TXD0 -------> PG13
        ETH_MII_TXD1/ETH_RMII_TXD1 -------> PG14
                                                  */

  /* Configure PA1, PA2 and PA7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7;
 800b0a0:	9304      	str	r3, [sp, #16]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800b0a2:	f7fe f941 	bl	8009328 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH);
 800b0a6:	220b      	movs	r2, #11
 800b0a8:	2101      	movs	r1, #1
 800b0aa:	488e      	ldr	r0, [pc, #568]	; (800b2e4 <ETH_BSP_Config+0x2c4>)
 800b0ac:	f7fe f98e 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
 800b0b0:	4621      	mov	r1, r4
 800b0b2:	220b      	movs	r2, #11
 800b0b4:	488b      	ldr	r0, [pc, #556]	; (800b2e4 <ETH_BSP_Config+0x2c4>)
 800b0b6:	f7fe f989 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);
 800b0ba:	220b      	movs	r2, #11
 800b0bc:	2107      	movs	r1, #7
 800b0be:	4889      	ldr	r0, [pc, #548]	; (800b2e4 <ETH_BSP_Config+0x2c4>)
 800b0c0:	f7fe f984 	bl	80093cc <GPIO_PinAFConfig>

  /* Configure PB5 and PB8 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_8;
 800b0c4:	f44f 7390 	mov.w	r3, #288	; 0x120
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 800b0c8:	a904      	add	r1, sp, #16
 800b0ca:	4887      	ldr	r0, [pc, #540]	; (800b2e8 <ETH_BSP_Config+0x2c8>)
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);

  /* Configure PB5 and PB8 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_8;
 800b0cc:	9304      	str	r3, [sp, #16]
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 800b0ce:	f7fe f92b 	bl	8009328 <GPIO_Init>
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_ETH);	
 800b0d2:	220b      	movs	r2, #11
 800b0d4:	2105      	movs	r1, #5
 800b0d6:	4884      	ldr	r0, [pc, #528]	; (800b2e8 <ETH_BSP_Config+0x2c8>)
 800b0d8:	f7fe f978 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_ETH);
 800b0dc:	220b      	movs	r2, #11
 800b0de:	2108      	movs	r1, #8
 800b0e0:	4881      	ldr	r0, [pc, #516]	; (800b2e8 <ETH_BSP_Config+0x2c8>)
 800b0e2:	f7fe f973 	bl	80093cc <GPIO_PinAFConfig>

  /* Configure PC1, PC2, PC3, PC4 and PC5 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
 800b0e6:	233e      	movs	r3, #62	; 0x3e
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800b0e8:	a904      	add	r1, sp, #16
 800b0ea:	4880      	ldr	r0, [pc, #512]	; (800b2ec <ETH_BSP_Config+0x2cc>)
  GPIO_Init(GPIOB, &GPIO_InitStructure);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_ETH);	
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_ETH);

  /* Configure PC1, PC2, PC3, PC4 and PC5 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
 800b0ec:	9304      	str	r3, [sp, #16]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800b0ee:	f7fe f91b 	bl	8009328 <GPIO_Init>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource1, GPIO_AF_ETH);
 800b0f2:	220b      	movs	r2, #11
 800b0f4:	2101      	movs	r1, #1
 800b0f6:	487d      	ldr	r0, [pc, #500]	; (800b2ec <ETH_BSP_Config+0x2cc>)
 800b0f8:	f7fe f968 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource2, GPIO_AF_ETH);
 800b0fc:	4621      	mov	r1, r4
 800b0fe:	220b      	movs	r2, #11
 800b100:	487a      	ldr	r0, [pc, #488]	; (800b2ec <ETH_BSP_Config+0x2cc>)
 800b102:	f7fe f963 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource3, GPIO_AF_ETH);
 800b106:	4629      	mov	r1, r5
 800b108:	220b      	movs	r2, #11
 800b10a:	4878      	ldr	r0, [pc, #480]	; (800b2ec <ETH_BSP_Config+0x2cc>)
 800b10c:	f7fe f95e 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
 800b110:	220b      	movs	r2, #11
 800b112:	2104      	movs	r1, #4
 800b114:	4875      	ldr	r0, [pc, #468]	; (800b2ec <ETH_BSP_Config+0x2cc>)
 800b116:	f7fe f959 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
 800b11a:	220b      	movs	r2, #11
 800b11c:	2105      	movs	r1, #5
 800b11e:	4873      	ldr	r0, [pc, #460]	; (800b2ec <ETH_BSP_Config+0x2cc>)
 800b120:	f7fe f954 	bl	80093cc <GPIO_PinAFConfig>
                                
  /* Configure PG11, PG14 and PG13 */
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14;
 800b124:	f44f 43d0 	mov.w	r3, #26624	; 0x6800
  GPIO_Init(GPIOG, &GPIO_InitStructure);
 800b128:	a904      	add	r1, sp, #16
 800b12a:	4871      	ldr	r0, [pc, #452]	; (800b2f0 <ETH_BSP_Config+0x2d0>)
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource3, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
                                
  /* Configure PG11, PG14 and PG13 */
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14;
 800b12c:	9304      	str	r3, [sp, #16]
  GPIO_Init(GPIOG, &GPIO_InitStructure);
 800b12e:	f7fe f8fb 	bl	8009328 <GPIO_Init>
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_ETH);
 800b132:	220b      	movs	r2, #11
 800b134:	4611      	mov	r1, r2
 800b136:	486e      	ldr	r0, [pc, #440]	; (800b2f0 <ETH_BSP_Config+0x2d0>)
 800b138:	f7fe f948 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource13, GPIO_AF_ETH);
 800b13c:	220b      	movs	r2, #11
 800b13e:	210d      	movs	r1, #13
 800b140:	486b      	ldr	r0, [pc, #428]	; (800b2f0 <ETH_BSP_Config+0x2d0>)
 800b142:	f7fe f943 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_ETH);
 800b146:	220b      	movs	r2, #11
 800b148:	210e      	movs	r1, #14
 800b14a:	4869      	ldr	r0, [pc, #420]	; (800b2f0 <ETH_BSP_Config+0x2d0>)
 800b14c:	f7fe f93e 	bl	80093cc <GPIO_PinAFConfig>

  /* Configure PH2, PH3, PH6, PH7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7;
 800b150:	23cc      	movs	r3, #204	; 0xcc
  GPIO_Init(GPIOH, &GPIO_InitStructure);
 800b152:	a904      	add	r1, sp, #16
 800b154:	4867      	ldr	r0, [pc, #412]	; (800b2f4 <ETH_BSP_Config+0x2d4>)
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource13, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_ETH);

  /* Configure PH2, PH3, PH6, PH7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7;
 800b156:	9304      	str	r3, [sp, #16]
  GPIO_Init(GPIOH, &GPIO_InitStructure);
 800b158:	f7fe f8e6 	bl	8009328 <GPIO_Init>
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource2, GPIO_AF_ETH);
 800b15c:	4621      	mov	r1, r4
 800b15e:	220b      	movs	r2, #11
 800b160:	4864      	ldr	r0, [pc, #400]	; (800b2f4 <ETH_BSP_Config+0x2d4>)
 800b162:	f7fe f933 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource3, GPIO_AF_ETH);
 800b166:	4629      	mov	r1, r5
 800b168:	220b      	movs	r2, #11
 800b16a:	4862      	ldr	r0, [pc, #392]	; (800b2f4 <ETH_BSP_Config+0x2d4>)
 800b16c:	f7fe f92e 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource6, GPIO_AF_ETH);
 800b170:	220b      	movs	r2, #11
 800b172:	2106      	movs	r1, #6
 800b174:	485f      	ldr	r0, [pc, #380]	; (800b2f4 <ETH_BSP_Config+0x2d4>)
 800b176:	f7fe f929 	bl	80093cc <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource7, GPIO_AF_ETH);
 800b17a:	220b      	movs	r2, #11
 800b17c:	2107      	movs	r1, #7
 800b17e:	485d      	ldr	r0, [pc, #372]	; (800b2f4 <ETH_BSP_Config+0x2d4>)
 800b180:	f7fe f924 	bl	80093cc <GPIO_PinAFConfig>

  /* Configure PI10 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 800b184:	f44f 6380 	mov.w	r3, #1024	; 0x400
  GPIO_Init(GPIOI, &GPIO_InitStructure);
 800b188:	a904      	add	r1, sp, #16
 800b18a:	485b      	ldr	r0, [pc, #364]	; (800b2f8 <ETH_BSP_Config+0x2d8>)
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource3, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource6, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource7, GPIO_AF_ETH);

  /* Configure PI10 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 800b18c:	9304      	str	r3, [sp, #16]
  GPIO_Init(GPIOI, &GPIO_InitStructure);
 800b18e:	f7fe f8cb 	bl	8009328 <GPIO_Init>
  GPIO_PinAFConfig(GPIOI, GPIO_PinSource10, GPIO_AF_ETH);
 800b192:	220b      	movs	r2, #11
 800b194:	210a      	movs	r1, #10
 800b196:	4858      	ldr	r0, [pc, #352]	; (800b2f8 <ETH_BSP_Config+0x2d8>)
 800b198:	f7fe f918 	bl	80093cc <GPIO_PinAFConfig>
  * @retval None
  */
static void ETH_MACDMA_Config(void)
{
  /* Enable ETHERNET clock  */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx |
 800b19c:	2101      	movs	r1, #1
 800b19e:	f04f 6060 	mov.w	r0, #234881024	; 0xe000000
 800b1a2:	f7fe f975 	bl	8009490 <RCC_AHB1PeriphClockCmd>
                        RCC_AHB1Periph_ETH_MAC_Rx, ENABLE);

  /* Reset ETHERNET on AHB Bus */
  ETH_DeInit();
 800b1a6:	f7fd fb15 	bl	80087d4 <ETH_DeInit>

  /* Software reset */
  ETH_SoftwareReset();
 800b1aa:	f7fd ff15 	bl	8008fd8 <ETH_SoftwareReset>

  /* Wait for software reset */
  while (ETH_GetSoftwareResetStatus() == SET);
 800b1ae:	f7fd ff1b 	bl	8008fe8 <ETH_GetSoftwareResetStatus>
 800b1b2:	2801      	cmp	r0, #1
 800b1b4:	d0fb      	beq.n	800b1ae <ETH_BSP_Config+0x18e>

  /* ETHERNET Configuration --------------------------------------------------*/
  /* Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter */
  ETH_StructInit(&ETH_InitStructure);
 800b1b6:	4c51      	ldr	r4, [pc, #324]	; (800b2fc <ETH_BSP_Config+0x2dc>)
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;

  /* Configure Ethernet */
  EthStatus = ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800b1b8:	4e51      	ldr	r6, [pc, #324]	; (800b300 <ETH_BSP_Config+0x2e0>)
  /* Wait for software reset */
  while (ETH_GetSoftwareResetStatus() == SET);

  /* ETHERNET Configuration --------------------------------------------------*/
  /* Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter */
  ETH_StructInit(&ETH_InitStructure);
 800b1ba:	4620      	mov	r0, r4
 800b1bc:	f7fd fb18 	bl	80087f0 <ETH_StructInit>
//  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
//  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
//  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;

  ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
  ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
 800b1c0:	f44f 7000 	mov.w	r0, #512	; 0x200
  ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;
  ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
  ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
  ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
#ifdef CHECKSUM_BY_HARDWARE
  ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable;
 800b1c4:	f44f 6180 	mov.w	r1, #1024	; 0x400
  /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
  the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
  if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */
  ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
  ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
  ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;
 800b1c8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000

  ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
  ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
  ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
 800b1cc:	2204      	movs	r2, #4
  /* Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter */
  ETH_StructInit(&ETH_InitStructure);

  /* Fill ETH_InitStructure parametrs */
  /*------------------------   MAC   -----------------------------------*/
  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
 800b1ce:	2501      	movs	r5, #1
//  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
//  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
//  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;

  ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
  ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
 800b1d0:	62a0      	str	r0, [r4, #40]	; 0x28
  ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;
  ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
  ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
  ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
#ifdef CHECKSUM_BY_HARDWARE
  ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable;
 800b1d2:	6261      	str	r1, [r4, #36]	; 0x24

  ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
  ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
  ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
  ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;
 800b1d4:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
 800b1d8:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
  the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
  if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */
  ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
  ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
  ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;
 800b1dc:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c

  ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
  ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
  ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
 800b1e0:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
  ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 800b1e4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
 800b1e8:	f44f 4280 	mov.w	r2, #16384	; 0x4000

  ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
  ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
  ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
  ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;
 800b1ec:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
 800b1f0:	f8c4 10ac 	str.w	r1, [r4, #172]	; 0xac
  ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 800b1f4:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
  ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;

  /* Configure Ethernet */
  EthStatus = ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800b1f8:	4629      	mov	r1, r5
  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
//  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
//  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
//  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;

  ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
 800b1fa:	2300      	movs	r3, #0
  ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
  ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
 800b1fc:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8

  /* Configure Ethernet */
  EthStatus = ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800b200:	4620      	mov	r0, r4
  /*------------------------   DMA   -----------------------------------------*/
  /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
  the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
  if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */
  ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
  ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
 800b202:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
//  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
//  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
//  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;

  ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
 800b206:	61e3      	str	r3, [r4, #28]
  ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
  ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
 800b208:	62e3      	str	r3, [r4, #44]	; 0x2c
  ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Disable;
 800b20a:	63a3      	str	r3, [r4, #56]	; 0x38
  ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;
 800b20c:	6463      	str	r3, [r4, #68]	; 0x44
  ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
 800b20e:	64e3      	str	r3, [r4, #76]	; 0x4c
  ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
 800b210:	6523      	str	r3, [r4, #80]	; 0x50
  ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
 800b212:	6563      	str	r3, [r4, #84]	; 0x54

  /*------------------------   DMA   -----------------------------------------*/
  /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
  the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
  if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */
  ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
 800b214:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
  ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;

  ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
 800b218:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
  ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
 800b21c:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
  /*------------------------   DMA   -----------------------------------------*/
  /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
  the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
  if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */
  ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
  ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
 800b220:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
  ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;

  ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
  ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
  ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
  ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
 800b224:	f8c4 20a4 	str.w	r2, [r4, #164]	; 0xa4
  /* Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter */
  ETH_StructInit(&ETH_InitStructure);

  /* Fill ETH_InitStructure parametrs */
  /*------------------------   MAC   -----------------------------------*/
  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
 800b228:	6025      	str	r5, [r4, #0]
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;

  /* Configure Ethernet */
  EthStatus = ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800b22a:	f7fd fb37 	bl	800889c <ETH_Init>

  /* Configure the Ethernet MAC/DMA */
  ETH_MACDMA_Config();

  /* Read PHY status register: Get Ethernet link status */
  if(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_SR) & 1)
 800b22e:	2110      	movs	r1, #16
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;

  /* Configure Ethernet */
  EthStatus = ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800b230:	4603      	mov	r3, r0

  /* Configure the Ethernet MAC/DMA */
  ETH_MACDMA_Config();

  /* Read PHY status register: Get Ethernet link status */
  if(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_SR) & 1)
 800b232:	4628      	mov	r0, r5
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;

  /* Configure Ethernet */
  EthStatus = ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800b234:	6033      	str	r3, [r6, #0]

  /* Configure the Ethernet MAC/DMA */
  ETH_MACDMA_Config();

  /* Read PHY status register: Get Ethernet link status */
  if(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_SR) & 1)
 800b236:	f7fd fedf 	bl	8008ff8 <ETH_ReadPHYRegister>
 800b23a:	07c3      	lsls	r3, r0, #31
 800b23c:	d503      	bpl.n	800b246 <ETH_BSP_Config+0x226>
  {
    EthStatus |= ETH_LINK_FLAG;
 800b23e:	6833      	ldr	r3, [r6, #0]
 800b240:	f043 0310 	orr.w	r3, r3, #16
 800b244:	6033      	str	r3, [r6, #0]
uint32_t Eth_Link_PHYITConfig(uint16_t PHYAddress)
{
  uint16_t tmpreg = 0;

  /* Read MICR register */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MICR);
 800b246:	2111      	movs	r1, #17
 800b248:	2001      	movs	r0, #1
 800b24a:	f7fd fed5 	bl	8008ff8 <ETH_ReadPHYRegister>

  /* Enable output interrupt events to signal via the INT pin */
  tmpreg |= (uint16_t)(PHY_MICR_INT_EN | PHY_MICR_INT_OE);
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_MICR, tmpreg)))
 800b24e:	f040 0203 	orr.w	r2, r0, #3
 800b252:	b292      	uxth	r2, r2
 800b254:	2111      	movs	r1, #17
 800b256:	2001      	movs	r0, #1
 800b258:	f7fd fefe 	bl	8009058 <ETH_WritePHYRegister>
 800b25c:	b150      	cbz	r0, 800b274 <ETH_BSP_Config+0x254>
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
  }

  /* Read MISR register */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MISR);
 800b25e:	2112      	movs	r1, #18
 800b260:	2001      	movs	r0, #1
 800b262:	f7fd fec9 	bl	8008ff8 <ETH_ReadPHYRegister>

  /* Enable Interrupt on change of link status */
  tmpreg |= (uint16_t)PHY_MISR_LINK_INT_EN;
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_MISR, tmpreg)))
 800b266:	f040 0220 	orr.w	r2, r0, #32
 800b26a:	b292      	uxth	r2, r2
 800b26c:	2112      	movs	r1, #18
 800b26e:	2001      	movs	r0, #1
 800b270:	f7fd fef2 	bl	8009058 <ETH_WritePHYRegister>
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the INT (PB14) Clock */
  RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
 800b274:	2101      	movs	r1, #1
 800b276:	2002      	movs	r0, #2
 800b278:	f7fe f90a 	bl	8009490 <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800b27c:	2101      	movs	r1, #1
 800b27e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800b282:	f7fe f921 	bl	80094c8 <RCC_APB2PeriphClockCmd>

  /* Configure INT pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Pin = ETH_LINK_PIN;
 800b286:	a90a      	add	r1, sp, #40	; 0x28
 800b288:	f44f 4680 	mov.w	r6, #16384	; 0x4000
  /* Enable the INT (PB14) Clock */
  RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure INT pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800b28c:	2500      	movs	r5, #0
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Pin = ETH_LINK_PIN;
 800b28e:	f841 6d20 	str.w	r6, [r1, #-32]!
  GPIO_Init(ETH_LINK_GPIO_PORT, &GPIO_InitStructure);
 800b292:	4815      	ldr	r0, [pc, #84]	; (800b2e8 <ETH_BSP_Config+0x2c8>)
  /* Enable the INT (PB14) Clock */
  RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure INT pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800b294:	f88d 500c 	strb.w	r5, [sp, #12]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800b298:	f88d 500f 	strb.w	r5, [sp, #15]
  GPIO_InitStructure.GPIO_Pin = ETH_LINK_PIN;
  GPIO_Init(ETH_LINK_GPIO_PORT, &GPIO_InitStructure);
 800b29c:	f7fe f844 	bl	8009328 <GPIO_Init>

  /* Connect EXTI Line to INT Pin */
  SYSCFG_EXTILineConfig(ETH_LINK_EXTI_PORT_SOURCE, ETH_LINK_EXTI_PIN_SOURCE);
 800b2a0:	210e      	movs	r1, #14
 800b2a2:	2001      	movs	r0, #1
 800b2a4:	f7fe f92c 	bl	8009500 <SYSCFG_EXTILineConfig>

  /* Configure EXTI line */
  EXTI_InitStructure.EXTI_Line = ETH_LINK_EXTI_LINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800b2a8:	2401      	movs	r4, #1
  EXTI_Init(&EXTI_InitStructure);
 800b2aa:	a804      	add	r0, sp, #16
  SYSCFG_EXTILineConfig(ETH_LINK_EXTI_PORT_SOURCE, ETH_LINK_EXTI_PIN_SOURCE);

  /* Configure EXTI line */
  EXTI_InitStructure.EXTI_Line = ETH_LINK_EXTI_LINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
 800b2ac:	230c      	movs	r3, #12
 800b2ae:	f88d 3015 	strb.w	r3, [sp, #21]

  /* Connect EXTI Line to INT Pin */
  SYSCFG_EXTILineConfig(ETH_LINK_EXTI_PORT_SOURCE, ETH_LINK_EXTI_PIN_SOURCE);

  /* Configure EXTI line */
  EXTI_InitStructure.EXTI_Line = ETH_LINK_EXTI_LINE;
 800b2b2:	9604      	str	r6, [sp, #16]
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 800b2b4:	f88d 5014 	strb.w	r5, [sp, #20]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800b2b8:	f88d 4016 	strb.w	r4, [sp, #22]
  EXTI_Init(&EXTI_InitStructure);
 800b2bc:	f7fd ffe2 	bl	8009284 <EXTI_Init>

  /* Enable and set the EXTI interrupt to priority 1*/
  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
 800b2c0:	2328      	movs	r3, #40	; 0x28
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 800b2c2:	a801      	add	r0, sp, #4
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);

  /* Enable and set the EXTI interrupt to priority 1*/
  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 800b2c4:	f88d 4005 	strb.w	r4, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800b2c8:	f88d 4007 	strb.w	r4, [sp, #7]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);

  /* Enable and set the EXTI interrupt to priority 1*/
  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
 800b2cc:	f88d 3004 	strb.w	r3, [sp, #4]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 800b2d0:	f7fd fef0 	bl	80090b4 <NVIC_Init>
  /* Configure the PHY to generate an interrupt on change of link status */
  Eth_Link_PHYITConfig(DP83848_PHY_ADDRESS);

  /* Configure the EXTI for Ethernet link status. */
  Eth_Link_EXTIConfig(); 
}
 800b2d4:	b00a      	add	sp, #40	; 0x28
 800b2d6:	bd70      	pop	{r4, r5, r6, pc}
 800b2d8:	51eb851f 	.word	0x51eb851f
 800b2dc:	e000e010 	.word	0xe000e010
 800b2e0:	e000ed00 	.word	0xe000ed00
 800b2e4:	40020000 	.word	0x40020000
 800b2e8:	40020400 	.word	0x40020400
 800b2ec:	40020800 	.word	0x40020800
 800b2f0:	40021800 	.word	0x40021800
 800b2f4:	40021c00 	.word	0x40021c00
 800b2f8:	40022000 	.word	0x40022000
 800b2fc:	20008970 	.word	0x20008970
 800b300:	20002eac 	.word	0x20002eac

0800b304 <Eth_Link_ITHandler>:
  * @brief  This function handles Ethernet link status.
  * @param  None
  * @retval None
  */
void Eth_Link_ITHandler(uint16_t PHYAddress)
{
 800b304:	b510      	push	{r4, lr}
  /* Check whether the link interrupt has occurred or not */
  if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
 800b306:	2112      	movs	r1, #18
  * @brief  This function handles Ethernet link status.
  * @param  None
  * @retval None
  */
void Eth_Link_ITHandler(uint16_t PHYAddress)
{
 800b308:	4604      	mov	r4, r0
  /* Check whether the link interrupt has occurred or not */
  if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
 800b30a:	f7fd fe75 	bl	8008ff8 <ETH_ReadPHYRegister>
 800b30e:	0483      	lsls	r3, r0, #18
 800b310:	d400      	bmi.n	800b314 <Eth_Link_ITHandler+0x10>
 800b312:	bd10      	pop	{r4, pc}
  {
    if((ETH_ReadPHYRegister(PHYAddress, PHY_SR) & 1))
 800b314:	4620      	mov	r0, r4
 800b316:	2110      	movs	r1, #16
 800b318:	f7fd fe6e 	bl	8008ff8 <ETH_ReadPHYRegister>
 800b31c:	f010 0f01 	tst.w	r0, #1
    {
      netif_set_link_up(&gnetif);
 800b320:	4804      	ldr	r0, [pc, #16]	; (800b334 <Eth_Link_ITHandler+0x30>)
void Eth_Link_ITHandler(uint16_t PHYAddress)
{
  /* Check whether the link interrupt has occurred or not */
  if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
  {
    if((ETH_ReadPHYRegister(PHYAddress, PHY_SR) & 1))
 800b322:	d103      	bne.n	800b32c <Eth_Link_ITHandler+0x28>
    else
    {
      netif_set_link_down(&gnetif);
    }
  }
}
 800b324:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      netif_set_link_up(&gnetif);
    }
    else
    {
      netif_set_link_down(&gnetif);
 800b328:	f7f8 bdce 	b.w	8003ec8 <netif_set_link_down>
    }
  }
}
 800b32c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* Check whether the link interrupt has occurred or not */
  if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
  {
    if((ETH_ReadPHYRegister(PHYAddress, PHY_SR) & 1))
    {
      netif_set_link_up(&gnetif);
 800b330:	f7f8 bda8 	b.w	8003e84 <netif_set_link_up>
 800b334:	20008934 	.word	0x20008934

0800b338 <ETH_link_callback>:
  * @brief  Link callback function, this function is called on change of link status.
  * @param  The network interface
  * @retval None
  */
void ETH_link_callback(struct netif *netif)
{
 800b338:	b570      	push	{r4, r5, r6, lr}
 800b33a:	b084      	sub	sp, #16
  __IO uint32_t timeout = 0;
 800b33c:	2500      	movs	r5, #0
  * @brief  Link callback function, this function is called on change of link status.
  * @param  The network interface
  * @retval None
  */
void ETH_link_callback(struct netif *netif)
{
 800b33e:	4604      	mov	r4, r0
  __IO uint32_t timeout = 0;
 800b340:	9500      	str	r5, [sp, #0]
  uint8_t iptab[4] = {0};
  uint8_t iptxt[20];
#endif /* USE_DHCP */

  /* Clear LCD */
  LCD_ClearLine(Line4);
 800b342:	f7fe f99f 	bl	8009684 <LCD_GetFont>
 800b346:	88c0      	ldrh	r0, [r0, #6]
 800b348:	0080      	lsls	r0, r0, #2
 800b34a:	b280      	uxth	r0, r0
 800b34c:	f7fe f9a0 	bl	8009690 <LCD_ClearLine>
  LCD_ClearLine(Line5);
 800b350:	f7fe f998 	bl	8009684 <LCD_GetFont>
 800b354:	88c0      	ldrh	r0, [r0, #6]
 800b356:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800b35a:	b280      	uxth	r0, r0
 800b35c:	f7fe f998 	bl	8009690 <LCD_ClearLine>
  LCD_ClearLine(Line6);
 800b360:	f7fe f990 	bl	8009684 <LCD_GetFont>
 800b364:	88c0      	ldrh	r0, [r0, #6]
 800b366:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800b36a:	0040      	lsls	r0, r0, #1
 800b36c:	b280      	uxth	r0, r0
 800b36e:	f7fe f98f 	bl	8009690 <LCD_ClearLine>
  LCD_ClearLine(Line7);
 800b372:	f7fe f987 	bl	8009684 <LCD_GetFont>
 800b376:	88c0      	ldrh	r0, [r0, #6]
 800b378:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 800b37c:	b280      	uxth	r0, r0
 800b37e:	f7fe f987 	bl	8009690 <LCD_ClearLine>
  LCD_ClearLine(Line8);
 800b382:	f7fe f97f 	bl	8009684 <LCD_GetFont>
 800b386:	88c0      	ldrh	r0, [r0, #6]
 800b388:	00c0      	lsls	r0, r0, #3
 800b38a:	b280      	uxth	r0, r0
 800b38c:	f7fe f980 	bl	8009690 <LCD_ClearLine>
  LCD_ClearLine(Line9);
 800b390:	f7fe f978 	bl	8009684 <LCD_GetFont>
 800b394:	88c0      	ldrh	r0, [r0, #6]
 800b396:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 800b39a:	b280      	uxth	r0, r0
 800b39c:	f7fe f978 	bl	8009690 <LCD_ClearLine>

  if(netif_is_link_up(netif))
 800b3a0:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
 800b3a4:	06da      	lsls	r2, r3, #27
 800b3a6:	d54b      	bpl.n	800b440 <ETH_link_callback+0x108>
  {
    /* Restart the auto-negotiation */
    if(ETH_InitStructure.ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
 800b3a8:	4e2c      	ldr	r6, [pc, #176]	; (800b45c <ETH_link_callback+0x124>)
 800b3aa:	6833      	ldr	r3, [r6, #0]
 800b3ac:	b9a3      	cbnz	r3, 800b3d8 <ETH_link_callback+0xa0>
      tmpreg = ETH->MACCR;
      ETH->MACCR = tmpreg;
    }

    /* Restart MAC interface */
    ETH_Start();
 800b3ae:	f7fd fc7b 	bl	8008ca8 <ETH_Start>

#ifdef USE_DHCP
    ipaddr.addr = 0;
    netmask.addr = 0;
    gw.addr = 0;
 800b3b2:	ab04      	add	r3, sp, #16

    /* Restart MAC interface */
    ETH_Start();

#ifdef USE_DHCP
    ipaddr.addr = 0;
 800b3b4:	2400      	movs	r4, #0
    netmask.addr = 0;
    gw.addr = 0;
    DHCP_state = DHCP_START;
 800b3b6:	4d2a      	ldr	r5, [pc, #168]	; (800b460 <ETH_link_callback+0x128>)
    ETH_Start();

#ifdef USE_DHCP
    ipaddr.addr = 0;
    netmask.addr = 0;
    gw.addr = 0;
 800b3b8:	f843 4d04 	str.w	r4, [r3, #-4]!
    IP4_ADDR(&ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3);
    IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3);
    IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
#endif /* USE_DHCP */

    netif_set_addr(&gnetif, &ipaddr , &netmask, &gw);
 800b3bc:	aa02      	add	r2, sp, #8
 800b3be:	a901      	add	r1, sp, #4
 800b3c0:	4828      	ldr	r0, [pc, #160]	; (800b464 <ETH_link_callback+0x12c>)

    /* Restart MAC interface */
    ETH_Start();

#ifdef USE_DHCP
    ipaddr.addr = 0;
 800b3c2:	9401      	str	r4, [sp, #4]
    netmask.addr = 0;
    gw.addr = 0;
    DHCP_state = DHCP_START;
 800b3c4:	2601      	movs	r6, #1
    /* Restart MAC interface */
    ETH_Start();

#ifdef USE_DHCP
    ipaddr.addr = 0;
    netmask.addr = 0;
 800b3c6:	9402      	str	r4, [sp, #8]
    gw.addr = 0;
    DHCP_state = DHCP_START;
 800b3c8:	702e      	strb	r6, [r5, #0]
    IP4_ADDR(&ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3);
    IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3);
    IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
#endif /* USE_DHCP */

    netif_set_addr(&gnetif, &ipaddr , &netmask, &gw);
 800b3ca:	f7f8 fcab 	bl	8003d24 <netif_set_addr>
    
    /* When the netif is fully configured this function must be called.*/
    netif_set_up(&gnetif);    
 800b3ce:	4825      	ldr	r0, [pc, #148]	; (800b464 <ETH_link_callback+0x12c>)
 800b3d0:	f7f8 fd38 	bl	8003e44 <netif_set_up>

    /* Set the LCD Text Color */
    LCD_SetTextColor(White);
#endif /* USE_LCD */
  }
}
 800b3d4:	b004      	add	sp, #16
 800b3d6:	bd70      	pop	{r4, r5, r6, pc}
    {
      /* Reset Timeout counter */
      timeout = 0;

      /* Enable auto-negotiation */
      ETH_WritePHYRegister(DP83848_PHY_ADDRESS, PHY_BCR, PHY_AutoNegotiation);
 800b3d8:	4629      	mov	r1, r5
 800b3da:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800b3de:	2001      	movs	r0, #1
  {
    /* Restart the auto-negotiation */
    if(ETH_InitStructure.ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
    {
      /* Reset Timeout counter */
      timeout = 0;
 800b3e0:	9500      	str	r5, [sp, #0]

      /* Wait until the auto-negotiation will be completed */
      do
      {
        timeout++;
      } while (!(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));
 800b3e2:	4c21      	ldr	r4, [pc, #132]	; (800b468 <ETH_link_callback+0x130>)
    {
      /* Reset Timeout counter */
      timeout = 0;

      /* Enable auto-negotiation */
      ETH_WritePHYRegister(DP83848_PHY_ADDRESS, PHY_BCR, PHY_AutoNegotiation);
 800b3e4:	f7fd fe38 	bl	8009058 <ETH_WritePHYRegister>
 800b3e8:	e002      	b.n	800b3f0 <ETH_link_callback+0xb8>

      /* Wait until the auto-negotiation will be completed */
      do
      {
        timeout++;
      } while (!(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));
 800b3ea:	9b00      	ldr	r3, [sp, #0]
 800b3ec:	42a3      	cmp	r3, r4
 800b3ee:	d808      	bhi.n	800b402 <ETH_link_callback+0xca>
      ETH_WritePHYRegister(DP83848_PHY_ADDRESS, PHY_BCR, PHY_AutoNegotiation);

      /* Wait until the auto-negotiation will be completed */
      do
      {
        timeout++;
 800b3f0:	9b00      	ldr	r3, [sp, #0]
      } while (!(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));
 800b3f2:	2101      	movs	r1, #1
      ETH_WritePHYRegister(DP83848_PHY_ADDRESS, PHY_BCR, PHY_AutoNegotiation);

      /* Wait until the auto-negotiation will be completed */
      do
      {
        timeout++;
 800b3f4:	440b      	add	r3, r1
      } while (!(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));
 800b3f6:	4608      	mov	r0, r1
      ETH_WritePHYRegister(DP83848_PHY_ADDRESS, PHY_BCR, PHY_AutoNegotiation);

      /* Wait until the auto-negotiation will be completed */
      do
      {
        timeout++;
 800b3f8:	9300      	str	r3, [sp, #0]
      } while (!(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));
 800b3fa:	f7fd fdfd 	bl	8008ff8 <ETH_ReadPHYRegister>
 800b3fe:	0683      	lsls	r3, r0, #26
 800b400:	d5f3      	bpl.n	800b3ea <ETH_link_callback+0xb2>

      /* Reset Timeout counter */
      timeout = 0;

      /* Read the result of the auto-negotiation */
      RegValue = ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_SR);
 800b402:	2110      	movs	r1, #16
      {
        timeout++;
      } while (!(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));

      /* Reset Timeout counter */
      timeout = 0;
 800b404:	2300      	movs	r3, #0

      /* Read the result of the auto-negotiation */
      RegValue = ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_SR);
 800b406:	2001      	movs	r0, #1
      {
        timeout++;
      } while (!(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));

      /* Reset Timeout counter */
      timeout = 0;
 800b408:	9300      	str	r3, [sp, #0]

      /* Read the result of the auto-negotiation */
      RegValue = ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_SR);
 800b40a:	f7fd fdf5 	bl	8008ff8 <ETH_ReadPHYRegister>
        ETH_InitStructure.ETH_Speed = ETH_Speed_100M;
      }

      /*------------------------ ETHERNET MACCR Re-Configuration --------------------*/
      /* Get the ETHERNET MACCR value */
      tmpreg = ETH->MACCR;
 800b40e:	4c17      	ldr	r4, [pc, #92]	; (800b46c <ETH_link_callback+0x134>)

      /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
      if((RegValue & PHY_DUPLEX_STATUS) != (uint16_t)RESET)
      {
        /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
        ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;  
 800b410:	f010 0f04 	tst.w	r0, #4
        ETH_InitStructure.ETH_Speed = ETH_Speed_100M;
      }

      /*------------------------ ETHERNET MACCR Re-Configuration --------------------*/
      /* Get the ETHERNET MACCR value */
      tmpreg = ETH->MACCR;
 800b414:	6823      	ldr	r3, [r4, #0]

      /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
      if((RegValue & PHY_DUPLEX_STATUS) != (uint16_t)RESET)
      {
        /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
        ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;  
 800b416:	bf0c      	ite	eq
 800b418:	2100      	moveq	r1, #0
 800b41a:	f44f 6100 	movne.w	r1, #2048	; 0x800
        ETH_InitStructure.ETH_Speed = ETH_Speed_10M; 
      }
      else
      {
        /* Set Ethernet speed to 100M following the auto-negotiation */ 
        ETH_InitStructure.ETH_Speed = ETH_Speed_100M;
 800b41e:	f010 0f02 	tst.w	r0, #2
 800b422:	bf14      	ite	ne
 800b424:	2200      	movne	r2, #0
 800b426:	f44f 4280 	moveq.w	r2, #16384	; 0x4000
 800b42a:	430b      	orrs	r3, r1
      /* Get the ETHERNET MACCR value */
      tmpreg = ETH->MACCR;

      /* Set the FES bit according to ETH_Speed value */ 
      /* Set the DM bit according to ETH_Mode value */ 
      tmpreg |= (uint32_t)(ETH_InitStructure.ETH_Speed | ETH_InitStructure.ETH_Mode);
 800b42c:	4313      	orrs	r3, r2

      /* Write to ETHERNET MACCR */
      ETH->MACCR = (uint32_t)tmpreg;
 800b42e:	6023      	str	r3, [r4, #0]

      _eth_delay_(ETH_REG_WRITE_DELAY);
 800b430:	2001      	movs	r0, #1
 800b432:	6231      	str	r1, [r6, #32]
 800b434:	6172      	str	r2, [r6, #20]
 800b436:	f7ff fbef 	bl	800ac18 <Delay>
      tmpreg = ETH->MACCR;
 800b43a:	6823      	ldr	r3, [r4, #0]
      ETH->MACCR = tmpreg;
 800b43c:	6023      	str	r3, [r4, #0]
 800b43e:	e7b6      	b.n	800b3ae <ETH_link_callback+0x76>
  #endif /* USE_DHCP */
#endif /* USE_LCD */
  }
  else
  {
    ETH_Stop();
 800b440:	f7fd fc68 	bl	8008d14 <ETH_Stop>
#ifdef USE_DHCP
    DHCP_state = DHCP_LINK_DOWN;
 800b444:	4b06      	ldr	r3, [pc, #24]	; (800b460 <ETH_link_callback+0x128>)
 800b446:	2205      	movs	r2, #5
    dhcp_stop(netif);
 800b448:	4620      	mov	r0, r4
  }
  else
  {
    ETH_Stop();
#ifdef USE_DHCP
    DHCP_state = DHCP_LINK_DOWN;
 800b44a:	701a      	strb	r2, [r3, #0]
    dhcp_stop(netif);
 800b44c:	f7f8 fa6c 	bl	8003928 <dhcp_stop>
#endif /* USE_DHCP */

    /*  When the netif link is down this function must be called.*/
    netif_set_down(&gnetif);
 800b450:	4804      	ldr	r0, [pc, #16]	; (800b464 <ETH_link_callback+0x12c>)
 800b452:	f7f8 fd09 	bl	8003e68 <netif_set_down>

    /* Set the LCD Text Color */
    LCD_SetTextColor(White);
#endif /* USE_LCD */
  }
}
 800b456:	b004      	add	sp, #16
 800b458:	bd70      	pop	{r4, r5, r6, pc}
 800b45a:	bf00      	nop
 800b45c:	20008970 	.word	0x20008970
 800b460:	2000896c 	.word	0x2000896c
 800b464:	20008934 	.word	0x20008934
 800b468:	0004fffe 	.word	0x0004fffe
 800b46c:	40028000 	.word	0x40028000

0800b470 <NMI_Handler>:
 800b470:	4770      	bx	lr
 800b472:	bf00      	nop

0800b474 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800b474:	e7fe      	b.n	800b474 <HardFault_Handler>
 800b476:	bf00      	nop

0800b478 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 800b478:	e7fe      	b.n	800b478 <MemManage_Handler>
 800b47a:	bf00      	nop

0800b47c <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800b47c:	e7fe      	b.n	800b47c <BusFault_Handler>
 800b47e:	bf00      	nop

0800b480 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 800b480:	e7fe      	b.n	800b480 <UsageFault_Handler>
 800b482:	bf00      	nop

0800b484 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 800b484:	4770      	bx	lr
 800b486:	bf00      	nop

0800b488 <SysTick_Handler>:
  * @retval None
  */
void SysTick_Handler(void)
{
  /* Update the LocalTime by adding SYSTEMTICK_PERIOD_MS each SysTick interrupt */
  Time_Update();
 800b488:	f7ff bbd4 	b.w	800ac34 <Time_Update>

0800b48c <EXTI15_10_IRQHandler>:
  * @brief  This function handles External line 10 interrupt request.
  * @param  None
  * @retval None
  */
void EXTI15_10_IRQHandler(void)
{
 800b48c:	b508      	push	{r3, lr}
  if(EXTI_GetITStatus(ETH_LINK_EXTI_LINE) != RESET)
 800b48e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800b492:	f7fd ff35 	bl	8009300 <EXTI_GetITStatus>
 800b496:	b900      	cbnz	r0, 800b49a <EXTI15_10_IRQHandler+0xe>
 800b498:	bd08      	pop	{r3, pc}
  {
    Eth_Link_ITHandler(DP83848_PHY_ADDRESS);
 800b49a:	2001      	movs	r0, #1
 800b49c:	f7ff ff32 	bl	800b304 <Eth_Link_ITHandler>
    /* Clear interrupt pending bit */
    EXTI_ClearITPendingBit(ETH_LINK_EXTI_LINE);
 800b4a0:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  }
}
 800b4a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  if(EXTI_GetITStatus(ETH_LINK_EXTI_LINE) != RESET)
  {
    Eth_Link_ITHandler(DP83848_PHY_ADDRESS);
    /* Clear interrupt pending bit */
    EXTI_ClearITPendingBit(ETH_LINK_EXTI_LINE);
 800b4a8:	f7fd bf38 	b.w	800931c <EXTI_ClearITPendingBit>

0800b4ac <__libc_init_array>:
 800b4ac:	b570      	push	{r4, r5, r6, lr}
 800b4ae:	4b0e      	ldr	r3, [pc, #56]	; (800b4e8 <__libc_init_array+0x3c>)
 800b4b0:	4c0e      	ldr	r4, [pc, #56]	; (800b4ec <__libc_init_array+0x40>)
 800b4b2:	1ae4      	subs	r4, r4, r3
 800b4b4:	10a4      	asrs	r4, r4, #2
 800b4b6:	2500      	movs	r5, #0
 800b4b8:	461e      	mov	r6, r3
 800b4ba:	42a5      	cmp	r5, r4
 800b4bc:	d004      	beq.n	800b4c8 <__libc_init_array+0x1c>
 800b4be:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800b4c2:	4798      	blx	r3
 800b4c4:	3501      	adds	r5, #1
 800b4c6:	e7f8      	b.n	800b4ba <__libc_init_array+0xe>
 800b4c8:	f001 fa7c 	bl	800c9c4 <_init>
 800b4cc:	4c08      	ldr	r4, [pc, #32]	; (800b4f0 <__libc_init_array+0x44>)
 800b4ce:	4b09      	ldr	r3, [pc, #36]	; (800b4f4 <__libc_init_array+0x48>)
 800b4d0:	1ae4      	subs	r4, r4, r3
 800b4d2:	10a4      	asrs	r4, r4, #2
 800b4d4:	2500      	movs	r5, #0
 800b4d6:	461e      	mov	r6, r3
 800b4d8:	42a5      	cmp	r5, r4
 800b4da:	d004      	beq.n	800b4e6 <__libc_init_array+0x3a>
 800b4dc:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800b4e0:	4798      	blx	r3
 800b4e2:	3501      	adds	r5, #1
 800b4e4:	e7f8      	b.n	800b4d8 <__libc_init_array+0x2c>
 800b4e6:	bd70      	pop	{r4, r5, r6, pc}
 800b4e8:	080198b0 	.word	0x080198b0
 800b4ec:	080198b0 	.word	0x080198b0
 800b4f0:	080198b4 	.word	0x080198b4
 800b4f4:	080198b0 	.word	0x080198b0

0800b4f8 <memcmp>:
 800b4f8:	b510      	push	{r4, lr}
 800b4fa:	3901      	subs	r1, #1
 800b4fc:	4402      	add	r2, r0
 800b4fe:	4290      	cmp	r0, r2
 800b500:	d007      	beq.n	800b512 <memcmp+0x1a>
 800b502:	f810 3b01 	ldrb.w	r3, [r0], #1
 800b506:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800b50a:	42a3      	cmp	r3, r4
 800b50c:	d0f7      	beq.n	800b4fe <memcmp+0x6>
 800b50e:	1b18      	subs	r0, r3, r4
 800b510:	bd10      	pop	{r4, pc}
 800b512:	2000      	movs	r0, #0
 800b514:	bd10      	pop	{r4, pc}

0800b516 <memcpy>:
 800b516:	b510      	push	{r4, lr}
 800b518:	1e43      	subs	r3, r0, #1
 800b51a:	440a      	add	r2, r1
 800b51c:	4291      	cmp	r1, r2
 800b51e:	d004      	beq.n	800b52a <memcpy+0x14>
 800b520:	f811 4b01 	ldrb.w	r4, [r1], #1
 800b524:	f803 4f01 	strb.w	r4, [r3, #1]!
 800b528:	e7f8      	b.n	800b51c <memcpy+0x6>
 800b52a:	bd10      	pop	{r4, pc}

0800b52c <memset>:
 800b52c:	4402      	add	r2, r0
 800b52e:	4603      	mov	r3, r0
 800b530:	4293      	cmp	r3, r2
 800b532:	d002      	beq.n	800b53a <memset+0xe>
 800b534:	f803 1b01 	strb.w	r1, [r3], #1
 800b538:	e7fa      	b.n	800b530 <memset+0x4>
 800b53a:	4770      	bx	lr

0800b53c <_puts_r>:
 800b53c:	b530      	push	{r4, r5, lr}
 800b53e:	4605      	mov	r5, r0
 800b540:	b089      	sub	sp, #36	; 0x24
 800b542:	4608      	mov	r0, r1
 800b544:	460c      	mov	r4, r1
 800b546:	f7f4 fe55 	bl	80001f4 <strlen>
 800b54a:	4b1e      	ldr	r3, [pc, #120]	; (800b5c4 <_puts_r+0x88>)
 800b54c:	9306      	str	r3, [sp, #24]
 800b54e:	2301      	movs	r3, #1
 800b550:	9005      	str	r0, [sp, #20]
 800b552:	9307      	str	r3, [sp, #28]
 800b554:	4418      	add	r0, r3
 800b556:	ab04      	add	r3, sp, #16
 800b558:	9301      	str	r3, [sp, #4]
 800b55a:	2302      	movs	r3, #2
 800b55c:	9404      	str	r4, [sp, #16]
 800b55e:	9003      	str	r0, [sp, #12]
 800b560:	9302      	str	r3, [sp, #8]
 800b562:	b125      	cbz	r5, 800b56e <_puts_r+0x32>
 800b564:	69ab      	ldr	r3, [r5, #24]
 800b566:	b913      	cbnz	r3, 800b56e <_puts_r+0x32>
 800b568:	4628      	mov	r0, r5
 800b56a:	f000 f8b9 	bl	800b6e0 <__sinit>
 800b56e:	69ab      	ldr	r3, [r5, #24]
 800b570:	68ac      	ldr	r4, [r5, #8]
 800b572:	b913      	cbnz	r3, 800b57a <_puts_r+0x3e>
 800b574:	4628      	mov	r0, r5
 800b576:	f000 f8b3 	bl	800b6e0 <__sinit>
 800b57a:	4b13      	ldr	r3, [pc, #76]	; (800b5c8 <_puts_r+0x8c>)
 800b57c:	429c      	cmp	r4, r3
 800b57e:	d101      	bne.n	800b584 <_puts_r+0x48>
 800b580:	686c      	ldr	r4, [r5, #4]
 800b582:	e008      	b.n	800b596 <_puts_r+0x5a>
 800b584:	4b11      	ldr	r3, [pc, #68]	; (800b5cc <_puts_r+0x90>)
 800b586:	429c      	cmp	r4, r3
 800b588:	d101      	bne.n	800b58e <_puts_r+0x52>
 800b58a:	68ac      	ldr	r4, [r5, #8]
 800b58c:	e003      	b.n	800b596 <_puts_r+0x5a>
 800b58e:	4b10      	ldr	r3, [pc, #64]	; (800b5d0 <_puts_r+0x94>)
 800b590:	429c      	cmp	r4, r3
 800b592:	bf08      	it	eq
 800b594:	68ec      	ldreq	r4, [r5, #12]
 800b596:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800b59a:	049a      	lsls	r2, r3, #18
 800b59c:	d406      	bmi.n	800b5ac <_puts_r+0x70>
 800b59e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800b5a0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800b5a4:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800b5a8:	81a3      	strh	r3, [r4, #12]
 800b5aa:	6662      	str	r2, [r4, #100]	; 0x64
 800b5ac:	aa01      	add	r2, sp, #4
 800b5ae:	4621      	mov	r1, r4
 800b5b0:	4628      	mov	r0, r5
 800b5b2:	f000 fa1b 	bl	800b9ec <__sfvwrite_r>
 800b5b6:	2800      	cmp	r0, #0
 800b5b8:	bf14      	ite	ne
 800b5ba:	f04f 30ff 	movne.w	r0, #4294967295
 800b5be:	200a      	moveq	r0, #10
 800b5c0:	b009      	add	sp, #36	; 0x24
 800b5c2:	bd30      	pop	{r4, r5, pc}
 800b5c4:	08019844 	.word	0x08019844
 800b5c8:	08019848 	.word	0x08019848
 800b5cc:	08019868 	.word	0x08019868
 800b5d0:	08019888 	.word	0x08019888

0800b5d4 <puts>:
 800b5d4:	4b02      	ldr	r3, [pc, #8]	; (800b5e0 <puts+0xc>)
 800b5d6:	4601      	mov	r1, r0
 800b5d8:	6818      	ldr	r0, [r3, #0]
 800b5da:	f7ff bfaf 	b.w	800b53c <_puts_r>
 800b5de:	bf00      	nop
 800b5e0:	2000013c 	.word	0x2000013c

0800b5e4 <strchr>:
 800b5e4:	b2c9      	uxtb	r1, r1
 800b5e6:	4603      	mov	r3, r0
 800b5e8:	f810 2b01 	ldrb.w	r2, [r0], #1
 800b5ec:	b11a      	cbz	r2, 800b5f6 <strchr+0x12>
 800b5ee:	4291      	cmp	r1, r2
 800b5f0:	d1f9      	bne.n	800b5e6 <strchr+0x2>
 800b5f2:	4618      	mov	r0, r3
 800b5f4:	4770      	bx	lr
 800b5f6:	2900      	cmp	r1, #0
 800b5f8:	bf0c      	ite	eq
 800b5fa:	4618      	moveq	r0, r3
 800b5fc:	2000      	movne	r0, #0
 800b5fe:	4770      	bx	lr

0800b600 <strncmp>:
 800b600:	b530      	push	{r4, r5, lr}
 800b602:	b182      	cbz	r2, 800b626 <strncmp+0x26>
 800b604:	1e45      	subs	r5, r0, #1
 800b606:	3901      	subs	r1, #1
 800b608:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 800b60c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800b610:	42a3      	cmp	r3, r4
 800b612:	d106      	bne.n	800b622 <strncmp+0x22>
 800b614:	43ec      	mvns	r4, r5
 800b616:	4414      	add	r4, r2
 800b618:	42e0      	cmn	r0, r4
 800b61a:	d001      	beq.n	800b620 <strncmp+0x20>
 800b61c:	2b00      	cmp	r3, #0
 800b61e:	d1f3      	bne.n	800b608 <strncmp+0x8>
 800b620:	461c      	mov	r4, r3
 800b622:	1b18      	subs	r0, r3, r4
 800b624:	bd30      	pop	{r4, r5, pc}
 800b626:	4610      	mov	r0, r2
 800b628:	bd30      	pop	{r4, r5, pc}

0800b62a <strstr>:
 800b62a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b62c:	7803      	ldrb	r3, [r0, #0]
 800b62e:	b963      	cbnz	r3, 800b64a <strstr+0x20>
 800b630:	780b      	ldrb	r3, [r1, #0]
 800b632:	2b00      	cmp	r3, #0
 800b634:	bf18      	it	ne
 800b636:	2000      	movne	r0, #0
 800b638:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b63a:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 800b63e:	b162      	cbz	r2, 800b65a <strstr+0x30>
 800b640:	f814 7f01 	ldrb.w	r7, [r4, #1]!
 800b644:	4297      	cmp	r7, r2
 800b646:	4630      	mov	r0, r6
 800b648:	d0f7      	beq.n	800b63a <strstr+0x10>
 800b64a:	4603      	mov	r3, r0
 800b64c:	1c46      	adds	r6, r0, #1
 800b64e:	7800      	ldrb	r0, [r0, #0]
 800b650:	b110      	cbz	r0, 800b658 <strstr+0x2e>
 800b652:	1e4d      	subs	r5, r1, #1
 800b654:	1e5c      	subs	r4, r3, #1
 800b656:	e7f0      	b.n	800b63a <strstr+0x10>
 800b658:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b65a:	4618      	mov	r0, r3
 800b65c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800b660 <_cleanup_r>:
 800b660:	4901      	ldr	r1, [pc, #4]	; (800b668 <_cleanup_r+0x8>)
 800b662:	f000 bb0d 	b.w	800bc80 <_fwalk_reent>
 800b666:	bf00      	nop
 800b668:	0800c651 	.word	0x0800c651

0800b66c <std.isra.0>:
 800b66c:	2300      	movs	r3, #0
 800b66e:	b510      	push	{r4, lr}
 800b670:	4604      	mov	r4, r0
 800b672:	6003      	str	r3, [r0, #0]
 800b674:	6043      	str	r3, [r0, #4]
 800b676:	6083      	str	r3, [r0, #8]
 800b678:	8181      	strh	r1, [r0, #12]
 800b67a:	6643      	str	r3, [r0, #100]	; 0x64
 800b67c:	81c2      	strh	r2, [r0, #14]
 800b67e:	6103      	str	r3, [r0, #16]
 800b680:	6143      	str	r3, [r0, #20]
 800b682:	6183      	str	r3, [r0, #24]
 800b684:	4619      	mov	r1, r3
 800b686:	2208      	movs	r2, #8
 800b688:	305c      	adds	r0, #92	; 0x5c
 800b68a:	f7ff ff4f 	bl	800b52c <memset>
 800b68e:	4b05      	ldr	r3, [pc, #20]	; (800b6a4 <std.isra.0+0x38>)
 800b690:	6263      	str	r3, [r4, #36]	; 0x24
 800b692:	4b05      	ldr	r3, [pc, #20]	; (800b6a8 <std.isra.0+0x3c>)
 800b694:	62a3      	str	r3, [r4, #40]	; 0x28
 800b696:	4b05      	ldr	r3, [pc, #20]	; (800b6ac <std.isra.0+0x40>)
 800b698:	62e3      	str	r3, [r4, #44]	; 0x2c
 800b69a:	4b05      	ldr	r3, [pc, #20]	; (800b6b0 <std.isra.0+0x44>)
 800b69c:	6224      	str	r4, [r4, #32]
 800b69e:	6323      	str	r3, [r4, #48]	; 0x30
 800b6a0:	bd10      	pop	{r4, pc}
 800b6a2:	bf00      	nop
 800b6a4:	0800c4a9 	.word	0x0800c4a9
 800b6a8:	0800c4cb 	.word	0x0800c4cb
 800b6ac:	0800c503 	.word	0x0800c503
 800b6b0:	0800c527 	.word	0x0800c527

0800b6b4 <__sfmoreglue>:
 800b6b4:	b570      	push	{r4, r5, r6, lr}
 800b6b6:	2368      	movs	r3, #104	; 0x68
 800b6b8:	1e4d      	subs	r5, r1, #1
 800b6ba:	435d      	muls	r5, r3
 800b6bc:	460e      	mov	r6, r1
 800b6be:	f105 0174 	add.w	r1, r5, #116	; 0x74
 800b6c2:	f000 fafb 	bl	800bcbc <_malloc_r>
 800b6c6:	4604      	mov	r4, r0
 800b6c8:	b140      	cbz	r0, 800b6dc <__sfmoreglue+0x28>
 800b6ca:	2100      	movs	r1, #0
 800b6cc:	e880 0042 	stmia.w	r0, {r1, r6}
 800b6d0:	300c      	adds	r0, #12
 800b6d2:	60a0      	str	r0, [r4, #8]
 800b6d4:	f105 0268 	add.w	r2, r5, #104	; 0x68
 800b6d8:	f7ff ff28 	bl	800b52c <memset>
 800b6dc:	4620      	mov	r0, r4
 800b6de:	bd70      	pop	{r4, r5, r6, pc}

0800b6e0 <__sinit>:
 800b6e0:	6983      	ldr	r3, [r0, #24]
 800b6e2:	b510      	push	{r4, lr}
 800b6e4:	4604      	mov	r4, r0
 800b6e6:	bb4b      	cbnz	r3, 800b73c <__sinit+0x5c>
 800b6e8:	f8c0 30d8 	str.w	r3, [r0, #216]	; 0xd8
 800b6ec:	f8c0 30dc 	str.w	r3, [r0, #220]	; 0xdc
 800b6f0:	f8c0 30e0 	str.w	r3, [r0, #224]	; 0xe0
 800b6f4:	4b12      	ldr	r3, [pc, #72]	; (800b740 <__sinit+0x60>)
 800b6f6:	4a13      	ldr	r2, [pc, #76]	; (800b744 <__sinit+0x64>)
 800b6f8:	681b      	ldr	r3, [r3, #0]
 800b6fa:	6282      	str	r2, [r0, #40]	; 0x28
 800b6fc:	4298      	cmp	r0, r3
 800b6fe:	bf04      	itt	eq
 800b700:	2301      	moveq	r3, #1
 800b702:	6183      	streq	r3, [r0, #24]
 800b704:	f000 f820 	bl	800b748 <__sfp>
 800b708:	6060      	str	r0, [r4, #4]
 800b70a:	4620      	mov	r0, r4
 800b70c:	f000 f81c 	bl	800b748 <__sfp>
 800b710:	60a0      	str	r0, [r4, #8]
 800b712:	4620      	mov	r0, r4
 800b714:	f000 f818 	bl	800b748 <__sfp>
 800b718:	2200      	movs	r2, #0
 800b71a:	60e0      	str	r0, [r4, #12]
 800b71c:	2104      	movs	r1, #4
 800b71e:	6860      	ldr	r0, [r4, #4]
 800b720:	f7ff ffa4 	bl	800b66c <std.isra.0>
 800b724:	2201      	movs	r2, #1
 800b726:	2109      	movs	r1, #9
 800b728:	68a0      	ldr	r0, [r4, #8]
 800b72a:	f7ff ff9f 	bl	800b66c <std.isra.0>
 800b72e:	2202      	movs	r2, #2
 800b730:	2112      	movs	r1, #18
 800b732:	68e0      	ldr	r0, [r4, #12]
 800b734:	f7ff ff9a 	bl	800b66c <std.isra.0>
 800b738:	2301      	movs	r3, #1
 800b73a:	61a3      	str	r3, [r4, #24]
 800b73c:	bd10      	pop	{r4, pc}
 800b73e:	bf00      	nop
 800b740:	080198ac 	.word	0x080198ac
 800b744:	0800b661 	.word	0x0800b661

0800b748 <__sfp>:
 800b748:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b74a:	4b1c      	ldr	r3, [pc, #112]	; (800b7bc <__sfp+0x74>)
 800b74c:	681e      	ldr	r6, [r3, #0]
 800b74e:	69b3      	ldr	r3, [r6, #24]
 800b750:	4607      	mov	r7, r0
 800b752:	b913      	cbnz	r3, 800b75a <__sfp+0x12>
 800b754:	4630      	mov	r0, r6
 800b756:	f7ff ffc3 	bl	800b6e0 <__sinit>
 800b75a:	36d8      	adds	r6, #216	; 0xd8
 800b75c:	68b4      	ldr	r4, [r6, #8]
 800b75e:	6873      	ldr	r3, [r6, #4]
 800b760:	3b01      	subs	r3, #1
 800b762:	d404      	bmi.n	800b76e <__sfp+0x26>
 800b764:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 800b768:	b17d      	cbz	r5, 800b78a <__sfp+0x42>
 800b76a:	3468      	adds	r4, #104	; 0x68
 800b76c:	e7f8      	b.n	800b760 <__sfp+0x18>
 800b76e:	6833      	ldr	r3, [r6, #0]
 800b770:	b10b      	cbz	r3, 800b776 <__sfp+0x2e>
 800b772:	6836      	ldr	r6, [r6, #0]
 800b774:	e7f2      	b.n	800b75c <__sfp+0x14>
 800b776:	2104      	movs	r1, #4
 800b778:	4638      	mov	r0, r7
 800b77a:	f7ff ff9b 	bl	800b6b4 <__sfmoreglue>
 800b77e:	6030      	str	r0, [r6, #0]
 800b780:	2800      	cmp	r0, #0
 800b782:	d1f6      	bne.n	800b772 <__sfp+0x2a>
 800b784:	230c      	movs	r3, #12
 800b786:	603b      	str	r3, [r7, #0]
 800b788:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b78a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b78e:	81e3      	strh	r3, [r4, #14]
 800b790:	2301      	movs	r3, #1
 800b792:	81a3      	strh	r3, [r4, #12]
 800b794:	6665      	str	r5, [r4, #100]	; 0x64
 800b796:	6025      	str	r5, [r4, #0]
 800b798:	60a5      	str	r5, [r4, #8]
 800b79a:	6065      	str	r5, [r4, #4]
 800b79c:	6125      	str	r5, [r4, #16]
 800b79e:	6165      	str	r5, [r4, #20]
 800b7a0:	61a5      	str	r5, [r4, #24]
 800b7a2:	2208      	movs	r2, #8
 800b7a4:	4629      	mov	r1, r5
 800b7a6:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800b7aa:	f7ff febf 	bl	800b52c <memset>
 800b7ae:	6365      	str	r5, [r4, #52]	; 0x34
 800b7b0:	63a5      	str	r5, [r4, #56]	; 0x38
 800b7b2:	64a5      	str	r5, [r4, #72]	; 0x48
 800b7b4:	64e5      	str	r5, [r4, #76]	; 0x4c
 800b7b6:	4620      	mov	r0, r4
 800b7b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b7ba:	bf00      	nop
 800b7bc:	080198ac 	.word	0x080198ac

0800b7c0 <__sfp_lock_acquire>:
 800b7c0:	4770      	bx	lr

0800b7c2 <__sfp_lock_release>:
 800b7c2:	4770      	bx	lr

0800b7c4 <_malloc_trim_r>:
 800b7c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b7c8:	4f25      	ldr	r7, [pc, #148]	; (800b860 <_malloc_trim_r+0x9c>)
 800b7ca:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 800b86c <_malloc_trim_r+0xa8>
 800b7ce:	4689      	mov	r9, r1
 800b7d0:	4606      	mov	r6, r0
 800b7d2:	f000 fcae 	bl	800c132 <__malloc_lock>
 800b7d6:	68bb      	ldr	r3, [r7, #8]
 800b7d8:	685d      	ldr	r5, [r3, #4]
 800b7da:	f1a8 0411 	sub.w	r4, r8, #17
 800b7de:	f025 0503 	bic.w	r5, r5, #3
 800b7e2:	442c      	add	r4, r5
 800b7e4:	ebc9 0404 	rsb	r4, r9, r4
 800b7e8:	fbb4 f4f8 	udiv	r4, r4, r8
 800b7ec:	3c01      	subs	r4, #1
 800b7ee:	fb08 f404 	mul.w	r4, r8, r4
 800b7f2:	4544      	cmp	r4, r8
 800b7f4:	da05      	bge.n	800b802 <_malloc_trim_r+0x3e>
 800b7f6:	4630      	mov	r0, r6
 800b7f8:	f000 fc9c 	bl	800c134 <__malloc_unlock>
 800b7fc:	2000      	movs	r0, #0
 800b7fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b802:	2100      	movs	r1, #0
 800b804:	4630      	mov	r0, r6
 800b806:	f000 fe3f 	bl	800c488 <_sbrk_r>
 800b80a:	68bb      	ldr	r3, [r7, #8]
 800b80c:	442b      	add	r3, r5
 800b80e:	4298      	cmp	r0, r3
 800b810:	d1f1      	bne.n	800b7f6 <_malloc_trim_r+0x32>
 800b812:	4261      	negs	r1, r4
 800b814:	4630      	mov	r0, r6
 800b816:	f000 fe37 	bl	800c488 <_sbrk_r>
 800b81a:	3001      	adds	r0, #1
 800b81c:	d110      	bne.n	800b840 <_malloc_trim_r+0x7c>
 800b81e:	2100      	movs	r1, #0
 800b820:	4630      	mov	r0, r6
 800b822:	f000 fe31 	bl	800c488 <_sbrk_r>
 800b826:	68ba      	ldr	r2, [r7, #8]
 800b828:	1a83      	subs	r3, r0, r2
 800b82a:	2b0f      	cmp	r3, #15
 800b82c:	dde3      	ble.n	800b7f6 <_malloc_trim_r+0x32>
 800b82e:	490d      	ldr	r1, [pc, #52]	; (800b864 <_malloc_trim_r+0xa0>)
 800b830:	6809      	ldr	r1, [r1, #0]
 800b832:	1a40      	subs	r0, r0, r1
 800b834:	490c      	ldr	r1, [pc, #48]	; (800b868 <_malloc_trim_r+0xa4>)
 800b836:	f043 0301 	orr.w	r3, r3, #1
 800b83a:	6008      	str	r0, [r1, #0]
 800b83c:	6053      	str	r3, [r2, #4]
 800b83e:	e7da      	b.n	800b7f6 <_malloc_trim_r+0x32>
 800b840:	68bb      	ldr	r3, [r7, #8]
 800b842:	4a09      	ldr	r2, [pc, #36]	; (800b868 <_malloc_trim_r+0xa4>)
 800b844:	1b2d      	subs	r5, r5, r4
 800b846:	f045 0501 	orr.w	r5, r5, #1
 800b84a:	605d      	str	r5, [r3, #4]
 800b84c:	6813      	ldr	r3, [r2, #0]
 800b84e:	4630      	mov	r0, r6
 800b850:	1b1c      	subs	r4, r3, r4
 800b852:	6014      	str	r4, [r2, #0]
 800b854:	f000 fc6e 	bl	800c134 <__malloc_unlock>
 800b858:	2001      	movs	r0, #1
 800b85a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b85e:	bf00      	nop
 800b860:	20000140 	.word	0x20000140
 800b864:	2000054c 	.word	0x2000054c
 800b868:	20002ebc 	.word	0x20002ebc
 800b86c:	00000080 	.word	0x00000080

0800b870 <_free_r>:
 800b870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b874:	4604      	mov	r4, r0
 800b876:	4688      	mov	r8, r1
 800b878:	2900      	cmp	r1, #0
 800b87a:	f000 80ad 	beq.w	800b9d8 <_free_r+0x168>
 800b87e:	f000 fc58 	bl	800c132 <__malloc_lock>
 800b882:	f858 2c04 	ldr.w	r2, [r8, #-4]
 800b886:	4d55      	ldr	r5, [pc, #340]	; (800b9dc <_free_r+0x16c>)
 800b888:	f022 0001 	bic.w	r0, r2, #1
 800b88c:	f1a8 0308 	sub.w	r3, r8, #8
 800b890:	181f      	adds	r7, r3, r0
 800b892:	68a9      	ldr	r1, [r5, #8]
 800b894:	687e      	ldr	r6, [r7, #4]
 800b896:	428f      	cmp	r7, r1
 800b898:	f026 0603 	bic.w	r6, r6, #3
 800b89c:	f002 0201 	and.w	r2, r2, #1
 800b8a0:	d11b      	bne.n	800b8da <_free_r+0x6a>
 800b8a2:	4430      	add	r0, r6
 800b8a4:	b93a      	cbnz	r2, 800b8b6 <_free_r+0x46>
 800b8a6:	f858 2c08 	ldr.w	r2, [r8, #-8]
 800b8aa:	1a9b      	subs	r3, r3, r2
 800b8ac:	4410      	add	r0, r2
 800b8ae:	6899      	ldr	r1, [r3, #8]
 800b8b0:	68da      	ldr	r2, [r3, #12]
 800b8b2:	60ca      	str	r2, [r1, #12]
 800b8b4:	6091      	str	r1, [r2, #8]
 800b8b6:	f040 0201 	orr.w	r2, r0, #1
 800b8ba:	605a      	str	r2, [r3, #4]
 800b8bc:	60ab      	str	r3, [r5, #8]
 800b8be:	4b48      	ldr	r3, [pc, #288]	; (800b9e0 <_free_r+0x170>)
 800b8c0:	681b      	ldr	r3, [r3, #0]
 800b8c2:	4298      	cmp	r0, r3
 800b8c4:	d304      	bcc.n	800b8d0 <_free_r+0x60>
 800b8c6:	4b47      	ldr	r3, [pc, #284]	; (800b9e4 <_free_r+0x174>)
 800b8c8:	4620      	mov	r0, r4
 800b8ca:	6819      	ldr	r1, [r3, #0]
 800b8cc:	f7ff ff7a 	bl	800b7c4 <_malloc_trim_r>
 800b8d0:	4620      	mov	r0, r4
 800b8d2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800b8d6:	f000 bc2d 	b.w	800c134 <__malloc_unlock>
 800b8da:	607e      	str	r6, [r7, #4]
 800b8dc:	b97a      	cbnz	r2, 800b8fe <_free_r+0x8e>
 800b8de:	f858 1c08 	ldr.w	r1, [r8, #-8]
 800b8e2:	1a5b      	subs	r3, r3, r1
 800b8e4:	4408      	add	r0, r1
 800b8e6:	6899      	ldr	r1, [r3, #8]
 800b8e8:	f105 0e08 	add.w	lr, r5, #8
 800b8ec:	4571      	cmp	r1, lr
 800b8ee:	d008      	beq.n	800b902 <_free_r+0x92>
 800b8f0:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 800b8f4:	f8c1 e00c 	str.w	lr, [r1, #12]
 800b8f8:	f8ce 1008 	str.w	r1, [lr, #8]
 800b8fc:	e002      	b.n	800b904 <_free_r+0x94>
 800b8fe:	2200      	movs	r2, #0
 800b900:	e000      	b.n	800b904 <_free_r+0x94>
 800b902:	2201      	movs	r2, #1
 800b904:	19b9      	adds	r1, r7, r6
 800b906:	6849      	ldr	r1, [r1, #4]
 800b908:	07c9      	lsls	r1, r1, #31
 800b90a:	d40e      	bmi.n	800b92a <_free_r+0xba>
 800b90c:	4430      	add	r0, r6
 800b90e:	68b9      	ldr	r1, [r7, #8]
 800b910:	b942      	cbnz	r2, 800b924 <_free_r+0xb4>
 800b912:	4e35      	ldr	r6, [pc, #212]	; (800b9e8 <_free_r+0x178>)
 800b914:	42b1      	cmp	r1, r6
 800b916:	d105      	bne.n	800b924 <_free_r+0xb4>
 800b918:	616b      	str	r3, [r5, #20]
 800b91a:	612b      	str	r3, [r5, #16]
 800b91c:	2201      	movs	r2, #1
 800b91e:	60d9      	str	r1, [r3, #12]
 800b920:	6099      	str	r1, [r3, #8]
 800b922:	e002      	b.n	800b92a <_free_r+0xba>
 800b924:	68fe      	ldr	r6, [r7, #12]
 800b926:	60ce      	str	r6, [r1, #12]
 800b928:	60b1      	str	r1, [r6, #8]
 800b92a:	f040 0101 	orr.w	r1, r0, #1
 800b92e:	6059      	str	r1, [r3, #4]
 800b930:	5018      	str	r0, [r3, r0]
 800b932:	2a00      	cmp	r2, #0
 800b934:	d1cc      	bne.n	800b8d0 <_free_r+0x60>
 800b936:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800b93a:	d212      	bcs.n	800b962 <_free_r+0xf2>
 800b93c:	08c0      	lsrs	r0, r0, #3
 800b93e:	1081      	asrs	r1, r0, #2
 800b940:	2201      	movs	r2, #1
 800b942:	fa02 f101 	lsl.w	r1, r2, r1
 800b946:	686a      	ldr	r2, [r5, #4]
 800b948:	3001      	adds	r0, #1
 800b94a:	430a      	orrs	r2, r1
 800b94c:	606a      	str	r2, [r5, #4]
 800b94e:	eb05 02c0 	add.w	r2, r5, r0, lsl #3
 800b952:	f855 1030 	ldr.w	r1, [r5, r0, lsl #3]
 800b956:	6099      	str	r1, [r3, #8]
 800b958:	3a08      	subs	r2, #8
 800b95a:	60da      	str	r2, [r3, #12]
 800b95c:	f845 3030 	str.w	r3, [r5, r0, lsl #3]
 800b960:	e038      	b.n	800b9d4 <_free_r+0x164>
 800b962:	0a42      	lsrs	r2, r0, #9
 800b964:	2a04      	cmp	r2, #4
 800b966:	d802      	bhi.n	800b96e <_free_r+0xfe>
 800b968:	0982      	lsrs	r2, r0, #6
 800b96a:	3238      	adds	r2, #56	; 0x38
 800b96c:	e015      	b.n	800b99a <_free_r+0x12a>
 800b96e:	2a14      	cmp	r2, #20
 800b970:	d801      	bhi.n	800b976 <_free_r+0x106>
 800b972:	325b      	adds	r2, #91	; 0x5b
 800b974:	e011      	b.n	800b99a <_free_r+0x12a>
 800b976:	2a54      	cmp	r2, #84	; 0x54
 800b978:	d802      	bhi.n	800b980 <_free_r+0x110>
 800b97a:	0b02      	lsrs	r2, r0, #12
 800b97c:	326e      	adds	r2, #110	; 0x6e
 800b97e:	e00c      	b.n	800b99a <_free_r+0x12a>
 800b980:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 800b984:	d802      	bhi.n	800b98c <_free_r+0x11c>
 800b986:	0bc2      	lsrs	r2, r0, #15
 800b988:	3277      	adds	r2, #119	; 0x77
 800b98a:	e006      	b.n	800b99a <_free_r+0x12a>
 800b98c:	f240 5154 	movw	r1, #1364	; 0x554
 800b990:	428a      	cmp	r2, r1
 800b992:	bf9a      	itte	ls
 800b994:	0c82      	lsrls	r2, r0, #18
 800b996:	327c      	addls	r2, #124	; 0x7c
 800b998:	227e      	movhi	r2, #126	; 0x7e
 800b99a:	1c51      	adds	r1, r2, #1
 800b99c:	eb05 06c2 	add.w	r6, r5, r2, lsl #3
 800b9a0:	f855 1031 	ldr.w	r1, [r5, r1, lsl #3]
 800b9a4:	4f0d      	ldr	r7, [pc, #52]	; (800b9dc <_free_r+0x16c>)
 800b9a6:	428e      	cmp	r6, r1
 800b9a8:	d10b      	bne.n	800b9c2 <_free_r+0x152>
 800b9aa:	2101      	movs	r1, #1
 800b9ac:	1092      	asrs	r2, r2, #2
 800b9ae:	fa01 f202 	lsl.w	r2, r1, r2
 800b9b2:	6879      	ldr	r1, [r7, #4]
 800b9b4:	4311      	orrs	r1, r2
 800b9b6:	6079      	str	r1, [r7, #4]
 800b9b8:	4631      	mov	r1, r6
 800b9ba:	e008      	b.n	800b9ce <_free_r+0x15e>
 800b9bc:	6889      	ldr	r1, [r1, #8]
 800b9be:	428e      	cmp	r6, r1
 800b9c0:	d004      	beq.n	800b9cc <_free_r+0x15c>
 800b9c2:	684a      	ldr	r2, [r1, #4]
 800b9c4:	f022 0203 	bic.w	r2, r2, #3
 800b9c8:	4290      	cmp	r0, r2
 800b9ca:	d3f7      	bcc.n	800b9bc <_free_r+0x14c>
 800b9cc:	68ce      	ldr	r6, [r1, #12]
 800b9ce:	60de      	str	r6, [r3, #12]
 800b9d0:	6099      	str	r1, [r3, #8]
 800b9d2:	60b3      	str	r3, [r6, #8]
 800b9d4:	60cb      	str	r3, [r1, #12]
 800b9d6:	e77b      	b.n	800b8d0 <_free_r+0x60>
 800b9d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b9dc:	20000140 	.word	0x20000140
 800b9e0:	20000548 	.word	0x20000548
 800b9e4:	20002eb8 	.word	0x20002eb8
 800b9e8:	20000148 	.word	0x20000148

0800b9ec <__sfvwrite_r>:
 800b9ec:	6893      	ldr	r3, [r2, #8]
 800b9ee:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b9f2:	4606      	mov	r6, r0
 800b9f4:	460c      	mov	r4, r1
 800b9f6:	4690      	mov	r8, r2
 800b9f8:	b90b      	cbnz	r3, 800b9fe <__sfvwrite_r+0x12>
 800b9fa:	2000      	movs	r0, #0
 800b9fc:	e13b      	b.n	800bc76 <__sfvwrite_r+0x28a>
 800b9fe:	898b      	ldrh	r3, [r1, #12]
 800ba00:	0718      	lsls	r0, r3, #28
 800ba02:	d50f      	bpl.n	800ba24 <__sfvwrite_r+0x38>
 800ba04:	690b      	ldr	r3, [r1, #16]
 800ba06:	b16b      	cbz	r3, 800ba24 <__sfvwrite_r+0x38>
 800ba08:	f8b4 900c 	ldrh.w	r9, [r4, #12]
 800ba0c:	f8d8 b000 	ldr.w	fp, [r8]
 800ba10:	f009 0502 	and.w	r5, r9, #2
 800ba14:	b2ad      	uxth	r5, r5
 800ba16:	b355      	cbz	r5, 800ba6e <__sfvwrite_r+0x82>
 800ba18:	f04f 0900 	mov.w	r9, #0
 800ba1c:	464f      	mov	r7, r9
 800ba1e:	f8df a25c 	ldr.w	sl, [pc, #604]	; 800bc7c <__sfvwrite_r+0x290>
 800ba22:	e01b      	b.n	800ba5c <__sfvwrite_r+0x70>
 800ba24:	4621      	mov	r1, r4
 800ba26:	4630      	mov	r0, r6
 800ba28:	f000 fd94 	bl	800c554 <__swsetup_r>
 800ba2c:	2800      	cmp	r0, #0
 800ba2e:	d0eb      	beq.n	800ba08 <__sfvwrite_r+0x1c>
 800ba30:	e11f      	b.n	800bc72 <__sfvwrite_r+0x286>
 800ba32:	4557      	cmp	r7, sl
 800ba34:	463b      	mov	r3, r7
 800ba36:	464a      	mov	r2, r9
 800ba38:	bf28      	it	cs
 800ba3a:	4653      	movcs	r3, sl
 800ba3c:	6a21      	ldr	r1, [r4, #32]
 800ba3e:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800ba40:	4630      	mov	r0, r6
 800ba42:	47a8      	blx	r5
 800ba44:	2800      	cmp	r0, #0
 800ba46:	f340 8110 	ble.w	800bc6a <__sfvwrite_r+0x27e>
 800ba4a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800ba4e:	4481      	add	r9, r0
 800ba50:	1a3f      	subs	r7, r7, r0
 800ba52:	1a18      	subs	r0, r3, r0
 800ba54:	f8c8 0008 	str.w	r0, [r8, #8]
 800ba58:	2800      	cmp	r0, #0
 800ba5a:	d0ce      	beq.n	800b9fa <__sfvwrite_r+0xe>
 800ba5c:	2f00      	cmp	r7, #0
 800ba5e:	d1e8      	bne.n	800ba32 <__sfvwrite_r+0x46>
 800ba60:	f8db 9000 	ldr.w	r9, [fp]
 800ba64:	f8db 7004 	ldr.w	r7, [fp, #4]
 800ba68:	f10b 0b08 	add.w	fp, fp, #8
 800ba6c:	e7f6      	b.n	800ba5c <__sfvwrite_r+0x70>
 800ba6e:	f019 0901 	ands.w	r9, r9, #1
 800ba72:	d003      	beq.n	800ba7c <__sfvwrite_r+0x90>
 800ba74:	9500      	str	r5, [sp, #0]
 800ba76:	46a9      	mov	r9, r5
 800ba78:	46aa      	mov	sl, r5
 800ba7a:	e0bd      	b.n	800bbf8 <__sfvwrite_r+0x20c>
 800ba7c:	464f      	mov	r7, r9
 800ba7e:	b937      	cbnz	r7, 800ba8e <__sfvwrite_r+0xa2>
 800ba80:	f8db 9000 	ldr.w	r9, [fp]
 800ba84:	f8db 7004 	ldr.w	r7, [fp, #4]
 800ba88:	f10b 0b08 	add.w	fp, fp, #8
 800ba8c:	e7f7      	b.n	800ba7e <__sfvwrite_r+0x92>
 800ba8e:	89a2      	ldrh	r2, [r4, #12]
 800ba90:	68a5      	ldr	r5, [r4, #8]
 800ba92:	0591      	lsls	r1, r2, #22
 800ba94:	d552      	bpl.n	800bb3c <__sfvwrite_r+0x150>
 800ba96:	42af      	cmp	r7, r5
 800ba98:	d342      	bcc.n	800bb20 <__sfvwrite_r+0x134>
 800ba9a:	f412 6f90 	tst.w	r2, #1152	; 0x480
 800ba9e:	d03d      	beq.n	800bb1c <__sfvwrite_r+0x130>
 800baa0:	6921      	ldr	r1, [r4, #16]
 800baa2:	6823      	ldr	r3, [r4, #0]
 800baa4:	1a5b      	subs	r3, r3, r1
 800baa6:	9300      	str	r3, [sp, #0]
 800baa8:	6963      	ldr	r3, [r4, #20]
 800baaa:	2002      	movs	r0, #2
 800baac:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800bab0:	fb93 faf0 	sdiv	sl, r3, r0
 800bab4:	9b00      	ldr	r3, [sp, #0]
 800bab6:	3301      	adds	r3, #1
 800bab8:	443b      	add	r3, r7
 800baba:	459a      	cmp	sl, r3
 800babc:	bf38      	it	cc
 800babe:	469a      	movcc	sl, r3
 800bac0:	0553      	lsls	r3, r2, #21
 800bac2:	d510      	bpl.n	800bae6 <__sfvwrite_r+0xfa>
 800bac4:	4651      	mov	r1, sl
 800bac6:	4630      	mov	r0, r6
 800bac8:	f000 f8f8 	bl	800bcbc <_malloc_r>
 800bacc:	4605      	mov	r5, r0
 800bace:	b1c0      	cbz	r0, 800bb02 <__sfvwrite_r+0x116>
 800bad0:	9a00      	ldr	r2, [sp, #0]
 800bad2:	6921      	ldr	r1, [r4, #16]
 800bad4:	f7ff fd1f 	bl	800b516 <memcpy>
 800bad8:	89a3      	ldrh	r3, [r4, #12]
 800bada:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800bade:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800bae2:	81a3      	strh	r3, [r4, #12]
 800bae4:	e010      	b.n	800bb08 <__sfvwrite_r+0x11c>
 800bae6:	4652      	mov	r2, sl
 800bae8:	4630      	mov	r0, r6
 800baea:	f000 fb25 	bl	800c138 <_realloc_r>
 800baee:	4605      	mov	r5, r0
 800baf0:	b950      	cbnz	r0, 800bb08 <__sfvwrite_r+0x11c>
 800baf2:	6921      	ldr	r1, [r4, #16]
 800baf4:	4630      	mov	r0, r6
 800baf6:	f7ff febb 	bl	800b870 <_free_r>
 800bafa:	89a3      	ldrh	r3, [r4, #12]
 800bafc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800bb00:	81a3      	strh	r3, [r4, #12]
 800bb02:	230c      	movs	r3, #12
 800bb04:	6033      	str	r3, [r6, #0]
 800bb06:	e0b0      	b.n	800bc6a <__sfvwrite_r+0x27e>
 800bb08:	9b00      	ldr	r3, [sp, #0]
 800bb0a:	6125      	str	r5, [r4, #16]
 800bb0c:	441d      	add	r5, r3
 800bb0e:	ebc3 030a 	rsb	r3, r3, sl
 800bb12:	6025      	str	r5, [r4, #0]
 800bb14:	f8c4 a014 	str.w	sl, [r4, #20]
 800bb18:	463d      	mov	r5, r7
 800bb1a:	60a3      	str	r3, [r4, #8]
 800bb1c:	42af      	cmp	r7, r5
 800bb1e:	d200      	bcs.n	800bb22 <__sfvwrite_r+0x136>
 800bb20:	463d      	mov	r5, r7
 800bb22:	462a      	mov	r2, r5
 800bb24:	4649      	mov	r1, r9
 800bb26:	6820      	ldr	r0, [r4, #0]
 800bb28:	f000 fae8 	bl	800c0fc <memmove>
 800bb2c:	68a3      	ldr	r3, [r4, #8]
 800bb2e:	1b5b      	subs	r3, r3, r5
 800bb30:	60a3      	str	r3, [r4, #8]
 800bb32:	6823      	ldr	r3, [r4, #0]
 800bb34:	441d      	add	r5, r3
 800bb36:	6025      	str	r5, [r4, #0]
 800bb38:	463d      	mov	r5, r7
 800bb3a:	e029      	b.n	800bb90 <__sfvwrite_r+0x1a4>
 800bb3c:	6820      	ldr	r0, [r4, #0]
 800bb3e:	6923      	ldr	r3, [r4, #16]
 800bb40:	4298      	cmp	r0, r3
 800bb42:	d802      	bhi.n	800bb4a <__sfvwrite_r+0x15e>
 800bb44:	6962      	ldr	r2, [r4, #20]
 800bb46:	4297      	cmp	r7, r2
 800bb48:	d213      	bcs.n	800bb72 <__sfvwrite_r+0x186>
 800bb4a:	42bd      	cmp	r5, r7
 800bb4c:	bf28      	it	cs
 800bb4e:	463d      	movcs	r5, r7
 800bb50:	462a      	mov	r2, r5
 800bb52:	4649      	mov	r1, r9
 800bb54:	f000 fad2 	bl	800c0fc <memmove>
 800bb58:	68a3      	ldr	r3, [r4, #8]
 800bb5a:	6822      	ldr	r2, [r4, #0]
 800bb5c:	1b5b      	subs	r3, r3, r5
 800bb5e:	442a      	add	r2, r5
 800bb60:	60a3      	str	r3, [r4, #8]
 800bb62:	6022      	str	r2, [r4, #0]
 800bb64:	b9a3      	cbnz	r3, 800bb90 <__sfvwrite_r+0x1a4>
 800bb66:	4621      	mov	r1, r4
 800bb68:	4630      	mov	r0, r6
 800bb6a:	f000 fe53 	bl	800c814 <_fflush_r>
 800bb6e:	b178      	cbz	r0, 800bb90 <__sfvwrite_r+0x1a4>
 800bb70:	e07b      	b.n	800bc6a <__sfvwrite_r+0x27e>
 800bb72:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 800bb76:	42bb      	cmp	r3, r7
 800bb78:	bf28      	it	cs
 800bb7a:	463b      	movcs	r3, r7
 800bb7c:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800bb7e:	fb93 f3f2 	sdiv	r3, r3, r2
 800bb82:	6a21      	ldr	r1, [r4, #32]
 800bb84:	4353      	muls	r3, r2
 800bb86:	4630      	mov	r0, r6
 800bb88:	464a      	mov	r2, r9
 800bb8a:	47a8      	blx	r5
 800bb8c:	1e05      	subs	r5, r0, #0
 800bb8e:	dd6c      	ble.n	800bc6a <__sfvwrite_r+0x27e>
 800bb90:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800bb94:	44a9      	add	r9, r5
 800bb96:	1b7f      	subs	r7, r7, r5
 800bb98:	1b5d      	subs	r5, r3, r5
 800bb9a:	f8c8 5008 	str.w	r5, [r8, #8]
 800bb9e:	2d00      	cmp	r5, #0
 800bba0:	f47f af6d 	bne.w	800ba7e <__sfvwrite_r+0x92>
 800bba4:	e729      	b.n	800b9fa <__sfvwrite_r+0xe>
 800bba6:	9b00      	ldr	r3, [sp, #0]
 800bba8:	b383      	cbz	r3, 800bc0c <__sfvwrite_r+0x220>
 800bbaa:	6820      	ldr	r0, [r4, #0]
 800bbac:	6921      	ldr	r1, [r4, #16]
 800bbae:	6962      	ldr	r2, [r4, #20]
 800bbb0:	4555      	cmp	r5, sl
 800bbb2:	462b      	mov	r3, r5
 800bbb4:	bf28      	it	cs
 800bbb6:	4653      	movcs	r3, sl
 800bbb8:	4288      	cmp	r0, r1
 800bbba:	d936      	bls.n	800bc2a <__sfvwrite_r+0x23e>
 800bbbc:	68a7      	ldr	r7, [r4, #8]
 800bbbe:	4417      	add	r7, r2
 800bbc0:	42bb      	cmp	r3, r7
 800bbc2:	dd32      	ble.n	800bc2a <__sfvwrite_r+0x23e>
 800bbc4:	4649      	mov	r1, r9
 800bbc6:	463a      	mov	r2, r7
 800bbc8:	f000 fa98 	bl	800c0fc <memmove>
 800bbcc:	6823      	ldr	r3, [r4, #0]
 800bbce:	443b      	add	r3, r7
 800bbd0:	6023      	str	r3, [r4, #0]
 800bbd2:	4621      	mov	r1, r4
 800bbd4:	4630      	mov	r0, r6
 800bbd6:	f000 fe1d 	bl	800c814 <_fflush_r>
 800bbda:	2800      	cmp	r0, #0
 800bbdc:	d145      	bne.n	800bc6a <__sfvwrite_r+0x27e>
 800bbde:	1bed      	subs	r5, r5, r7
 800bbe0:	d03c      	beq.n	800bc5c <__sfvwrite_r+0x270>
 800bbe2:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800bbe6:	44b9      	add	r9, r7
 800bbe8:	ebc7 0a0a 	rsb	sl, r7, sl
 800bbec:	1bdf      	subs	r7, r3, r7
 800bbee:	f8c8 7008 	str.w	r7, [r8, #8]
 800bbf2:	2f00      	cmp	r7, #0
 800bbf4:	f43f af01 	beq.w	800b9fa <__sfvwrite_r+0xe>
 800bbf8:	f1ba 0f00 	cmp.w	sl, #0
 800bbfc:	d1d3      	bne.n	800bba6 <__sfvwrite_r+0x1ba>
 800bbfe:	2300      	movs	r3, #0
 800bc00:	e89b 0600 	ldmia.w	fp, {r9, sl}
 800bc04:	9300      	str	r3, [sp, #0]
 800bc06:	f10b 0b08 	add.w	fp, fp, #8
 800bc0a:	e7f5      	b.n	800bbf8 <__sfvwrite_r+0x20c>
 800bc0c:	4652      	mov	r2, sl
 800bc0e:	210a      	movs	r1, #10
 800bc10:	4648      	mov	r0, r9
 800bc12:	f7f4 fafd 	bl	8000210 <memchr>
 800bc16:	b118      	cbz	r0, 800bc20 <__sfvwrite_r+0x234>
 800bc18:	3001      	adds	r0, #1
 800bc1a:	ebc9 0500 	rsb	r5, r9, r0
 800bc1e:	e001      	b.n	800bc24 <__sfvwrite_r+0x238>
 800bc20:	f10a 0501 	add.w	r5, sl, #1
 800bc24:	2301      	movs	r3, #1
 800bc26:	9300      	str	r3, [sp, #0]
 800bc28:	e7bf      	b.n	800bbaa <__sfvwrite_r+0x1be>
 800bc2a:	4293      	cmp	r3, r2
 800bc2c:	db08      	blt.n	800bc40 <__sfvwrite_r+0x254>
 800bc2e:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 800bc30:	6a21      	ldr	r1, [r4, #32]
 800bc32:	4613      	mov	r3, r2
 800bc34:	4630      	mov	r0, r6
 800bc36:	464a      	mov	r2, r9
 800bc38:	47b8      	blx	r7
 800bc3a:	1e07      	subs	r7, r0, #0
 800bc3c:	dccf      	bgt.n	800bbde <__sfvwrite_r+0x1f2>
 800bc3e:	e014      	b.n	800bc6a <__sfvwrite_r+0x27e>
 800bc40:	461a      	mov	r2, r3
 800bc42:	4649      	mov	r1, r9
 800bc44:	9301      	str	r3, [sp, #4]
 800bc46:	f000 fa59 	bl	800c0fc <memmove>
 800bc4a:	9b01      	ldr	r3, [sp, #4]
 800bc4c:	68a2      	ldr	r2, [r4, #8]
 800bc4e:	1ad2      	subs	r2, r2, r3
 800bc50:	60a2      	str	r2, [r4, #8]
 800bc52:	6822      	ldr	r2, [r4, #0]
 800bc54:	441a      	add	r2, r3
 800bc56:	6022      	str	r2, [r4, #0]
 800bc58:	461f      	mov	r7, r3
 800bc5a:	e7c0      	b.n	800bbde <__sfvwrite_r+0x1f2>
 800bc5c:	4621      	mov	r1, r4
 800bc5e:	4630      	mov	r0, r6
 800bc60:	f000 fdd8 	bl	800c814 <_fflush_r>
 800bc64:	b908      	cbnz	r0, 800bc6a <__sfvwrite_r+0x27e>
 800bc66:	9500      	str	r5, [sp, #0]
 800bc68:	e7bb      	b.n	800bbe2 <__sfvwrite_r+0x1f6>
 800bc6a:	89a3      	ldrh	r3, [r4, #12]
 800bc6c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800bc70:	81a3      	strh	r3, [r4, #12]
 800bc72:	f04f 30ff 	mov.w	r0, #4294967295
 800bc76:	b003      	add	sp, #12
 800bc78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bc7c:	7ffffc00 	.word	0x7ffffc00

0800bc80 <_fwalk_reent>:
 800bc80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800bc84:	4680      	mov	r8, r0
 800bc86:	4689      	mov	r9, r1
 800bc88:	f100 04d8 	add.w	r4, r0, #216	; 0xd8
 800bc8c:	2600      	movs	r6, #0
 800bc8e:	b194      	cbz	r4, 800bcb6 <_fwalk_reent+0x36>
 800bc90:	68a5      	ldr	r5, [r4, #8]
 800bc92:	6867      	ldr	r7, [r4, #4]
 800bc94:	3f01      	subs	r7, #1
 800bc96:	d40c      	bmi.n	800bcb2 <_fwalk_reent+0x32>
 800bc98:	89ab      	ldrh	r3, [r5, #12]
 800bc9a:	2b01      	cmp	r3, #1
 800bc9c:	d907      	bls.n	800bcae <_fwalk_reent+0x2e>
 800bc9e:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800bca2:	3301      	adds	r3, #1
 800bca4:	d003      	beq.n	800bcae <_fwalk_reent+0x2e>
 800bca6:	4629      	mov	r1, r5
 800bca8:	4640      	mov	r0, r8
 800bcaa:	47c8      	blx	r9
 800bcac:	4306      	orrs	r6, r0
 800bcae:	3568      	adds	r5, #104	; 0x68
 800bcb0:	e7f0      	b.n	800bc94 <_fwalk_reent+0x14>
 800bcb2:	6824      	ldr	r4, [r4, #0]
 800bcb4:	e7eb      	b.n	800bc8e <_fwalk_reent+0xe>
 800bcb6:	4630      	mov	r0, r6
 800bcb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800bcbc <_malloc_r>:
 800bcbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bcc0:	f101 040b 	add.w	r4, r1, #11
 800bcc4:	2c16      	cmp	r4, #22
 800bcc6:	b085      	sub	sp, #20
 800bcc8:	4681      	mov	r9, r0
 800bcca:	d903      	bls.n	800bcd4 <_malloc_r+0x18>
 800bccc:	f034 0407 	bics.w	r4, r4, #7
 800bcd0:	d501      	bpl.n	800bcd6 <_malloc_r+0x1a>
 800bcd2:	e002      	b.n	800bcda <_malloc_r+0x1e>
 800bcd4:	2410      	movs	r4, #16
 800bcd6:	428c      	cmp	r4, r1
 800bcd8:	d203      	bcs.n	800bce2 <_malloc_r+0x26>
 800bcda:	230c      	movs	r3, #12
 800bcdc:	f8c9 3000 	str.w	r3, [r9]
 800bce0:	e1ea      	b.n	800c0b8 <_malloc_r+0x3fc>
 800bce2:	4648      	mov	r0, r9
 800bce4:	f000 fa25 	bl	800c132 <__malloc_lock>
 800bce8:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 800bcec:	4d9e      	ldr	r5, [pc, #632]	; (800bf68 <_malloc_r+0x2ac>)
 800bcee:	d217      	bcs.n	800bd20 <_malloc_r+0x64>
 800bcf0:	f104 0208 	add.w	r2, r4, #8
 800bcf4:	442a      	add	r2, r5
 800bcf6:	f1a2 0108 	sub.w	r1, r2, #8
 800bcfa:	6856      	ldr	r6, [r2, #4]
 800bcfc:	428e      	cmp	r6, r1
 800bcfe:	ea4f 03d4 	mov.w	r3, r4, lsr #3
 800bd02:	d102      	bne.n	800bd0a <_malloc_r+0x4e>
 800bd04:	68d6      	ldr	r6, [r2, #12]
 800bd06:	42b2      	cmp	r2, r6
 800bd08:	d008      	beq.n	800bd1c <_malloc_r+0x60>
 800bd0a:	6873      	ldr	r3, [r6, #4]
 800bd0c:	68f2      	ldr	r2, [r6, #12]
 800bd0e:	68b1      	ldr	r1, [r6, #8]
 800bd10:	f023 0303 	bic.w	r3, r3, #3
 800bd14:	60ca      	str	r2, [r1, #12]
 800bd16:	4433      	add	r3, r6
 800bd18:	6091      	str	r1, [r2, #8]
 800bd1a:	e02f      	b.n	800bd7c <_malloc_r+0xc0>
 800bd1c:	3302      	adds	r3, #2
 800bd1e:	e03d      	b.n	800bd9c <_malloc_r+0xe0>
 800bd20:	0a63      	lsrs	r3, r4, #9
 800bd22:	d01a      	beq.n	800bd5a <_malloc_r+0x9e>
 800bd24:	2b04      	cmp	r3, #4
 800bd26:	d802      	bhi.n	800bd2e <_malloc_r+0x72>
 800bd28:	09a3      	lsrs	r3, r4, #6
 800bd2a:	3338      	adds	r3, #56	; 0x38
 800bd2c:	e018      	b.n	800bd60 <_malloc_r+0xa4>
 800bd2e:	2b14      	cmp	r3, #20
 800bd30:	d801      	bhi.n	800bd36 <_malloc_r+0x7a>
 800bd32:	335b      	adds	r3, #91	; 0x5b
 800bd34:	e014      	b.n	800bd60 <_malloc_r+0xa4>
 800bd36:	2b54      	cmp	r3, #84	; 0x54
 800bd38:	d802      	bhi.n	800bd40 <_malloc_r+0x84>
 800bd3a:	0b23      	lsrs	r3, r4, #12
 800bd3c:	336e      	adds	r3, #110	; 0x6e
 800bd3e:	e00f      	b.n	800bd60 <_malloc_r+0xa4>
 800bd40:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 800bd44:	d802      	bhi.n	800bd4c <_malloc_r+0x90>
 800bd46:	0be3      	lsrs	r3, r4, #15
 800bd48:	3377      	adds	r3, #119	; 0x77
 800bd4a:	e009      	b.n	800bd60 <_malloc_r+0xa4>
 800bd4c:	f240 5254 	movw	r2, #1364	; 0x554
 800bd50:	4293      	cmp	r3, r2
 800bd52:	d804      	bhi.n	800bd5e <_malloc_r+0xa2>
 800bd54:	0ca3      	lsrs	r3, r4, #18
 800bd56:	337c      	adds	r3, #124	; 0x7c
 800bd58:	e002      	b.n	800bd60 <_malloc_r+0xa4>
 800bd5a:	233f      	movs	r3, #63	; 0x3f
 800bd5c:	e000      	b.n	800bd60 <_malloc_r+0xa4>
 800bd5e:	237e      	movs	r3, #126	; 0x7e
 800bd60:	1c5a      	adds	r2, r3, #1
 800bd62:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 800bd66:	f1a2 0008 	sub.w	r0, r2, #8
 800bd6a:	6856      	ldr	r6, [r2, #4]
 800bd6c:	e00c      	b.n	800bd88 <_malloc_r+0xcc>
 800bd6e:	2900      	cmp	r1, #0
 800bd70:	68f1      	ldr	r1, [r6, #12]
 800bd72:	db08      	blt.n	800bd86 <_malloc_r+0xca>
 800bd74:	68b3      	ldr	r3, [r6, #8]
 800bd76:	60d9      	str	r1, [r3, #12]
 800bd78:	608b      	str	r3, [r1, #8]
 800bd7a:	18b3      	adds	r3, r6, r2
 800bd7c:	685a      	ldr	r2, [r3, #4]
 800bd7e:	f042 0201 	orr.w	r2, r2, #1
 800bd82:	605a      	str	r2, [r3, #4]
 800bd84:	e1a3      	b.n	800c0ce <_malloc_r+0x412>
 800bd86:	460e      	mov	r6, r1
 800bd88:	4286      	cmp	r6, r0
 800bd8a:	d006      	beq.n	800bd9a <_malloc_r+0xde>
 800bd8c:	6872      	ldr	r2, [r6, #4]
 800bd8e:	f022 0203 	bic.w	r2, r2, #3
 800bd92:	1b11      	subs	r1, r2, r4
 800bd94:	290f      	cmp	r1, #15
 800bd96:	ddea      	ble.n	800bd6e <_malloc_r+0xb2>
 800bd98:	3b01      	subs	r3, #1
 800bd9a:	3301      	adds	r3, #1
 800bd9c:	4a72      	ldr	r2, [pc, #456]	; (800bf68 <_malloc_r+0x2ac>)
 800bd9e:	692e      	ldr	r6, [r5, #16]
 800bda0:	f102 0708 	add.w	r7, r2, #8
 800bda4:	42be      	cmp	r6, r7
 800bda6:	4639      	mov	r1, r7
 800bda8:	d079      	beq.n	800be9e <_malloc_r+0x1e2>
 800bdaa:	6870      	ldr	r0, [r6, #4]
 800bdac:	f020 0003 	bic.w	r0, r0, #3
 800bdb0:	ebc4 0e00 	rsb	lr, r4, r0
 800bdb4:	f1be 0f0f 	cmp.w	lr, #15
 800bdb8:	dd0d      	ble.n	800bdd6 <_malloc_r+0x11a>
 800bdba:	1933      	adds	r3, r6, r4
 800bdbc:	f044 0401 	orr.w	r4, r4, #1
 800bdc0:	6074      	str	r4, [r6, #4]
 800bdc2:	6153      	str	r3, [r2, #20]
 800bdc4:	6113      	str	r3, [r2, #16]
 800bdc6:	f04e 0201 	orr.w	r2, lr, #1
 800bdca:	60df      	str	r7, [r3, #12]
 800bdcc:	609f      	str	r7, [r3, #8]
 800bdce:	605a      	str	r2, [r3, #4]
 800bdd0:	f843 e00e 	str.w	lr, [r3, lr]
 800bdd4:	e17b      	b.n	800c0ce <_malloc_r+0x412>
 800bdd6:	f1be 0f00 	cmp.w	lr, #0
 800bdda:	6157      	str	r7, [r2, #20]
 800bddc:	6117      	str	r7, [r2, #16]
 800bdde:	db05      	blt.n	800bdec <_malloc_r+0x130>
 800bde0:	4430      	add	r0, r6
 800bde2:	6843      	ldr	r3, [r0, #4]
 800bde4:	f043 0301 	orr.w	r3, r3, #1
 800bde8:	6043      	str	r3, [r0, #4]
 800bdea:	e170      	b.n	800c0ce <_malloc_r+0x412>
 800bdec:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800bdf0:	d215      	bcs.n	800be1e <_malloc_r+0x162>
 800bdf2:	08c0      	lsrs	r0, r0, #3
 800bdf4:	ea4f 0ea0 	mov.w	lr, r0, asr #2
 800bdf8:	2701      	movs	r7, #1
 800bdfa:	fa07 fe0e 	lsl.w	lr, r7, lr
 800bdfe:	6857      	ldr	r7, [r2, #4]
 800be00:	3001      	adds	r0, #1
 800be02:	ea4e 0707 	orr.w	r7, lr, r7
 800be06:	6057      	str	r7, [r2, #4]
 800be08:	eb02 07c0 	add.w	r7, r2, r0, lsl #3
 800be0c:	f852 e030 	ldr.w	lr, [r2, r0, lsl #3]
 800be10:	f8c6 e008 	str.w	lr, [r6, #8]
 800be14:	3f08      	subs	r7, #8
 800be16:	60f7      	str	r7, [r6, #12]
 800be18:	f842 6030 	str.w	r6, [r2, r0, lsl #3]
 800be1c:	e03d      	b.n	800be9a <_malloc_r+0x1de>
 800be1e:	0a42      	lsrs	r2, r0, #9
 800be20:	2a04      	cmp	r2, #4
 800be22:	d802      	bhi.n	800be2a <_malloc_r+0x16e>
 800be24:	0982      	lsrs	r2, r0, #6
 800be26:	3238      	adds	r2, #56	; 0x38
 800be28:	e015      	b.n	800be56 <_malloc_r+0x19a>
 800be2a:	2a14      	cmp	r2, #20
 800be2c:	d801      	bhi.n	800be32 <_malloc_r+0x176>
 800be2e:	325b      	adds	r2, #91	; 0x5b
 800be30:	e011      	b.n	800be56 <_malloc_r+0x19a>
 800be32:	2a54      	cmp	r2, #84	; 0x54
 800be34:	d802      	bhi.n	800be3c <_malloc_r+0x180>
 800be36:	0b02      	lsrs	r2, r0, #12
 800be38:	326e      	adds	r2, #110	; 0x6e
 800be3a:	e00c      	b.n	800be56 <_malloc_r+0x19a>
 800be3c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 800be40:	d802      	bhi.n	800be48 <_malloc_r+0x18c>
 800be42:	0bc2      	lsrs	r2, r0, #15
 800be44:	3277      	adds	r2, #119	; 0x77
 800be46:	e006      	b.n	800be56 <_malloc_r+0x19a>
 800be48:	f240 5754 	movw	r7, #1364	; 0x554
 800be4c:	42ba      	cmp	r2, r7
 800be4e:	bf9a      	itte	ls
 800be50:	0c82      	lsrls	r2, r0, #18
 800be52:	327c      	addls	r2, #124	; 0x7c
 800be54:	227e      	movhi	r2, #126	; 0x7e
 800be56:	1c57      	adds	r7, r2, #1
 800be58:	eb05 0ec2 	add.w	lr, r5, r2, lsl #3
 800be5c:	f855 7037 	ldr.w	r7, [r5, r7, lsl #3]
 800be60:	f8df c104 	ldr.w	ip, [pc, #260]	; 800bf68 <_malloc_r+0x2ac>
 800be64:	45be      	cmp	lr, r7
 800be66:	d10d      	bne.n	800be84 <_malloc_r+0x1c8>
 800be68:	2001      	movs	r0, #1
 800be6a:	1092      	asrs	r2, r2, #2
 800be6c:	fa00 f202 	lsl.w	r2, r0, r2
 800be70:	f8dc 0004 	ldr.w	r0, [ip, #4]
 800be74:	4310      	orrs	r0, r2
 800be76:	f8cc 0004 	str.w	r0, [ip, #4]
 800be7a:	4672      	mov	r2, lr
 800be7c:	e009      	b.n	800be92 <_malloc_r+0x1d6>
 800be7e:	68bf      	ldr	r7, [r7, #8]
 800be80:	45be      	cmp	lr, r7
 800be82:	d004      	beq.n	800be8e <_malloc_r+0x1d2>
 800be84:	687a      	ldr	r2, [r7, #4]
 800be86:	f022 0203 	bic.w	r2, r2, #3
 800be8a:	4290      	cmp	r0, r2
 800be8c:	d3f7      	bcc.n	800be7e <_malloc_r+0x1c2>
 800be8e:	68fa      	ldr	r2, [r7, #12]
 800be90:	46be      	mov	lr, r7
 800be92:	60f2      	str	r2, [r6, #12]
 800be94:	f8c6 e008 	str.w	lr, [r6, #8]
 800be98:	6096      	str	r6, [r2, #8]
 800be9a:	f8ce 600c 	str.w	r6, [lr, #12]
 800be9e:	2001      	movs	r0, #1
 800bea0:	109a      	asrs	r2, r3, #2
 800bea2:	fa00 f202 	lsl.w	r2, r0, r2
 800bea6:	6868      	ldr	r0, [r5, #4]
 800bea8:	4282      	cmp	r2, r0
 800beaa:	d85f      	bhi.n	800bf6c <_malloc_r+0x2b0>
 800beac:	4202      	tst	r2, r0
 800beae:	d106      	bne.n	800bebe <_malloc_r+0x202>
 800beb0:	f023 0303 	bic.w	r3, r3, #3
 800beb4:	0052      	lsls	r2, r2, #1
 800beb6:	4202      	tst	r2, r0
 800beb8:	f103 0304 	add.w	r3, r3, #4
 800bebc:	d0fa      	beq.n	800beb4 <_malloc_r+0x1f8>
 800bebe:	eb05 08c3 	add.w	r8, r5, r3, lsl #3
 800bec2:	46c2      	mov	sl, r8
 800bec4:	469c      	mov	ip, r3
 800bec6:	f8da 600c 	ldr.w	r6, [sl, #12]
 800beca:	4556      	cmp	r6, sl
 800becc:	d02c      	beq.n	800bf28 <_malloc_r+0x26c>
 800bece:	6870      	ldr	r0, [r6, #4]
 800bed0:	68f7      	ldr	r7, [r6, #12]
 800bed2:	f020 0003 	bic.w	r0, r0, #3
 800bed6:	ebc4 0e00 	rsb	lr, r4, r0
 800beda:	f1be 0f0f 	cmp.w	lr, #15
 800bede:	dd11      	ble.n	800bf04 <_malloc_r+0x248>
 800bee0:	1933      	adds	r3, r6, r4
 800bee2:	f044 0401 	orr.w	r4, r4, #1
 800bee6:	6074      	str	r4, [r6, #4]
 800bee8:	f856 2f08 	ldr.w	r2, [r6, #8]!
 800beec:	60d7      	str	r7, [r2, #12]
 800beee:	60ba      	str	r2, [r7, #8]
 800bef0:	f04e 0201 	orr.w	r2, lr, #1
 800bef4:	616b      	str	r3, [r5, #20]
 800bef6:	612b      	str	r3, [r5, #16]
 800bef8:	60d9      	str	r1, [r3, #12]
 800befa:	6099      	str	r1, [r3, #8]
 800befc:	605a      	str	r2, [r3, #4]
 800befe:	f843 e00e 	str.w	lr, [r3, lr]
 800bf02:	e00b      	b.n	800bf1c <_malloc_r+0x260>
 800bf04:	f1be 0f00 	cmp.w	lr, #0
 800bf08:	db0c      	blt.n	800bf24 <_malloc_r+0x268>
 800bf0a:	1833      	adds	r3, r6, r0
 800bf0c:	685a      	ldr	r2, [r3, #4]
 800bf0e:	f042 0201 	orr.w	r2, r2, #1
 800bf12:	605a      	str	r2, [r3, #4]
 800bf14:	f856 3f08 	ldr.w	r3, [r6, #8]!
 800bf18:	60df      	str	r7, [r3, #12]
 800bf1a:	60bb      	str	r3, [r7, #8]
 800bf1c:	4648      	mov	r0, r9
 800bf1e:	f000 f909 	bl	800c134 <__malloc_unlock>
 800bf22:	e0d8      	b.n	800c0d6 <_malloc_r+0x41a>
 800bf24:	463e      	mov	r6, r7
 800bf26:	e7d0      	b.n	800beca <_malloc_r+0x20e>
 800bf28:	f10c 0c01 	add.w	ip, ip, #1
 800bf2c:	f01c 0f03 	tst.w	ip, #3
 800bf30:	f10a 0a08 	add.w	sl, sl, #8
 800bf34:	d1c7      	bne.n	800bec6 <_malloc_r+0x20a>
 800bf36:	0798      	lsls	r0, r3, #30
 800bf38:	d104      	bne.n	800bf44 <_malloc_r+0x288>
 800bf3a:	686b      	ldr	r3, [r5, #4]
 800bf3c:	ea23 0302 	bic.w	r3, r3, r2
 800bf40:	606b      	str	r3, [r5, #4]
 800bf42:	e005      	b.n	800bf50 <_malloc_r+0x294>
 800bf44:	f858 0908 	ldr.w	r0, [r8], #-8
 800bf48:	4580      	cmp	r8, r0
 800bf4a:	f103 33ff 	add.w	r3, r3, #4294967295
 800bf4e:	d0f2      	beq.n	800bf36 <_malloc_r+0x27a>
 800bf50:	6868      	ldr	r0, [r5, #4]
 800bf52:	0052      	lsls	r2, r2, #1
 800bf54:	4282      	cmp	r2, r0
 800bf56:	d809      	bhi.n	800bf6c <_malloc_r+0x2b0>
 800bf58:	b142      	cbz	r2, 800bf6c <_malloc_r+0x2b0>
 800bf5a:	4663      	mov	r3, ip
 800bf5c:	4202      	tst	r2, r0
 800bf5e:	d1ae      	bne.n	800bebe <_malloc_r+0x202>
 800bf60:	3304      	adds	r3, #4
 800bf62:	0052      	lsls	r2, r2, #1
 800bf64:	e7fa      	b.n	800bf5c <_malloc_r+0x2a0>
 800bf66:	bf00      	nop
 800bf68:	20000140 	.word	0x20000140
 800bf6c:	f8d5 b008 	ldr.w	fp, [r5, #8]
 800bf70:	f8db 6004 	ldr.w	r6, [fp, #4]
 800bf74:	f026 0603 	bic.w	r6, r6, #3
 800bf78:	42b4      	cmp	r4, r6
 800bf7a:	d803      	bhi.n	800bf84 <_malloc_r+0x2c8>
 800bf7c:	1b33      	subs	r3, r6, r4
 800bf7e:	2b0f      	cmp	r3, #15
 800bf80:	f300 809c 	bgt.w	800c0bc <_malloc_r+0x400>
 800bf84:	4a56      	ldr	r2, [pc, #344]	; (800c0e0 <_malloc_r+0x424>)
 800bf86:	4957      	ldr	r1, [pc, #348]	; (800c0e4 <_malloc_r+0x428>)
 800bf88:	6812      	ldr	r2, [r2, #0]
 800bf8a:	6808      	ldr	r0, [r1, #0]
 800bf8c:	9101      	str	r1, [sp, #4]
 800bf8e:	f102 0810 	add.w	r8, r2, #16
 800bf92:	4a55      	ldr	r2, [pc, #340]	; (800c0e8 <_malloc_r+0x42c>)
 800bf94:	9203      	str	r2, [sp, #12]
 800bf96:	3001      	adds	r0, #1
 800bf98:	bf18      	it	ne
 800bf9a:	f102 31ff 	addne.w	r1, r2, #4294967295
 800bf9e:	44a0      	add	r8, r4
 800bfa0:	bf1e      	ittt	ne
 800bfa2:	4488      	addne	r8, r1
 800bfa4:	4251      	negne	r1, r2
 800bfa6:	ea01 0808 	andne.w	r8, r1, r8
 800bfaa:	eb0b 0306 	add.w	r3, fp, r6
 800bfae:	4641      	mov	r1, r8
 800bfb0:	4648      	mov	r0, r9
 800bfb2:	9302      	str	r3, [sp, #8]
 800bfb4:	f000 fa68 	bl	800c488 <_sbrk_r>
 800bfb8:	1c42      	adds	r2, r0, #1
 800bfba:	4607      	mov	r7, r0
 800bfbc:	d06f      	beq.n	800c09e <_malloc_r+0x3e2>
 800bfbe:	9b02      	ldr	r3, [sp, #8]
 800bfc0:	9a03      	ldr	r2, [sp, #12]
 800bfc2:	4283      	cmp	r3, r0
 800bfc4:	d901      	bls.n	800bfca <_malloc_r+0x30e>
 800bfc6:	45ab      	cmp	fp, r5
 800bfc8:	d169      	bne.n	800c09e <_malloc_r+0x3e2>
 800bfca:	f8df a128 	ldr.w	sl, [pc, #296]	; 800c0f4 <_malloc_r+0x438>
 800bfce:	f8df c128 	ldr.w	ip, [pc, #296]	; 800c0f8 <_malloc_r+0x43c>
 800bfd2:	f8da 0000 	ldr.w	r0, [sl]
 800bfd6:	42bb      	cmp	r3, r7
 800bfd8:	4440      	add	r0, r8
 800bfda:	f8ca 0000 	str.w	r0, [sl]
 800bfde:	d108      	bne.n	800bff2 <_malloc_r+0x336>
 800bfe0:	ea13 0f0c 	tst.w	r3, ip
 800bfe4:	d105      	bne.n	800bff2 <_malloc_r+0x336>
 800bfe6:	68ab      	ldr	r3, [r5, #8]
 800bfe8:	4446      	add	r6, r8
 800bfea:	f046 0601 	orr.w	r6, r6, #1
 800bfee:	605e      	str	r6, [r3, #4]
 800bff0:	e049      	b.n	800c086 <_malloc_r+0x3ca>
 800bff2:	9901      	ldr	r1, [sp, #4]
 800bff4:	f8d1 e000 	ldr.w	lr, [r1]
 800bff8:	f1be 3fff 	cmp.w	lr, #4294967295
 800bffc:	bf15      	itete	ne
 800bffe:	1afb      	subne	r3, r7, r3
 800c000:	4b38      	ldreq	r3, [pc, #224]	; (800c0e4 <_malloc_r+0x428>)
 800c002:	181b      	addne	r3, r3, r0
 800c004:	601f      	streq	r7, [r3, #0]
 800c006:	bf18      	it	ne
 800c008:	f8ca 3000 	strne.w	r3, [sl]
 800c00c:	f017 0307 	ands.w	r3, r7, #7
 800c010:	bf1c      	itt	ne
 800c012:	f1c3 0308 	rsbne	r3, r3, #8
 800c016:	18ff      	addne	r7, r7, r3
 800c018:	44b8      	add	r8, r7
 800c01a:	441a      	add	r2, r3
 800c01c:	ea08 080c 	and.w	r8, r8, ip
 800c020:	ebc8 0802 	rsb	r8, r8, r2
 800c024:	4641      	mov	r1, r8
 800c026:	4648      	mov	r0, r9
 800c028:	f000 fa2e 	bl	800c488 <_sbrk_r>
 800c02c:	1c43      	adds	r3, r0, #1
 800c02e:	bf04      	itt	eq
 800c030:	4638      	moveq	r0, r7
 800c032:	f04f 0800 	moveq.w	r8, #0
 800c036:	f8da 3000 	ldr.w	r3, [sl]
 800c03a:	60af      	str	r7, [r5, #8]
 800c03c:	1bc2      	subs	r2, r0, r7
 800c03e:	4442      	add	r2, r8
 800c040:	4443      	add	r3, r8
 800c042:	f042 0201 	orr.w	r2, r2, #1
 800c046:	45ab      	cmp	fp, r5
 800c048:	f8ca 3000 	str.w	r3, [sl]
 800c04c:	607a      	str	r2, [r7, #4]
 800c04e:	d01a      	beq.n	800c086 <_malloc_r+0x3ca>
 800c050:	2e0f      	cmp	r6, #15
 800c052:	d802      	bhi.n	800c05a <_malloc_r+0x39e>
 800c054:	2301      	movs	r3, #1
 800c056:	607b      	str	r3, [r7, #4]
 800c058:	e021      	b.n	800c09e <_malloc_r+0x3e2>
 800c05a:	f8db 3004 	ldr.w	r3, [fp, #4]
 800c05e:	3e0c      	subs	r6, #12
 800c060:	f026 0607 	bic.w	r6, r6, #7
 800c064:	f003 0301 	and.w	r3, r3, #1
 800c068:	4333      	orrs	r3, r6
 800c06a:	f8cb 3004 	str.w	r3, [fp, #4]
 800c06e:	eb0b 0306 	add.w	r3, fp, r6
 800c072:	2205      	movs	r2, #5
 800c074:	2e0f      	cmp	r6, #15
 800c076:	605a      	str	r2, [r3, #4]
 800c078:	609a      	str	r2, [r3, #8]
 800c07a:	d904      	bls.n	800c086 <_malloc_r+0x3ca>
 800c07c:	f10b 0108 	add.w	r1, fp, #8
 800c080:	4648      	mov	r0, r9
 800c082:	f7ff fbf5 	bl	800b870 <_free_r>
 800c086:	4a19      	ldr	r2, [pc, #100]	; (800c0ec <_malloc_r+0x430>)
 800c088:	f8da 3000 	ldr.w	r3, [sl]
 800c08c:	6811      	ldr	r1, [r2, #0]
 800c08e:	428b      	cmp	r3, r1
 800c090:	bf88      	it	hi
 800c092:	6013      	strhi	r3, [r2, #0]
 800c094:	4a16      	ldr	r2, [pc, #88]	; (800c0f0 <_malloc_r+0x434>)
 800c096:	6811      	ldr	r1, [r2, #0]
 800c098:	428b      	cmp	r3, r1
 800c09a:	bf88      	it	hi
 800c09c:	6013      	strhi	r3, [r2, #0]
 800c09e:	68ab      	ldr	r3, [r5, #8]
 800c0a0:	685a      	ldr	r2, [r3, #4]
 800c0a2:	f022 0203 	bic.w	r2, r2, #3
 800c0a6:	4294      	cmp	r4, r2
 800c0a8:	eba2 0304 	sub.w	r3, r2, r4
 800c0ac:	d801      	bhi.n	800c0b2 <_malloc_r+0x3f6>
 800c0ae:	2b0f      	cmp	r3, #15
 800c0b0:	dc04      	bgt.n	800c0bc <_malloc_r+0x400>
 800c0b2:	4648      	mov	r0, r9
 800c0b4:	f000 f83e 	bl	800c134 <__malloc_unlock>
 800c0b8:	2600      	movs	r6, #0
 800c0ba:	e00c      	b.n	800c0d6 <_malloc_r+0x41a>
 800c0bc:	68ae      	ldr	r6, [r5, #8]
 800c0be:	f044 0201 	orr.w	r2, r4, #1
 800c0c2:	4434      	add	r4, r6
 800c0c4:	f043 0301 	orr.w	r3, r3, #1
 800c0c8:	6072      	str	r2, [r6, #4]
 800c0ca:	60ac      	str	r4, [r5, #8]
 800c0cc:	6063      	str	r3, [r4, #4]
 800c0ce:	4648      	mov	r0, r9
 800c0d0:	f000 f830 	bl	800c134 <__malloc_unlock>
 800c0d4:	3608      	adds	r6, #8
 800c0d6:	4630      	mov	r0, r6
 800c0d8:	b005      	add	sp, #20
 800c0da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c0de:	bf00      	nop
 800c0e0:	20002eb8 	.word	0x20002eb8
 800c0e4:	2000054c 	.word	0x2000054c
 800c0e8:	00000080 	.word	0x00000080
 800c0ec:	20002eb4 	.word	0x20002eb4
 800c0f0:	20002eb0 	.word	0x20002eb0
 800c0f4:	20002ebc 	.word	0x20002ebc
 800c0f8:	0000007f 	.word	0x0000007f

0800c0fc <memmove>:
 800c0fc:	4288      	cmp	r0, r1
 800c0fe:	b510      	push	{r4, lr}
 800c100:	eb01 0302 	add.w	r3, r1, r2
 800c104:	d801      	bhi.n	800c10a <memmove+0xe>
 800c106:	1e42      	subs	r2, r0, #1
 800c108:	e00b      	b.n	800c122 <memmove+0x26>
 800c10a:	4298      	cmp	r0, r3
 800c10c:	d2fb      	bcs.n	800c106 <memmove+0xa>
 800c10e:	1881      	adds	r1, r0, r2
 800c110:	1ad2      	subs	r2, r2, r3
 800c112:	42d3      	cmn	r3, r2
 800c114:	d004      	beq.n	800c120 <memmove+0x24>
 800c116:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800c11a:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800c11e:	e7f8      	b.n	800c112 <memmove+0x16>
 800c120:	bd10      	pop	{r4, pc}
 800c122:	4299      	cmp	r1, r3
 800c124:	d004      	beq.n	800c130 <memmove+0x34>
 800c126:	f811 4b01 	ldrb.w	r4, [r1], #1
 800c12a:	f802 4f01 	strb.w	r4, [r2, #1]!
 800c12e:	e7f8      	b.n	800c122 <memmove+0x26>
 800c130:	bd10      	pop	{r4, pc}

0800c132 <__malloc_lock>:
 800c132:	4770      	bx	lr

0800c134 <__malloc_unlock>:
 800c134:	4770      	bx	lr
	...

0800c138 <_realloc_r>:
 800c138:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c13c:	4681      	mov	r9, r0
 800c13e:	460c      	mov	r4, r1
 800c140:	b929      	cbnz	r1, 800c14e <_realloc_r+0x16>
 800c142:	4611      	mov	r1, r2
 800c144:	b003      	add	sp, #12
 800c146:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c14a:	f7ff bdb7 	b.w	800bcbc <_malloc_r>
 800c14e:	9201      	str	r2, [sp, #4]
 800c150:	f7ff ffef 	bl	800c132 <__malloc_lock>
 800c154:	9a01      	ldr	r2, [sp, #4]
 800c156:	f854 ec04 	ldr.w	lr, [r4, #-4]
 800c15a:	f102 080b 	add.w	r8, r2, #11
 800c15e:	f1b8 0f16 	cmp.w	r8, #22
 800c162:	f1a4 0b08 	sub.w	fp, r4, #8
 800c166:	f02e 0503 	bic.w	r5, lr, #3
 800c16a:	d903      	bls.n	800c174 <_realloc_r+0x3c>
 800c16c:	f038 0807 	bics.w	r8, r8, #7
 800c170:	d502      	bpl.n	800c178 <_realloc_r+0x40>
 800c172:	e003      	b.n	800c17c <_realloc_r+0x44>
 800c174:	f04f 0810 	mov.w	r8, #16
 800c178:	4590      	cmp	r8, r2
 800c17a:	d204      	bcs.n	800c186 <_realloc_r+0x4e>
 800c17c:	230c      	movs	r3, #12
 800c17e:	f8c9 3000 	str.w	r3, [r9]
 800c182:	2000      	movs	r0, #0
 800c184:	e17d      	b.n	800c482 <_realloc_r+0x34a>
 800c186:	45a8      	cmp	r8, r5
 800c188:	f340 8150 	ble.w	800c42c <_realloc_r+0x2f4>
 800c18c:	4ba6      	ldr	r3, [pc, #664]	; (800c428 <_realloc_r+0x2f0>)
 800c18e:	6898      	ldr	r0, [r3, #8]
 800c190:	eb0b 0105 	add.w	r1, fp, r5
 800c194:	4281      	cmp	r1, r0
 800c196:	684f      	ldr	r7, [r1, #4]
 800c198:	d005      	beq.n	800c1a6 <_realloc_r+0x6e>
 800c19a:	f027 0601 	bic.w	r6, r7, #1
 800c19e:	440e      	add	r6, r1
 800c1a0:	6876      	ldr	r6, [r6, #4]
 800c1a2:	07f6      	lsls	r6, r6, #31
 800c1a4:	d426      	bmi.n	800c1f4 <_realloc_r+0xbc>
 800c1a6:	f027 0a03 	bic.w	sl, r7, #3
 800c1aa:	4281      	cmp	r1, r0
 800c1ac:	eb05 070a 	add.w	r7, r5, sl
 800c1b0:	d118      	bne.n	800c1e4 <_realloc_r+0xac>
 800c1b2:	f108 0610 	add.w	r6, r8, #16
 800c1b6:	42b7      	cmp	r7, r6
 800c1b8:	db1f      	blt.n	800c1fa <_realloc_r+0xc2>
 800c1ba:	eb0b 0008 	add.w	r0, fp, r8
 800c1be:	ebc8 0707 	rsb	r7, r8, r7
 800c1c2:	f047 0701 	orr.w	r7, r7, #1
 800c1c6:	6098      	str	r0, [r3, #8]
 800c1c8:	6047      	str	r7, [r0, #4]
 800c1ca:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800c1ce:	f003 0301 	and.w	r3, r3, #1
 800c1d2:	ea43 0308 	orr.w	r3, r3, r8
 800c1d6:	4648      	mov	r0, r9
 800c1d8:	f844 3c04 	str.w	r3, [r4, #-4]
 800c1dc:	f7ff ffaa 	bl	800c134 <__malloc_unlock>
 800c1e0:	4620      	mov	r0, r4
 800c1e2:	e14e      	b.n	800c482 <_realloc_r+0x34a>
 800c1e4:	45b8      	cmp	r8, r7
 800c1e6:	dc08      	bgt.n	800c1fa <_realloc_r+0xc2>
 800c1e8:	68cb      	ldr	r3, [r1, #12]
 800c1ea:	688a      	ldr	r2, [r1, #8]
 800c1ec:	463d      	mov	r5, r7
 800c1ee:	60d3      	str	r3, [r2, #12]
 800c1f0:	609a      	str	r2, [r3, #8]
 800c1f2:	e11b      	b.n	800c42c <_realloc_r+0x2f4>
 800c1f4:	f04f 0a00 	mov.w	sl, #0
 800c1f8:	4651      	mov	r1, sl
 800c1fa:	f01e 0f01 	tst.w	lr, #1
 800c1fe:	f040 80c3 	bne.w	800c388 <_realloc_r+0x250>
 800c202:	f854 7c08 	ldr.w	r7, [r4, #-8]
 800c206:	ebc7 070b 	rsb	r7, r7, fp
 800c20a:	687e      	ldr	r6, [r7, #4]
 800c20c:	f026 0603 	bic.w	r6, r6, #3
 800c210:	442e      	add	r6, r5
 800c212:	2900      	cmp	r1, #0
 800c214:	f000 8083 	beq.w	800c31e <_realloc_r+0x1e6>
 800c218:	4281      	cmp	r1, r0
 800c21a:	44b2      	add	sl, r6
 800c21c:	d147      	bne.n	800c2ae <_realloc_r+0x176>
 800c21e:	f108 0110 	add.w	r1, r8, #16
 800c222:	458a      	cmp	sl, r1
 800c224:	db7b      	blt.n	800c31e <_realloc_r+0x1e6>
 800c226:	463e      	mov	r6, r7
 800c228:	68fa      	ldr	r2, [r7, #12]
 800c22a:	f856 1f08 	ldr.w	r1, [r6, #8]!
 800c22e:	60ca      	str	r2, [r1, #12]
 800c230:	6091      	str	r1, [r2, #8]
 800c232:	1f2a      	subs	r2, r5, #4
 800c234:	2a24      	cmp	r2, #36	; 0x24
 800c236:	d825      	bhi.n	800c284 <_realloc_r+0x14c>
 800c238:	2a13      	cmp	r2, #19
 800c23a:	d91b      	bls.n	800c274 <_realloc_r+0x13c>
 800c23c:	6821      	ldr	r1, [r4, #0]
 800c23e:	60b9      	str	r1, [r7, #8]
 800c240:	6861      	ldr	r1, [r4, #4]
 800c242:	60f9      	str	r1, [r7, #12]
 800c244:	2a1b      	cmp	r2, #27
 800c246:	d803      	bhi.n	800c250 <_realloc_r+0x118>
 800c248:	f107 0210 	add.w	r2, r7, #16
 800c24c:	3408      	adds	r4, #8
 800c24e:	e012      	b.n	800c276 <_realloc_r+0x13e>
 800c250:	68a1      	ldr	r1, [r4, #8]
 800c252:	6139      	str	r1, [r7, #16]
 800c254:	68e1      	ldr	r1, [r4, #12]
 800c256:	6179      	str	r1, [r7, #20]
 800c258:	2a24      	cmp	r2, #36	; 0x24
 800c25a:	bf01      	itttt	eq
 800c25c:	6922      	ldreq	r2, [r4, #16]
 800c25e:	61ba      	streq	r2, [r7, #24]
 800c260:	6961      	ldreq	r1, [r4, #20]
 800c262:	61f9      	streq	r1, [r7, #28]
 800c264:	bf19      	ittee	ne
 800c266:	f107 0218 	addne.w	r2, r7, #24
 800c26a:	3410      	addne	r4, #16
 800c26c:	f107 0220 	addeq.w	r2, r7, #32
 800c270:	3418      	addeq	r4, #24
 800c272:	e000      	b.n	800c276 <_realloc_r+0x13e>
 800c274:	4632      	mov	r2, r6
 800c276:	6821      	ldr	r1, [r4, #0]
 800c278:	6011      	str	r1, [r2, #0]
 800c27a:	6861      	ldr	r1, [r4, #4]
 800c27c:	6051      	str	r1, [r2, #4]
 800c27e:	68a1      	ldr	r1, [r4, #8]
 800c280:	6091      	str	r1, [r2, #8]
 800c282:	e005      	b.n	800c290 <_realloc_r+0x158>
 800c284:	4621      	mov	r1, r4
 800c286:	4630      	mov	r0, r6
 800c288:	9301      	str	r3, [sp, #4]
 800c28a:	f7ff ff37 	bl	800c0fc <memmove>
 800c28e:	9b01      	ldr	r3, [sp, #4]
 800c290:	eb07 0208 	add.w	r2, r7, r8
 800c294:	ebc8 0a0a 	rsb	sl, r8, sl
 800c298:	609a      	str	r2, [r3, #8]
 800c29a:	f04a 0301 	orr.w	r3, sl, #1
 800c29e:	6053      	str	r3, [r2, #4]
 800c2a0:	687b      	ldr	r3, [r7, #4]
 800c2a2:	f003 0301 	and.w	r3, r3, #1
 800c2a6:	ea43 0308 	orr.w	r3, r3, r8
 800c2aa:	607b      	str	r3, [r7, #4]
 800c2ac:	e0b6      	b.n	800c41c <_realloc_r+0x2e4>
 800c2ae:	45d0      	cmp	r8, sl
 800c2b0:	dc35      	bgt.n	800c31e <_realloc_r+0x1e6>
 800c2b2:	68cb      	ldr	r3, [r1, #12]
 800c2b4:	688a      	ldr	r2, [r1, #8]
 800c2b6:	4638      	mov	r0, r7
 800c2b8:	60d3      	str	r3, [r2, #12]
 800c2ba:	609a      	str	r2, [r3, #8]
 800c2bc:	f850 2f08 	ldr.w	r2, [r0, #8]!
 800c2c0:	68fb      	ldr	r3, [r7, #12]
 800c2c2:	60d3      	str	r3, [r2, #12]
 800c2c4:	609a      	str	r2, [r3, #8]
 800c2c6:	1f2a      	subs	r2, r5, #4
 800c2c8:	2a24      	cmp	r2, #36	; 0x24
 800c2ca:	d823      	bhi.n	800c314 <_realloc_r+0x1dc>
 800c2cc:	2a13      	cmp	r2, #19
 800c2ce:	d91a      	bls.n	800c306 <_realloc_r+0x1ce>
 800c2d0:	6823      	ldr	r3, [r4, #0]
 800c2d2:	60bb      	str	r3, [r7, #8]
 800c2d4:	6863      	ldr	r3, [r4, #4]
 800c2d6:	60fb      	str	r3, [r7, #12]
 800c2d8:	2a1b      	cmp	r2, #27
 800c2da:	d803      	bhi.n	800c2e4 <_realloc_r+0x1ac>
 800c2dc:	f107 0010 	add.w	r0, r7, #16
 800c2e0:	3408      	adds	r4, #8
 800c2e2:	e010      	b.n	800c306 <_realloc_r+0x1ce>
 800c2e4:	68a3      	ldr	r3, [r4, #8]
 800c2e6:	613b      	str	r3, [r7, #16]
 800c2e8:	68e3      	ldr	r3, [r4, #12]
 800c2ea:	617b      	str	r3, [r7, #20]
 800c2ec:	2a24      	cmp	r2, #36	; 0x24
 800c2ee:	bf01      	itttt	eq
 800c2f0:	6923      	ldreq	r3, [r4, #16]
 800c2f2:	61bb      	streq	r3, [r7, #24]
 800c2f4:	6963      	ldreq	r3, [r4, #20]
 800c2f6:	61fb      	streq	r3, [r7, #28]
 800c2f8:	bf19      	ittee	ne
 800c2fa:	f107 0018 	addne.w	r0, r7, #24
 800c2fe:	3410      	addne	r4, #16
 800c300:	f107 0020 	addeq.w	r0, r7, #32
 800c304:	3418      	addeq	r4, #24
 800c306:	6823      	ldr	r3, [r4, #0]
 800c308:	6003      	str	r3, [r0, #0]
 800c30a:	6863      	ldr	r3, [r4, #4]
 800c30c:	6043      	str	r3, [r0, #4]
 800c30e:	68a3      	ldr	r3, [r4, #8]
 800c310:	6083      	str	r3, [r0, #8]
 800c312:	e002      	b.n	800c31a <_realloc_r+0x1e2>
 800c314:	4621      	mov	r1, r4
 800c316:	f7ff fef1 	bl	800c0fc <memmove>
 800c31a:	4655      	mov	r5, sl
 800c31c:	e02e      	b.n	800c37c <_realloc_r+0x244>
 800c31e:	45b0      	cmp	r8, r6
 800c320:	dc32      	bgt.n	800c388 <_realloc_r+0x250>
 800c322:	4638      	mov	r0, r7
 800c324:	68fb      	ldr	r3, [r7, #12]
 800c326:	f850 2f08 	ldr.w	r2, [r0, #8]!
 800c32a:	60d3      	str	r3, [r2, #12]
 800c32c:	609a      	str	r2, [r3, #8]
 800c32e:	1f2a      	subs	r2, r5, #4
 800c330:	2a24      	cmp	r2, #36	; 0x24
 800c332:	d825      	bhi.n	800c380 <_realloc_r+0x248>
 800c334:	2a13      	cmp	r2, #19
 800c336:	d91a      	bls.n	800c36e <_realloc_r+0x236>
 800c338:	6823      	ldr	r3, [r4, #0]
 800c33a:	60bb      	str	r3, [r7, #8]
 800c33c:	6863      	ldr	r3, [r4, #4]
 800c33e:	60fb      	str	r3, [r7, #12]
 800c340:	2a1b      	cmp	r2, #27
 800c342:	d803      	bhi.n	800c34c <_realloc_r+0x214>
 800c344:	f107 0010 	add.w	r0, r7, #16
 800c348:	3408      	adds	r4, #8
 800c34a:	e010      	b.n	800c36e <_realloc_r+0x236>
 800c34c:	68a3      	ldr	r3, [r4, #8]
 800c34e:	613b      	str	r3, [r7, #16]
 800c350:	68e3      	ldr	r3, [r4, #12]
 800c352:	617b      	str	r3, [r7, #20]
 800c354:	2a24      	cmp	r2, #36	; 0x24
 800c356:	bf01      	itttt	eq
 800c358:	6923      	ldreq	r3, [r4, #16]
 800c35a:	61bb      	streq	r3, [r7, #24]
 800c35c:	6963      	ldreq	r3, [r4, #20]
 800c35e:	61fb      	streq	r3, [r7, #28]
 800c360:	bf19      	ittee	ne
 800c362:	f107 0018 	addne.w	r0, r7, #24
 800c366:	3410      	addne	r4, #16
 800c368:	f107 0020 	addeq.w	r0, r7, #32
 800c36c:	3418      	addeq	r4, #24
 800c36e:	6823      	ldr	r3, [r4, #0]
 800c370:	6003      	str	r3, [r0, #0]
 800c372:	6863      	ldr	r3, [r4, #4]
 800c374:	6043      	str	r3, [r0, #4]
 800c376:	68a3      	ldr	r3, [r4, #8]
 800c378:	6083      	str	r3, [r0, #8]
 800c37a:	4635      	mov	r5, r6
 800c37c:	46bb      	mov	fp, r7
 800c37e:	e055      	b.n	800c42c <_realloc_r+0x2f4>
 800c380:	4621      	mov	r1, r4
 800c382:	f7ff febb 	bl	800c0fc <memmove>
 800c386:	e7f8      	b.n	800c37a <_realloc_r+0x242>
 800c388:	4611      	mov	r1, r2
 800c38a:	4648      	mov	r0, r9
 800c38c:	f7ff fc96 	bl	800bcbc <_malloc_r>
 800c390:	4606      	mov	r6, r0
 800c392:	2800      	cmp	r0, #0
 800c394:	d042      	beq.n	800c41c <_realloc_r+0x2e4>
 800c396:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800c39a:	f023 0301 	bic.w	r3, r3, #1
 800c39e:	f1a0 0208 	sub.w	r2, r0, #8
 800c3a2:	445b      	add	r3, fp
 800c3a4:	429a      	cmp	r2, r3
 800c3a6:	d105      	bne.n	800c3b4 <_realloc_r+0x27c>
 800c3a8:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800c3ac:	f023 0303 	bic.w	r3, r3, #3
 800c3b0:	441d      	add	r5, r3
 800c3b2:	e03b      	b.n	800c42c <_realloc_r+0x2f4>
 800c3b4:	1f2a      	subs	r2, r5, #4
 800c3b6:	2a24      	cmp	r2, #36	; 0x24
 800c3b8:	d829      	bhi.n	800c40e <_realloc_r+0x2d6>
 800c3ba:	2a13      	cmp	r2, #19
 800c3bc:	d91e      	bls.n	800c3fc <_realloc_r+0x2c4>
 800c3be:	6823      	ldr	r3, [r4, #0]
 800c3c0:	6003      	str	r3, [r0, #0]
 800c3c2:	6863      	ldr	r3, [r4, #4]
 800c3c4:	6043      	str	r3, [r0, #4]
 800c3c6:	2a1b      	cmp	r2, #27
 800c3c8:	d804      	bhi.n	800c3d4 <_realloc_r+0x29c>
 800c3ca:	f100 0308 	add.w	r3, r0, #8
 800c3ce:	f104 0208 	add.w	r2, r4, #8
 800c3d2:	e015      	b.n	800c400 <_realloc_r+0x2c8>
 800c3d4:	68a3      	ldr	r3, [r4, #8]
 800c3d6:	6083      	str	r3, [r0, #8]
 800c3d8:	68e3      	ldr	r3, [r4, #12]
 800c3da:	60c3      	str	r3, [r0, #12]
 800c3dc:	2a24      	cmp	r2, #36	; 0x24
 800c3de:	bf01      	itttt	eq
 800c3e0:	6923      	ldreq	r3, [r4, #16]
 800c3e2:	6103      	streq	r3, [r0, #16]
 800c3e4:	6961      	ldreq	r1, [r4, #20]
 800c3e6:	6141      	streq	r1, [r0, #20]
 800c3e8:	bf19      	ittee	ne
 800c3ea:	f100 0310 	addne.w	r3, r0, #16
 800c3ee:	f104 0210 	addne.w	r2, r4, #16
 800c3f2:	f100 0318 	addeq.w	r3, r0, #24
 800c3f6:	f104 0218 	addeq.w	r2, r4, #24
 800c3fa:	e001      	b.n	800c400 <_realloc_r+0x2c8>
 800c3fc:	4603      	mov	r3, r0
 800c3fe:	4622      	mov	r2, r4
 800c400:	6811      	ldr	r1, [r2, #0]
 800c402:	6019      	str	r1, [r3, #0]
 800c404:	6851      	ldr	r1, [r2, #4]
 800c406:	6059      	str	r1, [r3, #4]
 800c408:	6892      	ldr	r2, [r2, #8]
 800c40a:	609a      	str	r2, [r3, #8]
 800c40c:	e002      	b.n	800c414 <_realloc_r+0x2dc>
 800c40e:	4621      	mov	r1, r4
 800c410:	f7ff fe74 	bl	800c0fc <memmove>
 800c414:	4621      	mov	r1, r4
 800c416:	4648      	mov	r0, r9
 800c418:	f7ff fa2a 	bl	800b870 <_free_r>
 800c41c:	4648      	mov	r0, r9
 800c41e:	f7ff fe89 	bl	800c134 <__malloc_unlock>
 800c422:	4630      	mov	r0, r6
 800c424:	e02d      	b.n	800c482 <_realloc_r+0x34a>
 800c426:	bf00      	nop
 800c428:	20000140 	.word	0x20000140
 800c42c:	ebc8 0205 	rsb	r2, r8, r5
 800c430:	2a0f      	cmp	r2, #15
 800c432:	f8db 3004 	ldr.w	r3, [fp, #4]
 800c436:	d914      	bls.n	800c462 <_realloc_r+0x32a>
 800c438:	f003 0301 	and.w	r3, r3, #1
 800c43c:	eb0b 0108 	add.w	r1, fp, r8
 800c440:	ea43 0308 	orr.w	r3, r3, r8
 800c444:	f8cb 3004 	str.w	r3, [fp, #4]
 800c448:	f042 0301 	orr.w	r3, r2, #1
 800c44c:	440a      	add	r2, r1
 800c44e:	604b      	str	r3, [r1, #4]
 800c450:	6853      	ldr	r3, [r2, #4]
 800c452:	f043 0301 	orr.w	r3, r3, #1
 800c456:	6053      	str	r3, [r2, #4]
 800c458:	3108      	adds	r1, #8
 800c45a:	4648      	mov	r0, r9
 800c45c:	f7ff fa08 	bl	800b870 <_free_r>
 800c460:	e00a      	b.n	800c478 <_realloc_r+0x340>
 800c462:	f003 0301 	and.w	r3, r3, #1
 800c466:	432b      	orrs	r3, r5
 800c468:	eb0b 0205 	add.w	r2, fp, r5
 800c46c:	f8cb 3004 	str.w	r3, [fp, #4]
 800c470:	6853      	ldr	r3, [r2, #4]
 800c472:	f043 0301 	orr.w	r3, r3, #1
 800c476:	6053      	str	r3, [r2, #4]
 800c478:	4648      	mov	r0, r9
 800c47a:	f7ff fe5b 	bl	800c134 <__malloc_unlock>
 800c47e:	f10b 0008 	add.w	r0, fp, #8
 800c482:	b003      	add	sp, #12
 800c484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c488 <_sbrk_r>:
 800c488:	b538      	push	{r3, r4, r5, lr}
 800c48a:	4c06      	ldr	r4, [pc, #24]	; (800c4a4 <_sbrk_r+0x1c>)
 800c48c:	2300      	movs	r3, #0
 800c48e:	4605      	mov	r5, r0
 800c490:	4608      	mov	r0, r1
 800c492:	6023      	str	r3, [r4, #0]
 800c494:	f7fd fa62 	bl	800995c <_sbrk>
 800c498:	1c43      	adds	r3, r0, #1
 800c49a:	d102      	bne.n	800c4a2 <_sbrk_r+0x1a>
 800c49c:	6823      	ldr	r3, [r4, #0]
 800c49e:	b103      	cbz	r3, 800c4a2 <_sbrk_r+0x1a>
 800c4a0:	602b      	str	r3, [r5, #0]
 800c4a2:	bd38      	pop	{r3, r4, r5, pc}
 800c4a4:	20008a2c 	.word	0x20008a2c

0800c4a8 <__sread>:
 800c4a8:	b510      	push	{r4, lr}
 800c4aa:	460c      	mov	r4, r1
 800c4ac:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c4b0:	f000 fa54 	bl	800c95c <_read_r>
 800c4b4:	2800      	cmp	r0, #0
 800c4b6:	bfab      	itete	ge
 800c4b8:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800c4ba:	89a3      	ldrhlt	r3, [r4, #12]
 800c4bc:	181b      	addge	r3, r3, r0
 800c4be:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800c4c2:	bfac      	ite	ge
 800c4c4:	6563      	strge	r3, [r4, #84]	; 0x54
 800c4c6:	81a3      	strhlt	r3, [r4, #12]
 800c4c8:	bd10      	pop	{r4, pc}

0800c4ca <__swrite>:
 800c4ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c4ce:	461f      	mov	r7, r3
 800c4d0:	898b      	ldrh	r3, [r1, #12]
 800c4d2:	05db      	lsls	r3, r3, #23
 800c4d4:	4605      	mov	r5, r0
 800c4d6:	460c      	mov	r4, r1
 800c4d8:	4616      	mov	r6, r2
 800c4da:	d505      	bpl.n	800c4e8 <__swrite+0x1e>
 800c4dc:	2302      	movs	r3, #2
 800c4de:	2200      	movs	r2, #0
 800c4e0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c4e4:	f000 f9c0 	bl	800c868 <_lseek_r>
 800c4e8:	89a3      	ldrh	r3, [r4, #12]
 800c4ea:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800c4ee:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800c4f2:	81a3      	strh	r3, [r4, #12]
 800c4f4:	4632      	mov	r2, r6
 800c4f6:	463b      	mov	r3, r7
 800c4f8:	4628      	mov	r0, r5
 800c4fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800c4fe:	f000 b817 	b.w	800c530 <_write_r>

0800c502 <__sseek>:
 800c502:	b510      	push	{r4, lr}
 800c504:	460c      	mov	r4, r1
 800c506:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c50a:	f000 f9ad 	bl	800c868 <_lseek_r>
 800c50e:	1c43      	adds	r3, r0, #1
 800c510:	89a3      	ldrh	r3, [r4, #12]
 800c512:	bf15      	itete	ne
 800c514:	6560      	strne	r0, [r4, #84]	; 0x54
 800c516:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800c51a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800c51e:	81a3      	strheq	r3, [r4, #12]
 800c520:	bf18      	it	ne
 800c522:	81a3      	strhne	r3, [r4, #12]
 800c524:	bd10      	pop	{r4, pc}

0800c526 <__sclose>:
 800c526:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c52a:	f000 b881 	b.w	800c630 <_close_r>
	...

0800c530 <_write_r>:
 800c530:	b538      	push	{r3, r4, r5, lr}
 800c532:	4c07      	ldr	r4, [pc, #28]	; (800c550 <_write_r+0x20>)
 800c534:	4605      	mov	r5, r0
 800c536:	4608      	mov	r0, r1
 800c538:	4611      	mov	r1, r2
 800c53a:	2200      	movs	r2, #0
 800c53c:	6022      	str	r2, [r4, #0]
 800c53e:	461a      	mov	r2, r3
 800c540:	f7fd f9fe 	bl	8009940 <_write>
 800c544:	1c43      	adds	r3, r0, #1
 800c546:	d102      	bne.n	800c54e <_write_r+0x1e>
 800c548:	6823      	ldr	r3, [r4, #0]
 800c54a:	b103      	cbz	r3, 800c54e <_write_r+0x1e>
 800c54c:	602b      	str	r3, [r5, #0]
 800c54e:	bd38      	pop	{r3, r4, r5, pc}
 800c550:	20008a2c 	.word	0x20008a2c

0800c554 <__swsetup_r>:
 800c554:	4b32      	ldr	r3, [pc, #200]	; (800c620 <__swsetup_r+0xcc>)
 800c556:	b570      	push	{r4, r5, r6, lr}
 800c558:	681d      	ldr	r5, [r3, #0]
 800c55a:	4606      	mov	r6, r0
 800c55c:	460c      	mov	r4, r1
 800c55e:	b125      	cbz	r5, 800c56a <__swsetup_r+0x16>
 800c560:	69ab      	ldr	r3, [r5, #24]
 800c562:	b913      	cbnz	r3, 800c56a <__swsetup_r+0x16>
 800c564:	4628      	mov	r0, r5
 800c566:	f7ff f8bb 	bl	800b6e0 <__sinit>
 800c56a:	4b2e      	ldr	r3, [pc, #184]	; (800c624 <__swsetup_r+0xd0>)
 800c56c:	429c      	cmp	r4, r3
 800c56e:	d101      	bne.n	800c574 <__swsetup_r+0x20>
 800c570:	686c      	ldr	r4, [r5, #4]
 800c572:	e008      	b.n	800c586 <__swsetup_r+0x32>
 800c574:	4b2c      	ldr	r3, [pc, #176]	; (800c628 <__swsetup_r+0xd4>)
 800c576:	429c      	cmp	r4, r3
 800c578:	d101      	bne.n	800c57e <__swsetup_r+0x2a>
 800c57a:	68ac      	ldr	r4, [r5, #8]
 800c57c:	e003      	b.n	800c586 <__swsetup_r+0x32>
 800c57e:	4b2b      	ldr	r3, [pc, #172]	; (800c62c <__swsetup_r+0xd8>)
 800c580:	429c      	cmp	r4, r3
 800c582:	bf08      	it	eq
 800c584:	68ec      	ldreq	r4, [r5, #12]
 800c586:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800c58a:	b29a      	uxth	r2, r3
 800c58c:	0715      	lsls	r5, r2, #28
 800c58e:	d41d      	bmi.n	800c5cc <__swsetup_r+0x78>
 800c590:	06d0      	lsls	r0, r2, #27
 800c592:	d402      	bmi.n	800c59a <__swsetup_r+0x46>
 800c594:	2209      	movs	r2, #9
 800c596:	6032      	str	r2, [r6, #0]
 800c598:	e03a      	b.n	800c610 <__swsetup_r+0xbc>
 800c59a:	0751      	lsls	r1, r2, #29
 800c59c:	d512      	bpl.n	800c5c4 <__swsetup_r+0x70>
 800c59e:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800c5a0:	b141      	cbz	r1, 800c5b4 <__swsetup_r+0x60>
 800c5a2:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800c5a6:	4299      	cmp	r1, r3
 800c5a8:	d002      	beq.n	800c5b0 <__swsetup_r+0x5c>
 800c5aa:	4630      	mov	r0, r6
 800c5ac:	f7ff f960 	bl	800b870 <_free_r>
 800c5b0:	2300      	movs	r3, #0
 800c5b2:	6363      	str	r3, [r4, #52]	; 0x34
 800c5b4:	89a3      	ldrh	r3, [r4, #12]
 800c5b6:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 800c5ba:	81a3      	strh	r3, [r4, #12]
 800c5bc:	2300      	movs	r3, #0
 800c5be:	6063      	str	r3, [r4, #4]
 800c5c0:	6923      	ldr	r3, [r4, #16]
 800c5c2:	6023      	str	r3, [r4, #0]
 800c5c4:	89a3      	ldrh	r3, [r4, #12]
 800c5c6:	f043 0308 	orr.w	r3, r3, #8
 800c5ca:	81a3      	strh	r3, [r4, #12]
 800c5cc:	6923      	ldr	r3, [r4, #16]
 800c5ce:	b94b      	cbnz	r3, 800c5e4 <__swsetup_r+0x90>
 800c5d0:	89a3      	ldrh	r3, [r4, #12]
 800c5d2:	f403 7320 	and.w	r3, r3, #640	; 0x280
 800c5d6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c5da:	d003      	beq.n	800c5e4 <__swsetup_r+0x90>
 800c5dc:	4621      	mov	r1, r4
 800c5de:	4630      	mov	r0, r6
 800c5e0:	f000 f980 	bl	800c8e4 <__smakebuf_r>
 800c5e4:	89a2      	ldrh	r2, [r4, #12]
 800c5e6:	f012 0301 	ands.w	r3, r2, #1
 800c5ea:	d005      	beq.n	800c5f8 <__swsetup_r+0xa4>
 800c5ec:	2300      	movs	r3, #0
 800c5ee:	60a3      	str	r3, [r4, #8]
 800c5f0:	6963      	ldr	r3, [r4, #20]
 800c5f2:	425b      	negs	r3, r3
 800c5f4:	61a3      	str	r3, [r4, #24]
 800c5f6:	e003      	b.n	800c600 <__swsetup_r+0xac>
 800c5f8:	0792      	lsls	r2, r2, #30
 800c5fa:	bf58      	it	pl
 800c5fc:	6963      	ldrpl	r3, [r4, #20]
 800c5fe:	60a3      	str	r3, [r4, #8]
 800c600:	6923      	ldr	r3, [r4, #16]
 800c602:	b95b      	cbnz	r3, 800c61c <__swsetup_r+0xc8>
 800c604:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800c608:	f003 0080 	and.w	r0, r3, #128	; 0x80
 800c60c:	b280      	uxth	r0, r0
 800c60e:	b130      	cbz	r0, 800c61e <__swsetup_r+0xca>
 800c610:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c614:	81a3      	strh	r3, [r4, #12]
 800c616:	f04f 30ff 	mov.w	r0, #4294967295
 800c61a:	bd70      	pop	{r4, r5, r6, pc}
 800c61c:	2000      	movs	r0, #0
 800c61e:	bd70      	pop	{r4, r5, r6, pc}
 800c620:	2000013c 	.word	0x2000013c
 800c624:	08019848 	.word	0x08019848
 800c628:	08019868 	.word	0x08019868
 800c62c:	08019888 	.word	0x08019888

0800c630 <_close_r>:
 800c630:	b538      	push	{r3, r4, r5, lr}
 800c632:	4c06      	ldr	r4, [pc, #24]	; (800c64c <_close_r+0x1c>)
 800c634:	2300      	movs	r3, #0
 800c636:	4605      	mov	r5, r0
 800c638:	4608      	mov	r0, r1
 800c63a:	6023      	str	r3, [r4, #0]
 800c63c:	f7fd f9a8 	bl	8009990 <_close>
 800c640:	1c43      	adds	r3, r0, #1
 800c642:	d102      	bne.n	800c64a <_close_r+0x1a>
 800c644:	6823      	ldr	r3, [r4, #0]
 800c646:	b103      	cbz	r3, 800c64a <_close_r+0x1a>
 800c648:	602b      	str	r3, [r5, #0]
 800c64a:	bd38      	pop	{r3, r4, r5, pc}
 800c64c:	20008a2c 	.word	0x20008a2c

0800c650 <_fclose_r>:
 800c650:	b570      	push	{r4, r5, r6, lr}
 800c652:	4605      	mov	r5, r0
 800c654:	460c      	mov	r4, r1
 800c656:	b909      	cbnz	r1, 800c65c <_fclose_r+0xc>
 800c658:	2000      	movs	r0, #0
 800c65a:	bd70      	pop	{r4, r5, r6, pc}
 800c65c:	b118      	cbz	r0, 800c666 <_fclose_r+0x16>
 800c65e:	6983      	ldr	r3, [r0, #24]
 800c660:	b90b      	cbnz	r3, 800c666 <_fclose_r+0x16>
 800c662:	f7ff f83d 	bl	800b6e0 <__sinit>
 800c666:	4b20      	ldr	r3, [pc, #128]	; (800c6e8 <_fclose_r+0x98>)
 800c668:	429c      	cmp	r4, r3
 800c66a:	d101      	bne.n	800c670 <_fclose_r+0x20>
 800c66c:	686c      	ldr	r4, [r5, #4]
 800c66e:	e008      	b.n	800c682 <_fclose_r+0x32>
 800c670:	4b1e      	ldr	r3, [pc, #120]	; (800c6ec <_fclose_r+0x9c>)
 800c672:	429c      	cmp	r4, r3
 800c674:	d101      	bne.n	800c67a <_fclose_r+0x2a>
 800c676:	68ac      	ldr	r4, [r5, #8]
 800c678:	e003      	b.n	800c682 <_fclose_r+0x32>
 800c67a:	4b1d      	ldr	r3, [pc, #116]	; (800c6f0 <_fclose_r+0xa0>)
 800c67c:	429c      	cmp	r4, r3
 800c67e:	bf08      	it	eq
 800c680:	68ec      	ldreq	r4, [r5, #12]
 800c682:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800c686:	2b00      	cmp	r3, #0
 800c688:	d0e6      	beq.n	800c658 <_fclose_r+0x8>
 800c68a:	4621      	mov	r1, r4
 800c68c:	4628      	mov	r0, r5
 800c68e:	f000 f831 	bl	800c6f4 <__sflush_r>
 800c692:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800c694:	4606      	mov	r6, r0
 800c696:	b133      	cbz	r3, 800c6a6 <_fclose_r+0x56>
 800c698:	6a21      	ldr	r1, [r4, #32]
 800c69a:	4628      	mov	r0, r5
 800c69c:	4798      	blx	r3
 800c69e:	2800      	cmp	r0, #0
 800c6a0:	bfb8      	it	lt
 800c6a2:	f04f 36ff 	movlt.w	r6, #4294967295
 800c6a6:	89a3      	ldrh	r3, [r4, #12]
 800c6a8:	061b      	lsls	r3, r3, #24
 800c6aa:	d503      	bpl.n	800c6b4 <_fclose_r+0x64>
 800c6ac:	6921      	ldr	r1, [r4, #16]
 800c6ae:	4628      	mov	r0, r5
 800c6b0:	f7ff f8de 	bl	800b870 <_free_r>
 800c6b4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800c6b6:	b141      	cbz	r1, 800c6ca <_fclose_r+0x7a>
 800c6b8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800c6bc:	4299      	cmp	r1, r3
 800c6be:	d002      	beq.n	800c6c6 <_fclose_r+0x76>
 800c6c0:	4628      	mov	r0, r5
 800c6c2:	f7ff f8d5 	bl	800b870 <_free_r>
 800c6c6:	2300      	movs	r3, #0
 800c6c8:	6363      	str	r3, [r4, #52]	; 0x34
 800c6ca:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c6cc:	b121      	cbz	r1, 800c6d8 <_fclose_r+0x88>
 800c6ce:	4628      	mov	r0, r5
 800c6d0:	f7ff f8ce 	bl	800b870 <_free_r>
 800c6d4:	2300      	movs	r3, #0
 800c6d6:	64a3      	str	r3, [r4, #72]	; 0x48
 800c6d8:	f7ff f872 	bl	800b7c0 <__sfp_lock_acquire>
 800c6dc:	2300      	movs	r3, #0
 800c6de:	81a3      	strh	r3, [r4, #12]
 800c6e0:	f7ff f86f 	bl	800b7c2 <__sfp_lock_release>
 800c6e4:	4630      	mov	r0, r6
 800c6e6:	bd70      	pop	{r4, r5, r6, pc}
 800c6e8:	08019848 	.word	0x08019848
 800c6ec:	08019868 	.word	0x08019868
 800c6f0:	08019888 	.word	0x08019888

0800c6f4 <__sflush_r>:
 800c6f4:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 800c6f8:	b293      	uxth	r3, r2
 800c6fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c6fe:	4605      	mov	r5, r0
 800c700:	0718      	lsls	r0, r3, #28
 800c702:	460c      	mov	r4, r1
 800c704:	d460      	bmi.n	800c7c8 <__sflush_r+0xd4>
 800c706:	684b      	ldr	r3, [r1, #4]
 800c708:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800c70c:	2b00      	cmp	r3, #0
 800c70e:	818a      	strh	r2, [r1, #12]
 800c710:	dc02      	bgt.n	800c718 <__sflush_r+0x24>
 800c712:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800c714:	2b00      	cmp	r3, #0
 800c716:	dd17      	ble.n	800c748 <__sflush_r+0x54>
 800c718:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800c71a:	b1ae      	cbz	r6, 800c748 <__sflush_r+0x54>
 800c71c:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 800c720:	2300      	movs	r3, #0
 800c722:	b292      	uxth	r2, r2
 800c724:	682f      	ldr	r7, [r5, #0]
 800c726:	602b      	str	r3, [r5, #0]
 800c728:	b10a      	cbz	r2, 800c72e <__sflush_r+0x3a>
 800c72a:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800c72c:	e015      	b.n	800c75a <__sflush_r+0x66>
 800c72e:	6a21      	ldr	r1, [r4, #32]
 800c730:	2301      	movs	r3, #1
 800c732:	4628      	mov	r0, r5
 800c734:	47b0      	blx	r6
 800c736:	1c41      	adds	r1, r0, #1
 800c738:	d10f      	bne.n	800c75a <__sflush_r+0x66>
 800c73a:	682b      	ldr	r3, [r5, #0]
 800c73c:	b16b      	cbz	r3, 800c75a <__sflush_r+0x66>
 800c73e:	2b1d      	cmp	r3, #29
 800c740:	d001      	beq.n	800c746 <__sflush_r+0x52>
 800c742:	2b16      	cmp	r3, #22
 800c744:	d103      	bne.n	800c74e <__sflush_r+0x5a>
 800c746:	602f      	str	r7, [r5, #0]
 800c748:	2000      	movs	r0, #0
 800c74a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c74e:	89a3      	ldrh	r3, [r4, #12]
 800c750:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c754:	81a3      	strh	r3, [r4, #12]
 800c756:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c75a:	89a3      	ldrh	r3, [r4, #12]
 800c75c:	075a      	lsls	r2, r3, #29
 800c75e:	d505      	bpl.n	800c76c <__sflush_r+0x78>
 800c760:	6863      	ldr	r3, [r4, #4]
 800c762:	1ac0      	subs	r0, r0, r3
 800c764:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800c766:	b10b      	cbz	r3, 800c76c <__sflush_r+0x78>
 800c768:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800c76a:	1ac0      	subs	r0, r0, r3
 800c76c:	2300      	movs	r3, #0
 800c76e:	4602      	mov	r2, r0
 800c770:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800c772:	6a21      	ldr	r1, [r4, #32]
 800c774:	4628      	mov	r0, r5
 800c776:	47b0      	blx	r6
 800c778:	1c43      	adds	r3, r0, #1
 800c77a:	89a3      	ldrh	r3, [r4, #12]
 800c77c:	d106      	bne.n	800c78c <__sflush_r+0x98>
 800c77e:	6829      	ldr	r1, [r5, #0]
 800c780:	291d      	cmp	r1, #29
 800c782:	d83e      	bhi.n	800c802 <__sflush_r+0x10e>
 800c784:	4a22      	ldr	r2, [pc, #136]	; (800c810 <__sflush_r+0x11c>)
 800c786:	40ca      	lsrs	r2, r1
 800c788:	07d6      	lsls	r6, r2, #31
 800c78a:	d53a      	bpl.n	800c802 <__sflush_r+0x10e>
 800c78c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800c790:	b21b      	sxth	r3, r3
 800c792:	2200      	movs	r2, #0
 800c794:	6062      	str	r2, [r4, #4]
 800c796:	04d9      	lsls	r1, r3, #19
 800c798:	6922      	ldr	r2, [r4, #16]
 800c79a:	81a3      	strh	r3, [r4, #12]
 800c79c:	6022      	str	r2, [r4, #0]
 800c79e:	d504      	bpl.n	800c7aa <__sflush_r+0xb6>
 800c7a0:	1c42      	adds	r2, r0, #1
 800c7a2:	d101      	bne.n	800c7a8 <__sflush_r+0xb4>
 800c7a4:	682b      	ldr	r3, [r5, #0]
 800c7a6:	b903      	cbnz	r3, 800c7aa <__sflush_r+0xb6>
 800c7a8:	6560      	str	r0, [r4, #84]	; 0x54
 800c7aa:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800c7ac:	602f      	str	r7, [r5, #0]
 800c7ae:	2900      	cmp	r1, #0
 800c7b0:	d0ca      	beq.n	800c748 <__sflush_r+0x54>
 800c7b2:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800c7b6:	4299      	cmp	r1, r3
 800c7b8:	d002      	beq.n	800c7c0 <__sflush_r+0xcc>
 800c7ba:	4628      	mov	r0, r5
 800c7bc:	f7ff f858 	bl	800b870 <_free_r>
 800c7c0:	2000      	movs	r0, #0
 800c7c2:	6360      	str	r0, [r4, #52]	; 0x34
 800c7c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c7c8:	690f      	ldr	r7, [r1, #16]
 800c7ca:	2f00      	cmp	r7, #0
 800c7cc:	d0bc      	beq.n	800c748 <__sflush_r+0x54>
 800c7ce:	079b      	lsls	r3, r3, #30
 800c7d0:	680e      	ldr	r6, [r1, #0]
 800c7d2:	bf08      	it	eq
 800c7d4:	694b      	ldreq	r3, [r1, #20]
 800c7d6:	600f      	str	r7, [r1, #0]
 800c7d8:	bf18      	it	ne
 800c7da:	2300      	movne	r3, #0
 800c7dc:	ebc7 0806 	rsb	r8, r7, r6
 800c7e0:	608b      	str	r3, [r1, #8]
 800c7e2:	e002      	b.n	800c7ea <__sflush_r+0xf6>
 800c7e4:	4407      	add	r7, r0
 800c7e6:	ebc0 0808 	rsb	r8, r0, r8
 800c7ea:	f1b8 0f00 	cmp.w	r8, #0
 800c7ee:	ddab      	ble.n	800c748 <__sflush_r+0x54>
 800c7f0:	4643      	mov	r3, r8
 800c7f2:	463a      	mov	r2, r7
 800c7f4:	6a21      	ldr	r1, [r4, #32]
 800c7f6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800c7f8:	4628      	mov	r0, r5
 800c7fa:	47b0      	blx	r6
 800c7fc:	2800      	cmp	r0, #0
 800c7fe:	dcf1      	bgt.n	800c7e4 <__sflush_r+0xf0>
 800c800:	89a3      	ldrh	r3, [r4, #12]
 800c802:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c806:	81a3      	strh	r3, [r4, #12]
 800c808:	f04f 30ff 	mov.w	r0, #4294967295
 800c80c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c810:	20400001 	.word	0x20400001

0800c814 <_fflush_r>:
 800c814:	b538      	push	{r3, r4, r5, lr}
 800c816:	690b      	ldr	r3, [r1, #16]
 800c818:	4605      	mov	r5, r0
 800c81a:	460c      	mov	r4, r1
 800c81c:	b1db      	cbz	r3, 800c856 <_fflush_r+0x42>
 800c81e:	b118      	cbz	r0, 800c828 <_fflush_r+0x14>
 800c820:	6983      	ldr	r3, [r0, #24]
 800c822:	b90b      	cbnz	r3, 800c828 <_fflush_r+0x14>
 800c824:	f7fe ff5c 	bl	800b6e0 <__sinit>
 800c828:	4b0c      	ldr	r3, [pc, #48]	; (800c85c <_fflush_r+0x48>)
 800c82a:	429c      	cmp	r4, r3
 800c82c:	d101      	bne.n	800c832 <_fflush_r+0x1e>
 800c82e:	686c      	ldr	r4, [r5, #4]
 800c830:	e008      	b.n	800c844 <_fflush_r+0x30>
 800c832:	4b0b      	ldr	r3, [pc, #44]	; (800c860 <_fflush_r+0x4c>)
 800c834:	429c      	cmp	r4, r3
 800c836:	d101      	bne.n	800c83c <_fflush_r+0x28>
 800c838:	68ac      	ldr	r4, [r5, #8]
 800c83a:	e003      	b.n	800c844 <_fflush_r+0x30>
 800c83c:	4b09      	ldr	r3, [pc, #36]	; (800c864 <_fflush_r+0x50>)
 800c83e:	429c      	cmp	r4, r3
 800c840:	bf08      	it	eq
 800c842:	68ec      	ldreq	r4, [r5, #12]
 800c844:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800c848:	b12b      	cbz	r3, 800c856 <_fflush_r+0x42>
 800c84a:	4621      	mov	r1, r4
 800c84c:	4628      	mov	r0, r5
 800c84e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800c852:	f7ff bf4f 	b.w	800c6f4 <__sflush_r>
 800c856:	2000      	movs	r0, #0
 800c858:	bd38      	pop	{r3, r4, r5, pc}
 800c85a:	bf00      	nop
 800c85c:	08019848 	.word	0x08019848
 800c860:	08019868 	.word	0x08019868
 800c864:	08019888 	.word	0x08019888

0800c868 <_lseek_r>:
 800c868:	b538      	push	{r3, r4, r5, lr}
 800c86a:	4c07      	ldr	r4, [pc, #28]	; (800c888 <_lseek_r+0x20>)
 800c86c:	4605      	mov	r5, r0
 800c86e:	4608      	mov	r0, r1
 800c870:	4611      	mov	r1, r2
 800c872:	2200      	movs	r2, #0
 800c874:	6022      	str	r2, [r4, #0]
 800c876:	461a      	mov	r2, r3
 800c878:	f7fd f896 	bl	80099a8 <_lseek>
 800c87c:	1c43      	adds	r3, r0, #1
 800c87e:	d102      	bne.n	800c886 <_lseek_r+0x1e>
 800c880:	6823      	ldr	r3, [r4, #0]
 800c882:	b103      	cbz	r3, 800c886 <_lseek_r+0x1e>
 800c884:	602b      	str	r3, [r5, #0]
 800c886:	bd38      	pop	{r3, r4, r5, pc}
 800c888:	20008a2c 	.word	0x20008a2c

0800c88c <__swhatbuf_r>:
 800c88c:	b570      	push	{r4, r5, r6, lr}
 800c88e:	460e      	mov	r6, r1
 800c890:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c894:	2900      	cmp	r1, #0
 800c896:	b090      	sub	sp, #64	; 0x40
 800c898:	4614      	mov	r4, r2
 800c89a:	461d      	mov	r5, r3
 800c89c:	da0a      	bge.n	800c8b4 <__swhatbuf_r+0x28>
 800c89e:	89b3      	ldrh	r3, [r6, #12]
 800c8a0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800c8a4:	2200      	movs	r2, #0
 800c8a6:	b298      	uxth	r0, r3
 800c8a8:	602a      	str	r2, [r5, #0]
 800c8aa:	b1b0      	cbz	r0, 800c8da <__swhatbuf_r+0x4e>
 800c8ac:	2340      	movs	r3, #64	; 0x40
 800c8ae:	6023      	str	r3, [r4, #0]
 800c8b0:	4610      	mov	r0, r2
 800c8b2:	e015      	b.n	800c8e0 <__swhatbuf_r+0x54>
 800c8b4:	aa01      	add	r2, sp, #4
 800c8b6:	f000 f863 	bl	800c980 <_fstat_r>
 800c8ba:	2800      	cmp	r0, #0
 800c8bc:	dbef      	blt.n	800c89e <__swhatbuf_r+0x12>
 800c8be:	9a02      	ldr	r2, [sp, #8]
 800c8c0:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 800c8c4:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 800c8c8:	425a      	negs	r2, r3
 800c8ca:	415a      	adcs	r2, r3
 800c8cc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c8d0:	602a      	str	r2, [r5, #0]
 800c8d2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800c8d6:	6023      	str	r3, [r4, #0]
 800c8d8:	e002      	b.n	800c8e0 <__swhatbuf_r+0x54>
 800c8da:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c8de:	6023      	str	r3, [r4, #0]
 800c8e0:	b010      	add	sp, #64	; 0x40
 800c8e2:	bd70      	pop	{r4, r5, r6, pc}

0800c8e4 <__smakebuf_r>:
 800c8e4:	898b      	ldrh	r3, [r1, #12]
 800c8e6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800c8e8:	079e      	lsls	r6, r3, #30
 800c8ea:	4605      	mov	r5, r0
 800c8ec:	460c      	mov	r4, r1
 800c8ee:	d410      	bmi.n	800c912 <__smakebuf_r+0x2e>
 800c8f0:	ab01      	add	r3, sp, #4
 800c8f2:	466a      	mov	r2, sp
 800c8f4:	f7ff ffca 	bl	800c88c <__swhatbuf_r>
 800c8f8:	9900      	ldr	r1, [sp, #0]
 800c8fa:	4606      	mov	r6, r0
 800c8fc:	4628      	mov	r0, r5
 800c8fe:	f7ff f9dd 	bl	800bcbc <_malloc_r>
 800c902:	b968      	cbnz	r0, 800c920 <__smakebuf_r+0x3c>
 800c904:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800c908:	059a      	lsls	r2, r3, #22
 800c90a:	d422      	bmi.n	800c952 <__smakebuf_r+0x6e>
 800c90c:	f043 0302 	orr.w	r3, r3, #2
 800c910:	81a3      	strh	r3, [r4, #12]
 800c912:	f104 0347 	add.w	r3, r4, #71	; 0x47
 800c916:	6023      	str	r3, [r4, #0]
 800c918:	6123      	str	r3, [r4, #16]
 800c91a:	2301      	movs	r3, #1
 800c91c:	6163      	str	r3, [r4, #20]
 800c91e:	e018      	b.n	800c952 <__smakebuf_r+0x6e>
 800c920:	4b0d      	ldr	r3, [pc, #52]	; (800c958 <__smakebuf_r+0x74>)
 800c922:	62ab      	str	r3, [r5, #40]	; 0x28
 800c924:	89a3      	ldrh	r3, [r4, #12]
 800c926:	6020      	str	r0, [r4, #0]
 800c928:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c92c:	81a3      	strh	r3, [r4, #12]
 800c92e:	9b00      	ldr	r3, [sp, #0]
 800c930:	6163      	str	r3, [r4, #20]
 800c932:	9b01      	ldr	r3, [sp, #4]
 800c934:	6120      	str	r0, [r4, #16]
 800c936:	b14b      	cbz	r3, 800c94c <__smakebuf_r+0x68>
 800c938:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800c93c:	4628      	mov	r0, r5
 800c93e:	f000 f831 	bl	800c9a4 <_isatty_r>
 800c942:	b118      	cbz	r0, 800c94c <__smakebuf_r+0x68>
 800c944:	89a3      	ldrh	r3, [r4, #12]
 800c946:	f043 0301 	orr.w	r3, r3, #1
 800c94a:	81a3      	strh	r3, [r4, #12]
 800c94c:	89a0      	ldrh	r0, [r4, #12]
 800c94e:	4330      	orrs	r0, r6
 800c950:	81a0      	strh	r0, [r4, #12]
 800c952:	b002      	add	sp, #8
 800c954:	bd70      	pop	{r4, r5, r6, pc}
 800c956:	bf00      	nop
 800c958:	0800b661 	.word	0x0800b661

0800c95c <_read_r>:
 800c95c:	b538      	push	{r3, r4, r5, lr}
 800c95e:	4c07      	ldr	r4, [pc, #28]	; (800c97c <_read_r+0x20>)
 800c960:	4605      	mov	r5, r0
 800c962:	4608      	mov	r0, r1
 800c964:	4611      	mov	r1, r2
 800c966:	2200      	movs	r2, #0
 800c968:	6022      	str	r2, [r4, #0]
 800c96a:	461a      	mov	r2, r3
 800c96c:	f7fc ffda 	bl	8009924 <_read>
 800c970:	1c43      	adds	r3, r0, #1
 800c972:	d102      	bne.n	800c97a <_read_r+0x1e>
 800c974:	6823      	ldr	r3, [r4, #0]
 800c976:	b103      	cbz	r3, 800c97a <_read_r+0x1e>
 800c978:	602b      	str	r3, [r5, #0]
 800c97a:	bd38      	pop	{r3, r4, r5, pc}
 800c97c:	20008a2c 	.word	0x20008a2c

0800c980 <_fstat_r>:
 800c980:	b538      	push	{r3, r4, r5, lr}
 800c982:	4c07      	ldr	r4, [pc, #28]	; (800c9a0 <_fstat_r+0x20>)
 800c984:	2300      	movs	r3, #0
 800c986:	4605      	mov	r5, r0
 800c988:	4608      	mov	r0, r1
 800c98a:	4611      	mov	r1, r2
 800c98c:	6023      	str	r3, [r4, #0]
 800c98e:	f7fd f803 	bl	8009998 <_fstat>
 800c992:	1c43      	adds	r3, r0, #1
 800c994:	d102      	bne.n	800c99c <_fstat_r+0x1c>
 800c996:	6823      	ldr	r3, [r4, #0]
 800c998:	b103      	cbz	r3, 800c99c <_fstat_r+0x1c>
 800c99a:	602b      	str	r3, [r5, #0]
 800c99c:	bd38      	pop	{r3, r4, r5, pc}
 800c99e:	bf00      	nop
 800c9a0:	20008a2c 	.word	0x20008a2c

0800c9a4 <_isatty_r>:
 800c9a4:	b538      	push	{r3, r4, r5, lr}
 800c9a6:	4c06      	ldr	r4, [pc, #24]	; (800c9c0 <_isatty_r+0x1c>)
 800c9a8:	2300      	movs	r3, #0
 800c9aa:	4605      	mov	r5, r0
 800c9ac:	4608      	mov	r0, r1
 800c9ae:	6023      	str	r3, [r4, #0]
 800c9b0:	f7fc fff8 	bl	80099a4 <_isatty>
 800c9b4:	1c43      	adds	r3, r0, #1
 800c9b6:	d102      	bne.n	800c9be <_isatty_r+0x1a>
 800c9b8:	6823      	ldr	r3, [r4, #0]
 800c9ba:	b103      	cbz	r3, 800c9be <_isatty_r+0x1a>
 800c9bc:	602b      	str	r3, [r5, #0]
 800c9be:	bd38      	pop	{r3, r4, r5, pc}
 800c9c0:	20008a2c 	.word	0x20008a2c

0800c9c4 <_init>:
 800c9c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c9c6:	bf00      	nop
 800c9c8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c9ca:	bc08      	pop	{r3}
 800c9cc:	469e      	mov	lr, r3
 800c9ce:	4770      	bx	lr

0800c9d0 <_fini>:
 800c9d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c9d2:	bf00      	nop
 800c9d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c9d6:	bc08      	pop	{r3}
 800c9d8:	469e      	mov	lr, r3
 800c9da:	4770      	bx	lr
